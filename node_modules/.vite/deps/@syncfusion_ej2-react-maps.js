import {
  require_react_dom
} from "./chunk-AN6BL2YV.js";
import {
  __toESM,
  require_react
} from "./chunk-X4QARNC5.js";

// node_modules/@syncfusion/ej2-react-base/src/component-base.js
var React = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());

// node_modules/@syncfusion/ej2-base/src/util.js
var isBlazorPlatform = false;
function createInstance(classFunction, params) {
  var arrayParam = params;
  arrayParam.unshift(void 0);
  return new (Function.prototype.bind.apply(classFunction, arrayParam))();
}
function setImmediate(handler) {
  var unbind;
  var num = new Uint16Array(5);
  var intCrypto = window.msCrypto || window.crypto;
  intCrypto.getRandomValues(num);
  var secret = "ej2" + combineArray(num);
  var messageHandler = function(event) {
    if (event.source === window && typeof event.data === "string" && event.data.length <= 32 && event.data === secret) {
      handler();
      unbind();
    }
  };
  window.addEventListener("message", messageHandler, false);
  window.postMessage(secret, window.location.origin);
  return unbind = function() {
    window.removeEventListener("message", messageHandler);
    handler = messageHandler = secret = void 0;
  };
}
function getValue(nameSpace, obj) {
  var value = obj;
  var splits = nameSpace.replace(/\[/g, ".").replace(/\]/g, "").split(".");
  for (var i = 0; i < splits.length && !isUndefined(value); i++) {
    value = value[splits[parseInt(i.toString(), 10)]];
  }
  return value;
}
function setValue(nameSpace, value, obj) {
  var keys2 = nameSpace.replace(/\[/g, ".").replace(/\]/g, "").split(".");
  var start = obj || {};
  var fromObj = start;
  var i;
  var length = keys2.length;
  var key;
  for (i = 0; i < length; i++) {
    key = keys2[parseInt(i.toString(), 10)];
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      continue;
    }
    if (i + 1 === length) {
      fromObj["" + key] = value === void 0 ? {} : value;
    } else if (isNullOrUndefined(fromObj["" + key])) {
      fromObj["" + key] = {};
    }
    fromObj = fromObj["" + key];
  }
  return start;
}
function deleteObject(obj, key) {
  delete obj["" + key];
}
var containerObject = typeof window !== "undefined" ? window : {};
function isObject(obj) {
  var objCon = {};
  return !isNullOrUndefined(obj) && obj.constructor === objCon.constructor;
}
function merge(source, destination) {
  if (!isNullOrUndefined(destination)) {
    var temrObj = source;
    var tempProp = destination;
    var keys2 = Object.keys(destination);
    var deepmerge = "deepMerge";
    for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
      var key = keys_1[_i];
      if (!isNullOrUndefined(temrObj["" + deepmerge]) && temrObj["" + deepmerge].indexOf(key) !== -1 && (isObject(tempProp["" + key]) || Array.isArray(tempProp["" + key]))) {
        extend(temrObj["" + key], temrObj["" + key], tempProp["" + key], true);
      } else {
        temrObj["" + key] = tempProp["" + key];
      }
    }
  }
}
function extend(copied, first, second, deep) {
  var result = copied && typeof copied === "object" ? copied : {};
  var length = arguments.length;
  var args = [copied, first, second, deep];
  if (deep) {
    length = length - 1;
  }
  var _loop_1 = function(i2) {
    if (!args[parseInt(i2.toString(), 10)]) {
      return "continue";
    }
    var obj1 = args[parseInt(i2.toString(), 10)];
    Object.keys(obj1).forEach(function(key) {
      var src = result["" + key];
      var copy = obj1["" + key];
      var clone;
      var isArrayChanged = Array.isArray(copy) && Array.isArray(src) && copy.length !== src.length;
      var blazorEventExtend = isBlazor() ? !(src instanceof Event) && !isArrayChanged : true;
      if (deep && blazorEventExtend && (isObject(copy) || Array.isArray(copy))) {
        if (isObject(copy)) {
          clone = src ? src : {};
          if (Array.isArray(clone) && Object.prototype.hasOwnProperty.call(clone, "isComplexArray")) {
            extend(clone, {}, copy, deep);
          } else {
            result["" + key] = extend(clone, {}, copy, deep);
          }
        } else {
          clone = isBlazor() ? src && Object.keys(copy).length : src ? src : [];
          result["" + key] = extend([], clone, copy, clone && clone.length || copy && copy.length);
        }
      } else {
        result["" + key] = copy;
      }
    });
  };
  for (var i = 1; i < length; i++) {
    _loop_1(i);
  }
  return result;
}
function isNullOrUndefined(value) {
  return value === void 0 || value === null;
}
function isUndefined(value) {
  return "undefined" === typeof value;
}
function debounce(eventFunction, delay) {
  var out;
  return function() {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var later = function() {
      out = null;
      return eventFunction.apply(_this, args);
    };
    clearTimeout(out);
    out = setTimeout(later, delay);
  };
}
function compareElementParent(child, parent) {
  var node = child;
  if (node === parent) {
    return true;
  } else if (node === document || !node) {
    return false;
  } else {
    return compareElementParent(node.parentNode, parent);
  }
}
function throwError(message) {
  try {
    throw new Error(message);
  } catch (e) {
    throw new Error(e.message + "\n" + e.stack);
  }
}
function print(element, printWindow) {
  var div = document.createElement("div");
  var links = [].slice.call(document.getElementsByTagName("head")[0].querySelectorAll("base, link, style"));
  var blinks = [].slice.call(document.getElementsByTagName("body")[0].querySelectorAll("link, style"));
  if (blinks.length) {
    for (var l = 0, len = blinks.length; l < len; l++) {
      links.push(blinks[parseInt(l.toString(), 10)]);
    }
  }
  var reference = "";
  if (isNullOrUndefined(printWindow)) {
    printWindow = window.open("", "print", "height=452,width=1024,tabbar=no");
  }
  div.appendChild(element.cloneNode(true));
  for (var i = 0, len = links.length; i < len; i++) {
    reference += links[parseInt(i.toString(), 10)].outerHTML;
  }
  printWindow.document.write("<!DOCTYPE html> <html><head>" + reference + "</head><body>" + div.innerHTML + "<script> (function() { window.ready = true; })(); <\/script></body></html>");
  printWindow.document.close();
  printWindow.focus();
  var interval = setInterval(function() {
    if (printWindow.ready) {
      printWindow.print();
      printWindow.close();
      clearInterval(interval);
    }
  }, 500);
  return printWindow;
}
function isBlazor() {
  return isBlazorPlatform;
}
function uniqueID() {
  if (typeof window === "undefined") {
    return;
  }
  var num = new Uint16Array(5);
  var intCrypto = window.msCrypto || window.crypto;
  return intCrypto.getRandomValues(num);
}
function combineArray(num) {
  var ret = "";
  for (var i = 0; i < 5; i++) {
    ret += (i ? "," : "") + num[parseInt(i.toString(), 10)];
  }
  return ret;
}

// node_modules/@syncfusion/ej2-base/src/intl/parser-base.js
var defaultNumberingSystem = {
  "latn": {
    "_digits": "0123456789",
    "_type": "numeric"
  }
};
var defaultNumberSymbols = {
  "decimal": ".",
  "group": ",",
  "percentSign": "%",
  "plusSign": "+",
  "minusSign": "-",
  "infinity": "∞",
  "nan": "NaN",
  "exponential": "E"
};
var latnNumberSystem = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
var ParserBase = (
  /** @class */
  (function() {
    function ParserBase2() {
    }
    ParserBase2.getMainObject = function(obj, cName) {
      var value = isBlazor() ? cName : "main." + cName;
      return getValue(value, obj);
    };
    ParserBase2.getNumberingSystem = function(obj) {
      return getValue("supplemental.numberingSystems", obj) || this.numberingSystems;
    };
    ParserBase2.reverseObject = function(prop, keys2) {
      var propKeys = keys2 || Object.keys(prop);
      var res = {};
      for (var _i = 0, propKeys_1 = propKeys; _i < propKeys_1.length; _i++) {
        var key = propKeys_1[_i];
        if (!Object.prototype.hasOwnProperty.call(res, prop["" + key])) {
          res[prop["" + key]] = key;
        }
      }
      return res;
    };
    ParserBase2.getSymbolRegex = function(props) {
      var regexStr = props.map(function(str) {
        return str.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
      }).join("|");
      var regExp3 = RegExp;
      return new regExp3(regexStr, "g");
    };
    ParserBase2.getSymbolMatch = function(prop) {
      var matchKeys = Object.keys(defaultNumberSymbols);
      var ret = {};
      for (var _i = 0, matchKeys_1 = matchKeys; _i < matchKeys_1.length; _i++) {
        var key = matchKeys_1[_i];
        ret[prop["" + key]] = defaultNumberSymbols["" + key];
      }
      return ret;
    };
    ParserBase2.constructRegex = function(val) {
      var len = val.length;
      var ret = "";
      for (var i = 0; i < len; i++) {
        if (i !== len - 1) {
          ret += val[parseInt(i.toString(), 10)] + "|";
        } else {
          ret += val[parseInt(i.toString(), 10)];
        }
      }
      return ret;
    };
    ParserBase2.convertValueParts = function(value, regex, obj) {
      return value.replace(regex, function(str) {
        return obj["" + str];
      });
    };
    ParserBase2.getDefaultNumberingSystem = function(obj) {
      var ret = {};
      ret.obj = getValue("numbers", obj);
      ret.nSystem = getValue("defaultNumberingSystem", ret.obj);
      return ret;
    };
    ParserBase2.getCurrentNumericOptions = function(curObj, numberSystem, needSymbols, blazorMode) {
      var ret = {};
      var cur = this.getDefaultNumberingSystem(curObj);
      if (!isUndefined(cur.nSystem) || blazorMode) {
        var digits = blazorMode ? getValue("obj.mapperDigits", cur) : getValue(cur.nSystem + "._digits", numberSystem);
        if (!isUndefined(digits)) {
          ret.numericPair = this.reverseObject(digits, latnNumberSystem);
          var regExp3 = RegExp;
          ret.numberParseRegex = new regExp3(this.constructRegex(digits), "g");
          ret.numericRegex = "[" + digits[0] + "-" + digits[9] + "]";
          if (needSymbols) {
            ret.numericRegex = digits[0] + "-" + digits[9];
            ret.symbolNumberSystem = getValue(blazorMode ? "numberSymbols" : "symbols-numberSystem-" + cur.nSystem, cur.obj);
            ret.symbolMatch = this.getSymbolMatch(ret.symbolNumberSystem);
            ret.numberSystem = cur.nSystem;
          }
        }
      }
      return ret;
    };
    ParserBase2.getNumberMapper = function(curObj, numberSystem, isNumber) {
      var ret = { mapper: {} };
      var cur = this.getDefaultNumberingSystem(curObj);
      if (!isUndefined(cur.nSystem)) {
        ret.numberSystem = cur.nSystem;
        ret.numberSymbols = getValue("symbols-numberSystem-" + cur.nSystem, cur.obj);
        ret.timeSeparator = getValue("timeSeparator", ret.numberSymbols);
        var digits = getValue(cur.nSystem + "._digits", numberSystem);
        if (!isUndefined(digits)) {
          for (var _i = 0, latnNumberSystem_1 = latnNumberSystem; _i < latnNumberSystem_1.length; _i++) {
            var i = latnNumberSystem_1[_i];
            ret.mapper[parseInt(i.toString(), 10)] = digits[parseInt(i.toString(), 10)];
          }
        }
      }
      return ret;
    };
    ParserBase2.nPair = "numericPair";
    ParserBase2.nRegex = "numericRegex";
    ParserBase2.numberingSystems = defaultNumberingSystem;
    return ParserBase2;
  })()
);
var blazorCurrencyData = {
  "DJF": "Fdj",
  "ERN": "Nfk",
  "ETB": "Br",
  "NAD": "$",
  "ZAR": "R",
  "XAF": "FCFA",
  "GHS": "GH₵",
  "XDR": "XDR",
  "AED": "د.إ.",
  "BHD": "د.ب.",
  "DZD": "د.ج.",
  "EGP": "ج.م.",
  "ILS": "₪",
  "IQD": "د.ع.",
  "JOD": "د.ا.",
  "KMF": "CF",
  "KWD": "د.ك.",
  "LBP": "ل.ل.",
  "LYD": "د.ل.",
  "MAD": "د.م.",
  "MRU": "أ.م.",
  "OMR": "ر.ع.",
  "QAR": "ر.ق.",
  "SAR": "ر.س.",
  "SDG": "ج.س.",
  "SOS": "S",
  "SSP": "£",
  "SYP": "ل.س.",
  "TND": "د.ت.",
  "YER": "ر.ي.",
  "CLP": "$",
  "INR": "₹",
  "TZS": "TSh",
  "EUR": "€",
  "AZN": "₼",
  "RUB": "₽",
  "BYN": "Br",
  "ZMW": "K",
  "BGN": "лв.",
  "NGN": "₦",
  "XOF": "CFA",
  "BDT": "৳",
  "CNY": "¥",
  "BAM": "КМ",
  "UGX": "USh",
  "USD": "$",
  "CZK": "Kč",
  "GBP": "£",
  "DKK": "kr.",
  "KES": "Ksh",
  "CHF": "CHF",
  "MVR": "ރ.",
  "BTN": "Nu.",
  "XCD": "EC$",
  "AUD": "$",
  "BBD": "$",
  "BIF": "FBu",
  "BMD": "$",
  "BSD": "$",
  "BWP": "P",
  "BZD": "$",
  "CAD": "$",
  "NZD": "$",
  "FJD": "$",
  "FKP": "£",
  "GIP": "£",
  "GMD": "D",
  "GYD": "$",
  "HKD": "$",
  "IDR": "Rp",
  "JMD": "$",
  "KYD": "$",
  "LRD": "$",
  "MGA": "Ar",
  "MOP": "MOP$",
  "MUR": "Rs",
  "MWK": "MK",
  "MYR": "RM",
  "PGK": "K",
  "PHP": "₱",
  "PKR": "Rs",
  "RWF": "RF",
  "SBD": "$",
  "SCR": "SR",
  "SEK": "kr",
  "SGD": "$",
  "SHP": "£",
  "SLL": "Le",
  "ANG": "NAf.",
  "SZL": "E",
  "TOP": "T$",
  "TTD": "$",
  "VUV": "VT",
  "WST": "WS$",
  "ARS": "$",
  "BOB": "Bs",
  "BRL": "R$",
  "COP": "$",
  "CRC": "₡",
  "CUP": "$",
  "DOP": "$",
  "GTQ": "Q",
  "HNL": "L",
  "MXN": "$",
  "NIO": "C$",
  "PAB": "B/.",
  "PEN": "S/",
  "PYG": "₲",
  "UYU": "$",
  "VES": "Bs.S",
  "IRR": "ريال",
  "GNF": "FG",
  "CDF": "FC",
  "HTG": "G",
  "XPF": "FCFP",
  "HRK": "kn",
  "HUF": "Ft",
  "AMD": "֏",
  "ISK": "kr",
  "JPY": "¥",
  "GEL": "₾",
  "CVE": "​",
  "KZT": "₸",
  "KHR": "៛",
  "KPW": "₩",
  "KRW": "₩",
  "KGS": "сом",
  "AOA": "Kz",
  "LAK": "₭",
  "MZN": "MTn",
  "MKD": "ден",
  "MNT": "₮",
  "BND": "$",
  "MMK": "K",
  "NOK": "kr",
  "NPR": "रु",
  "AWG": "Afl.",
  "SRD": "$",
  "PLN": "zł",
  "AFN": "؋",
  "STN": "Db",
  "MDL": "L",
  "RON": "lei",
  "UAH": "₴",
  "LKR": "රු.",
  "ALL": "Lekë",
  "RSD": "дин.",
  "TJS": "смн",
  "THB": "฿",
  "TMT": "m.",
  "TRY": "₺",
  "UZS": "сўм",
  "VND": "₫",
  "TWD": "NT$"
};
function getBlazorCurrencySymbol(currencyCode) {
  return getValue(currencyCode || "", blazorCurrencyData);
}

// node_modules/@syncfusion/ej2-base/src/intl/intl-base.js
var defaultCurrencyCode = "USD";
var NumberFormat = null;
var DateFormat = null;
function setNumberFormat(value) {
  NumberFormat = value;
}
function setDateFormat(value) {
  DateFormat = value;
}
var regExp = RegExp;
var blazorCultureFormats = {
  "en-US": {
    "d": "M/d/y",
    "D": "EEEE, MMMM d, y",
    "f": "EEEE, MMMM d, y h:mm a",
    "F": "EEEE, MMMM d, y h:mm:s a",
    "g": "M/d/y h:mm a",
    "G": "M/d/yyyy h:mm:ss tt",
    "m": "MMMM d",
    "M": "MMMM d",
    "r": "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'",
    "R": "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'",
    "s": "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
    "t": "h:mm tt",
    "T": "h:m:s tt",
    "u": "yyyy'-'MM'-'dd HH':'mm':'ss'Z'",
    "U": "dddd, MMMM d, yyyy h:mm:ss tt",
    "y": "MMMM yyyy",
    "Y": "MMMM yyyy"
  }
};
var IntlBase;
(function(IntlBase2) {
  IntlBase2.negativeDataRegex = /^(('[^']+'|''|[^*#@0,.E])*)(\*.)?((([#,]*[0,]*0+)(\.0*[0-9]*#*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
  IntlBase2.customRegex = /^(('[^']+'|''|[^*#@0,.])*)(\*.)?((([0#,]*[0,]*[0#]*[0# ]*)(\.[0#]*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
  IntlBase2.latnParseRegex = /0|1|2|3|4|5|6|7|8|9/g;
  var fractionRegex = /[0-9]/g;
  IntlBase2.defaultCurrency = "$";
  var mapper2 = ["infinity", "nan", "group", "decimal"];
  var patternRegex = /G|M|L|H|c|'| a|yy|y|EEEE|E/g;
  var patternMatch = {
    "G": "",
    "M": "m",
    "L": "m",
    "H": "h",
    "c": "d",
    "'": '"',
    " a": " AM/PM",
    "yy": "yy",
    "y": "yyyy",
    "EEEE": "dddd",
    "E": "ddd"
  };
  IntlBase2.dateConverterMapper = /dddd|ddd/ig;
  var defaultFirstDay = "sun";
  IntlBase2.islamicRegex = /^islamic/;
  var firstDayMapper = {
    "sun": 0,
    "mon": 1,
    "tue": 2,
    "wed": 3,
    "thu": 4,
    "fri": 5,
    "sat": 6
  };
  IntlBase2.formatRegex = new regExp("(^[ncpae]{1})([0-1]?[0-9]|20)?$", "i");
  IntlBase2.currencyFormatRegex = new regExp("(^[ca]{1})([0-1]?[0-9]|20)?$", "i");
  IntlBase2.curWithoutNumberRegex = /(c|a)$/ig;
  var typeMapper = {
    "$": "isCurrency",
    "%": "isPercent",
    "-": "isNegative",
    0: "nlead",
    1: "nend"
  };
  IntlBase2.dateParseRegex = /([a-z])\1*|'([^']|'')+'|''|./gi;
  IntlBase2.basicPatterns = ["short", "medium", "long", "full"];
  IntlBase2.defaultObject = {
    "dates": {
      "calendars": {
        "gregorian": {
          "months": {
            "stand-alone": {
              "abbreviated": {
                "1": "Jan",
                "2": "Feb",
                "3": "Mar",
                "4": "Apr",
                "5": "May",
                "6": "Jun",
                "7": "Jul",
                "8": "Aug",
                "9": "Sep",
                "10": "Oct",
                "11": "Nov",
                "12": "Dec"
              },
              "narrow": {
                "1": "J",
                "2": "F",
                "3": "M",
                "4": "A",
                "5": "M",
                "6": "J",
                "7": "J",
                "8": "A",
                "9": "S",
                "10": "O",
                "11": "N",
                "12": "D"
              },
              "wide": {
                "1": "January",
                "2": "February",
                "3": "March",
                "4": "April",
                "5": "May",
                "6": "June",
                "7": "July",
                "8": "August",
                "9": "September",
                "10": "October",
                "11": "November",
                "12": "December"
              }
            }
          },
          "days": {
            "stand-alone": {
              "abbreviated": {
                "sun": "Sun",
                "mon": "Mon",
                "tue": "Tue",
                "wed": "Wed",
                "thu": "Thu",
                "fri": "Fri",
                "sat": "Sat"
              },
              "narrow": {
                "sun": "S",
                "mon": "M",
                "tue": "T",
                "wed": "W",
                "thu": "T",
                "fri": "F",
                "sat": "S"
              },
              "short": {
                "sun": "Su",
                "mon": "Mo",
                "tue": "Tu",
                "wed": "We",
                "thu": "Th",
                "fri": "Fr",
                "sat": "Sa"
              },
              "wide": {
                "sun": "Sunday",
                "mon": "Monday",
                "tue": "Tuesday",
                "wed": "Wednesday",
                "thu": "Thursday",
                "fri": "Friday",
                "sat": "Saturday"
              }
            }
          },
          "dayPeriods": {
            "format": {
              "wide": {
                "am": "AM",
                "pm": "PM"
              }
            }
          },
          "eras": {
            "eraNames": {
              "0": "Before Christ",
              "0-alt-variant": "Before Common Era",
              "1": "Anno Domini",
              "1-alt-variant": "Common Era"
            },
            "eraAbbr": {
              "0": "BC",
              "0-alt-variant": "BCE",
              "1": "AD",
              "1-alt-variant": "CE"
            },
            "eraNarrow": {
              "0": "B",
              "0-alt-variant": "BCE",
              "1": "A",
              "1-alt-variant": "CE"
            }
          },
          "dateFormats": {
            "full": "EEEE, MMMM d, y",
            "long": "MMMM d, y",
            "medium": "MMM d, y",
            "short": "M/d/yy"
          },
          "timeFormats": {
            "full": "h:mm:ss a zzzz",
            "long": "h:mm:ss a z",
            "medium": "h:mm:ss a",
            "short": "h:mm a"
          },
          "dateTimeFormats": {
            "full": "{1} 'at' {0}",
            "long": "{1} 'at' {0}",
            "medium": "{1}, {0}",
            "short": "{1}, {0}",
            "availableFormats": {
              "d": "d",
              "E": "ccc",
              "Ed": "d E",
              "Ehm": "E h:mm a",
              "EHm": "E HH:mm",
              "Ehms": "E h:mm:ss a",
              "EHms": "E HH:mm:ss",
              "Gy": "y G",
              "GyMMM": "MMM y G",
              "GyMMMd": "MMM d, y G",
              "GyMMMEd": "E, MMM d, y G",
              "h": "h a",
              "H": "HH",
              "hm": "h:mm a",
              "Hm": "HH:mm",
              "hms": "h:mm:ss a",
              "Hms": "HH:mm:ss",
              "hmsv": "h:mm:ss a v",
              "Hmsv": "HH:mm:ss v",
              "hmv": "h:mm a v",
              "Hmv": "HH:mm v",
              "M": "L",
              "Md": "M/d",
              "MEd": "E, M/d",
              "MMM": "LLL",
              "MMMd": "MMM d",
              "MMMEd": "E, MMM d",
              "MMMMd": "MMMM d",
              "ms": "mm:ss",
              "y": "y",
              "yM": "M/y",
              "yMd": "M/d/y",
              "yMEd": "E, M/d/y",
              "yMMM": "MMM y",
              "yMMMd": "MMM d, y",
              "yMMMEd": "E, MMM d, y",
              "yMMMM": "MMMM y"
            }
          }
        },
        "islamic": {
          "months": {
            "stand-alone": {
              "abbreviated": {
                "1": "Muh.",
                "2": "Saf.",
                "3": "Rab. I",
                "4": "Rab. II",
                "5": "Jum. I",
                "6": "Jum. II",
                "7": "Raj.",
                "8": "Sha.",
                "9": "Ram.",
                "10": "Shaw.",
                "11": "Dhuʻl-Q.",
                "12": "Dhuʻl-H."
              },
              "narrow": {
                "1": "1",
                "2": "2",
                "3": "3",
                "4": "4",
                "5": "5",
                "6": "6",
                "7": "7",
                "8": "8",
                "9": "9",
                "10": "10",
                "11": "11",
                "12": "12"
              },
              "wide": {
                "1": "Muharram",
                "2": "Safar",
                "3": "Rabiʻ I",
                "4": "Rabiʻ II",
                "5": "Jumada I",
                "6": "Jumada II",
                "7": "Rajab",
                "8": "Shaʻban",
                "9": "Ramadan",
                "10": "Shawwal",
                "11": "Dhuʻl-Qiʻdah",
                "12": "Dhuʻl-Hijjah"
              }
            }
          },
          "days": {
            "stand-alone": {
              "abbreviated": {
                "sun": "Sun",
                "mon": "Mon",
                "tue": "Tue",
                "wed": "Wed",
                "thu": "Thu",
                "fri": "Fri",
                "sat": "Sat"
              },
              "narrow": {
                "sun": "S",
                "mon": "M",
                "tue": "T",
                "wed": "W",
                "thu": "T",
                "fri": "F",
                "sat": "S"
              },
              "short": {
                "sun": "Su",
                "mon": "Mo",
                "tue": "Tu",
                "wed": "We",
                "thu": "Th",
                "fri": "Fr",
                "sat": "Sa"
              },
              "wide": {
                "sun": "Sunday",
                "mon": "Monday",
                "tue": "Tuesday",
                "wed": "Wednesday",
                "thu": "Thursday",
                "fri": "Friday",
                "sat": "Saturday"
              }
            }
          },
          "dayPeriods": {
            "format": {
              "wide": {
                "am": "AM",
                "pm": "PM"
              }
            }
          },
          "eras": {
            "eraNames": {
              "0": "AH"
            },
            "eraAbbr": {
              "0": "AH"
            },
            "eraNarrow": {
              "0": "AH"
            }
          },
          "dateFormats": {
            "full": "EEEE, MMMM d, y G",
            "long": "MMMM d, y G",
            "medium": "MMM d, y G",
            "short": "M/d/y GGGGG"
          },
          "timeFormats": {
            "full": "h:mm:ss a zzzz",
            "long": "h:mm:ss a z",
            "medium": "h:mm:ss a",
            "short": "h:mm a"
          },
          "dateTimeFormats": {
            "full": "{1} 'at' {0}",
            "long": "{1} 'at' {0}",
            "medium": "{1}, {0}",
            "short": "{1}, {0}",
            "availableFormats": {
              "d": "d",
              "E": "ccc",
              "Ed": "d E",
              "Ehm": "E h:mm a",
              "EHm": "E HH:mm",
              "Ehms": "E h:mm:ss a",
              "EHms": "E HH:mm:ss",
              "Gy": "y G",
              "GyMMM": "MMM y G",
              "GyMMMd": "MMM d, y G",
              "GyMMMEd": "E, MMM d, y G",
              "h": "h a",
              "H": "HH",
              "hm": "h:mm a",
              "Hm": "HH:mm",
              "hms": "h:mm:ss a",
              "Hms": "HH:mm:ss",
              "M": "L",
              "Md": "M/d",
              "MEd": "E, M/d",
              "MMM": "LLL",
              "MMMd": "MMM d",
              "MMMEd": "E, MMM d",
              "MMMMd": "MMMM d",
              "ms": "mm:ss",
              "y": "y G",
              "yyyy": "y G",
              "yyyyM": "M/y GGGGG",
              "yyyyMd": "M/d/y GGGGG",
              "yyyyMEd": "E, M/d/y GGGGG",
              "yyyyMMM": "MMM y G",
              "yyyyMMMd": "MMM d, y G",
              "yyyyMMMEd": "E, MMM d, y G",
              "yyyyMMMM": "MMMM y G",
              "yyyyQQQ": "QQQ y G",
              "yyyyQQQQ": "QQQQ y G"
            }
          }
        }
      },
      "timeZoneNames": {
        "hourFormat": "+HH:mm;-HH:mm",
        "gmtFormat": "GMT{0}",
        "gmtZeroFormat": "GMT"
      }
    },
    "numbers": {
      "currencies": {
        "USD": {
          "displayName": "US Dollar",
          "symbol": "$",
          "symbol-alt-narrow": "$"
        },
        "EUR": {
          "displayName": "Euro",
          "symbol": "€",
          "symbol-alt-narrow": "€"
        },
        "GBP": {
          "displayName": "British Pound",
          "symbol-alt-narrow": "£"
        }
      },
      "defaultNumberingSystem": "latn",
      "minimumGroupingDigits": "1",
      "symbols-numberSystem-latn": {
        "decimal": ".",
        "group": ",",
        "list": ";",
        "percentSign": "%",
        "plusSign": "+",
        "minusSign": "-",
        "exponential": "E",
        "superscriptingExponent": "×",
        "perMille": "‰",
        "infinity": "∞",
        "nan": "NaN",
        "timeSeparator": ":"
      },
      "decimalFormats-numberSystem-latn": {
        "standard": "#,##0.###"
      },
      "percentFormats-numberSystem-latn": {
        "standard": "#,##0%"
      },
      "currencyFormats-numberSystem-latn": {
        "standard": "¤#,##0.00",
        "accounting": "¤#,##0.00;(¤#,##0.00)"
      },
      "scientificFormats-numberSystem-latn": {
        "standard": "#E0"
      }
    }
  };
  IntlBase2.blazorDefaultObject = {
    "numbers": {
      "mapper": {
        "0": "0",
        "1": "1",
        "2": "2",
        "3": "3",
        "4": "4",
        "5": "5",
        "6": "6",
        "7": "7",
        "8": "8",
        "9": "9"
      },
      "mapperDigits": "0123456789",
      "numberSymbols": {
        "decimal": ".",
        "group": ",",
        "plusSign": "+",
        "minusSign": "-",
        "percentSign": "%",
        "nan": "NaN",
        "timeSeparator": ":",
        "infinity": "∞"
      },
      "timeSeparator": ":",
      "currencySymbol": "$",
      "currencypData": {
        "nlead": "$",
        "nend": "",
        "groupSeparator": ",",
        "groupData": {
          "primary": 3
        },
        "maximumFraction": 2,
        "minimumFraction": 2
      },
      "percentpData": {
        "nlead": "",
        "nend": "%",
        "groupSeparator": ",",
        "groupData": {
          "primary": 3
        },
        "maximumFraction": 2,
        "minimumFraction": 2
      },
      "percentnData": {
        "nlead": "-",
        "nend": "%",
        "groupSeparator": ",",
        "groupData": {
          "primary": 3
        },
        "maximumFraction": 2,
        "minimumFraction": 2
      },
      "currencynData": {
        "nlead": "($",
        "nend": ")",
        "groupSeparator": ",",
        "groupData": {
          "primary": 3
        },
        "maximumFraction": 2,
        "minimumFraction": 2
      },
      "decimalnData": {
        "nlead": "-",
        "nend": "",
        "groupData": {
          "primary": 3
        },
        "maximumFraction": 2,
        "minimumFraction": 2
      },
      "decimalpData": {
        "nlead": "",
        "nend": "",
        "groupData": {
          "primary": 3
        },
        "maximumFraction": 2,
        "minimumFraction": 2
      }
    },
    "dates": {
      "dayPeriods": {
        "am": "AM",
        "pm": "PM"
      },
      "dateSeperator": "/",
      "days": {
        "abbreviated": {
          "sun": "Sun",
          "mon": "Mon",
          "tue": "Tue",
          "wed": "Wed",
          "thu": "Thu",
          "fri": "Fri",
          "sat": "Sat"
        },
        "short": {
          "sun": "Su",
          "mon": "Mo",
          "tue": "Tu",
          "wed": "We",
          "thu": "Th",
          "fri": "Fr",
          "sat": "Sa"
        },
        "wide": {
          "sun": "Sunday",
          "mon": "Monday",
          "tue": "Tuesday",
          "wed": "Wednesday",
          "thu": "Thursday",
          "fri": "Friday",
          "sat": "Saturday"
        }
      },
      "months": {
        "abbreviated": {
          "1": "Jan",
          "2": "Feb",
          "3": "Mar",
          "4": "Apr",
          "5": "May",
          "6": "Jun",
          "7": "Jul",
          "8": "Aug",
          "9": "Sep",
          "10": "Oct",
          "11": "Nov",
          "12": "Dec"
        },
        "wide": {
          "1": "January",
          "2": "February",
          "3": "March",
          "4": "April",
          "5": "May",
          "6": "June",
          "7": "July",
          "8": "August",
          "9": "September",
          "10": "October",
          "11": "November",
          "12": "December"
        }
      },
      "eras": {
        "1": "AD"
      }
    }
  };
  IntlBase2.monthIndex = {
    3: "abbreviated",
    4: "wide",
    5: "narrow",
    1: "abbreviated"
  };
  IntlBase2.month = "months";
  IntlBase2.days = "days";
  IntlBase2.patternMatcher = {
    C: "currency",
    P: "percent",
    N: "decimal",
    A: "currency",
    E: "scientific"
  };
  function getResultantPattern(skeleton, dateObject, type, isIslamic, blazorCulture) {
    var resPattern;
    var iType = type || "date";
    if (blazorCulture) {
      resPattern = compareBlazorDateFormats({ skeleton }, blazorCulture).format || compareBlazorDateFormats({ skeleton: "d" }, "en-US").format;
    } else {
      if (IntlBase2.basicPatterns.indexOf(skeleton) !== -1) {
        resPattern = getValue(iType + "Formats." + skeleton, dateObject);
        if (iType === "dateTime") {
          var dPattern = getValue("dateFormats." + skeleton, dateObject);
          var tPattern = getValue("timeFormats." + skeleton, dateObject);
          resPattern = resPattern.replace("{1}", dPattern).replace("{0}", tPattern);
        }
      } else {
        resPattern = getValue("dateTimeFormats.availableFormats." + skeleton, dateObject);
      }
      if (isUndefined(resPattern) && skeleton === "yMd") {
        resPattern = "M/d/y";
      }
    }
    return resPattern;
  }
  IntlBase2.getResultantPattern = getResultantPattern;
  function getDependables(cldr, culture, mode, isNumber) {
    var ret = {};
    var calendartype = mode || "gregorian";
    ret.parserObject = ParserBase.getMainObject(cldr, culture) || (isBlazor() ? IntlBase2.blazorDefaultObject : IntlBase2.defaultObject);
    if (isNumber) {
      ret.numericObject = getValue("numbers", ret.parserObject);
    } else {
      var dateString = isBlazor() ? "dates" : "dates.calendars." + calendartype;
      ret.dateObject = getValue(dateString, ret.parserObject);
    }
    return ret;
  }
  IntlBase2.getDependables = getDependables;
  function getSymbolPattern(type, numSystem, obj, isAccount) {
    return getValue(type + "Formats-numberSystem-" + numSystem + (isAccount ? ".accounting" : ".standard"), obj) || (isAccount ? getValue(type + "Formats-numberSystem-" + numSystem + ".standard", obj) : "");
  }
  IntlBase2.getSymbolPattern = getSymbolPattern;
  function ConvertDateToWeekFormat(format) {
    var convertMapper = format.match(IntlBase2.dateConverterMapper);
    if (convertMapper && isBlazor()) {
      var tempString = convertMapper[0].length === 3 ? "EEE" : "EEEE";
      return format.replace(IntlBase2.dateConverterMapper, tempString);
    }
    return format;
  }
  IntlBase2.ConvertDateToWeekFormat = ConvertDateToWeekFormat;
  function compareBlazorDateFormats(formatOptions, culture) {
    var format = formatOptions.format || formatOptions.skeleton;
    var curFormatMapper = getValue((culture || "en-US") + "." + format, blazorCultureFormats);
    if (!curFormatMapper) {
      curFormatMapper = getValue("en-US." + format, blazorCultureFormats);
    }
    if (curFormatMapper) {
      curFormatMapper = ConvertDateToWeekFormat(curFormatMapper);
      formatOptions.format = curFormatMapper.replace(/tt/, "a");
    }
    return formatOptions;
  }
  IntlBase2.compareBlazorDateFormats = compareBlazorDateFormats;
  function getProperNumericSkeleton(skeleton) {
    var matches2 = skeleton.match(IntlBase2.formatRegex);
    var ret = {};
    var pattern = matches2[1].toUpperCase();
    ret.isAccount = pattern === "A";
    ret.type = IntlBase2.patternMatcher["" + pattern];
    if (skeleton.length > 1) {
      ret.fractionDigits = parseInt(matches2[2], 10);
    }
    return ret;
  }
  IntlBase2.getProperNumericSkeleton = getProperNumericSkeleton;
  function getFormatData(pattern, needFraction, cSymbol, fractionOnly) {
    var nData = fractionOnly ? {} : { nlead: "", nend: "" };
    var match = pattern.match(IntlBase2.customRegex);
    if (match) {
      if (!fractionOnly) {
        nData.nlead = changeCurrencySymbol(match[1], cSymbol);
        nData.nend = changeCurrencySymbol(match[10], cSymbol);
        nData.groupPattern = match[4];
      }
      var fraction = match[7];
      if (fraction && needFraction) {
        var fmatch = fraction.match(fractionRegex);
        if (!isNullOrUndefined(fmatch)) {
          nData.minimumFraction = fmatch.length;
        } else {
          nData.minimumFraction = 0;
        }
        nData.maximumFraction = fraction.length - 1;
      }
    }
    return nData;
  }
  IntlBase2.getFormatData = getFormatData;
  function changeCurrencySymbol(val, sym) {
    if (val) {
      val = val.replace(IntlBase2.defaultCurrency, sym);
      return sym === "" ? val.trim() : val;
    }
    return "";
  }
  IntlBase2.changeCurrencySymbol = changeCurrencySymbol;
  function getCurrencySymbol(numericObject, currencyCode, altSymbol, ignoreCurrency) {
    var symbol = altSymbol ? "." + altSymbol : ".symbol";
    var getCurrency = ignoreCurrency ? "$" : getValue("currencies." + currencyCode + symbol, numericObject) || getValue("currencies." + currencyCode + ".symbol-alt-narrow", numericObject) || "$";
    return getCurrency;
  }
  IntlBase2.getCurrencySymbol = getCurrencySymbol;
  function customFormat(format, dOptions, obj) {
    var options = {};
    var formatSplit = format.split(";");
    var data = ["pData", "nData", "zeroData"];
    for (var i = 0; i < formatSplit.length; i++) {
      options["" + data[parseInt(i.toString(), 10)]] = customNumberFormat(formatSplit[parseInt(i.toString(), 10)], dOptions, obj);
    }
    if (isNullOrUndefined(options.nData)) {
      options.nData = extend({}, options.pData);
      options.nData.nlead = isNullOrUndefined(dOptions) ? "-" + options.nData.nlead : dOptions.minusSymbol + options.nData.nlead;
    }
    return options;
  }
  IntlBase2.customFormat = customFormat;
  function customNumberFormat(format, dOptions, numObject) {
    var cOptions = { type: "decimal", minimumFractionDigits: 0, maximumFractionDigits: 0 };
    var pattern = format.match(IntlBase2.customRegex);
    if (isNullOrUndefined(pattern) || pattern[5] === "" && format !== "N/A") {
      cOptions.type = void 0;
      return cOptions;
    }
    cOptions.nlead = pattern[1];
    cOptions.nend = pattern[10];
    var integerPart = pattern[6];
    var spaceCapture = integerPart.match(/ $/g) ? true : false;
    var spaceGrouping = integerPart.replace(/ $/g, "").indexOf(" ") !== -1;
    cOptions.useGrouping = integerPart.indexOf(",") !== -1 || spaceGrouping;
    integerPart = integerPart.replace(/,/g, "");
    integerPart = /\s$/.test(integerPart) ? integerPart.replace(/ /g, "") : integerPart;
    var fractionPart = pattern[7];
    if (integerPart.indexOf("0") !== -1) {
      cOptions.minimumIntegerDigits = integerPart.length - integerPart.indexOf("0");
    }
    if (!isNullOrUndefined(fractionPart)) {
      cOptions.minimumFractionDigits = fractionPart.lastIndexOf("0");
      cOptions.maximumFractionDigits = fractionPart.lastIndexOf("#");
      if (cOptions.minimumFractionDigits === -1) {
        cOptions.minimumFractionDigits = 0;
      }
      if (cOptions.maximumFractionDigits === -1 || cOptions.maximumFractionDigits < cOptions.minimumFractionDigits) {
        cOptions.maximumFractionDigits = cOptions.minimumFractionDigits;
      }
    }
    if (!isNullOrUndefined(dOptions)) {
      dOptions.isCustomFormat = true;
      extend(cOptions, isCurrencyPercent([cOptions.nlead, cOptions.nend], "$", dOptions.currencySymbol));
      if (!cOptions.isCurrency) {
        extend(cOptions, isCurrencyPercent([cOptions.nlead, cOptions.nend], "%", dOptions.percentSymbol));
      }
    } else {
      extend(cOptions, isCurrencyPercent([cOptions.nlead, cOptions.nend], "%", "%"));
    }
    if (!isNullOrUndefined(numObject)) {
      var symbolPattern = getSymbolPattern(cOptions.type, dOptions.numberMapper.numberSystem, numObject, false);
      if (cOptions.useGrouping) {
        cOptions.groupSeparator = spaceGrouping ? " " : dOptions.numberMapper.numberSymbols[mapper2[2]];
        cOptions.groupData = NumberFormat.getGroupingDetails(symbolPattern.split(";")[0]);
      }
      cOptions.nlead = cOptions.nlead.replace(/'/g, "");
      cOptions.nend = spaceCapture ? " " + cOptions.nend.replace(/'/g, "") : cOptions.nend.replace(/'/g, "");
    }
    return cOptions;
  }
  IntlBase2.customNumberFormat = customNumberFormat;
  function isCurrencyPercent(parts, actual, symbol) {
    var options = { nlead: parts[0], nend: parts[1] };
    for (var i = 0; i < 2; i++) {
      var part = parts[parseInt(i.toString(), 10)];
      var loc = part.indexOf(actual);
      if (loc !== -1 && (loc < part.indexOf("'") || loc > part.lastIndexOf("'"))) {
        options["" + typeMapper[parseInt(i.toString(), 10)]] = part.substr(0, loc) + symbol + part.substr(loc + 1);
        options["" + typeMapper["" + actual]] = true;
        options.type = options.isCurrency ? "currency" : "percent";
        break;
      }
    }
    return options;
  }
  IntlBase2.isCurrencyPercent = isCurrencyPercent;
  function getDateSeparator(dateObj) {
    var value = (getValue("dateFormats.short", dateObj) || "").match(/[dM]([^dM])[dM]/i);
    return value ? value[1] : "/";
  }
  IntlBase2.getDateSeparator = getDateSeparator;
  function getActualDateTimeFormat(culture, options, cldr, isExcelFormat) {
    var dependable = getDependables(cldr, culture, options.calendar);
    if (isBlazor()) {
      options = compareBlazorDateFormats(options, culture);
    }
    var actualPattern = options.format || getResultantPattern(options.skeleton, dependable.dateObject, options.type);
    if (isExcelFormat) {
      actualPattern = actualPattern.replace(patternRegex, function(pattern2) {
        return patternMatch["" + pattern2];
      });
      if (actualPattern.indexOf("z") !== -1) {
        var tLength = actualPattern.match(/z/g).length;
        var timeZonePattern = void 0;
        var options_1 = { "timeZone": {} };
        options_1.numMapper = ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr));
        options_1.timeZone = getValue("dates.timeZoneNames", dependable.parserObject);
        var value = /* @__PURE__ */ new Date();
        var timezone = value.getTimezoneOffset();
        var pattern = tLength < 4 ? "+H;-H" : options_1.timeZone.hourFormat;
        pattern = pattern.replace(/:/g, options_1.numMapper.timeSeparator);
        if (timezone === 0) {
          timeZonePattern = options_1.timeZone.gmtZeroFormat;
        } else {
          timeZonePattern = DateFormat.getTimeZoneValue(timezone, pattern);
          timeZonePattern = options_1.timeZone.gmtFormat.replace(/\{0\}/, timeZonePattern);
        }
        actualPattern = actualPattern.replace(/[z]+/, '"' + timeZonePattern + '"');
      }
      actualPattern = actualPattern.replace(/ $/, "");
    }
    return actualPattern;
  }
  IntlBase2.getActualDateTimeFormat = getActualDateTimeFormat;
  function processSymbol(actual, option) {
    if (actual.indexOf(",") !== -1) {
      var split = actual.split(",");
      actual = split[0] + getValue("numberMapper.numberSymbols.group", option) + split[1].replace(".", getValue("numberMapper.numberSymbols.decimal", option));
    } else {
      actual = actual.replace(".", getValue("numberMapper.numberSymbols.decimal", option));
    }
    return actual;
  }
  IntlBase2.processSymbol = processSymbol;
  function getActualNumberFormat(culture, options, cldr, isExcel) {
    var dependable = getDependables(cldr, culture, "", true);
    var parseOptions = { custom: true };
    var numrericObject = dependable.numericObject;
    var minFrac;
    var curObj = {};
    var curMatch = (options.format || "").match(IntlBase2.currencyFormatRegex);
    var type = IntlBase2.formatRegex.test(options.format) ? getProperNumericSkeleton(options.format || "N") : {};
    var dOptions = {};
    if (curMatch) {
      dOptions.numberMapper = isBlazor() ? extend({}, dependable.numericObject) : ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr), true);
      var curCode = isBlazor() ? getValue("currencySymbol", dependable.numericObject) : getCurrencySymbol(dependable.numericObject, options.currency || defaultCurrencyCode, options.altSymbol);
      var symbolPattern = getSymbolPattern("currency", dOptions.numberMapper.numberSystem, dependable.numericObject, /a/i.test(options.format));
      symbolPattern = symbolPattern.replace(/\u00A4/g, curCode);
      var split = symbolPattern.split(";");
      curObj.hasNegativePattern = isBlazor() ? true : split.length > 1;
      curObj.nData = isBlazor() ? getValue(type.type + "nData", numrericObject) : getFormatData(split[1] || "-" + split[0], true, curCode);
      curObj.pData = isBlazor() ? getValue(type.type + "pData", numrericObject) : getFormatData(split[0], false, curCode);
      if (!curMatch[2] && !options.minimumFractionDigits && !options.maximumFractionDigits) {
        minFrac = getFormatData(symbolPattern.split(";")[0], true, "", true).minimumFraction;
      }
    }
    var actualPattern;
    if (IntlBase2.formatRegex.test(options.format) || !options.format) {
      extend(parseOptions, getProperNumericSkeleton(options.format || "N"));
      parseOptions.custom = false;
      actualPattern = "###0";
      if (parseOptions.fractionDigits || options.minimumFractionDigits || options.maximumFractionDigits || minFrac) {
        var defaultMinimum = 0;
        if (parseOptions.fractionDigits) {
          options.minimumFractionDigits = options.maximumFractionDigits = parseOptions.fractionDigits;
        }
        actualPattern = fractionDigitsPattern(actualPattern, minFrac || parseOptions.fractionDigits || options.minimumFractionDigits || defaultMinimum, options.maximumFractionDigits || defaultMinimum);
      }
      if (options.minimumIntegerDigits) {
        actualPattern = minimumIntegerPattern(actualPattern, options.minimumIntegerDigits);
      }
      if (options.useGrouping) {
        actualPattern = groupingPattern(actualPattern);
      }
      if (parseOptions.type === "currency" || parseOptions.type && isBlazor()) {
        if (isBlazor() && parseOptions.type !== "currency") {
          curObj.pData = getValue(parseOptions.type + "pData", numrericObject);
          curObj.nData = getValue(parseOptions.type + "nData", numrericObject);
        }
        var cPattern = actualPattern;
        actualPattern = curObj.pData.nlead + cPattern + curObj.pData.nend;
        if (curObj.hasNegativePattern || isBlazor()) {
          actualPattern += ";" + curObj.nData.nlead + cPattern + curObj.nData.nend;
        }
      }
      if (parseOptions.type === "percent" && !isBlazor()) {
        actualPattern += " %";
      }
    } else {
      actualPattern = options.format.replace(/'/g, '"');
    }
    if (Object.keys(dOptions).length > 0) {
      actualPattern = !isExcel ? processSymbol(actualPattern, dOptions) : actualPattern;
    }
    return actualPattern;
  }
  IntlBase2.getActualNumberFormat = getActualNumberFormat;
  function fractionDigitsPattern(pattern, minDigits, maxDigits) {
    pattern += ".";
    for (var a = 0; a < minDigits; a++) {
      pattern += "0";
    }
    if (minDigits < maxDigits) {
      var diff = maxDigits - minDigits;
      for (var b = 0; b < diff; b++) {
        pattern += "#";
      }
    }
    return pattern;
  }
  IntlBase2.fractionDigitsPattern = fractionDigitsPattern;
  function minimumIntegerPattern(pattern, digits) {
    var temp = pattern.split(".");
    var integer = "";
    for (var x = 0; x < digits; x++) {
      integer += "0";
    }
    return temp[1] ? integer + "." + temp[1] : integer;
  }
  IntlBase2.minimumIntegerPattern = minimumIntegerPattern;
  function groupingPattern(pattern) {
    var temp = pattern.split(".");
    var integer = temp[0];
    var no = 3 - integer.length % 3;
    var hash = no && no === 1 ? "#" : no === 2 ? "##" : "";
    integer = hash + integer;
    pattern = "";
    for (var x = integer.length - 1; x > 0; x = x - 3) {
      pattern = "," + integer[x - 2] + integer[x - 1] + integer[parseInt(x.toString(), 10)] + pattern;
    }
    pattern = pattern.slice(1);
    return temp[1] ? pattern + "." + temp[1] : pattern;
  }
  IntlBase2.groupingPattern = groupingPattern;
  function getWeekData(culture, cldr) {
    var firstDay = defaultFirstDay;
    var mapper3 = getValue("supplemental.weekData.firstDay", cldr);
    var iCulture = culture;
    if (/en-/.test(iCulture)) {
      iCulture = iCulture.slice(3);
    }
    iCulture = iCulture.slice(0, 2).toUpperCase() + iCulture.substr(2);
    if (mapper3) {
      firstDay = mapper3["" + iCulture] || mapper3[iCulture.slice(0, 2)] || defaultFirstDay;
    }
    return firstDayMapper["" + firstDay];
  }
  IntlBase2.getWeekData = getWeekData;
  function replaceBlazorCurrency(pData, aCurrency, rCurrency) {
    var iCurrency = getBlazorCurrencySymbol(rCurrency);
    if (aCurrency !== iCurrency) {
      for (var _i = 0, pData_1 = pData; _i < pData_1.length; _i++) {
        var data = pData_1[_i];
        data.nend = data.nend.replace(aCurrency, iCurrency);
        data.nlead = data.nlead.replace(aCurrency, iCurrency);
      }
    }
  }
  IntlBase2.replaceBlazorCurrency = replaceBlazorCurrency;
  function getWeekOfYear(date, firstDayOfWeek) {
    var newYear = new Date(date.getFullYear(), 0, 1);
    var day = newYear.getDay();
    var weeknum;
    day = day >= 0 ? day : day + 7;
    var daynum = Math.floor((date.getTime() - newYear.getTime() - (date.getTimezoneOffset() - newYear.getTimezoneOffset()) * 6e4) / 864e5) + 1;
    if (day < 4) {
      weeknum = Math.floor((daynum + day - firstDayOfWeek - 1) / 7) + 1;
      if (weeknum > 52) {
        var nYear = new Date(date.getFullYear() + 1, 0, 1);
        var nday = nYear.getDay();
        nday = nday >= 0 ? nday : nday + 7;
        weeknum = nday < 4 ? 1 : 53;
      }
    } else {
      weeknum = Math.floor((daynum + day - firstDayOfWeek - 1) / 7);
    }
    return weeknum;
  }
  IntlBase2.getWeekOfYear = getWeekOfYear;
})(IntlBase || (IntlBase = {}));

// node_modules/@syncfusion/ej2-base/src/ajax.js
var headerRegex = /^(.*?):[ \t]*([^\r\n]*)$/gm;
var defaultType = "GET";
var Ajax = (
  /** @class */
  (function() {
    function Ajax2(options, type, async, contentType) {
      this.mode = true;
      this.emitError = true;
      this.options = {};
      if (typeof options === "string") {
        this.url = options;
        this.type = type ? type.toUpperCase() : defaultType;
        this.mode = !isNullOrUndefined(async) ? async : true;
      } else if (typeof options === "object") {
        this.options = options;
        merge(this, this.options);
      }
      this.type = this.type ? this.type.toUpperCase() : defaultType;
      this.contentType = this.contentType !== void 0 ? this.contentType : contentType;
    }
    Ajax2.prototype.send = function(data) {
      var _this = this;
      this.data = isNullOrUndefined(data) ? this.data : data;
      var eventArgs = {
        cancel: false,
        httpRequest: null
      };
      var promise = new Promise(function(resolve, reject) {
        _this.httpRequest = new XMLHttpRequest();
        _this.httpRequest.onreadystatechange = function() {
          _this.stateChange(resolve, reject);
        };
        if (!isNullOrUndefined(_this.onLoad)) {
          _this.httpRequest.onload = _this.onLoad;
        }
        if (!isNullOrUndefined(_this.onProgress)) {
          _this.httpRequest.onprogress = _this.onProgress;
        }
        if (!isNullOrUndefined(_this.onAbort)) {
          _this.httpRequest.onabort = _this.onAbort;
        }
        if (!isNullOrUndefined(_this.onError)) {
          _this.httpRequest.onerror = _this.onError;
        }
        if (!isNullOrUndefined(_this.onUploadProgress)) {
          _this.httpRequest.upload.onprogress = _this.onUploadProgress;
        }
        _this.httpRequest.open(_this.type, _this.url, _this.mode);
        if (!isNullOrUndefined(_this.data) && _this.contentType !== null) {
          _this.httpRequest.setRequestHeader("Content-Type", _this.contentType || "application/json; charset=utf-8");
        }
        if (_this.beforeSend) {
          eventArgs.httpRequest = _this.httpRequest;
          _this.beforeSend(eventArgs);
        }
        if (!eventArgs.cancel) {
          _this.httpRequest.send(!isNullOrUndefined(_this.data) ? _this.data : null);
        }
      });
      return promise;
    };
    Ajax2.prototype.successHandler = function(data) {
      if (this.onSuccess) {
        this.onSuccess(data, this);
      }
      return data;
    };
    Ajax2.prototype.failureHandler = function(reason) {
      if (this.onFailure) {
        this.onFailure(this.httpRequest);
      }
      return reason;
    };
    Ajax2.prototype.stateChange = function(resolve, reject) {
      var data = this.httpRequest.responseText;
      if (this.dataType && this.dataType.toLowerCase() === "json") {
        if (data === "") {
          data = void 0;
        } else {
          try {
            data = JSON.parse(data);
          } catch (error) {
          }
        }
      }
      if (this.httpRequest.readyState === 4) {
        if (this.httpRequest.status >= 200 && this.httpRequest.status <= 299 || this.httpRequest.status === 304) {
          resolve(this.successHandler(data));
        } else {
          if (this.emitError) {
            reject(new Error(this.failureHandler(this.httpRequest.statusText)));
          } else {
            resolve();
          }
        }
      }
    };
    Ajax2.prototype.getResponseHeader = function(key) {
      var responseHeaders = {};
      var headers = headerRegex.exec(this.httpRequest.getAllResponseHeaders());
      while (headers) {
        responseHeaders[headers[1].toLowerCase()] = headers[2];
        headers = headerRegex.exec(this.httpRequest.getAllResponseHeaders());
      }
      var header = responseHeaders[key.toLowerCase()];
      return isNullOrUndefined(header) ? null : header;
    };
    return Ajax2;
  })()
);

// node_modules/@syncfusion/ej2-base/src/fetch.js
var Fetch = (
  /** @class */
  (function() {
    function Fetch2(options, type, contentType) {
      this.type = "GET";
      this.emitError = true;
      if (typeof options === "string") {
        this.url = options;
        this.type = !isNullOrUndefined(type) ? type.toUpperCase() : this.type;
        this.contentType = contentType;
      } else if (isObject(options) && Object.keys(options).length > 0) {
        merge(this, options);
      }
      this.contentType = !isNullOrUndefined(this.contentType) ? this.contentType : "application/json; charset=utf-8";
    }
    Fetch2.prototype.send = function(data) {
      var _this = this;
      var contentTypes = {
        "application/json": "json",
        "multipart/form-data": "formData",
        "application/octet-stream": "blob",
        "application/x-www-form-urlencoded": "formData"
      };
      try {
        if (isNullOrUndefined(this.fetchRequest) && this.type === "GET") {
          this.fetchRequest = new Request(this.url, { method: this.type });
        } else if (isNullOrUndefined(this.fetchRequest)) {
          this.data = !isNullOrUndefined(data) ? data : this.data;
          this.fetchRequest = new Request(this.url, {
            method: this.type,
            headers: { "Content-Type": this.contentType },
            body: this.data
          });
        }
        var eventArgs = { cancel: false, fetchRequest: this.fetchRequest };
        this.triggerEvent(this["beforeSend"], eventArgs);
        if (eventArgs.cancel) {
          return null;
        }
        this.fetchResponse = fetch(this.fetchRequest);
        return this.fetchResponse.then(function(response) {
          _this.triggerEvent(_this["onLoad"], response);
          if (!response.ok) {
            throw response;
          }
          var responseType = "text";
          for (var _i = 0, _a = Object.keys(contentTypes); _i < _a.length; _i++) {
            var key = _a[_i];
            if (response.headers.get("Content-Type") && response.headers.get("Content-Type").indexOf(key) !== -1) {
              responseType = contentTypes[key];
            }
          }
          return response[responseType]();
        }).then(function(data2) {
          _this.triggerEvent(_this["onSuccess"], data2, _this);
          return data2;
        }).catch(function(error) {
          var returnVal = {};
          if (_this.emitError) {
            _this.triggerEvent(_this["onFailure"], error);
            returnVal = Promise.reject(error);
          }
          return returnVal;
        });
      } catch (error) {
        return error;
      }
    };
    Fetch2.prototype.triggerEvent = function(callback, data, instance) {
      if (!isNullOrUndefined(callback) && typeof callback === "function") {
        callback(data, instance);
      }
    };
    return Fetch2;
  })()
);

// node_modules/@syncfusion/ej2-base/src/browser.js
var REGX_MOBILE = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|mobile/i;
var REGX_IE = /msie|trident/i;
var REGX_IE11 = /Trident\/7\./;
var REGX_IOS = /(ipad|iphone|ipod touch)/i;
var REGX_IOS7 = /(ipad|iphone|ipod touch);.*os 7_\d|(ipad|iphone|ipod touch);.*os 8_\d/i;
var REGX_ANDROID = /android/i;
var REGX_WINDOWS = /trident|windows phone|edge/i;
var REGX_VERSION = /(version)[ /]([\w.]+)/i;
var REGX_BROWSER = {
  OPERA: /(opera|opr)(?:.*version|)[ /]([\w.]+)/i,
  EDGE: /(edge)(?:.*version|)[ /]([\w.]+)/i,
  CHROME: /(chrome|crios)[ /]([\w.]+)/i,
  PANTHOMEJS: /(phantomjs)[ /]([\w.]+)/i,
  SAFARI: /(safari)[ /]([\w.]+)/i,
  WEBKIT: /(webkit)[ /]([\w.]+)/i,
  MSIE: /(msie|trident) ([\w.]+)/i,
  MOZILLA: /(mozilla)(?:.*? rv:([\w.]+)|)/i
};
if (typeof window !== "undefined") {
  window.browserDetails = window.browserDetails || {};
}
var Browser = (
  /** @class */
  (function() {
    function Browser2() {
    }
    Browser2.extractBrowserDetail = function() {
      var browserInfo = { culture: {} };
      var keys2 = Object.keys(REGX_BROWSER);
      var clientInfo = [];
      for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        clientInfo = Browser2.userAgent.match(REGX_BROWSER["" + key]);
        if (clientInfo) {
          browserInfo.name = clientInfo[1].toLowerCase() === "opr" ? "opera" : clientInfo[1].toLowerCase();
          browserInfo.name = clientInfo[1].toLowerCase() === "crios" ? "chrome" : browserInfo.name;
          browserInfo.version = clientInfo[2];
          browserInfo.culture.name = browserInfo.culture.language = navigator.language;
          if (Browser2.userAgent.match(REGX_IE11)) {
            browserInfo.name = "msie";
            break;
          }
          var version = Browser2.userAgent.match(REGX_VERSION);
          if (browserInfo.name === "safari" && version) {
            browserInfo.version = version[2];
          }
          break;
        }
      }
      return browserInfo;
    };
    Browser2.getEvent = function(event) {
      var events = {
        start: {
          isPointer: "pointerdown",
          isTouch: "touchstart",
          isDevice: "mousedown"
        },
        move: {
          isPointer: "pointermove",
          isTouch: "touchmove",
          isDevice: "mousemove"
        },
        end: {
          isPointer: "pointerup",
          isTouch: "touchend",
          isDevice: "mouseup"
        },
        cancel: {
          isPointer: "pointercancel",
          isTouch: "touchcancel",
          isDevice: "mouseleave"
        }
      };
      return Browser2.isPointer ? events["" + event].isPointer : Browser2.isTouch ? events["" + event].isTouch + (!Browser2.isDevice ? " " + events["" + event].isDevice : "") : events["" + event].isDevice;
    };
    Browser2.getTouchStartEvent = function() {
      return Browser2.getEvent("start");
    };
    Browser2.getTouchEndEvent = function() {
      return Browser2.getEvent("end");
    };
    Browser2.getTouchMoveEvent = function() {
      return Browser2.getEvent("move");
    };
    Browser2.getTouchCancelEvent = function() {
      return Browser2.getEvent("cancel");
    };
    Browser2.isSafari = function() {
      return Browser2.isDevice && Browser2.isIos && Browser2.isTouch && typeof window !== "undefined" && window.navigator.userAgent.toLowerCase().indexOf("iphone") === -1 && window.navigator.userAgent.toLowerCase().indexOf("safari") > -1;
    };
    Browser2.getValue = function(key, regX) {
      var browserDetails = typeof window !== "undefined" ? window.browserDetails : {};
      if (typeof navigator !== "undefined" && navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1 && Browser2.isTouch === true && !REGX_BROWSER.CHROME.test(navigator.userAgent)) {
        browserDetails["isIos"] = true;
        browserDetails["isDevice"] = true;
        browserDetails["isTouch"] = true;
        browserDetails["isPointer"] = true;
        browserDetails["isPointer"] = "pointerEnabled" in window.navigator;
      }
      if (typeof window !== "undefined" && window.Capacitor && window.Capacitor.getPlatform() === "ios") {
        browserDetails["isPointer"] = false;
      }
      if ("undefined" === typeof browserDetails["" + key]) {
        return browserDetails["" + key] = regX.test(Browser2.userAgent);
      }
      return browserDetails["" + key];
    };
    Object.defineProperty(Browser2, "userAgent", {
      get: function() {
        return Browser2.uA;
      },
      //Properties
      /**
       * Property specifies the userAgent of the browser. Default userAgent value is based on the browser.
       * Also we can set our own userAgent.
       *
       * @param {string} uA ?
       */
      set: function(uA) {
        Browser2.uA = uA;
        window.browserDetails = {};
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "info", {
      //Read Only Properties
      /**
       * Property is to get the browser information like Name, Version and Language
       *
       * @returns {BrowserInfo} ?
       */
      get: function() {
        if (isUndefined(window.browserDetails.info)) {
          return window.browserDetails.info = Browser2.extractBrowserDetail();
        }
        return window.browserDetails.info;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isIE", {
      /**
       * Property is to get whether the userAgent is based IE.
       *
       * @returns {boolean} ?
       */
      get: function() {
        return Browser2.getValue("isIE", REGX_IE);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isTouch", {
      /**
       * Property is to get whether the browser has touch support.
       *
       * @returns {boolean} ?
       */
      get: function() {
        if (isUndefined(window.browserDetails.isTouch)) {
          return window.browserDetails.isTouch = "ontouchstart" in window.navigator || window && window.navigator && window.navigator.maxTouchPoints > 0 || "ontouchstart" in window;
        }
        return window.browserDetails.isTouch;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isPointer", {
      /**
       * Property is to get whether the browser has Pointer support.
       *
       * @returns {boolean} ?
       */
      get: function() {
        if (isUndefined(window.browserDetails.isPointer)) {
          return window.browserDetails.isPointer = "pointerEnabled" in window.navigator;
        }
        return window.browserDetails.isPointer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isMSPointer", {
      /**
       * Property is to get whether the browser has MSPointer support.
       *
       * @returns {boolean} ?
       */
      get: function() {
        if (isUndefined(window.browserDetails.isMSPointer)) {
          return window.browserDetails.isMSPointer = "msPointerEnabled" in window.navigator;
        }
        return window.browserDetails.isMSPointer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isDevice", {
      /**
       * Property is to get whether the userAgent is device based.
       *
       * @returns {boolean} ?
       */
      get: function() {
        return Browser2.getValue("isDevice", REGX_MOBILE);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isIos", {
      /**
       * Property is to get whether the userAgent is IOS.
       *
       * @returns {boolean} ?
       */
      get: function() {
        return Browser2.getValue("isIos", REGX_IOS);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isIos7", {
      /**
       * Property is to get whether the userAgent is Ios7.
       *
       * @returns {boolean} ?
       */
      get: function() {
        return Browser2.getValue("isIos7", REGX_IOS7);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isAndroid", {
      /**
       * Property is to get whether the userAgent is Android.
       *
       * @returns {boolean} ?
       */
      get: function() {
        return Browser2.getValue("isAndroid", REGX_ANDROID);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isWebView", {
      /**
       * Property is to identify whether application ran in web view.
       *
       * @returns {boolean} ?
       */
      get: function() {
        if (isUndefined(window.browserDetails.isWebView)) {
          window.browserDetails.isWebView = !(isUndefined(window.cordova) && isUndefined(window.PhoneGap) && isUndefined(window.phonegap) && window.forge !== "object");
          return window.browserDetails.isWebView;
        }
        return window.browserDetails.isWebView;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "isWindows", {
      /**
       * Property is to get whether the userAgent is Windows.
       *
       * @returns {boolean} ?
       */
      get: function() {
        return Browser2.getValue("isWindows", REGX_WINDOWS);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "touchStartEvent", {
      /**
       * Property is to get the touch start event. It returns event name based on browser.
       *
       * @returns {string} ?
       */
      get: function() {
        if (isUndefined(window.browserDetails.touchStartEvent)) {
          return window.browserDetails.touchStartEvent = Browser2.getTouchStartEvent();
        }
        return window.browserDetails.touchStartEvent;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "touchMoveEvent", {
      /**
       * Property is to get the touch move event. It returns event name based on browser.
       *
       * @returns {string} ?
       */
      get: function() {
        if (isUndefined(window.browserDetails.touchMoveEvent)) {
          return window.browserDetails.touchMoveEvent = Browser2.getTouchMoveEvent();
        }
        return window.browserDetails.touchMoveEvent;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "touchEndEvent", {
      /**
       * Property is to get the touch end event. It returns event name based on browser.
       *
       * @returns {string} ?
       */
      get: function() {
        if (isUndefined(window.browserDetails.touchEndEvent)) {
          return window.browserDetails.touchEndEvent = Browser2.getTouchEndEvent();
        }
        return window.browserDetails.touchEndEvent;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Browser2, "touchCancelEvent", {
      /**
       * Property is to cancel the touch end event.
       *
       * @returns {string} ?
       */
      get: function() {
        if (isUndefined(window.browserDetails.touchCancelEvent)) {
          return window.browserDetails.touchCancelEvent = Browser2.getTouchCancelEvent();
        }
        return window.browserDetails.touchCancelEvent;
      },
      enumerable: true,
      configurable: true
    });
    Browser2.uA = typeof navigator !== "undefined" ? navigator.userAgent : "";
    return Browser2;
  })()
);

// node_modules/@syncfusion/ej2-base/src/event-handler.js
var EventHandler = (
  /** @class */
  (function() {
    function EventHandler2() {
    }
    EventHandler2.addOrGetEventData = function(element) {
      if ("__eventList" in element) {
        return element.__eventList.events;
      } else {
        element.__eventList = {};
        return element.__eventList.events = [];
      }
    };
    EventHandler2.add = function(element, eventName, listener, bindTo, intDebounce) {
      var eventData = EventHandler2.addOrGetEventData(element);
      var debounceListener;
      if (intDebounce) {
        debounceListener = debounce(listener, intDebounce);
      } else {
        debounceListener = listener;
      }
      if (bindTo) {
        debounceListener = debounceListener.bind(bindTo);
      }
      var event = eventName.split(" ");
      for (var i = 0; i < event.length; i++) {
        eventData.push({
          name: event[parseInt(i.toString(), 10)],
          listener,
          debounce: debounceListener
        });
        if (Browser.isIE) {
          element.addEventListener(event[parseInt(i.toString(), 10)], debounceListener);
        } else {
          element.addEventListener(event[parseInt(i.toString(), 10)], debounceListener, { passive: false });
        }
      }
      return debounceListener;
    };
    EventHandler2.remove = function(element, eventName, listener) {
      var eventData = EventHandler2.addOrGetEventData(element);
      var event = eventName.split(" ");
      var _loop_1 = function(j2) {
        var index = -1;
        var debounceListener;
        if (eventData && eventData.length !== 0) {
          eventData.some(function(x, i) {
            return x.name === event[parseInt(j2.toString(), 10)] && x.listener === listener ? (index = i, debounceListener = x.debounce, true) : false;
          });
        }
        if (index !== -1) {
          eventData.splice(index, 1);
        }
        if (debounceListener) {
          element.removeEventListener(event[parseInt(j2.toString(), 10)], debounceListener);
        }
      };
      for (var j = 0; j < event.length; j++) {
        _loop_1(j);
      }
    };
    EventHandler2.clearEvents = function(element) {
      var eventData = EventHandler2.addOrGetEventData(element);
      var copyData = extend([], void 0, eventData);
      for (var i = 0; i < copyData.length; i++) {
        var parseValue = copyData[parseInt(i.toString(), 10)];
        element.removeEventListener(parseValue.name, parseValue.debounce);
        eventData.shift();
      }
    };
    EventHandler2.trigger = function(element, eventName, eventProp) {
      var eventData = EventHandler2.addOrGetEventData(element);
      for (var _i = 0, eventData_1 = eventData; _i < eventData_1.length; _i++) {
        var event_1 = eventData_1[_i];
        if (event_1.name === eventName) {
          event_1.debounce.call(this, eventProp);
        }
      }
    };
    return EventHandler2;
  })()
);

// node_modules/@syncfusion/ej2-base/src/dom.js
var SVG_REG = /^svg|^path|^g/;
function createElement(tagName, properties) {
  var element = SVG_REG.test(tagName) ? document.createElementNS("http://www.w3.org/2000/svg", tagName) : document.createElement(tagName);
  if (typeof properties === "undefined") {
    return element;
  }
  element.innerHTML = properties.innerHTML ? properties.innerHTML : "";
  if (properties.className !== void 0) {
    element.className = properties.className;
  }
  if (properties.id !== void 0) {
    element.id = properties.id;
  }
  if (properties.styles !== void 0) {
    element.style.cssText = properties.styles;
  }
  if (properties.attrs !== void 0) {
    attributes(element, properties.attrs);
  }
  return element;
}
function addClass(elements, classes) {
  var classList = getClassList(classes);
  var regExp3 = RegExp;
  for (var _i = 0, _a = elements; _i < _a.length; _i++) {
    var ele = _a[_i];
    for (var _b = 0, classList_1 = classList; _b < classList_1.length; _b++) {
      var className = classList_1[_b];
      if (isObject(ele)) {
        var curClass = getValue("attributes.className", ele);
        if (isNullOrUndefined(curClass)) {
          setValue("attributes.className", className, ele);
        } else if (!new regExp3("\\b" + className + "\\b", "i").test(curClass)) {
          setValue("attributes.className", curClass + " " + className, ele);
        }
      } else {
        if (!ele.classList.contains(className)) {
          ele.classList.add(className);
        }
      }
    }
  }
  return elements;
}
function removeClass(elements, classes) {
  var classList = getClassList(classes);
  for (var _i = 0, _a = elements; _i < _a.length; _i++) {
    var ele = _a[_i];
    var flag = isObject(ele);
    var canRemove = flag ? getValue("attributes.className", ele) : ele.className !== "";
    if (canRemove) {
      for (var _b = 0, classList_2 = classList; _b < classList_2.length; _b++) {
        var className = classList_2[_b];
        if (flag) {
          var classes_1 = getValue("attributes.className", ele);
          var classArr = classes_1.split(" ");
          var index = classArr.indexOf(className);
          if (index !== -1) {
            classArr.splice(index, 1);
          }
          setValue("attributes.className", classArr.join(" "), ele);
        } else {
          ele.classList.remove(className);
        }
      }
    }
  }
  return elements;
}
function getClassList(classes) {
  var classList = [];
  if (typeof classes === "string") {
    classList.push(classes);
  } else {
    classList = classes;
  }
  return classList;
}
function isVisible(element) {
  var ele = element;
  return ele.style.visibility === "" && ele.offsetWidth > 0;
}
function detach(element) {
  var parentNode = element.parentNode;
  if (parentNode) {
    return parentNode.removeChild(element);
  }
}
function remove(element) {
  var parentNode = element.parentNode;
  EventHandler.clearEvents(element);
  parentNode.removeChild(element);
}
function attributes(element, attributes2) {
  var keys2 = Object.keys(attributes2);
  var ele = element;
  for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (isObject(ele)) {
      var iKey = key;
      if (key === "tabindex") {
        iKey = "tabIndex";
      }
      ele.attributes["" + iKey] = attributes2["" + key];
    } else {
      ele.setAttribute(key, attributes2["" + key]);
    }
  }
  return ele;
}
function select(selector, context, needsVDOM) {
  if (context === void 0) {
    context = document;
  }
  selector = querySelectId(selector);
  return context.querySelector(selector);
}
function selectAll(selector, context, needsVDOM) {
  if (context === void 0) {
    context = document;
  }
  selector = querySelectId(selector);
  var nodeList = context.querySelectorAll(selector);
  return nodeList;
}
function querySelectId(selector) {
  var charRegex = /(!|"|\$|%|&|'|\(|\)|\*|\/|:|;|<|=|\?|@|\]|\^|`|{|}|\||\+|~)/g;
  if (selector.match(/#[0-9]/g) || selector.match(charRegex)) {
    var idList = selector.split(",");
    for (var i = 0; i < idList.length; i++) {
      var list = idList[parseInt(i.toString(), 10)].split(" ");
      for (var j = 0; j < list.length; j++) {
        if (list[parseInt(j.toString(), 10)].indexOf("#") > -1) {
          if (!list[parseInt(j.toString(), 10)].match(/\[.*\]/)) {
            var splitId = list[parseInt(j.toString(), 10)].split("#");
            if (splitId[1].match(/^\d/) || splitId[1].match(charRegex)) {
              var setId = list[parseInt(j.toString(), 10)].split(".");
              setId[0] = setId[0].replace(/#/, "[id='") + "']";
              list[parseInt(j.toString(), 10)] = setId.join(".");
            }
          }
        }
      }
      idList[parseInt(i.toString(), 10)] = list.join(" ");
    }
    return idList.join(",");
  }
  return selector;
}
function closest(element, selector) {
  var el = element;
  if (typeof el.closest === "function") {
    return el.closest(selector);
  }
  while (el && el.nodeType === 1) {
    if (matches(el, selector)) {
      return el;
    }
    el = el.parentNode;
  }
  return null;
}
function setStyleAttribute(element, attrs) {
  if (attrs !== void 0) {
    Object.keys(attrs).forEach(function(key) {
      element.style["" + key] = attrs["" + key];
    });
  }
}
function matches(element, selector) {
  var matches2 = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
  if (matches2) {
    return matches2.call(element, selector);
  } else {
    return [].indexOf.call(document.querySelectorAll(selector), element) !== -1;
  }
}

// node_modules/@syncfusion/ej2-base/src/observer.js
var Observer = (
  /** @class */
  (function() {
    function Observer2(context) {
      this.ranArray = [];
      this.boundedEvents = {};
      if (isNullOrUndefined(context)) {
        return;
      }
      this.context = context;
    }
    Observer2.prototype.on = function(property, handler, context, id) {
      if (isNullOrUndefined(handler)) {
        return;
      }
      var cntxt = context || this.context;
      if (this.notExist(property)) {
        this.boundedEvents["" + property] = [{ handler, context: cntxt, id }];
        return;
      }
      if (!isNullOrUndefined(id)) {
        if (this.ranArray.indexOf(id) === -1) {
          this.ranArray.push(id);
          this.boundedEvents["" + property].push({ handler, context: cntxt, id });
        }
      } else if (!this.isHandlerPresent(this.boundedEvents["" + property], handler)) {
        this.boundedEvents["" + property].push({ handler, context: cntxt });
      }
    };
    Observer2.prototype.off = function(property, handler, id) {
      if (this.notExist(property)) {
        return;
      }
      var curObject = getValue(property, this.boundedEvents);
      if (handler) {
        for (var i = 0; i < curObject.length; i++) {
          if (id) {
            if (curObject[parseInt(i.toString(), 10)].id === id) {
              curObject.splice(i, 1);
              var indexLocation = this.ranArray.indexOf(id);
              if (indexLocation !== -1) {
                this.ranArray.splice(indexLocation, 1);
              }
              break;
            }
          } else if (handler === curObject[parseInt(i.toString(), 10)].handler) {
            curObject.splice(i, 1);
            break;
          }
        }
      } else {
        delete this.boundedEvents["" + property];
      }
    };
    Observer2.prototype.notify = function(property, argument, successHandler, errorHandler) {
      if (this.notExist(property)) {
        if (successHandler) {
          successHandler.call(this, argument);
        }
        return;
      }
      if (argument) {
        argument.name = property;
      }
      var blazor = "Blazor";
      var curObject = getValue(property, this.boundedEvents).slice(0);
      if (window["" + blazor]) {
        return this.blazorCallback(curObject, argument, successHandler, errorHandler, 0);
      } else {
        for (var _i = 0, curObject_1 = curObject; _i < curObject_1.length; _i++) {
          var cur = curObject_1[_i];
          cur.handler.call(cur.context, argument);
        }
        if (successHandler) {
          successHandler.call(this, argument);
        }
      }
    };
    Observer2.prototype.blazorCallback = function(objs, argument, successHandler, errorHandler, index) {
      var _this = this;
      var isTrigger = index === objs.length - 1;
      if (index < objs.length) {
        var obj_1 = objs[parseInt(index.toString(), 10)];
        var promise = obj_1.handler.call(obj_1.context, argument);
        if (promise && typeof promise.then === "function") {
          if (!successHandler) {
            return promise;
          }
          promise.then(function(data) {
            data = typeof data === "string" && _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data;
            extend(argument, argument, data, true);
            if (successHandler && isTrigger) {
              successHandler.call(obj_1.context, argument);
            } else {
              return _this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);
            }
          }).catch(function(data) {
            if (errorHandler) {
              errorHandler.call(obj_1.context, typeof data === "string" && _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data);
            }
          });
        } else if (successHandler && isTrigger) {
          successHandler.call(obj_1.context, argument);
        } else {
          return this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);
        }
      }
    };
    Observer2.prototype.dateReviver = function(key, value) {
      var dPattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;
      if (isBlazor && typeof value === "string" && value.match(dPattern) !== null) {
        return new Date(value);
      }
      return value;
    };
    Observer2.prototype.isJson = function(value) {
      try {
        JSON.parse(value);
      } catch (e) {
        return false;
      }
      return true;
    };
    Observer2.prototype.destroy = function() {
      this.boundedEvents = this.context = void 0;
    };
    Observer2.prototype.offIntlEvents = function() {
      var eventsArr = this.boundedEvents["notifyExternalChange"];
      if (eventsArr) {
        for (var i = 0; i < eventsArr.length; i++) {
          var curContext = eventsArr[parseInt(i.toString(), 10)].context;
          if (curContext && curContext.detectFunction && curContext.randomId && curContext.isReactMock) {
            this.off("notifyExternalChange", curContext.detectFunction, curContext.randomId);
            i--;
          }
        }
        if (!this.boundedEvents["notifyExternalChange"].length) {
          delete this.boundedEvents["notifyExternalChange"];
        }
      }
    };
    Observer2.prototype.notExist = function(prop) {
      return Object.prototype.hasOwnProperty.call(this.boundedEvents, prop) === false || this.boundedEvents["" + prop].length <= 0;
    };
    Observer2.prototype.isHandlerPresent = function(boundedEvents, handler) {
      for (var _i = 0, boundedEvents_1 = boundedEvents; _i < boundedEvents_1.length; _i++) {
        var cur = boundedEvents_1[_i];
        if (cur.handler === handler) {
          return true;
        }
      }
      return false;
    };
    return Observer2;
  })()
);

// node_modules/@syncfusion/ej2-base/src/base.js
var isColEName = new RegExp("]");
var Base = (
  /** @class */
  (function() {
    function Base2(options, element) {
      this.isRendered = false;
      this.isComplexArraySetter = false;
      this.isServerRendered = false;
      this.allowServerDataBinding = true;
      this.isProtectedOnChange = true;
      this.properties = {};
      this.changedProperties = {};
      this.oldProperties = {};
      this.bulkChanges = {};
      this.refreshing = false;
      this.ignoreCollectionWatch = false;
      this.finalUpdate = function() {
      };
      this.childChangedProperties = {};
      this.modelObserver = new Observer(this);
      if (!isUndefined(element)) {
        if ("string" === typeof element) {
          this.element = document.querySelector(element);
        } else {
          this.element = element;
        }
        if (!isNullOrUndefined(this.element)) {
          this.isProtectedOnChange = false;
          this.addInstance();
        }
      }
      if (!isUndefined(options)) {
        this.setProperties(options, true);
      }
      this.isDestroyed = false;
    }
    Base2.prototype.setProperties = function(prop, muteOnChange) {
      var prevDetection = this.isProtectedOnChange;
      this.isProtectedOnChange = !!muteOnChange;
      merge(this, prop);
      if (muteOnChange !== true) {
        merge(this.changedProperties, prop);
        this.dataBind();
      } else if (isBlazor() && this.isRendered) {
        this.serverDataBind(prop);
      }
      this.finalUpdate();
      this.changedProperties = {};
      this.oldProperties = {};
      this.isProtectedOnChange = prevDetection;
    };
    Base2.callChildDataBind = function(obj, parent) {
      var keys2 = Object.keys(obj);
      for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (parent["" + key] instanceof Array) {
          for (var _a = 0, _b = parent["" + key]; _a < _b.length; _a++) {
            var obj_1 = _b[_a];
            if (obj_1.dataBind !== void 0) {
              obj_1.dataBind();
            }
          }
        } else {
          parent["" + key].dataBind();
        }
      }
    };
    Base2.prototype.clearChanges = function() {
      this.finalUpdate();
      this.changedProperties = {};
      this.oldProperties = {};
      this.childChangedProperties = {};
    };
    Base2.prototype.dataBind = function() {
      Base2.callChildDataBind(this.childChangedProperties, this);
      if (Object.getOwnPropertyNames(this.changedProperties).length) {
        var prevDetection = this.isProtectedOnChange;
        var newChanges = this.changedProperties;
        var oldChanges = this.oldProperties;
        this.clearChanges();
        this.isProtectedOnChange = true;
        this.onPropertyChanged(newChanges, oldChanges);
        this.isProtectedOnChange = prevDetection;
      }
    };
    Base2.prototype.serverDataBind = function(newChanges) {
      if (!isBlazor()) {
        return;
      }
      newChanges = newChanges ? newChanges : {};
      extend(this.bulkChanges, {}, newChanges, true);
      var sfBlazor = "sfBlazor";
      if (this.allowServerDataBinding && window["" + sfBlazor].updateModel) {
        window["" + sfBlazor].updateModel(this);
        this.bulkChanges = {};
      }
    };
    Base2.prototype.saveChanges = function(key, newValue, oldValue) {
      if (isBlazor()) {
        var newChanges = {};
        newChanges["" + key] = newValue;
        this.serverDataBind(newChanges);
      }
      if (this.isProtectedOnChange) {
        return;
      }
      this.oldProperties["" + key] = oldValue;
      this.changedProperties["" + key] = newValue;
      this.finalUpdate();
      this.finalUpdate = setImmediate(this.dataBind.bind(this));
    };
    Base2.prototype.addEventListener = function(eventName, handler) {
      this.modelObserver.on(eventName, handler);
    };
    Base2.prototype.removeEventListener = function(eventName, handler) {
      this.modelObserver.off(eventName, handler);
    };
    Base2.prototype.trigger = function(eventName, eventProp, successHandler, errorHandler) {
      var _this = this;
      if (this.isDestroyed !== true) {
        var prevDetection = this.isProtectedOnChange;
        this.isProtectedOnChange = false;
        var data = this.modelObserver.notify(eventName, eventProp, successHandler, errorHandler);
        if (isColEName.test(eventName)) {
          var handler = getValue(eventName, this);
          if (handler) {
            var blazor = "Blazor";
            if (window["" + blazor]) {
              var promise = handler.call(this, eventProp);
              if (promise && typeof promise.then === "function") {
                if (!successHandler) {
                  data = promise;
                } else {
                  promise.then(function(data2) {
                    if (successHandler) {
                      data2 = typeof data2 === "string" && _this.modelObserver.isJson(data2) ? JSON.parse(data2) : data2;
                      successHandler.call(_this, data2);
                    }
                  }).catch(function(data2) {
                    if (errorHandler) {
                      data2 = typeof data2 === "string" && _this.modelObserver.isJson(data2) ? JSON.parse(data2) : data2;
                      errorHandler.call(_this, data2);
                    }
                  });
                }
              } else if (successHandler) {
                successHandler.call(this, eventProp);
              }
            } else {
              handler.call(this, eventProp);
              if (successHandler) {
                successHandler.call(this, eventProp);
              }
            }
          } else if (successHandler) {
            successHandler.call(this, eventProp);
          }
        }
        this.isProtectedOnChange = prevDetection;
        return data;
      }
    };
    Base2.prototype.addInstance = function() {
      var moduleClass = "e-" + this.getModuleName().toLowerCase();
      addClass([this.element], ["e-lib", moduleClass]);
      if (!isNullOrUndefined(this.element.ej2_instances)) {
        this.element.ej2_instances.push(this);
      } else {
        setValue("ej2_instances", [this], this.element);
      }
    };
    Base2.prototype.destroy = function() {
      var _this = this;
      this.element.ej2_instances = this.element.ej2_instances ? this.element.ej2_instances.filter(function(i) {
        if (proxyToRaw) {
          return proxyToRaw(i) !== proxyToRaw(_this);
        }
        return i !== _this;
      }) : [];
      removeClass([this.element], ["e-" + this.getModuleName()]);
      if (this.element.ej2_instances.length === 0) {
        removeClass([this.element], ["e-lib"]);
      }
      this.clearChanges();
      this.modelObserver.destroy();
      this.isDestroyed = true;
    };
    return Base2;
  })()
);
var proxyToRaw;

// node_modules/@syncfusion/ej2-base/src/notify-property-change.js
function getObject(instance, curKey, defaultValue, type) {
  if (!Object.prototype.hasOwnProperty.call(instance.properties, curKey) || !(instance.properties["" + curKey] instanceof type)) {
    instance.properties["" + curKey] = createInstance(type, [instance, curKey, defaultValue]);
  }
  return instance.properties["" + curKey];
}
function getObjectArray(instance, curKey, defaultValue, type, isSetter, isFactory) {
  var result = [];
  var len = defaultValue ? defaultValue.length : 0;
  for (var i = 0; i < len; i++) {
    var curType = type;
    if (isFactory) {
      curType = type(defaultValue[parseInt(i.toString(), 10)], instance);
    }
    if (isSetter) {
      var inst = createInstance(curType, [instance, curKey, {}, true]);
      inst.setProperties(defaultValue[parseInt(i.toString(), 10)], true);
      result.push(inst);
    } else {
      result.push(createInstance(curType, [instance, curKey, defaultValue[parseInt(i.toString(), 10)], false]));
    }
  }
  return result;
}
function propertyGetter(defaultValue, curKey) {
  return function() {
    if (!Object.prototype.hasOwnProperty.call(this.properties, curKey)) {
      this.properties["" + curKey] = defaultValue;
    }
    return this.properties["" + curKey];
  };
}
function propertySetter(defaultValue, curKey) {
  return function(newValue) {
    if (this.properties["" + curKey] !== newValue) {
      var oldVal = Object.prototype.hasOwnProperty.call(this.properties, curKey) ? this.properties["" + curKey] : defaultValue;
      this.saveChanges(curKey, newValue, oldVal);
      this.properties["" + curKey] = newValue;
    }
  };
}
function complexGetter(defaultValue, curKey, type) {
  return function() {
    return getObject(this, curKey, defaultValue, type);
  };
}
function complexSetter(defaultValue, curKey, type) {
  return function(newValue) {
    getObject(this, curKey, defaultValue, type).setProperties(newValue);
  };
}
function complexArrayGetter(defaultValue, curKey, type) {
  return function() {
    var _this = this;
    if (!Object.prototype.hasOwnProperty.call(this.properties, curKey)) {
      var defCollection = getObjectArray(this, curKey, defaultValue, type, false);
      this.properties["" + curKey] = defCollection;
    }
    var ignore = this.controlParent !== void 0 && this.controlParent.ignoreCollectionWatch || this.ignoreCollectionWatch;
    if (!Object.prototype.hasOwnProperty.call(this.properties["" + curKey], "push") && !ignore) {
      ["push", "pop"].forEach(function(extendFunc) {
        var descriptor = {
          value: complexArrayDefinedCallback(extendFunc, curKey, type, _this.properties["" + curKey]).bind(_this),
          configurable: true
        };
        Object.defineProperty(_this.properties["" + curKey], extendFunc, descriptor);
      });
    }
    if (!Object.prototype.hasOwnProperty.call(this.properties["" + curKey], "isComplexArray")) {
      Object.defineProperty(this.properties["" + curKey], "isComplexArray", { value: true });
    }
    return this.properties["" + curKey];
  };
}
function complexArraySetter(defaultValue, curKey, type) {
  return function(newValue) {
    this.isComplexArraySetter = true;
    var oldValueCollection = getObjectArray(this, curKey, defaultValue, type, false);
    var newValCollection = getObjectArray(this, curKey, newValue, type, true);
    this.isComplexArraySetter = false;
    this.saveChanges(curKey, newValCollection, oldValueCollection);
    this.properties["" + curKey] = newValCollection;
  };
}
function complexArrayDefinedCallback(dFunc, curKey, type, prop) {
  return function() {
    var newValue = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newValue[_i] = arguments[_i];
    }
    var keyString = this.propName ? this.getParentKey() + "." + curKey + "-" : curKey + "-";
    switch (dFunc) {
      case "push":
        for (var i = 0; i < newValue.length; i++) {
          var newValueParse = newValue[parseInt(i.toString(), 10)];
          Array.prototype["" + dFunc].apply(prop, [newValueParse]);
          var model = getArrayModel(keyString + (prop.length - 1), newValueParse, !this.controlParent, dFunc);
          this.serverDataBind(model, newValue[parseInt(i.toString(), 10)], false, dFunc);
        }
        break;
      case "pop": {
        Array.prototype["" + dFunc].apply(prop);
        var model = getArrayModel(keyString + prop.length, null, !this.controlParent, dFunc);
        this.serverDataBind(model, { ejsAction: "pop" }, false, dFunc);
        break;
      }
    }
    return prop;
  };
}
function getArrayModel(keyString, value, isControlParent, arrayFunction) {
  var modelObject = keyString;
  if (isControlParent) {
    modelObject = {};
    modelObject["" + keyString] = value;
    if (value && typeof value === "object") {
      var action = "ejsAction";
      modelObject["" + keyString]["" + action] = arrayFunction;
    }
  }
  return modelObject;
}
function Property(defaultValue) {
  return function(target, key) {
    var propertyDescriptor = {
      set: propertySetter(defaultValue, key),
      get: propertyGetter(defaultValue, key),
      enumerable: true,
      configurable: true
    };
    Object.defineProperty(target, key, propertyDescriptor);
    addPropertyCollection(target, key, "prop", defaultValue);
  };
}
function Complex(defaultValue, type) {
  return function(target, key) {
    var propertyDescriptor = {
      set: complexSetter(defaultValue, key, type),
      get: complexGetter(defaultValue, key, type),
      enumerable: true,
      configurable: true
    };
    Object.defineProperty(target, key, propertyDescriptor);
    addPropertyCollection(target, key, "complexProp", defaultValue, type);
  };
}
function Collection(defaultValue, type) {
  return function(target, key) {
    var propertyDescriptor = {
      set: complexArraySetter(defaultValue, key, type),
      get: complexArrayGetter(defaultValue, key, type),
      enumerable: true,
      configurable: true
    };
    Object.defineProperty(target, key, propertyDescriptor);
    addPropertyCollection(target, key, "colProp", defaultValue, type);
  };
}
function Event2() {
  return function(target, key) {
    var eventDescriptor = {
      set: function(newValue) {
        var oldValue = this.properties["" + key];
        if (oldValue !== newValue) {
          var finalContext = getParentContext(this, key);
          if (isUndefined(oldValue) === false) {
            finalContext.context.removeEventListener(finalContext.prefix, oldValue);
          }
          finalContext.context.addEventListener(finalContext.prefix, newValue);
          this.properties["" + key] = newValue;
        }
      },
      get: propertyGetter(void 0, key),
      enumerable: true,
      configurable: true
    };
    Object.defineProperty(target, key, eventDescriptor);
    addPropertyCollection(target, key, "event");
  };
}
function NotifyPropertyChanges(classConstructor) {
}
function addPropertyCollection(target, key, propertyType, defaultValue, type) {
  if (isUndefined(target.propList)) {
    target.propList = {
      props: [],
      complexProps: [],
      colProps: [],
      events: [],
      propNames: [],
      complexPropNames: [],
      colPropNames: [],
      eventNames: []
    };
  }
  target.propList[propertyType + "s"].push({
    propertyName: key,
    defaultValue,
    type
  });
  target.propList[propertyType + "Names"].push(key);
}
function getParentContext(context, prefix) {
  if (Object.prototype.hasOwnProperty.call(context, "parentObj") === false) {
    return { context, prefix };
  } else {
    var curText = getValue("propName", context);
    if (curText) {
      prefix = curText + "-" + prefix;
    }
    return getParentContext(getValue("parentObj", context), prefix);
  }
}

// node_modules/@syncfusion/ej2-base/src/animation.js
var __extends = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Animation = (
  /** @class */
  (function(_super) {
    __extends(Animation2, _super);
    function Animation2(options) {
      var _this = _super.call(this, options, void 0) || this;
      _this.easing = {
        ease: "cubic-bezier(0.250, 0.100, 0.250, 1.000)",
        linear: "cubic-bezier(0.250, 0.250, 0.750, 0.750)",
        easeIn: "cubic-bezier(0.420, 0.000, 1.000, 1.000)",
        easeOut: "cubic-bezier(0.000, 0.000, 0.580, 1.000)",
        easeInOut: "cubic-bezier(0.420, 0.000, 0.580, 1.000)",
        elasticInOut: "cubic-bezier(0.5,-0.58,0.38,1.81)",
        elasticIn: "cubic-bezier(0.17,0.67,0.59,1.81)",
        elasticOut: "cubic-bezier(0.7,-0.75,0.99,1.01)"
      };
      return _this;
    }
    Animation_1 = Animation2;
    Animation2.prototype.animate = function(element, options) {
      options = !options ? {} : options;
      var model = this.getModel(options);
      if (typeof element === "string") {
        var elements = Array.prototype.slice.call(selectAll(element, document));
        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
          var element_1 = elements_1[_i];
          model.element = element_1;
          Animation_1.delayAnimation(model);
        }
      } else {
        model.element = element;
        Animation_1.delayAnimation(model);
      }
    };
    Animation2.stop = function(element, model) {
      element.style.animation = "";
      element.removeAttribute("e-animate");
      var animationId = element.getAttribute("e-animation-id");
      if (animationId) {
        var frameId = parseInt(animationId, 10);
        cancelAnimationFrame(frameId);
        element.removeAttribute("e-animation-id");
      }
      if (model && model.end) {
        model.end.call(this, model);
      }
    };
    Animation2.delayAnimation = function(model) {
      if (animationMode === "Disable" || animationMode === GlobalAnimationMode.Disable) {
        if (model.begin) {
          model.begin.call(this, model);
        }
        if (model.end) {
          model.end.call(this, model);
        }
      } else {
        if (model.delay) {
          setTimeout(function() {
            Animation_1.applyAnimation(model);
          }, model.delay);
        } else {
          Animation_1.applyAnimation(model);
        }
      }
    };
    Animation2.applyAnimation = function(model) {
      var _this = this;
      model.timeStamp = 0;
      var step = 0;
      var timerId = 0;
      var prevTimeStamp = 0;
      var duration = model.duration;
      model.element.setAttribute("e-animate", "true");
      var startAnimation = function(timeStamp) {
        try {
          if (timeStamp) {
            prevTimeStamp = prevTimeStamp === 0 ? timeStamp : prevTimeStamp;
            model.timeStamp = timeStamp + model.timeStamp - prevTimeStamp;
            prevTimeStamp = timeStamp;
            if (!step && model.begin) {
              model.begin.call(_this, model);
            }
            step = step + 1;
            var avg = model.timeStamp / step;
            if (model.timeStamp < duration && model.timeStamp + avg < duration && model.element.getAttribute("e-animate")) {
              model.element.style.animation = model.name + " " + model.duration + "ms " + model.timingFunction;
              if (model.progress) {
                model.progress.call(_this, model);
              }
              requestAnimationFrame(startAnimation);
            } else {
              cancelAnimationFrame(timerId);
              model.element.removeAttribute("e-animation-id");
              model.element.removeAttribute("e-animate");
              model.element.style.animation = "";
              if (model.end) {
                model.end.call(_this, model);
              }
            }
          } else {
            timerId = requestAnimationFrame(startAnimation);
            model.element.setAttribute("e-animation-id", timerId.toString());
          }
        } catch (e) {
          cancelAnimationFrame(timerId);
          model.element.removeAttribute("e-animation-id");
          if (model.fail) {
            model.fail.call(_this, e);
          }
        }
      };
      startAnimation();
    };
    Animation2.prototype.getModel = function(options) {
      return {
        name: options.name || this.name,
        delay: options.delay || this.delay,
        duration: options.duration !== void 0 ? options.duration : this.duration,
        begin: options.begin || this.begin,
        end: options.end || this.end,
        fail: options.fail || this.fail,
        progress: options.progress || this.progress,
        timingFunction: this.easing[options.timingFunction] ? this.easing[options.timingFunction] : options.timingFunction || this.easing[this.timingFunction]
      };
    };
    Animation2.prototype.onPropertyChanged = function(newProp, oldProp) {
    };
    Animation2.prototype.getModuleName = function() {
      return "animation";
    };
    Animation2.prototype.destroy = function() {
    };
    var Animation_1;
    __decorate([
      Property("FadeIn")
    ], Animation2.prototype, "name", void 0);
    __decorate([
      Property(400)
    ], Animation2.prototype, "duration", void 0);
    __decorate([
      Property("ease")
    ], Animation2.prototype, "timingFunction", void 0);
    __decorate([
      Property(0)
    ], Animation2.prototype, "delay", void 0);
    __decorate([
      Event2()
    ], Animation2.prototype, "progress", void 0);
    __decorate([
      Event2()
    ], Animation2.prototype, "begin", void 0);
    __decorate([
      Event2()
    ], Animation2.prototype, "end", void 0);
    __decorate([
      Event2()
    ], Animation2.prototype, "fail", void 0);
    Animation2 = Animation_1 = __decorate([
      NotifyPropertyChanges
    ], Animation2);
    return Animation2;
  })(Base)
);
var animationMode;
var GlobalAnimationMode;
(function(GlobalAnimationMode2) {
  GlobalAnimationMode2["Default"] = "Default";
  GlobalAnimationMode2["Enable"] = "Enable";
  GlobalAnimationMode2["Disable"] = "Disable";
})(GlobalAnimationMode || (GlobalAnimationMode = {}));

// node_modules/@syncfusion/ej2-base/src/module-loader.js
var MODULE_SUFFIX = "Module";
var ModuleLoader = (
  /** @class */
  (function() {
    function ModuleLoader2(parent) {
      this.loadedModules = [];
      this.parent = parent;
    }
    ModuleLoader2.prototype.inject = function(requiredModules, moduleList) {
      var reqLength = requiredModules.length;
      if (reqLength === 0) {
        this.clean();
        return;
      }
      if (this.loadedModules.length) {
        this.clearUnusedModule(requiredModules);
      }
      for (var i = 0; i < reqLength; i++) {
        var modl = requiredModules[parseInt(i.toString(), 10)];
        for (var _i = 0, moduleList_1 = moduleList; _i < moduleList_1.length; _i++) {
          var module = moduleList_1[_i];
          var modName = modl.member;
          if (module && module.prototype.getModuleName() === modl.member && !this.isModuleLoaded(modName)) {
            var moduleObject = createInstance(module, modl.args);
            var memberName = this.getMemberName(modName);
            if (modl.isProperty) {
              setValue(memberName, module, this.parent);
            } else {
              setValue(memberName, moduleObject, this.parent);
            }
            var loadedModule = modl;
            loadedModule.member = memberName;
            this.loadedModules.push(loadedModule);
          }
        }
      }
    };
    ModuleLoader2.prototype.clean = function() {
      for (var _i = 0, _a = this.loadedModules; _i < _a.length; _i++) {
        var modules = _a[_i];
        if (!modules.isProperty) {
          getValue(modules.member, this.parent).destroy();
        }
      }
      this.loadedModules = [];
    };
    ModuleLoader2.prototype.getNonInjectedModules = function(requiredModules) {
      var _this = this;
      return requiredModules.filter(function(module) {
        return !_this.isModuleLoaded(module.member);
      });
    };
    ModuleLoader2.prototype.clearUnusedModule = function(moduleList) {
      var _this = this;
      var usedModules = moduleList.map(function(arg) {
        return _this.getMemberName(arg.member);
      });
      var removableModule = this.loadedModules.filter(function(module) {
        return usedModules.indexOf(module.member) === -1;
      });
      for (var _i = 0, removableModule_1 = removableModule; _i < removableModule_1.length; _i++) {
        var mod = removableModule_1[_i];
        if (!mod.isProperty) {
          getValue(mod.member, this.parent).destroy();
        }
        this.loadedModules.splice(this.loadedModules.indexOf(mod), 1);
        deleteObject(this.parent, mod.member);
      }
    };
    ModuleLoader2.prototype.getMemberName = function(name) {
      return name[0].toLowerCase() + name.substring(1) + MODULE_SUFFIX;
    };
    ModuleLoader2.prototype.isModuleLoaded = function(modName) {
      for (var _i = 0, _a = this.loadedModules; _i < _a.length; _i++) {
        var mod = _a[_i];
        if (mod.member === this.getMemberName(modName)) {
          return true;
        }
      }
      return false;
    };
    return ModuleLoader2;
  })()
);

// node_modules/@syncfusion/ej2-base/src/child-property.js
var ChildProperty = (
  /** @class */
  (function() {
    function ChildProperty2(parent, propName, defaultValue, isArray) {
      this.isComplexArraySetter = false;
      this.properties = {};
      this.changedProperties = {};
      this.childChangedProperties = {};
      this.oldProperties = {};
      this.finalUpdate = function() {
      };
      this.callChildDataBind = getValue("callChildDataBind", Base);
      this.parentObj = parent;
      this.controlParent = this.parentObj.controlParent || this.parentObj;
      this.propName = propName;
      this.isParentArray = isArray;
      this.setProperties(defaultValue, true);
    }
    ChildProperty2.prototype.updateChange = function(val, propName) {
      if (val === true) {
        this.parentObj.childChangedProperties["" + propName] = val;
      } else {
        delete this.parentObj.childChangedProperties["" + propName];
      }
      if (this.parentObj.updateChange) {
        this.parentObj.updateChange(val, this.parentObj.propName);
      }
    };
    ChildProperty2.prototype.updateTimeOut = function() {
      if (this.parentObj.updateTimeOut) {
        this.parentObj.finalUpdate();
        this.parentObj.updateTimeOut();
      } else {
        var changeTime_1 = setTimeout(this.parentObj.dataBind.bind(this.parentObj));
        var clearUpdate = function() {
          clearTimeout(changeTime_1);
        };
        this.finalUpdate = clearUpdate;
      }
    };
    ChildProperty2.prototype.clearChanges = function() {
      this.finalUpdate();
      this.updateChange(false, this.propName);
      this.oldProperties = {};
      this.changedProperties = {};
    };
    ChildProperty2.prototype.setProperties = function(prop, muteOnChange) {
      if (muteOnChange === true) {
        merge(this, prop);
        this.updateChange(false, this.propName);
        this.clearChanges();
      } else {
        merge(this, prop);
      }
    };
    ChildProperty2.prototype.dataBind = function() {
      this.callChildDataBind(this.childChangedProperties, this);
      if (this.isParentArray) {
        var curIndex = this.parentObj[this.propName].indexOf(this);
        if (Object.keys(this.changedProperties).length) {
          setValue(this.propName + "." + curIndex, this.changedProperties, this.parentObj.changedProperties);
          setValue(this.propName + "." + curIndex, this.oldProperties, this.parentObj.oldProperties);
        }
      } else {
        this.parentObj.changedProperties[this.propName] = this.changedProperties;
        this.parentObj.oldProperties[this.propName] = this.oldProperties;
      }
      this.clearChanges();
    };
    ChildProperty2.prototype.saveChanges = function(key, newValue, oldValue, restrictServerDataBind) {
      if (this.controlParent.isProtectedOnChange) {
        return;
      }
      if (!restrictServerDataBind) {
        this.serverDataBind(key, newValue, true);
      }
      this.oldProperties["" + key] = oldValue;
      this.changedProperties["" + key] = newValue;
      this.updateChange(true, this.propName);
      this.finalUpdate();
      this.updateTimeOut();
    };
    ChildProperty2.prototype.serverDataBind = function(key, value, isSaveChanges, action) {
      if (isBlazor() && !this.parentObj.isComplexArraySetter) {
        var parent_1;
        var newChanges = {};
        var parentKey = isSaveChanges ? this.getParentKey(true) + "." + key : key;
        if (parentKey.indexOf(".") !== -1) {
          var complexKeys = parentKey.split(".");
          parent_1 = newChanges;
          for (var i = 0; i < complexKeys.length; i++) {
            var isFinal = i === complexKeys.length - 1;
            parent_1[complexKeys[parseInt(i.toString(), 10)]] = isFinal ? value : {};
            parent_1 = isFinal ? parent_1 : parent_1[complexKeys[parseInt(i.toString(), 10)]];
          }
        } else {
          newChanges["" + parentKey] = {};
          parent_1 = newChanges["" + parentKey];
          newChanges["" + parentKey]["" + key] = value;
        }
        if (this.isParentArray) {
          var actionProperty = "ejsAction";
          parent_1["" + actionProperty] = action ? action : "none";
        }
        this.controlParent.serverDataBind(newChanges);
      }
    };
    ChildProperty2.prototype.getParentKey = function(isSaveChanges) {
      var index = "";
      var propName = this.propName;
      if (this.isParentArray) {
        index = this.parentObj[this.propName].indexOf(this);
        var valueLength = this.parentObj[this.propName].length;
        valueLength = isSaveChanges ? valueLength : valueLength > 0 ? valueLength - 1 : 0;
        index = index !== -1 ? "-" + index : "-" + valueLength;
        propName = propName + index;
      }
      if (this.controlParent !== this.parentObj) {
        propName = this.parentObj.getParentKey() + "." + this.propName + index;
      }
      return propName;
    };
    return ChildProperty2;
  })()
);

// node_modules/@syncfusion/ej2-base/src/hijri-parser.js
var HijriParser;
(function(HijriParser2) {
  var dateCorrection = [
    28607,
    28636,
    28665,
    28695,
    28724,
    28754,
    28783,
    28813,
    28843,
    28872,
    28901,
    28931,
    28960,
    28990,
    29019,
    29049,
    29078,
    29108,
    29137,
    29167,
    29196,
    29226,
    29255,
    29285,
    29315,
    29345,
    29375,
    29404,
    29434,
    29463,
    29492,
    29522,
    29551,
    29580,
    29610,
    29640,
    29669,
    29699,
    29729,
    29759,
    29788,
    29818,
    29847,
    29876,
    29906,
    29935,
    29964,
    29994,
    30023,
    30053,
    30082,
    30112,
    30141,
    30171,
    30200,
    30230,
    30259,
    30289,
    30318,
    30348,
    30378,
    30408,
    30437,
    30467,
    30496,
    30526,
    30555,
    30585,
    30614,
    30644,
    30673,
    30703,
    30732,
    30762,
    30791,
    30821,
    30850,
    30880,
    30909,
    30939,
    30968,
    30998,
    31027,
    31057,
    31086,
    31116,
    31145,
    31175,
    31204,
    31234,
    31263,
    31293,
    31322,
    31352,
    31381,
    31411,
    31441,
    31471,
    31500,
    31530,
    31559,
    31589,
    31618,
    31648,
    31676,
    31706,
    31736,
    31766,
    31795,
    31825,
    31854,
    31884,
    31913,
    31943,
    31972,
    32002,
    32031,
    32061,
    32090,
    32120,
    32150,
    32180,
    32209,
    32239,
    32268,
    32298,
    32327,
    32357,
    32386,
    32416,
    32445,
    32475,
    32504,
    32534,
    32563,
    32593,
    32622,
    32652,
    32681,
    32711,
    32740,
    32770,
    32799,
    32829,
    32858,
    32888,
    32917,
    32947,
    32976,
    33006,
    33035,
    33065,
    33094,
    33124,
    33153,
    33183,
    33213,
    33243,
    33272,
    33302,
    33331,
    33361,
    33390,
    33420,
    33450,
    33479,
    33509,
    33539,
    33568,
    33598,
    33627,
    33657,
    33686,
    33716,
    33745,
    33775,
    33804,
    33834,
    33863,
    33893,
    33922,
    33952,
    33981,
    34011,
    34040,
    34069,
    34099,
    34128,
    34158,
    34187,
    34217,
    34247,
    34277,
    34306,
    34336,
    34365,
    34395,
    34424,
    34454,
    34483,
    34512,
    34542,
    34571,
    34601,
    34631,
    34660,
    34690,
    34719,
    34749,
    34778,
    34808,
    34837,
    34867,
    34896,
    34926,
    34955,
    34985,
    35015,
    35044,
    35074,
    35103,
    35133,
    35162,
    35192,
    35222,
    35251,
    35280,
    35310,
    35340,
    35370,
    35399,
    35429,
    35458,
    35488,
    35517,
    35547,
    35576,
    35605,
    35635,
    35665,
    35694,
    35723,
    35753,
    35782,
    35811,
    35841,
    35871,
    35901,
    35930,
    35960,
    35989,
    36019,
    36048,
    36078,
    36107,
    36136,
    36166,
    36195,
    36225,
    36254,
    36284,
    36314,
    36343,
    36373,
    36403,
    36433,
    36462,
    36492,
    36521,
    36551,
    36580,
    36610,
    36639,
    36669,
    36698,
    36728,
    36757,
    36786,
    36816,
    36845,
    36875,
    36904,
    36934,
    36963,
    36993,
    37022,
    37052,
    37081,
    37111,
    37141,
    37170,
    37200,
    37229,
    37259,
    37288,
    37318,
    37347,
    37377,
    37406,
    37436,
    37465,
    37495,
    37524,
    37554,
    37584,
    37613,
    37643,
    37672,
    37701,
    37731,
    37760,
    37790,
    37819,
    37849,
    37878,
    37908,
    37938,
    37967,
    37997,
    38027,
    38056,
    38085,
    38115,
    38144,
    38174,
    38203,
    38233,
    38262,
    38292,
    38322,
    38351,
    38381,
    38410,
    38440,
    38469,
    38499,
    38528,
    38558,
    38587,
    38617,
    38646,
    38676,
    38705,
    38735,
    38764,
    38794,
    38823,
    38853,
    38882,
    38912,
    38941,
    38971,
    39001,
    39030,
    39059,
    39089,
    39118,
    39148,
    39178,
    39208,
    39237,
    39267,
    39297,
    39326,
    39355,
    39385,
    39414,
    39444,
    39473,
    39503,
    39532,
    39562,
    39592,
    39621,
    39650,
    39680,
    39709,
    39739,
    39768,
    39798,
    39827,
    39857,
    39886,
    39916,
    39946,
    39975,
    40005,
    40035,
    40064,
    40094,
    40123,
    40153,
    40182,
    40212,
    40241,
    40271,
    40300,
    40330,
    40359,
    40389,
    40418,
    40448,
    40477,
    40507,
    40536,
    40566,
    40595,
    40625,
    40655,
    40685,
    40714,
    40744,
    40773,
    40803,
    40832,
    40862,
    40892,
    40921,
    40951,
    40980,
    41009,
    41039,
    41068,
    41098,
    41127,
    41157,
    41186,
    41216,
    41245,
    41275,
    41304,
    41334,
    41364,
    41393,
    41422,
    41452,
    41481,
    41511,
    41540,
    41570,
    41599,
    41629,
    41658,
    41688,
    41718,
    41748,
    41777,
    41807,
    41836,
    41865,
    41894,
    41924,
    41953,
    41983,
    42012,
    42042,
    42072,
    42102,
    42131,
    42161,
    42190,
    42220,
    42249,
    42279,
    42308,
    42337,
    42367,
    42397,
    42426,
    42456,
    42485,
    42515,
    42545,
    42574,
    42604,
    42633,
    42662,
    42692,
    42721,
    42751,
    42780,
    42810,
    42839,
    42869,
    42899,
    42929,
    42958,
    42988,
    43017,
    43046,
    43076,
    43105,
    43135,
    43164,
    43194,
    43223,
    43253,
    43283,
    43312,
    43342,
    43371,
    43401,
    43430,
    43460,
    43489,
    43519,
    43548,
    43578,
    43607,
    43637,
    43666,
    43696,
    43726,
    43755,
    43785,
    43814,
    43844,
    43873,
    43903,
    43932,
    43962,
    43991,
    44021,
    44050,
    44080,
    44109,
    44139,
    44169,
    44198,
    44228,
    44258,
    44287,
    44317,
    44346,
    44375,
    44405,
    44434,
    44464,
    44493,
    44523,
    44553,
    44582,
    44612,
    44641,
    44671,
    44700,
    44730,
    44759,
    44788,
    44818,
    44847,
    44877,
    44906,
    44936,
    44966,
    44996,
    45025,
    45055,
    45084,
    45114,
    45143,
    45172,
    45202,
    45231,
    45261,
    45290,
    45320,
    45350,
    45380,
    45409,
    45439,
    45468,
    45498,
    45527,
    45556,
    45586,
    45615,
    45644,
    45674,
    45704,
    45733,
    45763,
    45793,
    45823,
    45852,
    45882,
    45911,
    45940,
    45970,
    45999,
    46028,
    46058,
    46088,
    46117,
    46147,
    46177,
    46206,
    46236,
    46265,
    46295,
    46324,
    46354,
    46383,
    46413,
    46442,
    46472,
    46501,
    46531,
    46560,
    46590,
    46620,
    46649,
    46679,
    46708,
    46738,
    46767,
    46797,
    46826,
    46856,
    46885,
    46915,
    46944,
    46974,
    47003,
    47033,
    47063,
    47092,
    47122,
    47151,
    47181,
    47210,
    47240,
    47269,
    47298,
    47328,
    47357,
    47387,
    47417,
    47446,
    47476,
    47506,
    47535,
    47565,
    47594,
    47624,
    47653,
    47682,
    47712,
    47741,
    47771,
    47800,
    47830,
    47860,
    47890,
    47919,
    47949,
    47978,
    48008,
    48037,
    48066,
    48096,
    48125,
    48155,
    48184,
    48214,
    48244,
    48273,
    48303,
    48333,
    48362,
    48392,
    48421,
    48450,
    48480,
    48509,
    48538,
    48568,
    48598,
    48627,
    48657,
    48687,
    48717,
    48746,
    48776,
    48805,
    48834,
    48864,
    48893,
    48922,
    48952,
    48982,
    49011,
    49041,
    49071,
    49100,
    49130,
    49160,
    49189,
    49218,
    49248,
    49277,
    49306,
    49336,
    49365,
    49395,
    49425,
    49455,
    49484,
    49514,
    49543,
    49573,
    49602,
    49632,
    49661,
    49690,
    49720,
    49749,
    49779,
    49809,
    49838,
    49868,
    49898,
    49927,
    49957,
    49986,
    50016,
    50045,
    50075,
    50104,
    50133,
    50163,
    50192,
    50222,
    50252,
    50281,
    50311,
    50340,
    50370,
    50400,
    50429,
    50459,
    50488,
    50518,
    50547,
    50576,
    50606,
    50635,
    50665,
    50694,
    50724,
    50754,
    50784,
    50813,
    50843,
    50872,
    50902,
    50931,
    50960,
    50990,
    51019,
    51049,
    51078,
    51108,
    51138,
    51167,
    51197,
    51227,
    51256,
    51286,
    51315,
    51345,
    51374,
    51403,
    51433,
    51462,
    51492,
    51522,
    51552,
    51582,
    51611,
    51641,
    51670,
    51699,
    51729,
    51758,
    51787,
    51816,
    51846,
    51876,
    51906,
    51936,
    51965,
    51995,
    52025,
    52054,
    52083,
    52113,
    52142,
    52171,
    52200,
    52230,
    52260,
    52290,
    52319,
    52349,
    52379,
    52408,
    52438,
    52467,
    52497,
    52526,
    52555,
    52585,
    52614,
    52644,
    52673,
    52703,
    52733,
    52762,
    52792,
    52822,
    52851,
    52881,
    52910,
    52939,
    52969,
    52998,
    53028,
    53057,
    53087,
    53116,
    53146,
    53176,
    53205,
    53235,
    53264,
    53294,
    53324,
    53353,
    53383,
    53412,
    53441,
    53471,
    53500,
    53530,
    53559,
    53589,
    53619,
    53648,
    53678,
    53708,
    53737,
    53767,
    53796,
    53825,
    53855,
    53884,
    53913,
    53943,
    53973,
    54003,
    54032,
    54062,
    54092,
    54121,
    54151,
    54180,
    54209,
    54239,
    54268,
    54297,
    54327,
    54357,
    54387,
    54416,
    54446,
    54476,
    54505,
    54535,
    54564,
    54593,
    54623,
    54652,
    54681,
    54711,
    54741,
    54770,
    54800,
    54830,
    54859,
    54889,
    54919,
    54948,
    54977,
    55007,
    55036,
    55066,
    55095,
    55125,
    55154,
    55184,
    55213,
    55243,
    55273,
    55302,
    55332,
    55361,
    55391,
    55420,
    55450,
    55479,
    55508,
    55538,
    55567,
    55597,
    55627,
    55657,
    55686,
    55716,
    55745,
    55775,
    55804,
    55834,
    55863,
    55892,
    55922,
    55951,
    55981,
    56011,
    56040,
    56070,
    56100,
    56129,
    56159,
    56188,
    56218,
    56247,
    56276,
    56306,
    56335,
    56365,
    56394,
    56424,
    56454,
    56483,
    56513,
    56543,
    56572,
    56601,
    56631,
    56660,
    56690,
    56719,
    56749,
    56778,
    56808,
    56837,
    56867,
    56897,
    56926,
    56956,
    56985,
    57015,
    57044,
    57074,
    57103,
    57133,
    57162,
    57192,
    57221,
    57251,
    57280,
    57310,
    57340,
    57369,
    57399,
    57429,
    57458,
    57487,
    57517,
    57546,
    57576,
    57605,
    57634,
    57664,
    57694,
    57723,
    57753,
    57783,
    57813,
    57842,
    57871,
    57901,
    57930,
    57959,
    57989,
    58018,
    58048,
    58077,
    58107,
    58137,
    58167,
    58196,
    58226,
    58255,
    58285,
    58314,
    58343,
    58373,
    58402,
    58432,
    58461,
    58491,
    58521,
    58551,
    58580,
    58610,
    58639,
    58669,
    58698,
    58727,
    58757,
    58786,
    58816,
    58845,
    58875,
    58905,
    58934,
    58964,
    58994,
    59023,
    59053,
    59082,
    59111,
    59141,
    59170,
    59200,
    59229,
    59259,
    59288,
    59318,
    59348,
    59377,
    59407,
    59436,
    59466,
    59495,
    59525,
    59554,
    59584,
    59613,
    59643,
    59672,
    59702,
    59731,
    59761,
    59791,
    59820,
    59850,
    59879,
    59909,
    59939,
    59968,
    59997,
    60027,
    60056,
    60086,
    60115,
    60145,
    60174,
    60204,
    60234,
    60264,
    60293,
    60323,
    60352,
    60381,
    60411,
    60440,
    60469,
    60499,
    60528,
    60558,
    60588,
    60618,
    60648,
    60677,
    60707,
    60736,
    60765,
    60795,
    60824,
    60853,
    60883,
    60912,
    60942,
    60972,
    61002,
    61031,
    61061,
    61090,
    61120,
    61149,
    61179,
    61208,
    61237,
    61267,
    61296,
    61326,
    61356,
    61385,
    61415,
    61445,
    61474,
    61504,
    61533,
    61563,
    61592,
    61621,
    61651,
    61680,
    61710,
    61739,
    61769,
    61799,
    61828,
    61858,
    61888,
    61917,
    61947,
    61976,
    62006,
    62035,
    62064,
    62094,
    62123,
    62153,
    62182,
    62212,
    62242,
    62271,
    62301,
    62331,
    62360,
    62390,
    62419,
    62448,
    62478,
    62507,
    62537,
    62566,
    62596,
    62625,
    62655,
    62685,
    62715,
    62744,
    62774,
    62803,
    62832,
    62862,
    62891,
    62921,
    62950,
    62980,
    63009,
    63039,
    63069,
    63099,
    63128,
    63157,
    63187,
    63216,
    63246,
    63275,
    63305,
    63334,
    63363,
    63393,
    63423,
    63453,
    63482,
    63512,
    63541,
    63571,
    63600,
    63630,
    63659,
    63689,
    63718,
    63747,
    63777,
    63807,
    63836,
    63866,
    63895,
    63925,
    63955,
    63984,
    64014,
    64043,
    64073,
    64102,
    64131,
    64161,
    64190,
    64220,
    64249,
    64279,
    64309,
    64339,
    64368,
    64398,
    64427,
    64457,
    64486,
    64515,
    64545,
    64574,
    64603,
    64633,
    64663,
    64692,
    64722,
    64752,
    64782,
    64811,
    64841,
    64870,
    64899,
    64929,
    64958,
    64987,
    65017,
    65047,
    65076,
    65106,
    65136,
    65166,
    65195,
    65225,
    65254,
    65283,
    65313,
    65342,
    65371,
    65401,
    65431,
    65460,
    65490,
    65520,
    65549,
    65579,
    65608,
    65638,
    65667,
    65697,
    65726,
    65755,
    65785,
    65815,
    65844,
    65874,
    65903,
    65933,
    65963,
    65992,
    66022,
    66051,
    66081,
    66110,
    66140,
    66169,
    66199,
    66228,
    66258,
    66287,
    66317,
    66346,
    66376,
    66405,
    66435,
    66465,
    66494,
    66524,
    66553,
    66583,
    66612,
    66641,
    66671,
    66700,
    66730,
    66760,
    66789,
    66819,
    66849,
    66878,
    66908,
    66937,
    66967,
    66996,
    67025,
    67055,
    67084,
    67114,
    67143,
    67173,
    67203,
    67233,
    67262,
    67292,
    67321,
    67351,
    67380,
    67409,
    67439,
    67468,
    67497,
    67527,
    67557,
    67587,
    67617,
    67646,
    67676,
    67705,
    67735,
    67764,
    67793,
    67823,
    67852,
    67882,
    67911,
    67941,
    67971,
    68e3,
    68030,
    68060,
    68089,
    68119,
    68148,
    68177,
    68207,
    68236,
    68266,
    68295,
    68325,
    68354,
    68384,
    68414,
    68443,
    68473,
    68502,
    68532,
    68561,
    68591,
    68620,
    68650,
    68679,
    68708,
    68738,
    68768,
    68797,
    68827,
    68857,
    68886,
    68916,
    68946,
    68975,
    69004,
    69034,
    69063,
    69092,
    69122,
    69152,
    69181,
    69211,
    69240,
    69270,
    69300,
    69330,
    69359,
    69388,
    69418,
    69447,
    69476,
    69506,
    69535,
    69565,
    69595,
    69624,
    69654,
    69684,
    69713,
    69743,
    69772,
    69802,
    69831,
    69861,
    69890,
    69919,
    69949,
    69978,
    70008,
    70038,
    70067,
    70097,
    70126,
    70156,
    70186,
    70215,
    70245,
    70274,
    70303,
    70333,
    70362,
    70392,
    70421,
    70451,
    70481,
    70510,
    70540,
    70570,
    70599,
    70629,
    70658,
    70687,
    70717,
    70746,
    70776,
    70805,
    70835,
    70864,
    70894,
    70924,
    70954,
    70983,
    71013,
    71042,
    71071,
    71101,
    71130,
    71159,
    71189,
    71218,
    71248,
    71278,
    71308,
    71337,
    71367,
    71397,
    71426,
    71455,
    71485,
    71514,
    71543,
    71573,
    71602,
    71632,
    71662,
    71691,
    71721,
    71751,
    71781,
    71810,
    71839,
    71869,
    71898,
    71927,
    71957,
    71986,
    72016,
    72046,
    72075,
    72105,
    72135,
    72164,
    72194,
    72223,
    72253,
    72282,
    72311,
    72341,
    72370,
    72400,
    72429,
    72459,
    72489,
    72518,
    72548,
    72577,
    72607,
    72637,
    72666,
    72695,
    72725,
    72754,
    72784,
    72813,
    72843,
    72872,
    72902,
    72931,
    72961,
    72991,
    73020,
    73050,
    73080,
    73109,
    73139,
    73168,
    73197,
    73227,
    73256,
    73286,
    73315,
    73345,
    73375,
    73404,
    73434,
    73464,
    73493,
    73523,
    73552,
    73581,
    73611,
    73640,
    73669,
    73699,
    73729,
    73758,
    73788,
    73818,
    73848,
    73877,
    73907,
    73936,
    73965,
    73995,
    74024,
    74053,
    74083,
    74113,
    74142,
    74172,
    74202,
    74231,
    74261,
    74291,
    74320,
    74349,
    74379,
    74408,
    74437,
    74467,
    74497,
    74526,
    74556,
    74586,
    74615,
    74645,
    74675,
    74704,
    74733,
    74763,
    74792,
    74822,
    74851,
    74881,
    74910,
    74940,
    74969,
    74999,
    75029,
    75058,
    75088,
    75117,
    75147,
    75176,
    75206,
    75235,
    75264,
    75294,
    75323,
    75353,
    75383,
    75412,
    75442,
    75472,
    75501,
    75531,
    75560,
    75590,
    75619,
    75648,
    75678,
    75707,
    75737,
    75766,
    75796,
    75826,
    75856,
    75885,
    75915,
    75944,
    75974,
    76003,
    76032,
    76062,
    76091,
    76121,
    76150,
    76180,
    76210,
    76239,
    76269,
    76299,
    76328,
    76358,
    76387,
    76416,
    76446,
    76475,
    76505,
    76534,
    76564,
    76593,
    76623,
    76653,
    76682,
    76712,
    76741,
    76771,
    76801,
    76830,
    76859,
    76889,
    76918,
    76948,
    76977,
    77007,
    77036,
    77066,
    77096,
    77125,
    77155,
    77185,
    77214,
    77243,
    77273,
    77302,
    77332,
    77361,
    77390,
    77420,
    77450,
    77479,
    77509,
    77539,
    77569,
    77598,
    77627,
    77657,
    77686,
    77715,
    77745,
    77774,
    77804,
    77833,
    77863,
    77893,
    77923,
    77952,
    77982,
    78011,
    78041,
    78070,
    78099,
    78129,
    78158,
    78188,
    78217,
    78247,
    78277,
    78307,
    78336,
    78366,
    78395,
    78425,
    78454,
    78483,
    78513,
    78542,
    78572,
    78601,
    78631,
    78661,
    78690,
    78720,
    78750,
    78779,
    78808,
    78838,
    78867,
    78897,
    78926,
    78956,
    78985,
    79015,
    79044,
    79074,
    79104,
    79133,
    79163,
    79192,
    79222,
    79251,
    79281,
    79310,
    79340,
    79369,
    79399,
    79428,
    79458,
    79487,
    79517,
    79546,
    79576,
    79606,
    79635,
    79665,
    79695,
    79724,
    79753,
    79783,
    79812,
    79841,
    79871,
    79900,
    79930,
    79960,
    79990
  ];
  function getHijriDate(gDate) {
    var day = gDate.getDate();
    var month2 = gDate.getMonth();
    var year = gDate.getFullYear();
    var tMonth = month2 + 1;
    var tYear = year;
    if (tMonth < 3) {
      tYear -= 1;
      tMonth += 12;
    }
    var yPrefix = Math.floor(tYear / 100);
    var julilanOffset = yPrefix - Math.floor(yPrefix / 4) - 2;
    var julianNumber = Math.floor(365.25 * (tYear + 4716)) + Math.floor(30.6001 * (tMonth + 1)) + day - julilanOffset - 1524;
    yPrefix = Math.floor((julianNumber - 186721625e-2) / 36524.25);
    julilanOffset = yPrefix - Math.floor(yPrefix / 4) + 1;
    var b = julianNumber + julilanOffset + 1524;
    var c = Math.floor((b - 122.1) / 365.25);
    var d = Math.floor(365.25 * c);
    var tempMonth = Math.floor((b - d) / 30.6001);
    day = b - d - Math.floor(30.6001 * tempMonth);
    month2 = Math.floor((b - d) / 20.6001);
    if (month2 > 13) {
      c += 1;
      month2 -= 12;
    }
    month2 -= 1;
    year = c - 4716;
    var modifiedJulianDate = julianNumber - 24e5;
    var iyear = 10631 / 30;
    var z = julianNumber - 1948084;
    var cyc = Math.floor(z / 10631);
    z = z - 10631 * cyc;
    var j = Math.floor((z - 0.1335) / iyear);
    var iy = 30 * cyc + j;
    z = z - Math.floor(j * iyear + 0.1335);
    var im = Math.floor((z + 28.5001) / 29.5);
    if (im === 13) {
      im = 12;
    }
    var tempDay = z - Math.floor(29.5001 * im - 29);
    var i = 0;
    for (; i < dateCorrection.length; i++) {
      if (dateCorrection[parseInt(i.toString(), 10)] > modifiedJulianDate) {
        break;
      }
    }
    var iln = i + 16260;
    var ii = Math.floor((iln - 1) / 12);
    var hYear = ii + 1;
    var hmonth = iln - 12 * ii;
    var hDate = modifiedJulianDate - dateCorrection[i - 1] + 1;
    if ((hDate + "").length > 2) {
      hDate = tempDay;
      hmonth = im;
      hYear = iy;
    }
    return { year: hYear, month: hmonth, date: hDate };
  }
  HijriParser2.getHijriDate = getHijriDate;
  function toGregorian(year, month2, day) {
    var iy = year;
    var im = month2;
    var id = day;
    var ii = iy - 1;
    var iln = ii * 12 + 1 + (im - 1);
    var i = iln - 16260;
    var mcjdn = id + dateCorrection[i - 1] - 1;
    var julianDate = mcjdn + 24e5;
    var z = Math.floor(julianDate + 0.5);
    var a = Math.floor((z - 186721625e-2) / 36524.25);
    a = z + 1 + a - Math.floor(a / 4);
    var b = a + 1524;
    var c = Math.floor((b - 122.1) / 365.25);
    var d = Math.floor(365.25 * c);
    var e = Math.floor((b - d) / 30.6001);
    var gDay = b - d - Math.floor(e * 30.6001);
    var gMonth = e - (e > 13.5 ? 13 : 1);
    var gYear = c - (gMonth > 2.5 ? 4716 : 4715);
    if (gYear <= 0) {
      gMonth--;
    }
    return /* @__PURE__ */ new Date(gYear + "/" + gMonth + "/" + gDay);
  }
  HijriParser2.toGregorian = toGregorian;
})(HijriParser || (HijriParser = {}));

// node_modules/@syncfusion/ej2-base/src/intl/date-formatter.js
var abbreviateRegexGlobal = /\/MMMMM|MMMM|MMM|a|LLLL|LLL|EEEEE|EEEE|E|K|cccc|ccc|WW|W|G+|z+/gi;
var standalone = "stand-alone";
var weekdayKey = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
var timeSetter = {
  m: "getMinutes",
  h: "getHours",
  H: "getHours",
  s: "getSeconds",
  d: "getDate",
  f: "getMilliseconds"
};
var datePartMatcher = {
  "M": "month",
  "d": "day",
  "E": "weekday",
  "c": "weekday",
  "y": "year",
  "m": "minute",
  "h": "hour",
  "H": "hour",
  "s": "second",
  "L": "month",
  "a": "designator",
  "z": "timeZone",
  "Z": "timeZone",
  "G": "era",
  "f": "milliseconds"
};
var timeSeparator = "timeSeparator";
var DateFormat2 = (
  /** @class */
  (function() {
    function DateFormat3() {
    }
    DateFormat3.dateFormat = function(culture, option, cldr) {
      var _this = this;
      var dependable = IntlBase.getDependables(cldr, culture, option.calendar);
      var numObject = getValue("parserObject.numbers", dependable);
      var dateObject = dependable.dateObject;
      var formatOptions = { isIslamic: IntlBase.islamicRegex.test(option.calendar) };
      formatOptions.firstDayOfWeek = IntlBase.getWeekData(culture, cldr);
      if (isBlazor() && option.isServerRendered) {
        option = IntlBase.compareBlazorDateFormats(option, culture);
      }
      var resPattern = option.format || IntlBase.getResultantPattern(option.skeleton, dependable.dateObject, option.type, false, isBlazor() ? culture : "");
      formatOptions.dateSeperator = isBlazor() ? getValue("dateSeperator", dateObject) : IntlBase.getDateSeparator(dependable.dateObject);
      if (isUndefined(resPattern)) {
        throwError("Format options or type given must be invalid");
      } else {
        resPattern = IntlBase.ConvertDateToWeekFormat(resPattern);
        if (isBlazor()) {
          resPattern = resPattern.replace(/tt/, "a");
        }
        formatOptions.pattern = resPattern;
        formatOptions.numMapper = isBlazor() ? extend({}, numObject) : ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr));
        var patternMatch = resPattern.match(abbreviateRegexGlobal) || [];
        for (var _i = 0, patternMatch_1 = patternMatch; _i < patternMatch_1.length; _i++) {
          var str = patternMatch_1[_i];
          var len = str.length;
          var char = str[0];
          if (char === "K") {
            char = "h";
          }
          switch (char) {
            case "E":
            case "c":
              if (isBlazor()) {
                formatOptions.weekday = getValue("days." + IntlBase.monthIndex["" + len], dateObject);
              } else {
                formatOptions.weekday = dependable.dateObject["" + IntlBase.days]["" + standalone][IntlBase.monthIndex["" + len]];
              }
              break;
            case "M":
            case "L":
              if (isBlazor()) {
                formatOptions.month = getValue("months." + IntlBase.monthIndex["" + len], dateObject);
              } else {
                formatOptions.month = dependable.dateObject["" + IntlBase.month]["" + standalone][IntlBase.monthIndex["" + len]];
              }
              break;
            case "a":
              formatOptions.designator = isBlazor() ? getValue("dayPeriods", dateObject) : getValue("dayPeriods.format.wide", dateObject);
              break;
            case "G": {
              var eText = len <= 3 ? "eraAbbr" : len === 4 ? "eraNames" : "eraNarrow";
              formatOptions.era = isBlazor() ? getValue("eras", dateObject) : getValue("eras." + eText, dependable.dateObject);
              break;
            }
            case "z":
              formatOptions.timeZone = getValue("dates.timeZoneNames", dependable.parserObject);
              break;
          }
        }
      }
      return function(value) {
        if (isNaN(value.getDate())) {
          return null;
        }
        return _this.intDateFormatter(value, formatOptions);
      };
    };
    DateFormat3.intDateFormatter = function(value, options) {
      var pattern = options.pattern;
      var ret = "";
      var matches2 = pattern.match(IntlBase.dateParseRegex);
      var dObject = this.getCurrentDateValue(value, options.isIslamic);
      for (var _i = 0, matches_1 = matches2; _i < matches_1.length; _i++) {
        var match = matches_1[_i];
        var length_1 = match.length;
        var char = match[0];
        if (char === "K") {
          char = "h";
        }
        var curval = void 0;
        var curvalstr = "";
        var isNumber = void 0;
        var processNumber = void 0;
        var curstr = "";
        switch (char) {
          case "M":
          case "L":
            curval = dObject.month;
            if (length_1 > 2) {
              ret += options.month["" + curval];
            } else {
              isNumber = true;
            }
            break;
          case "E":
          case "c":
            ret += options.weekday["" + weekdayKey[value.getDay()]];
            break;
          case "H":
          case "h":
          case "m":
          case "s":
          case "d":
          case "f":
            isNumber = true;
            if (char === "d") {
              curval = dObject.date;
            } else if (char === "f") {
              isNumber = false;
              processNumber = true;
              curvalstr = value["" + timeSetter["" + char]]().toString();
              curvalstr = curvalstr.substring(0, length_1);
              var curlength = curvalstr.length;
              if (length_1 !== curlength) {
                if (length_1 > 3) {
                  continue;
                }
                for (var i = 0; i < length_1 - curlength; i++) {
                  curvalstr = "0" + curvalstr.toString();
                }
              }
              curstr += curvalstr;
            } else {
              curval = value["" + timeSetter["" + char]]();
            }
            if (char === "h") {
              curval = curval % 12 || 12;
            }
            break;
          case "y":
            processNumber = true;
            curstr += dObject.year;
            if (length_1 === 2) {
              curstr = curstr.substr(curstr.length - 2);
            }
            break;
          case "a": {
            var desig = value.getHours() < 12 ? "am" : "pm";
            ret += options.designator["" + desig];
            break;
          }
          case "G": {
            var dec = value.getFullYear() < 0 ? 0 : 1;
            var retu = options.era["" + dec];
            if (isNullOrUndefined(retu)) {
              retu = options.era[dec ? 0 : 1];
            }
            ret += retu || "";
            break;
          }
          case "'":
            ret += match === "''" ? "'" : match.replace(/'/g, "");
            break;
          case "z": {
            var timezone = value.getTimezoneOffset();
            var pattern_1 = length_1 < 4 ? "+H;-H" : options.timeZone.hourFormat;
            pattern_1 = pattern_1.replace(/:/g, options.numMapper.timeSeparator);
            if (timezone === 0) {
              ret += options.timeZone.gmtZeroFormat;
            } else {
              processNumber = true;
              curstr = this.getTimeZoneValue(timezone, pattern_1);
            }
            curstr = options.timeZone.gmtFormat.replace(/\{0\}/, curstr);
            break;
          }
          case ":":
            ret += options.numMapper.numberSymbols["" + timeSeparator];
            break;
          case "/":
            ret += options.dateSeperator;
            break;
          case "W":
            isNumber = true;
            curval = IntlBase.getWeekOfYear(value, options.firstDayOfWeek);
            break;
          default:
            ret += match;
        }
        if (isNumber) {
          processNumber = true;
          curstr = this.checkTwodigitNumber(curval, length_1);
        }
        if (processNumber) {
          ret += ParserBase.convertValueParts(curstr, IntlBase.latnParseRegex, options.numMapper.mapper);
        }
      }
      return ret;
    };
    DateFormat3.getCurrentDateValue = function(value, isIslamic) {
      if (isIslamic) {
        return HijriParser.getHijriDate(value);
      }
      return { year: value.getFullYear(), month: value.getMonth() + 1, date: value.getDate() };
    };
    DateFormat3.checkTwodigitNumber = function(val, len) {
      var ret = val + "";
      if (len === 2 && ret.length !== 2) {
        return "0" + ret;
      }
      return ret;
    };
    DateFormat3.getTimeZoneValue = function(tVal, pattern) {
      var _this = this;
      var splt = pattern.split(";");
      var curPattern = splt[tVal > 0 ? 1 : 0];
      var no = Math.abs(tVal);
      return curPattern = curPattern.replace(/HH?|mm/g, function(str) {
        var len = str.length;
        var ishour = str.indexOf("H") !== -1;
        return _this.checkTwodigitNumber(Math.floor(ishour ? no / 60 : no % 60), len);
      });
    };
    return DateFormat3;
  })()
);
setDateFormat(DateFormat2);

// node_modules/@syncfusion/ej2-base/src/intl/number-formatter.js
var errorText = {
  "ms": "minimumSignificantDigits",
  "ls": "maximumSignificantDigits",
  "mf": "minimumFractionDigits",
  "lf": "maximumFractionDigits"
};
var percentSign = "percentSign";
var minusSign = "minusSign";
var mapper = ["infinity", "nan", "group", "decimal", "exponential"];
var NumberFormat2 = (
  /** @class */
  (function() {
    function NumberFormat3() {
    }
    NumberFormat3.numberFormatter = function(culture, option, cldr) {
      var _this = this;
      var fOptions = extend({}, option);
      var cOptions = {};
      var dOptions = {};
      var symbolPattern;
      var dependable = IntlBase.getDependables(cldr, culture, "", true);
      var numObject = dependable.numericObject;
      dOptions.numberMapper = isBlazor() ? extend({}, numObject) : ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr), true);
      dOptions.currencySymbol = isBlazor() ? getValue("currencySymbol", numObject) : IntlBase.getCurrencySymbol(dependable.numericObject, fOptions.currency || defaultCurrencyCode, option.altSymbol, option.ignoreCurrency);
      dOptions.percentSymbol = isBlazor() ? getValue("numberSymbols.percentSign", numObject) : dOptions.numberMapper.numberSymbols["" + percentSign];
      dOptions.minusSymbol = isBlazor() ? getValue("numberSymbols.minusSign", numObject) : dOptions.numberMapper.numberSymbols["" + minusSign];
      var symbols = dOptions.numberMapper.numberSymbols;
      if (option.format && !IntlBase.formatRegex.test(option.format)) {
        cOptions = IntlBase.customFormat(option.format, dOptions, dependable.numericObject);
        if (!isUndefined(fOptions.useGrouping) && fOptions.useGrouping) {
          fOptions.useGrouping = cOptions.pData.useGrouping;
        }
      } else {
        extend(fOptions, IntlBase.getProperNumericSkeleton(option.format || "N"));
        fOptions.isCurrency = fOptions.type === "currency";
        fOptions.isPercent = fOptions.type === "percent";
        if (!isBlazor()) {
          symbolPattern = IntlBase.getSymbolPattern(fOptions.type, dOptions.numberMapper.numberSystem, dependable.numericObject, fOptions.isAccount);
        }
        fOptions.groupOne = this.checkValueRange(fOptions.maximumSignificantDigits, fOptions.minimumSignificantDigits, true);
        this.checkValueRange(fOptions.maximumFractionDigits, fOptions.minimumFractionDigits, false, true);
        if (!isUndefined(fOptions.fractionDigits)) {
          fOptions.minimumFractionDigits = fOptions.maximumFractionDigits = fOptions.fractionDigits;
        }
        if (isUndefined(fOptions.useGrouping)) {
          fOptions.useGrouping = true;
        }
        if (fOptions.isCurrency && !isBlazor()) {
          symbolPattern = symbolPattern.replace(/\u00A4/g, IntlBase.defaultCurrency);
        }
        if (!isBlazor()) {
          var split = symbolPattern.split(";");
          cOptions.nData = IntlBase.getFormatData(split[1] || "-" + split[0], true, dOptions.currencySymbol);
          cOptions.pData = IntlBase.getFormatData(split[0], false, dOptions.currencySymbol);
          if (fOptions.useGrouping) {
            fOptions.groupSeparator = symbols[mapper[2]];
            fOptions.groupData = this.getGroupingDetails(split[0]);
          }
        } else {
          cOptions.nData = extend({}, {}, getValue(fOptions.type + "nData", numObject));
          cOptions.pData = extend({}, {}, getValue(fOptions.type + "pData", numObject));
          if (fOptions.type === "currency" && option.currency) {
            IntlBase.replaceBlazorCurrency([cOptions.pData, cOptions.nData], dOptions.currencySymbol, option.currency);
          }
        }
        var minFrac = isUndefined(fOptions.minimumFractionDigits);
        if (minFrac) {
          fOptions.minimumFractionDigits = cOptions.nData.minimumFraction;
        }
        if (isUndefined(fOptions.maximumFractionDigits)) {
          var mval = cOptions.nData.maximumFraction;
          fOptions.maximumFractionDigits = isUndefined(mval) && fOptions.isPercent ? 0 : mval;
        }
        var mfrac = fOptions.minimumFractionDigits;
        var lfrac = fOptions.maximumFractionDigits;
        if (!isUndefined(mfrac) && !isUndefined(lfrac)) {
          if (mfrac > lfrac) {
            fOptions.maximumFractionDigits = mfrac;
          }
        }
      }
      extend(cOptions.nData, fOptions);
      extend(cOptions.pData, fOptions);
      return function(value) {
        if (isNaN(value)) {
          return symbols[mapper[1]];
        } else if (!isFinite(value)) {
          return symbols[mapper[0]];
        }
        return _this.intNumberFormatter(value, cOptions, dOptions, option);
      };
    };
    NumberFormat3.getGroupingDetails = function(pattern) {
      var ret = {};
      var match = pattern.match(IntlBase.negativeDataRegex);
      if (match && match[4]) {
        var pattern_1 = match[4];
        var p = pattern_1.lastIndexOf(",");
        if (p !== -1) {
          var temp = pattern_1.split(".")[0];
          ret.primary = temp.length - p - 1;
          var s = pattern_1.lastIndexOf(",", p - 1);
          if (s !== -1) {
            ret.secondary = p - 1 - s;
          }
        }
      }
      return ret;
    };
    NumberFormat3.checkValueRange = function(val1, val2, checkbothExist, isFraction) {
      var decide = isFraction ? "f" : "s";
      var dint = 0;
      var str1 = errorText["l" + decide];
      var str2 = errorText["m" + decide];
      if (!isUndefined(val1)) {
        this.checkRange(val1, str1, isFraction);
        dint++;
      }
      if (!isUndefined(val2)) {
        this.checkRange(val2, str2, isFraction);
        dint++;
      }
      if (dint === 2) {
        if (val1 < val2) {
          throwError(str2 + "specified must be less than the" + str1);
        } else {
          return true;
        }
      } else if (checkbothExist && dint === 1) {
        throwError("Both" + str2 + "and" + str2 + "must be present");
      }
      return false;
    };
    NumberFormat3.checkRange = function(val, text, isFraction) {
      var range = isFraction ? [0, 20] : [1, 21];
      if (val < range[0] || val > range[1]) {
        throwError(text + "value must be within the range" + range[0] + "to" + range[1]);
      }
    };
    NumberFormat3.intNumberFormatter = function(value, fOptions, dOptions, option) {
      var curData;
      if (isUndefined(fOptions.nData.type)) {
        return void 0;
      } else {
        if (value < 0) {
          value = value * -1;
          curData = fOptions.nData;
        } else if (value === 0) {
          curData = fOptions.zeroData || fOptions.pData;
        } else {
          curData = fOptions.pData;
        }
        var fValue = "";
        if (curData.isPercent) {
          value = value * 100;
        }
        if (curData.groupOne) {
          fValue = this.processSignificantDigits(value, curData.minimumSignificantDigits, curData.maximumSignificantDigits);
        } else {
          fValue = this.processFraction(value, curData.minimumFractionDigits, curData.maximumFractionDigits, option);
          if (curData.minimumIntegerDigits) {
            fValue = this.processMinimumIntegers(fValue, curData.minimumIntegerDigits);
          }
          if (dOptions.isCustomFormat && curData.minimumFractionDigits < curData.maximumFractionDigits && /\d+\.\d+/.test(fValue)) {
            var temp = fValue.split(".");
            var decimalPart = temp[1];
            var len = decimalPart.length;
            for (var i = len - 1; i >= 0; i--) {
              if (decimalPart[parseInt(i.toString(), 10)] === "0" && i >= curData.minimumFractionDigits) {
                decimalPart = decimalPart.slice(0, i);
              } else {
                break;
              }
            }
            fValue = temp[0] + "." + decimalPart;
          }
        }
        if (curData.type === "scientific") {
          fValue = value.toExponential(curData.maximumFractionDigits);
          fValue = fValue.replace("e", dOptions.numberMapper.numberSymbols[mapper[4]]);
        }
        fValue = fValue.replace(".", dOptions.numberMapper.numberSymbols[mapper[3]]);
        fValue = curData.format === "#,###,,;(#,###,,)" ? this.customPivotFormat(parseInt(fValue, 10)) : fValue;
        if (curData.useGrouping) {
          fValue = this.groupNumbers(fValue, curData.groupData.primary, curData.groupSeparator || ",", dOptions.numberMapper.numberSymbols[mapper[3]] || ".", curData.groupData.secondary);
        }
        fValue = ParserBase.convertValueParts(fValue, IntlBase.latnParseRegex, dOptions.numberMapper.mapper);
        if (curData.nlead === "N/A") {
          return curData.nlead;
        } else {
          if (fValue === "0" && option && option.format === "0") {
            return fValue + curData.nend;
          }
          return curData.nlead + fValue + curData.nend;
        }
      }
    };
    NumberFormat3.processSignificantDigits = function(value, min, max) {
      var temp = value + "";
      var tn;
      var length = temp.length;
      if (length < min) {
        return value.toPrecision(min);
      } else {
        temp = value.toPrecision(max);
        tn = +temp;
        return tn + "";
      }
    };
    NumberFormat3.groupNumbers = function(val, level1, sep, decimalSymbol, level2) {
      var flag = !isNullOrUndefined(level2) && level2 !== 0;
      var split = val.split(decimalSymbol);
      var prefix = split[0];
      var length = prefix.length;
      var str = "";
      while (length > level1) {
        str = prefix.slice(length - level1, length) + (str.length ? sep + str : "");
        length -= level1;
        if (flag) {
          level1 = level2;
          flag = false;
        }
      }
      split[0] = prefix.slice(0, length) + (str.length ? sep : "") + str;
      return split.join(decimalSymbol);
    };
    NumberFormat3.processFraction = function(value, min, max, option) {
      var temp = (value + "").split(".")[1];
      var length = temp ? temp.length : 0;
      if (min && length < min) {
        var ret = "";
        if (length === 0) {
          ret = value.toFixed(min);
        } else {
          ret += value;
          for (var j = 0; j < min - length; j++) {
            ret += "0";
          }
          return ret;
        }
        return value.toFixed(min);
      } else if (!isNullOrUndefined(max) && (length > max || max === 0)) {
        return value.toFixed(max);
      }
      var str = value + "";
      if (str[0] === "0" && option && option.format === "###.00") {
        str = str.slice(1);
      }
      return str;
    };
    NumberFormat3.processMinimumIntegers = function(value, min) {
      var temp = value.split(".");
      var lead = temp[0];
      var len = lead.length;
      if (len < min) {
        for (var i = 0; i < min - len; i++) {
          lead = "0" + lead;
        }
        temp[0] = lead;
      }
      return temp.join(".");
    };
    NumberFormat3.customPivotFormat = function(value) {
      if (value >= 5e5) {
        value /= 1e6;
        var _a = value.toString().split("."), integer = _a[0], decimal = _a[1];
        return decimal && +decimal.substring(0, 1) >= 5 ? Math.ceil(value).toString() : Math.floor(value).toString();
      }
      return "";
    };
    return NumberFormat3;
  })()
);
setNumberFormat(NumberFormat2);

// node_modules/@syncfusion/ej2-base/src/intl/date-parser.js
var standalone2 = "stand-alone";
var latnRegex = /^[0-9]*$/;
var timeSetter2 = {
  minute: "setMinutes",
  hour: "setHours",
  second: "setSeconds",
  day: "setDate",
  month: "setMonth",
  milliseconds: "setMilliseconds"
};
var month = "months";
var DateParser = (
  /** @class */
  (function() {
    function DateParser2() {
    }
    DateParser2.dateParser = function(culture, option, cldr) {
      var _this = this;
      var dependable = IntlBase.getDependables(cldr, culture, option.calendar);
      var numOptions = ParserBase.getCurrentNumericOptions(dependable.parserObject, ParserBase.getNumberingSystem(cldr), false, isBlazor());
      var parseOptions = {};
      if (isBlazor() && option.isServerRendered) {
        option = IntlBase.compareBlazorDateFormats(option, culture);
      }
      var resPattern = option.format || IntlBase.getResultantPattern(option.skeleton, dependable.dateObject, option.type, false, isBlazor() ? culture : "");
      var regexString = "";
      var hourOnly;
      if (isUndefined(resPattern)) {
        throwError("Format options or type given must be invalid");
      } else {
        resPattern = IntlBase.ConvertDateToWeekFormat(resPattern);
        parseOptions = { isIslamic: IntlBase.islamicRegex.test(option.calendar), pattern: resPattern, evalposition: {}, culture };
        var patternMatch = resPattern.match(IntlBase.dateParseRegex) || [];
        var length_1 = patternMatch.length;
        var gmtCorrection = 0;
        var zCorrectTemp = 0;
        var isgmtTraversed = false;
        var nRegx = numOptions.numericRegex;
        var numMapper = isBlazor() ? dependable.parserObject.numbers : ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr));
        for (var i = 0; i < length_1; i++) {
          var str = patternMatch[parseInt(i.toString(), 10)];
          var len = str.length;
          var char = str[0] === "K" ? "h" : str[0];
          var isNumber = void 0;
          var canUpdate = void 0;
          var charKey = datePartMatcher["" + char];
          var optional = len === 2 ? "" : "?";
          if (isgmtTraversed) {
            gmtCorrection = zCorrectTemp;
            isgmtTraversed = false;
          }
          switch (char) {
            case "E":
            case "c": {
              var weekData = void 0;
              if (isBlazor()) {
                weekData = getValue("days." + IntlBase.monthIndex["" + len], dependable.dateObject);
              } else {
                weekData = dependable.dateObject["" + IntlBase.days]["" + standalone2][IntlBase.monthIndex["" + len]];
              }
              var weekObject = ParserBase.reverseObject(weekData);
              regexString += "(" + Object.keys(weekObject).join("|") + ")";
              break;
            }
            case "M":
            case "L":
            case "d":
            case "m":
            case "s":
            case "h":
            case "H":
            case "f":
              canUpdate = true;
              if ((char === "M" || char === "L") && len > 2) {
                var monthData = void 0;
                if (isBlazor()) {
                  monthData = getValue("months." + IntlBase.monthIndex["" + len], dependable.dateObject);
                } else {
                  monthData = dependable.dateObject["" + month]["" + standalone2][IntlBase.monthIndex["" + len]];
                }
                parseOptions["" + charKey] = ParserBase.reverseObject(monthData);
                regexString += "(" + Object.keys(parseOptions["" + charKey]).join("|") + ")";
              } else if (char === "f") {
                if (len > 3) {
                  continue;
                }
                isNumber = true;
                regexString += "(" + nRegx + nRegx + "?" + nRegx + "?)";
              } else {
                isNumber = true;
                regexString += "(" + nRegx + nRegx + optional + ")";
              }
              if (char === "h") {
                parseOptions.hour12 = true;
              }
              break;
            case "W": {
              var opt = len === 1 ? "?" : "";
              regexString += "(" + nRegx + opt + nRegx + ")";
              break;
            }
            case "y":
              canUpdate = isNumber = true;
              if (len === 2) {
                regexString += "(" + nRegx + nRegx + ")";
              } else {
                regexString += "(" + nRegx + "{" + len + ",})";
              }
              break;
            case "a": {
              canUpdate = true;
              var periodValur = isBlazor() ? getValue("dayPeriods", dependable.dateObject) : getValue("dayPeriods.format.wide", dependable.dateObject);
              parseOptions["" + charKey] = ParserBase.reverseObject(periodValur);
              regexString += "(" + Object.keys(parseOptions["" + charKey]).join("|") + ")";
              break;
            }
            case "G": {
              canUpdate = true;
              var eText = len <= 3 ? "eraAbbr" : len === 4 ? "eraNames" : "eraNarrow";
              parseOptions["" + charKey] = ParserBase.reverseObject(isBlazor() ? getValue("eras", dependable.dateObject) : getValue("eras." + eText, dependable.dateObject));
              regexString += "(" + Object.keys(parseOptions["" + charKey]).join("|") + "?)";
              break;
            }
            case "z": {
              var tval = (/* @__PURE__ */ new Date()).getTimezoneOffset();
              canUpdate = tval !== 0;
              parseOptions["" + charKey] = getValue("dates.timeZoneNames", dependable.parserObject);
              var tzone = parseOptions["" + charKey];
              hourOnly = len < 4;
              var hpattern = hourOnly ? "+H;-H" : tzone.hourFormat;
              hpattern = hpattern.replace(/:/g, numMapper.timeSeparator);
              regexString += "(" + this.parseTimeZoneRegx(hpattern, tzone, nRegx) + ")?";
              isgmtTraversed = true;
              zCorrectTemp = hourOnly ? 6 : 12;
              break;
            }
            case "'": {
              var iString = str.replace(/'/g, "");
              regexString += "(" + iString + ")?";
              break;
            }
            default:
              regexString += "([\\D])";
              break;
          }
          if (canUpdate) {
            parseOptions.evalposition["" + charKey] = { isNumber, pos: i + 1 + gmtCorrection, hourOnly };
          }
          if (i === length_1 - 1 && !isNullOrUndefined(regexString)) {
            var regExp3 = RegExp;
            parseOptions.parserRegex = new regExp3("^" + regexString + "$", "i");
          }
        }
      }
      return function(value) {
        var parsedDateParts = _this.internalDateParse(value, parseOptions, numOptions);
        if (isNullOrUndefined(parsedDateParts) || !Object.keys(parsedDateParts).length) {
          return null;
        }
        if (parseOptions.isIslamic) {
          var dobj = {};
          var tYear = parsedDateParts.year;
          var tDate = parsedDateParts.day;
          var tMonth = parsedDateParts.month;
          var ystrig = tYear ? tYear + "" : "";
          var is2DigitYear = ystrig.length === 2;
          if (!tYear || !tMonth || !tDate || is2DigitYear) {
            dobj = HijriParser.getHijriDate(/* @__PURE__ */ new Date());
          }
          if (is2DigitYear) {
            tYear = parseInt((dobj.year + "").slice(0, 2) + ystrig, 10);
          }
          var dateObject = HijriParser.toGregorian(tYear || dobj.year, tMonth || dobj.month, tDate || dobj.date);
          parsedDateParts.year = dateObject.getFullYear();
          parsedDateParts.month = dateObject.getMonth() + 1;
          parsedDateParts.day = dateObject.getDate();
        }
        return _this.getDateObject(parsedDateParts);
      };
    };
    DateParser2.getDateObject = function(options, value) {
      var res = value || /* @__PURE__ */ new Date();
      res.setMilliseconds(0);
      var tKeys = ["hour", "minute", "second", "milliseconds", "month", "day"];
      var y = options.year;
      var desig = options.designator;
      var tzone = options.timeZone;
      if (!isUndefined(y)) {
        var len = (y + "").length;
        if (len <= 2) {
          var century = Math.floor(res.getFullYear() / 100) * 100;
          y += century;
        }
        res.setFullYear(y);
      }
      for (var _i = 0, tKeys_1 = tKeys; _i < tKeys_1.length; _i++) {
        var key = tKeys_1[_i];
        var tValue = options["" + key];
        if (isUndefined(tValue) && key === "day") {
          res.setDate(1);
        }
        if (!isUndefined(tValue)) {
          if (key === "month") {
            tValue -= 1;
            if (tValue < 0 || tValue > 11) {
              return /* @__PURE__ */ new Date("invalid");
            }
            var pDate = res.getDate();
            res.setDate(1);
            res[timeSetter2["" + key]](tValue);
            var lDate = new Date(res.getFullYear(), tValue + 1, 0).getDate();
            res.setDate(pDate < lDate ? pDate : lDate);
          } else {
            if (key === "day") {
              var lastDay = new Date(res.getFullYear(), res.getMonth() + 1, 0).getDate();
              if (tValue < 1 || tValue > lastDay) {
                return null;
              }
            }
            res["" + timeSetter2["" + key]](tValue);
          }
        }
      }
      if (!isUndefined(desig)) {
        var hour = res.getHours();
        if (desig === "pm") {
          res.setHours(hour + (hour === 12 ? 0 : 12));
        } else if (hour === 12) {
          res.setHours(0);
        }
      }
      if (!isUndefined(tzone)) {
        var tzValue = tzone - res.getTimezoneOffset();
        if (tzValue !== 0) {
          res.setMinutes(res.getMinutes() + tzValue);
        }
      }
      return res;
    };
    DateParser2.internalDateParse = function(value, parseOptions, num) {
      var matches2 = value.match(parseOptions.parserRegex);
      var retOptions = { "hour": 0, "minute": 0, "second": 0 };
      if (isNullOrUndefined(matches2)) {
        return null;
      } else {
        var props = Object.keys(parseOptions.evalposition);
        for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
          var prop = props_1[_i];
          var curObject = parseOptions.evalposition["" + prop];
          var matchString = matches2[curObject.pos];
          if (curObject.isNumber) {
            retOptions["" + prop] = this.internalNumberParser(matchString, num);
          } else {
            if (prop === "timeZone" && !isUndefined(matchString)) {
              var pos = curObject.pos;
              var val = void 0;
              var tmatch = matches2[pos + 1];
              var flag = !isUndefined(tmatch);
              if (curObject.hourOnly) {
                val = this.getZoneValue(flag, tmatch, matches2[pos + 4], num) * 60;
              } else {
                val = this.getZoneValue(flag, tmatch, matches2[pos + 7], num) * 60;
                val += this.getZoneValue(flag, matches2[pos + 4], matches2[pos + 10], num);
              }
              if (!isNullOrUndefined(val)) {
                retOptions["" + prop] = val;
              }
            } else {
              var cultureOptions = ["en-US", "en-MH", "en-MP"];
              matchString = prop === "month" && !parseOptions.isIslamic && (parseOptions.culture === "en" || parseOptions.culture === "en-GB" || parseOptions.culture === "en-US") ? matchString[0].toUpperCase() + matchString.substring(1).toLowerCase() : matchString;
              matchString = prop !== "month" && prop === "designator" && parseOptions.culture && parseOptions.culture.indexOf("en-") !== -1 && cultureOptions.indexOf(parseOptions.culture) === -1 ? matchString.toLowerCase() : matchString;
              retOptions["" + prop] = parseOptions["" + prop]["" + matchString];
            }
          }
        }
        if (parseOptions.hour12) {
          retOptions.hour12 = true;
        }
      }
      return retOptions;
    };
    DateParser2.internalNumberParser = function(value, option) {
      value = ParserBase.convertValueParts(value, option.numberParseRegex, option.numericPair);
      if (latnRegex.test(value)) {
        return +value;
      }
      return null;
    };
    DateParser2.parseTimeZoneRegx = function(hourFormat, tZone, nRegex) {
      var pattern = tZone.gmtFormat;
      var ret;
      var cRegex = "(" + nRegex + ")(" + nRegex + ")";
      ret = hourFormat.replace("+", "\\+");
      if (hourFormat.indexOf("HH") !== -1) {
        ret = ret.replace(/HH|mm/g, "(" + cRegex + ")");
      } else {
        ret = ret.replace(/H|m/g, "(" + cRegex + "?)");
      }
      var splitStr = ret.split(";").map(function(str) {
        return pattern.replace("{0}", str);
      });
      ret = splitStr.join("|") + "|" + tZone.gmtZeroFormat;
      return ret;
    };
    DateParser2.getZoneValue = function(flag, val1, val2, num) {
      var ival = flag ? val1 : val2;
      if (!ival) {
        return 0;
      }
      var value = this.internalNumberParser(ival, num);
      if (flag) {
        return -value;
      }
      return value;
    };
    return DateParser2;
  })()
);

// node_modules/@syncfusion/ej2-base/src/intl/number-parser.js
var regExp2 = RegExp;
var parseRegex = new regExp2("^([^0-9]*)(([0-9,]*[0-9]+)(.[0-9]+)?)([Ee][+-]?[0-9]+)?([^0-9]*)$");
var groupRegex = /,/g;
var keys = ["minusSign", "infinity"];
var NumberParser = (
  /** @class */
  (function() {
    function NumberParser2() {
    }
    NumberParser2.numberParser = function(culture, option, cldr) {
      var _this = this;
      var dependable = IntlBase.getDependables(cldr, culture, "", true);
      var parseOptions = { custom: true };
      if (IntlBase.formatRegex.test(option.format) || !option.format) {
        extend(parseOptions, IntlBase.getProperNumericSkeleton(option.format || "N"));
        parseOptions.custom = false;
        if (!parseOptions.fractionDigits) {
          if (option.maximumFractionDigits) {
            parseOptions.maximumFractionDigits = option.maximumFractionDigits;
          }
        }
      } else {
        extend(parseOptions, IntlBase.customFormat(option.format, null, null));
      }
      var numbers = getValue("numbers", dependable.parserObject);
      var numOptions = ParserBase.getCurrentNumericOptions(dependable.parserObject, ParserBase.getNumberingSystem(cldr), true, isBlazor());
      parseOptions.symbolRegex = ParserBase.getSymbolRegex(Object.keys(numOptions.symbolMatch));
      parseOptions.infinity = numOptions.symbolNumberSystem[keys[1]];
      var symbolpattern;
      if (!isBlazor()) {
        symbolpattern = IntlBase.getSymbolPattern(parseOptions.type, numOptions.numberSystem, dependable.numericObject, parseOptions.isAccount);
        if (symbolpattern) {
          symbolpattern = symbolpattern.replace(/\u00A4/g, IntlBase.defaultCurrency);
          var split = symbolpattern.split(";");
          parseOptions.nData = IntlBase.getFormatData(split[1] || "-" + split[0], true, "");
          parseOptions.pData = IntlBase.getFormatData(split[0], true, "");
        }
      } else {
        parseOptions.nData = extend({}, {}, getValue(parseOptions.type + "nData", numbers));
        parseOptions.pData = extend({}, {}, getValue(parseOptions.type + "pData", numbers));
        if (parseOptions.type === "currency" && option.currency) {
          IntlBase.replaceBlazorCurrency([parseOptions.pData, parseOptions.nData], getValue("currencySymbol", numbers), option.currency);
        }
      }
      return function(value) {
        return _this.getParsedNumber(value, parseOptions, numOptions);
      };
    };
    NumberParser2.getParsedNumber = function(value, options, numOptions) {
      var isNegative;
      var isPercent;
      var tempValue;
      var lead;
      var end;
      var ret;
      if (value.indexOf(options.infinity) !== -1) {
        return Infinity;
      } else {
        value = ParserBase.convertValueParts(value, options.symbolRegex, numOptions.symbolMatch);
        value = ParserBase.convertValueParts(value, numOptions.numberParseRegex, numOptions.numericPair);
        value = value.indexOf("-") !== -1 ? value.replace("-.", "-0.") : value;
        if (value.indexOf(".") === 0) {
          value = "0" + value;
        }
        var matches2 = value.match(parseRegex);
        if (isNullOrUndefined(matches2)) {
          return NaN;
        }
        lead = matches2[1];
        tempValue = matches2[2];
        var exponent = matches2[5];
        end = matches2[6];
        isNegative = options.custom ? lead === options.nData.nlead && end === options.nData.nend : lead.indexOf(options.nData.nlead) !== -1 && end.indexOf(options.nData.nend) !== -1;
        isPercent = isNegative ? options.nData.isPercent : options.pData.isPercent;
        tempValue = tempValue.replace(groupRegex, "");
        if (exponent) {
          tempValue += exponent;
        }
        ret = +tempValue;
        if (options.type === "percent" || isPercent) {
          ret = ret / 100;
        }
        if (options.custom || options.fractionDigits) {
          ret = parseFloat(ret.toFixed(options.custom ? isNegative ? options.nData.maximumFractionDigits : options.pData.maximumFractionDigits : options.fractionDigits));
        }
        if (options.maximumFractionDigits) {
          ret = this.convertMaxFracDigits(tempValue, options, ret, isNegative);
        }
        if (isNegative) {
          ret *= -1;
        }
        return ret;
      }
    };
    NumberParser2.convertMaxFracDigits = function(value, options, ret, isNegative) {
      var decimalSplitValue = value.split(".");
      if (decimalSplitValue[1] && decimalSplitValue[1].length > options.maximumFractionDigits) {
        ret = +ret.toFixed(options.custom ? isNegative ? options.nData.maximumFractionDigits : options.pData.maximumFractionDigits : options.maximumFractionDigits);
      }
      return ret;
    };
    return NumberParser2;
  })()
);

// node_modules/@syncfusion/ej2-base/src/internationalization.js
var onIntlChange = new Observer();
var rightToLeft = false;
var cldrData = {};
var defaultCulture = "en-US";
var Internationalization = (
  /** @class */
  (function() {
    function Internationalization2(cultureName) {
      if (cultureName) {
        this.culture = cultureName;
      }
    }
    Internationalization2.prototype.getDateFormat = function(options) {
      return DateFormat2.dateFormat(this.getCulture(), options || { type: "date", skeleton: "short" }, cldrData);
    };
    Internationalization2.prototype.getNumberFormat = function(options) {
      if (options && !options.currency) {
        options.currency = defaultCurrencyCode;
      }
      if (isBlazor() && options && !options.format) {
        options.minimumFractionDigits = 0;
      }
      return NumberFormat2.numberFormatter(this.getCulture(), options || {}, cldrData);
    };
    Internationalization2.prototype.getDateParser = function(options) {
      return DateParser.dateParser(this.getCulture(), options || { skeleton: "short", type: "date" }, cldrData);
    };
    Internationalization2.prototype.getNumberParser = function(options) {
      if (isBlazor() && options && !options.format) {
        options.minimumFractionDigits = 0;
      }
      return NumberParser.numberParser(this.getCulture(), options || { format: "N" }, cldrData);
    };
    Internationalization2.prototype.formatNumber = function(value, option) {
      return this.getNumberFormat(option)(value);
    };
    Internationalization2.prototype.formatDate = function(value, option) {
      return this.getDateFormat(option)(value);
    };
    Internationalization2.prototype.parseDate = function(value, option) {
      return this.getDateParser(option)(value);
    };
    Internationalization2.prototype.parseNumber = function(value, option) {
      return this.getNumberParser(option)(value);
    };
    Internationalization2.prototype.getDatePattern = function(option, isExcelFormat) {
      return IntlBase.getActualDateTimeFormat(this.getCulture(), option, cldrData, isExcelFormat);
    };
    Internationalization2.prototype.getNumberPattern = function(option, isExcel) {
      return IntlBase.getActualNumberFormat(this.getCulture(), option, cldrData, isExcel);
    };
    Internationalization2.prototype.getFirstDayOfWeek = function() {
      return IntlBase.getWeekData(this.getCulture(), cldrData);
    };
    Internationalization2.prototype.getCulture = function() {
      return this.culture || defaultCulture;
    };
    return Internationalization2;
  })()
);

// node_modules/@syncfusion/ej2-base/src/validate-lic.js
var componentList = ["grid", "pivotview", "treegrid", "spreadsheet", "rangeNavigator", "DocumentEditor", "listbox", "inplaceeditor", "PdfViewer", "richtexteditor", "DashboardLayout", "chart", "stockChart", "circulargauge", "diagram", "heatmap", "lineargauge", "maps", "slider", "smithchart", "barcode", "sparkline", "treemap", "bulletChart", "kanban", "daterangepicker", "schedule", "gantt", "signature", "query-builder", "drop-down-tree", "carousel", "filemanager", "uploader", "accordion", "tab", "treeview"];
var bypassKey = [
  115,
  121,
  110,
  99,
  102,
  117,
  115,
  105,
  111,
  110,
  46,
  105,
  115,
  76,
  105,
  99,
  86,
  97,
  108,
  105,
  100,
  97,
  116,
  101,
  100
];
var accountURL;
var LicenseValidator = (
  /** @class */
  (function() {
    function LicenseValidator2(key) {
      this.isValidated = false;
      this.isLicensed = true;
      this.version = "30";
      this.platform = /JavaScript|ASPNET|ASPNETCORE|ASPNETMVC|FileFormats|essentialstudio/i;
      this.errors = {
        noLicense: "<span>This application was built using a trial version of Syncfusion<sup>®</sup> Essential Studio<sup>®</sup>. To remove the license validation message permanently, a valid license key must be included.</span>",
        trailExpired: "<span>This application was built using a trial version of Syncfusion<sup>®</sup> Essential Studio<sup>®</sup>. To remove the license validation message permanently, a valid license key must be included.</span>",
        versionMismatched: "<span>The included Syncfusion<sup>®</sup> license key is invalid.</span>",
        platformMismatched: "<span>The included Syncfusion<sup>®</sup> license key is invalid.</span>",
        invalidKey: "<span>The included Syncfusion<sup>®</sup> license key is invalid.</span>"
      };
      this.minVersion = null;
      this.manager = /* @__PURE__ */ (function() {
        var licKey = null;
        function set(key2) {
          licKey = key2;
        }
        function get() {
          return licKey;
        }
        return {
          setKey: set,
          getKey: get
        };
      })();
      this.npxManager = /* @__PURE__ */ (function() {
        var npxLicKey = "npxKeyReplace";
        function get() {
          return npxLicKey;
        }
        return {
          getKey: get
        };
      })();
      this.manager.setKey(key);
    }
    LicenseValidator2.prototype.validate = function() {
      var contentKey = [
        115,
        121,
        110,
        99,
        102,
        117,
        115,
        105,
        111,
        110,
        46,
        108,
        105,
        99,
        101,
        110,
        115,
        101,
        67,
        111,
        110,
        116,
        101,
        110,
        116
      ];
      var URLKey = [
        115,
        121,
        110,
        99,
        102,
        117,
        115,
        105,
        111,
        110,
        46,
        99,
        108,
        97,
        105,
        109,
        65,
        99,
        99,
        111,
        117,
        110,
        116,
        85,
        82,
        76
      ];
      if (!this.isValidated && (containerObject && !getValue(convertToChar(bypassKey), containerObject) && !getValue("Blazor", containerObject))) {
        var validateMsg = void 0;
        var validateURL = void 0;
        if (this.manager && this.manager.getKey() || this.npxManager && this.npxManager.getKey() !== "npxKeyReplace") {
          var result = this.getInfoFromKey();
          if (result && result.length) {
            for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
              var res = result_1[_i];
              if (!this.platform.test(res.platform) || res.invalidPlatform) {
                validateMsg = this.errors.platformMismatched;
              } else {
                if (res.minVersion >= res.lastValue && res.minVersion !== res.lastValue || res.lastValue < parseInt(this.version, 10)) {
                  validateMsg = this.errors.versionMismatched;
                  validateMsg = validateMsg.replace("##LicenseVersion", res.version);
                  validateMsg = validateMsg.replace("##Requireversion", this.version + ".x");
                } else {
                  if (res.lastValue == null || isNaN(res.lastValue)) {
                    validateMsg = this.errors.versionMismatched;
                    validateMsg = validateMsg.replace("##LicenseVersion", res.version);
                    validateMsg = validateMsg.replace("##Requireversion", this.version + ".x");
                  }
                }
                if (res.expiryDate) {
                  var expDate = new Date(res.expiryDate);
                  var currDate = /* @__PURE__ */ new Date();
                  if (expDate !== currDate && expDate < currDate) {
                    validateMsg = this.errors.trailExpired;
                  } else {
                    break;
                  }
                }
              }
            }
          } else {
            validateMsg = this.errors.invalidKey;
          }
        } else {
          var licenseContent = getValue(convertToChar(contentKey), containerObject);
          validateURL = getValue(convertToChar(URLKey), containerObject);
          if (licenseContent && licenseContent !== "") {
            validateMsg = licenseContent;
          } else {
            validateMsg = this.errors.noLicense;
          }
        }
        if (validateMsg && typeof document !== "undefined" && !isNullOrUndefined(document)) {
          accountURL = validateURL && validateURL !== "" ? validateURL : "https://www.syncfusion.com/account/claim-license-key?pl=SmF2YVNjcmlwdA==&vs=MzA=&utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information";
          var errorDiv = createElement("div", {
            innerHTML: `<img src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzE5OV80KSI+CjxwYXRoIGQ9Ik0xMiAyMUMxNi45NzA2IDIxIDIxIDE2Ljk3MDYgMjEgMTJDMjEgNy4wMjk0NCAxNi45NzA2IDMgMTIgM0M3LjAyOTQ0IDMgMyA3LjAyOTQ0IDMgMTJDMyAxNi45NzA2IDcuMDI5NDQgMjEgMTIgMjFaIiBzdHJva2U9IiM3MzczNzMiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0xMS4yNSAxMS4yNUgxMlYxNi41SDEyLjc1IiBmaWxsPSIjNjE2MDYzIi8+CjxwYXRoIGQ9Ik0xMS4yNSAxMS4yNUgxMlYxNi41SDEyLjc1IiBzdHJva2U9IiM3MzczNzMiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+CjxwYXRoIGQ9Ik0xMS44MTI1IDlDMTIuNDMzOCA5IDEyLjkzNzUgOC40OTYzMiAxMi45Mzc1IDcuODc1QzEyLjkzNzUgNy4yNTM2OCAxMi40MzM4IDYuNzUgMTEuODEyNSA2Ljc1QzExLjE5MTIgNi43NSAxMC42ODc1IDcuMjUzNjggMTAuNjg3NSA3Ljg3NUMxMC42ODc1IDguNDk2MzIgMTEuMTkxMiA5IDExLjgxMjUgOVoiIGZpbGw9IiM3MzczNzMiLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8xOTlfNCI+CjxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K' style="top: 6px;
                    position: absolute;
                    left: 16px;
                    width: 24px;
                    height: 24px;"/>` + validateMsg + ' <a style="text-decoration: none;color: #0D6EFD;font-weight: 500;" href=' + accountURL + ">Claim your free account</a>"
          });
          errorDiv.setAttribute("style", "position: fixed;\n                top: 10px;\n                left: 10px;\n                right: 10px;\n                font-size: 14px;\n                background: #EEF2FF;\n                color: #222222;\n                z-index: 999999999;\n                text-align: left;\n                border: 1px solid #EEEEEE;\n                padding: 10px 11px 10px 50px;\n                border-radius: 8px;\n                font-family: Helvetica Neue, Helvetica, Arial;");
          document.body.appendChild(errorDiv);
          this.isLicensed = false;
        }
        this.isValidated = true;
        setValue(convertToChar(bypassKey), this.isValidated, containerObject);
      }
      return this.isLicensed;
    };
    LicenseValidator2.prototype.getDecryptedData = function(key) {
      try {
        return atob(key);
      } catch (error) {
        return "";
      }
    };
    LicenseValidator2.prototype.getInfoFromKey = function() {
      try {
        var licKey = "";
        var pkey = [
          5439488,
          7929856,
          5111808,
          6488064,
          4587520,
          7667712,
          5439488,
          6881280,
          5177344,
          7208960,
          4194304,
          4456448,
          6619136,
          7733248,
          5242880,
          7077888,
          6356992,
          7602176,
          4587520,
          7274496,
          7471104,
          7143424
        ];
        var decryptedStr = [];
        var resultArray = [];
        var invalidPlatform = false;
        var isNpxKey = false;
        if (this.manager.getKey()) {
          licKey = this.manager.getKey();
        } else {
          isNpxKey = true;
          licKey = this.npxManager.getKey().split("npxKeyReplace")[1];
        }
        var licKeySplit = licKey.split(";");
        for (var _i = 0, licKeySplit_1 = licKeySplit; _i < licKeySplit_1.length; _i++) {
          var lKey = licKeySplit_1[_i];
          var decodeStr = this.getDecryptedData(lKey);
          if (!decodeStr) {
            continue;
          }
          var k = 0;
          var buffr = "";
          if (!isNpxKey) {
            for (var i = 0; i < decodeStr.length; i++, k++) {
              if (k === pkey.length) {
                k = 0;
              }
              var c = decodeStr.charCodeAt(i);
              buffr += String.fromCharCode(c ^ pkey[parseInt(k.toString(), 10)] >> 16);
            }
          } else {
            var charKey = decodeStr[decodeStr.length - 1];
            var decryptedKey = [];
            for (var i = 0; i < decodeStr.length; i++) {
              decryptedKey[parseInt(i.toString(), 10)] = decodeStr[parseInt(i.toString(), 10)].charCodeAt(0) - charKey.charCodeAt(0);
            }
            for (var i = 0; i < decryptedKey.length; i++) {
              buffr += String.fromCharCode(decryptedKey[parseInt(i.toString(), 10)]);
            }
          }
          if (this.platform.test(buffr)) {
            decryptedStr = buffr.split(";");
            invalidPlatform = false;
            if (decryptedStr.length > 3) {
              var minVersion = parseInt(decryptedStr[1].split(".")[0], 10);
              var lastValue = parseInt(decryptedStr[4], 10);
              resultArray.push({
                platform: decryptedStr[0],
                version: decryptedStr[1],
                expiryDate: decryptedStr[2],
                lastValue,
                minVersion
              });
            }
          } else if (buffr && buffr.split(";").length > 3) {
            invalidPlatform = true;
          }
        }
        if (invalidPlatform && !resultArray.length) {
          return [{ invalidPlatform }];
        } else {
          return resultArray.length ? resultArray : null;
        }
      } catch (error) {
        return null;
      }
    };
    return LicenseValidator2;
  })()
);
var licenseValidator = new LicenseValidator();
function convertToChar(cArr) {
  var ret = "";
  for (var _i = 0, cArr_1 = cArr; _i < cArr_1.length; _i++) {
    var arr = cArr_1[_i];
    ret += String.fromCharCode(arr);
  }
  return ret;
}
function registerLicense(key) {
  licenseValidator = new LicenseValidator(key);
}
var validateLicense = function(key) {
  if (key) {
    registerLicense(key);
  }
  return licenseValidator.validate();
};
var createLicenseOverlay = function() {
  var bannerTemplate = '\n    <div style="\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: rgba(0, 0, 0, 0.5);\n    z-index: 99999;\n    ">\n        <div style="\n    background: #FFFFFF;\n    height: 455px;\n    width: 840px;\n    font-family: Helvetica Neue, Helvetica, Arial;\n    color: #000000;\n    box-shadow: 0px 4.8px 14.4px rgb(0 0 0 / 18%), 0px 25.6px 57.6px rgb(0 0 0 / 22%);\n    display: block;\n    margin: 8% auto;\n    border-radius: 20px;\n    ">\n            <div style="\n    position: absolute;\nwidth: 838px;\nheight: 62px;\nbackground-color: #F9F9F9;\nborder: 1px solid #EEEEEE;\nborder-top-left-radius: 20px;\nborder-top-right-radius: 20px;\n">\n                <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQ2IiBoZWlnaHQ9IjMyIiB2aWV3Qm94PSIwIDAgMTQ2IDMyIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNNDAuNTk2NSAxNS4wMDc4SDMyLjQyNUMzMS41NTU3IDE1LjAwNzggMzAuOTAzNyAxNS4xODEyIDMwLjUxMjUgMTUuNDg0NkMzMC4xMjEzIDE1LjgzMTQgMjkuOTA0IDE2LjMwODIgMjkuOTA0IDE3LjA0NTFDMjkuOTA0IDE3LjYwODYgMzAuMDc3OCAxOC4wNDIxIDMwLjQyNTYgMTguMzAyMkMzMC43NzMzIDE4LjYwNTYgMzEuMjk0OSAxOC43MzU2IDMxLjk5MDMgMTguNzM1NkgzNi4zMzY5QzM4LjExODkgMTguNzM1NiAzOS40MjI5IDE5LjA4MjQgNDAuMTYxOCAxOS43MzI2QzQwLjk0NDIgMjAuNDI2MiA0MS4yOTE5IDIxLjU1MzIgNDEuMjkxOSAyMy4xMTM3QzQxLjI5MTkgMjQuNzE3NiA0MC44NTcyIDI1Ljg4OCAzOS45ODc5IDI2LjY2ODJDMzkuMTE4NiAyNy40MDUxIDM3LjcyNzcgMjcuNzk1MyAzNS44NTg3IDI3Ljc5NTNIMjcuMDc4N1YyNS4wMjFIMzUuMzM3MkMzNi4yOTM0IDI1LjAyMSAzNi45NDU0IDI0Ljg5MSAzNy4zMzY2IDI0LjYzMDlDMzcuNzI3NyAyNC4zNzA4IDM3LjkwMTYgMjMuODk0IDM3LjkwMTYgMjMuMjg3MUMzNy45MDE2IDIyLjYzNjkgMzcuNzI3NyAyMi4xNjAxIDM3LjM4IDIxLjlDMzcuMDMyMyAyMS42Mzk5IDM2LjQyMzggMjEuNDY2NSAzNS41NTQ1IDIxLjQ2NjVIMzEuNjQyNkMyOS44NjA1IDIxLjQ2NjUgMjguNTEzMSAyMS4xMTk4IDI3LjY4NzMgMjAuMzgyOEMyNi44NjE0IDE5LjY0NTkgMjYuNDI2OCAxOC41MTg5IDI2LjQyNjggMTcuMDAxN0MyNi40MjY4IDE1LjM1NDUgMjYuODYxNCAxNC4xNDA4IDI3LjczMDcgMTMuMzYwNkMyOC42IDEyLjU4MDMgMjkuOTkwOSAxMi4yMzM1IDMxLjkwMzQgMTIuMjMzNUg0MC41OTY1VjE1LjAwNzhaIiBmaWxsPSIjMzU0M0E4Ii8+CjxwYXRoIGQ9Ik00OC4wNzI3IDI1LjI4MTFINTAuNTA2OFYxNi4zOTQ5SDUzLjU0OTNWMjcuNTM1MkM1My41NDkzIDI5LjA1MjQgNTMuMjAxNiAzMC4xNzk0IDUyLjUwNjIgMzAuOTE2M0M1MS44MTA3IDMxLjY1MzIgNTAuNzI0MSAzMiA0OS4yNDYzIDMySDQzLjMzNVYyOS42NTkySDQ4LjcyNDdDNDkuMjg5NyAyOS42NTkyIDQ5Ljc2NzkgMjkuNTI5MiA1MC4wNzIxIDI5LjIyNThDNTAuMzc2NCAyOC45NjU3IDUwLjU1MDIgMjguNTMyMiA1MC41NTAyIDI4LjAxMlYyNy44Mzg2SDQ3Ljg5ODlDNDYuMjAzNyAyNy44Mzg2IDQ0Ljk0MzIgMjcuNDkxOSA0NC4yNDc4IDI2Ljg0MTZDNDMuNTA4OSAyNi4xNDgxIDQzLjE2MTEgMjUuMDY0NCA0My4xNjExIDIzLjQ2MDVWMTYuMzk0OUg0Ni4xNjAyVjIzLjIwMDVDNDYuMTYwMiAyNC4wNjc0IDQ2LjI5MDYgMjQuNjMwOSA0Ni41NTE0IDI0Ljg5MUM0Ni43MjUzIDI1LjE1MTEgNDcuMjQ2OSAyNS4yODExIDQ4LjA3MjcgMjUuMjgxMVoiIGZpbGw9IiMzNTQzQTgiLz4KPHBhdGggZD0iTTU1Ljg5NjUgMTYuMzk0OUg2MS41OTA0QzYzLjMyOTEgMTYuMzk0OSA2NC41NDYxIDE2LjY5ODMgNjUuMjg1IDE3LjM0ODVDNjYuMDIzOSAxNy45OTg4IDY2LjM3MTYgMTkuMDgyNCA2Ni4zNzE2IDIwLjU1NjNWMjcuNzk1M0g2My4zMjkxVjIwLjk0NjRDNjMuMzI5MSAyMC4wNzk0IDYzLjE5ODcgMTkuNTE1OSA2Mi45Mzc5IDE5LjI5OTJDNjIuNjc3MSAxOS4wMzkxIDYyLjE1NTUgMTguOTA5MSA2MS4zMjk3IDE4LjkwOTFINTguODk1NlYyNy44Mzg2SDU1Ljg1M1YxNi4zOTQ5SDU1Ljg5NjVaIiBmaWxsPSIjMzU0M0E4Ii8+CjxwYXRoIGQ9Ik03NC45MzQyIDI1LjM2NzhINzguMTUwNlYyNy43OTUySDc0LjAyMTRDNzIuOTc4MiAyNy43OTUyIDcyLjEwODkgMjcuNjY1MiA3MS40NTcgMjcuNDkxOEM3MC44MDUgMjcuMjc1IDcwLjE5NjUgMjYuOTI4MyA2OS43MTgzIDI2LjQ1MTRDNjkuMTk2OCAyNS45MzEzIDY4Ljc2MjEgMjUuMjgxMSA2OC40NTc4IDI0LjU0NDJDNjguMTUzNiAyMy44MDcyIDY4LjAyMzIgMjIuOTgzNiA2OC4wMjMyIDIyLjE2QzY4LjAyMzIgMjEuMjkzMSA2OC4xNTM2IDIwLjQ2OTUgNjguNDU3OCAxOS42ODkyQzY4Ljc2MjEgMTguOTA5IDY5LjE1MzMgMTguMzAyMSA2OS43MTgzIDE3Ljc4MTlDNzAuMjM5OSAxNy4zMDUxIDcwLjgwNSAxNi45NTgzIDcxLjUwMDQgMTYuNzQxNkM3Mi4xOTU5IDE2LjUyNDkgNzMuMDIxNyAxNi40MzgyIDc0LjA2NDkgMTYuNDM4Mkg3OC4xOTQxVjE4LjkwOUg3NC45MzQyQzczLjQ5OTggMTguOTA5IDcyLjU0MzYgMTkuMTY5MSA3MS45Nzg1IDE5LjY0NTlDNzEuNDU2OSAyMC4xMjI3IDcxLjE1MjcgMjAuOTg5NyA3MS4xNTI3IDIyLjIwMzRDNzEuMTUyNyAyMi44OTY5IDcxLjI4MzEgMjMuNDYwNSA3MS41MDA0IDIzLjkzNzNDNzEuNzE3NyAyNC40MTQxIDcyLjA2NTUgMjQuNzYwOSA3Mi41MDAxIDI1LjA2NDNDNzIuNzE3NCAyNS4xOTQ0IDcyLjk3ODIgMjUuMjgxMSA3My4yODI1IDI1LjM2NzhDNzMuNjMwMiAyNS4zMjQ0IDc0LjE1MTggMjUuMzY3OCA3NC45MzQyIDI1LjM2NzhaIiBmaWxsPSIjMzU0M0E4Ii8+CjxwYXRoIGQ9Ik04MC44NDU2IDE4LjY0ODlINzguNjcyNFYxNi4zNTE1SDgwLjg0NTZWMTUuMTgxMUM4MC44NDU2IDE0LjAxMDggODEuMDYzIDEzLjIzMDUgODEuNDk3NiAxMi44NDA0QzgxLjkzMjMgMTIuNDUwMyA4Mi43NTgxIDEyLjIzMzUgODMuOTc1MSAxMi4yMzM1SDg2Ljg0MzhWMTQuNDAwOUg4NS40MDk1Qzg0Ljg4NzkgMTQuNDAwOSA4NC41NDAyIDE0LjQ4NzYgODQuMzIyOSAxNC42NjFDODQuMTA1NSAxNC44MzQ0IDgzLjk3NTEgMTUuMDk0NSA4My45NzUxIDE1LjQ0MTJWMTYuMzUxNUg4Ni44NDM4VjE4LjY0ODlIODMuOTc1MVYyNy43OTUzSDgwLjg0NTZWMTguNjQ4OVoiIGZpbGw9IiMzNTQzQTgiLz4KPHBhdGggZD0iTTk4LjQwNTYgMjcuNzk1M0g5Mi43MTE2QzkxLjAxNjUgMjcuNzk1MyA4OS44NDI5IDI3LjQ0ODUgODkuMDYwNSAyNi43OTgzQzg4LjMyMTYgMjYuMTQ4MSA4Ny45MzA0IDI1LjA2NDQgODcuOTMwNCAyMy41OTA2VjE2LjM5NDlIOTAuOTI5NVYyMy40MTcyQzkwLjkyOTUgMjQuMTk3NCA5MS4wNTk5IDI0LjY3NDMgOTEuMzIwNyAyNC45MzQ0QzkxLjU4MTUgMjUuMTk0NCA5Mi4xMDMxIDI1LjMyNDUgOTIuOTI4OSAyNS4zMjQ1SDk1LjM2M1YxNi4zOTQ5SDk4LjQwNTZWMjcuNzk1M1oiIGZpbGw9IiMzNTQzQTgiLz4KPHBhdGggZD0iTTEwMC42MjIgMjUuNDExMkgxMDcuMDExQzEwNy41NzcgMjUuNDExMiAxMDguMDExIDI1LjMyNDUgMTA4LjI3MiAyNS4xNTExQzEwOC41MzMgMjQuOTc3NyAxMDguNjYzIDI0LjY3NDMgMTA4LjY2MyAyNC4zMjc1QzEwOC42NjMgMjMuOTM3NCAxMDguNTMzIDIzLjY3NzMgMTA4LjI3MiAyMy40NjA1QzEwOC4wMTEgMjMuMjg3MSAxMDcuNTc3IDIzLjIwMDUgMTA3LjA1NSAyMy4yMDA1SDEwNC40NDdDMTAyLjg4MiAyMy4yMDA1IDEwMS44MzkgMjIuOTgzNyAxMDEuMzE4IDIyLjUwNjlDMTAwLjc1MiAyMi4wMzAxIDEwMC40OTIgMjEuMjA2NSAxMDAuNDkyIDE5Ljk5MjdDMTAwLjQ5MiAxOC43NzkgMTAwLjgzOSAxNy44Njg3IDEwMS40OTEgMTcuMjYxOEMxMDIuMTQzIDE2LjY5ODMgMTAzLjE4NyAxNi4zOTQ5IDEwNC41MzQgMTYuMzk0OUgxMTEuMDU0VjE4Ljc3OUgxMDUuNzA4QzEwNC44MzggMTguNzc5IDEwNC4yNzMgMTguODY1NyAxMDQuMDEyIDE4Ljk5NTdDMTAzLjc1MiAxOS4xNjkxIDEwMy42MjEgMTkuNDI5MiAxMDMuNjIxIDE5LjgxOTRDMTAzLjYyMSAyMC4xNjYxIDEwMy43NTIgMjAuNDI2MiAxMDMuOTY5IDIwLjU5OTZDMTA0LjE4NiAyMC43NzMgMTA0LjU3NyAyMC44NTk3IDEwNS4wNTYgMjAuODU5N0gxMDcuNzk0QzEwOS4wNTQgMjAuODU5NyAxMTAuMDExIDIxLjE2MzEgMTEwLjY2MyAyMS43MjY2QzExMS4zMTUgMjIuMjkwMiAxMTEuNjYyIDIzLjE1NzEgMTExLjY2MiAyNC4yNDA4QzExMS42NjIgMjUuMjgxMSAxMTEuMzU4IDI2LjE0ODEgMTEwLjc5MyAyNi43OTgzQzExMC4yMjggMjcuNDQ4NSAxMDkuNDQ2IDI3Ljc5NTMgMTA4LjUzMyAyNy43OTUzSDEwMC43MDlWMjUuNDExMkgxMDAuNjIyWiIgZmlsbD0iIzM1NDNBOCIvPgo8cGF0aCBkPSJNMTE2LjU3NCAxNS4wOTQ0SDExMy40MDFWMTIuMjc2OUgxMTYuNTc0VjE1LjA5NDRaTTExNi41NzQgMjcuNzk1M0gxMTMuNDAxVjE2LjM5NDlIMTE2LjU3NFYyNy43OTUzWiIgZmlsbD0iIzM1NDNBOCIvPgo8cGF0aCBkPSJNMTMwLjMwOSAyMi4xMTY3QzEzMC4zMDkgMjMuODkzOSAxMjkuNzQ0IDI1LjMyNDQgMTI4LjY1NyAyNi40MDgxQzEyNy41NzEgMjcuNDkxOCAxMjYuMDkzIDI4LjAxMiAxMjQuMjI0IDI4LjAxMkMxMjIuMzU1IDI4LjAxMiAxMjAuODc3IDI3LjQ5MTggMTE5Ljc5IDI2LjQwODFDMTE4LjcwNCAyNS4zMjQ0IDExOC4xMzkgMjMuODkzOSAxMTguMTM5IDIyLjExNjdDMTE4LjEzOSAyMC4zMzk0IDExOC43MDQgMTguOTA5IDExOS43OSAxNy44MjUzQzEyMC44NzcgMTYuNzQxNiAxMjIuMzk4IDE2LjIyMTQgMTI0LjIyNCAxNi4yMjE0QzEyNi4wNDkgMTYuMjIxNCAxMjcuNTI3IDE2Ljc0MTYgMTI4LjY1NyAxNy44MjUzQzEyOS43NDQgMTguODY1NiAxMzAuMzA5IDIwLjI5NjEgMTMwLjMwOSAyMi4xMTY3Wk0xMjEuMjY4IDIyLjExNjdDMTIxLjI2OCAyMy4yMDA0IDEyMS41MjkgMjQuMDY3MyAxMjIuMDUxIDI0LjY3NDJDMTIyLjU3MiAyNS4yODExIDEyMy4yNjggMjUuNTg0NSAxMjQuMTggMjUuNTg0NUMxMjUuMDkzIDI1LjU4NDUgMTI1Ljc4OSAyNS4yODExIDEyNi4zMSAyNC42NzQyQzEyNi44MzIgMjQuMDY3MyAxMjcuMDkzIDIzLjIwMDQgMTI3LjA5MyAyMi4xMTY3QzEyNy4wOTMgMjEuMDMzIDEyNi44MzIgMjAuMTY2MSAxMjYuMzEgMTkuNjAyNUMxMjUuNzg5IDE4Ljk5NTcgMTI1LjA5MyAxOC42OTIyIDEyNC4xMzcgMTguNjkyMkMxMjMuMjI0IDE4LjY5MjIgMTIyLjUyOSAxOC45OTU3IDEyMi4wMDcgMTkuNjAyNUMxMjEuNTI5IDIwLjE2NjEgMTIxLjI2OCAyMS4wMzMgMTIxLjI2OCAyMi4xMTY3WiIgZmlsbD0iIzM1NDNBOCIvPgo8cGF0aCBkPSJNMTMxLjc4NyAxNi4zOTQ5SDEzNy40ODFDMTM5LjIxOSAxNi4zOTQ5IDE0MC40MzYgMTYuNjk4MyAxNDEuMTc1IDE3LjM0ODVDMTQxLjkxNCAxNy45OTg4IDE0Mi4yNjIgMTkuMDgyNCAxNDIuMjYyIDIwLjU1NjNWMjcuNzk1M0gxMzkuMjE5VjIwLjk0NjRDMTM5LjIxOSAyMC4wNzk0IDEzOS4wODkgMTkuNTE1OSAxMzguODI4IDE5LjI5OTJDMTM4LjU2NyAxOS4wMzkxIDEzOC4wNDYgMTguOTA5MSAxMzcuMjIgMTguOTA5MUgxMzQuNzg2VjI3LjgzODZIMTMxLjc0M1YxNi4zOTQ5SDEzMS43ODdaIiBmaWxsPSIjMzU0M0E4Ii8+CjxwYXRoIGQ9Ik03LjEyODMxIDMuNzM3NDNIMFYxMC44NDY0SDcuMTI4MzFWMy43Mzc0M1oiIGZpbGw9IiMzNTQzQTgiLz4KPHBhdGggZD0iTTIzLjI1MTMgLTIuMTU3MjVlLTA1TDE4LjU1MTMgNS41MTY4NUwyNC4wODMxIDEwLjIwNDFMMjguNzgzMSA0LjY4NzI1TDIzLjI1MTMgLTIuMTU3MjVlLTA1WiIgZmlsbD0iI0ZGODYwMCIvPgo8cGF0aCBkPSJNMTUuNjA0MSAzLjczNzQzSDguNDc1ODNWMTAuODQ2NEgxNS42MDQxVjMuNzM3NDNaIiBmaWxsPSIjMzU0M0E4Ii8+CjxwYXRoIGQ9Ik03LjEyODMxIDEyLjE5MDJIMFYxOS4yOTkySDcuMTI4MzFWMTIuMTkwMloiIGZpbGw9IiMzNTQzQTgiLz4KPHBhdGggZD0iTTE1LjYwNDEgMTIuMTkwMkg4LjQ3NTgzVjE5LjI5OTJIMTUuNjA0MVYxMi4xOTAyWiIgZmlsbD0iIzM1NDNBOCIvPgo8cGF0aCBkPSJNMjQuMDc5NyAxMi4xOTAySDE2Ljk1MTRWMTkuMjk5MkgyNC4wNzk3VjEyLjE5MDJaIiBmaWxsPSIjRkY4NjAwIi8+CjxwYXRoIGQ9Ik03LjEyODMxIDIwLjY4NjNIMFYyNy43OTUzSDcuMTI4MzFWMjAuNjg2M1oiIGZpbGw9IiMzNTQzQTgiLz4KPHBhdGggZD0iTTE1LjYwNDEgMjAuNjg2M0g4LjQ3NTgzVjI3Ljc5NTNIMTUuNjA0MVYyMC42ODYzWiIgZmlsbD0iIzM1NDNBOCIvPgo8cGF0aCBkPSJNMjQuMTIzMiAyMC42ODYzSDE2Ljk5NDlWMjcuNzk1M0gyNC4xMjMyVjIwLjY4NjNaIiBmaWxsPSIjMzU0M0E4Ii8+CjxwYXRoIGQ9Ik0xNDYgMTUuODMxM0MxNDYgMTYuODcxNyAxNDUuMTc0IDE3LjY5NTMgMTQ0LjEzMSAxNy42OTUzQzE0My4wODggMTcuNjk1MyAxNDIuMjYyIDE2Ljg3MTcgMTQyLjI2MiAxNS44MzEzQzE0Mi4yNjIgMTQuNzkxIDE0My4wODggMTQuMDEwNyAxNDQuMTMxIDE0LjAxMDdDMTQ1LjEzMSAxMy45Njc0IDE0NiAxNC43OTEgMTQ2IDE1LjgzMTNaTTE0Mi45NTcgMTQuNzkxQzE0Mi42OTcgMTUuMDUxMSAxNDIuNTY2IDE1LjQ0MTIgMTQyLjU2NiAxNS44MzEzQzE0Mi41NjYgMTYuNjk4MyAxNDMuMjYyIDE3LjM5MTggMTQ0LjEzMSAxNy4zOTE4QzE0NSAxNy4zOTE4IDE0NS42OTYgMTYuNjk4MyAxNDUuNjk2IDE1LjgzMTNDMTQ1LjY5NiAxNS4wMDc3IDE0NSAxNC4yNzA4IDE0NC4xNzQgMTQuMjcwOEMxNDMuNjUzIDE0LjI3MDggMTQzLjI2MiAxNC40NDQyIDE0Mi45NTcgMTQuNzkxWk0xNDQuODcgMTYuOTE1SDE0NC40NzlMMTQzLjkxNCAxNi4wOTE0VjE2LjkxNUgxNDMuNjA5VjE0Ljc0NzZIMTQzLjk1N0MxNDQuNDM1IDE0Ljc0NzYgMTQ0LjY1MyAxNC45NjQ0IDE0NC42NTMgMTUuMzU0NUMxNDQuNjUzIDE1LjY1NzkgMTQ0LjQ3OSAxNS44NzQ3IDE0NC4xNzQgMTUuOTYxNEwxNDQuODcgMTYuOTE1Wk0xNDQuMDQ0IDE1LjY1NzlDMTQ0LjI2MSAxNS42NTc5IDE0NC4zOTIgMTUuNTI3OSAxNDQuMzkyIDE1LjM1NDVDMTQ0LjM5MiAxNS4xMzc4IDE0NC4yNjEgMTUuMDUxMSAxNDQuMDAxIDE1LjA1MTFIMTQzLjkxNFYxNS42NTc5SDE0NC4wNDRaIiBmaWxsPSIjMzU0M0E4Ii8+Cjwvc3ZnPgo=" style="\n    text-align: left;\n    width: 146px;\n    position: absolute;\n    top: 14px;\n    left: 31px;\n">\n            </div>\n            <div style="\n    position: relative;\n    top: 80px;\n    left: 32px;\n    font-size: 20px;\n    text-align: left;\n    font-weight: 700;\n    letter-spacing: 0.02em;\n    font-style: normal;\n    line-height: 125%;\n    ">Claim your FREE account and get a key in less than a minute</div>\n            <ul style="\n        font-size: 15px;\n        font-weight: 400;\n        color: #333333;\n        letter-spacing: 0.01em;\n        position: relative;\n        left: 32px;\n        top: 88px;\n        line-height: 180%;\n        ">\n                <li><span>Access to a 30-day free trial of any of our products.</span></li>\n                <li><span>Access to 24x5 support by developers via the <a href="https://support.syncfusion.com/create?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information" style="text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;">support tickets</a>, <a href="https://www.syncfusion.com/forums?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information" style="text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;">forum</a>, <a href="https://www.syncfusion.com/feedback?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information\n                " style="text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;">feature &amp; feedback page</a> and chat.</span></li>\n                <li><span>200+ <a href="https://www.syncfusion.com/succinctly-free-ebooks?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information" style="text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;">ebooks </a>on the latest technologies, industry trends, and research topics.</span>\n                </li>\n                <li><span>Largest collection of over 7500 flat and wireframe icons for free with Syncfusion<sup>®</sup> <a href="https://www.syncfusion.com/downloads/metrostudio?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information\n                " style="text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;">Metro Studio.</a></span></li>\n                <li><span>Free and unlimited access to Syncfusion<sup>®</sup> technical <a href="https://www.syncfusion.com/blogs/?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information\n                " style="text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;">blogs</a> and <a href="https://www.syncfusion.com/resources/techportal/whitepapers?utm_source=es_license_validation_banner&utm_medium=listing&utm_campaign=license-information" style="text-decoration: none;\n                color: #0D6EFD;\n                font-weight: 500;">whitepapers.</a></span></li>\n            </ul>\n            <div style="\n            font-size: 18px;\n            font-weight: 700;\n            position: relative;\n            line-height: 125%;\n            letter-spacing: 0.02em;\n            top: 90px;\n            left: 32px;\n    ">Syncfusion is trusted by 29,000+ businesses worldwide</div>\n            <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjIyMzAiIGhlaWdodD0iMTU2Ij4KPHBhdGggZD0iTTAgMCBDMTAuMjAxNTE3OTEgOC44MjE1MTgwNSAxNi4yMjU4NjAxNyAxOS4zODQ1MTIyMiAxNy4yODEyNSAzMi45NzI2NTYyNSBDMTcuNDE3OTUwMTYgNDUuOTc2MjU4NTUgMTMuMTkyNTE4MDQgNTcuNjM2ODk1NzMgNC4yNDYwOTM3NSA2Ny4xMzI4MTI1IEMtNS44MzQzNzk4NyA3Ni42NDQzNzA1IC0xNi43MjM2MTUyMyA4MC40NzU4MTc3IC0zMC40MTAxNTYyNSA4MC4yMjI2NTYyNSBDLTQzLjEyNjA0NDAyIDc5LjI2MTgzMzU2IC01NC4yMDMwOTQ1MyA3My40MDM0NzMyNCAtNjIuNzE4NzUgNjMuOTcyNjU2MjUgQy03MS4xNDgwNjkyNSA1MS44OTg2NTk5MiAtNzMuMTk0NzM3MSA0MC4zOTM3NzYxNCAtNzEuNzE4NzUgMjUuOTcyNjU2MjUgQy02OS4wOTkxNjQzNyAxNC41NTg3NDc0NCAtNjIuMzc0NTczNzggNC42NDI1NDI1NiAtNTIuNzE4NzUgLTIuMDI3MzQzNzUgQy0zNS45MDE4NDE2MSAtMTEuOTUyMDc2NTcgLTE1Ljg5MjUyMDU5IC0xMi4xNTE1ODYzNiAwIDAgWiAiIGZpbGw9IiMwODY4NDIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzODguNzE4NzUsNDIuMDI3MzQzNzUpIi8+CjxwYXRoIGQ9Ik0wIDAgQzcuMzY3MjM5MTYgNC4wNDIzMjQxMSAxMS4xMDI1Mzc1MyAxMS4zOTA0MDEzMyAxNCAxOSBDMTQuMzg5NjU4MjYgMjAuOTg5NzkzMzQgMTQuNzQwMDUyODkgMjIuOTg5MTQ0ODEgMTUgMjUgQzE1LjY2IDI1IDE2LjMyIDI1IDE3IDI1IEMxNy4xMDA1NDY4NyAyNC4xNDQwNjI1IDE3LjIwMTA5Mzc1IDIzLjI4ODEyNSAxNy4zMDQ2ODc1IDIyLjQwNjI1IEMxOC45MTc0Mjc1NSAxNC41MDU2MzU4IDIzLjYwODM5NDI3IDUuNzcxNDMyNzMgMzAuMTc5Njg3NSAwLjg5NDUzMTI1IEMzMy43MzEzMzY1NCAtMC44NTA4MDcwMSAzNi4wNzI1NTM3NiAtMC42MjM0MDQxNyA0MCAwIEM0Ny43ODg2NDkxMyAzLjU4Mjc3ODYgNTEuMzQ3MDc2MTEgMTAuOTI1MDE3NDYgNTQuMzUyNzgzMiAxOC41ODg4NjcxOSBDNjAuNjYxMjYyNjMgMzUuNzMzMjUxOTkgNjMuMjM3ODY0ODggNTQuNDE0MDMxNTkgNjMuMDYyNSA3Mi42MjUgQzYzLjA1Nzk4ODI4IDczLjUzMzc4OTA2IDYzLjA1MzQ3NjU2IDc0LjQ0MjU3ODEyIDYzLjA0ODgyODEyIDc1LjM3ODkwNjI1IEM2My4wMzcyMTIwMiA3Ny41ODU5NjY5NSA2My4wMTkyODQ1MyA3OS43OTI5OTI5OSA2MyA4MiBDNTkuMDQgODIgNTUuMDggODIgNTEgODIgQzUwLjkzMDA2ODM2IDgwLjkwMzQ5MTIxIDUwLjg2MDEzNjcyIDc5LjgwNjk4MjQyIDUwLjc4ODA4NTk0IDc4LjY3NzI0NjA5IEM1MC4zMzA4MzIxNSA0MS45ODYzMDU3MyA1MC4zMzA4MzIxNSA0MS45ODYzMDU3MyAzOSA4IEMzOC4wMSA3LjY3IDM3LjAyIDcuMzQgMzYgNyBDMjUuMTQyMTkxNjggMTYuMjQ0MTIxMzEgMjQuODI2NDcwMzkgMzguNDA3NTg2NzUgMjMuNjgzNTkzNzUgNTEuNjcyMzYzMjggQzIzLjA0MTM0NzcxIDU5Ljc3NjY1NDY5IDIyLjUwMDE0OTM2IDY3Ljg4NTgxMjE3IDIyIDc2IEMxOC4wNCA3NiAxNC4wOCA3NiAxMCA3NiBDOS44OTUxMDI1NCA3NC40NzU4NDQ3MyA5Ljg5NTEwMjU0IDc0LjQ3NTg0NDczIDkuNzg4MDg1OTQgNzIuOTIwODk4NDQgQzkuMjg4Njk2MTIgMzkuNjQwNjkzMTMgOS4yODg2OTYxMiAzOS42NDA2OTMxMyAtMSA5IEMtMy4wMzU2NDA0IDcuNzQxNDM2NTkgLTMuMDM1NjQwNCA3Ljc0MTQzNjU5IC01IDcgQy0xNS44NDgzODY5NyAxNi40OTIzMzg2IC0xNi4wNTg3MjYyNSA0MC4yNTk3NTY0MSAtMTcgNTQgQy0xNy40NzQyMTEwMiA2My4zMjgyOTc4NCAtMTcuNzQ3NjYxNTkgNzIuNjYzNDc4NzQgLTE4IDgyIEMtMjIuMjkgODIgLTI2LjU4IDgyIC0zMSA4MiBDLTMxLjg5MjU5MjA1IDU1LjgxNzI5OTc3IC0yOS45NTA2NDQ2MiAyMi44Mzc1NTI0MSAtMTIgMiBDLTguNDczMzg5NDMgLTAuNjQ0OTU3OTMgLTQuMjE5NTgzOTggLTAuOTU4OTk2MzYgMCAwIFogIiBmaWxsPSIjRkZDQzAwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4MjgsMzcpIi8+CjxwYXRoIGQ9Ik0wIDAgQzUuODg3MjkwNzMgMS40NDk4NTUxOCA5LjE2NjM4NTEzIDEuMjgxNTYyNTYgMTQuNzUgLTAuODM5ODQzNzUgQzIwLjM1Nzc0OTYyIC0yLjU0NjE0OTE0IDI1LjU0MDY3MjkyIC0xLjM4Mjk1NTEgMzAuNjI1IDEuMjUgQzMyLjkzNzM1MDYzIDMuMjczMzA2OCAzNC4xMDM0MzU0MiA0LjU3NzExOTE4IDM1LjEyNSA3LjQzNzUgQzM0LjM0MTI1IDguMTggMzMuNTU3NSA4LjkyMjUgMzIuNzUgOS42ODc1IEMyOS4xMTkwMTcwMyAxMy40OTEzODY5MiAyOC4yMzgzODk0NyAxNS4wMzE0NzA1OCAyNy44MTI1IDIwLjMxMjUgQzI3Ljk2MDg4MjA0IDI1LjAxNzA4MzQ0IDI5LjE5MzUzOTM2IDI4LjU3NDg0NDU4IDMyLjY2MDE1NjI1IDMxLjkxNzk2ODc1IEMzNC4xMDgzOTEwMSAzMy4xNDAyMzc4IDM1LjYxMjk3ODE1IDM0LjI5NTA4MzQ5IDM3LjEyNSAzNS40Mzc1IEMzNi4wNzAxOTM1MiA0Mi40Njk1NDMyIDMyLjAzNjA5MDQ5IDQ3Ljk3MzE5OTEgMjcuNzUgNTMuNSBDMjQuMjczODU5MzcgNTYuMDY1NzIyODUgMjEuNDA5Njc2NTkgNTYuNjI0MTU5MTggMTcuMTI1IDU2LjQzNzUgQzE1LjExMjc3OTUzIDU1LjgwODY4MTEgMTMuMTEyMjMyNjggNTUuMTQxMzExNTcgMTEuMTI1IDU0LjQzNzUgQzcuMTMyMjAwNjEgNTQuMDEwODUwMDcgMy44Njk5NzIwNCA1NC4xNzkwNDAzMSAwLjA2MjUgNTUuNSBDLTMuNzQ1OTgyNzYgNTYuNzE1NDczMjIgLTYuMDIwMDcxMDYgNTYuNDcwMDcwMjUgLTkuODc1IDU1LjQzNzUgQy0xNy44OTY4MjA0OCA1MC4zNjI0NzA3MiAtMjMuMjI0ODkxNjcgNDAuMjQ1NjM5MjYgLTI1LjQzMzU5Mzc1IDMxLjEzMjgxMjUgQy0yNi42OTE4Nzk2IDIzLjQ0OTQ3NDE1IC0yNy4zMTA4Njc4MiAxNC4yMDI1NjkzMiAtMjIuODc1IDcuNDM3NSBDLTE5LjE4NzExNTEzIDMuMTY0NjQwMjkgLTE0Ljk1ODc1MDk1IC0wLjQ2NDczMTYxIC05LjI2NTYyNSAtMS41NzQyMTg3NSBDLTYuMDIyMDAxNTYgLTEuNTU4MzE4NjQgLTMuMTQ1MDkxMDYgLTAuNzc5NDY1MjEgMCAwIFogIiBmaWxsPSIjMDAwMDAwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMjIuODc1LDU1LjU2MjUpIi8+CjxwYXRoIGQ9Ik0wIDAgQzYuOTk4NjY1NzYgNi41NjU2MTQ1OCAxMy4yMzU0MjQ3IDEzLjIxNDc1OTU1IDE0LjE3OTY4NzUgMjMuMTg3NSBDMTMuOTYxMTk2MzQgMjguMjczOTc0MSAxMi4yNTY2NDk1NCAzMi4wNjY5ODMyNiA5LjAzNTE1NjI1IDM1Ljk3NjU2MjUgQzAuNTMzMzg4MDQgNDMuNTgzNDA3NzQgLTguOTc3NTY4MjUgNDUuMDAzODkwNjcgLTE5Ljg1NTQ2ODc1IDQ0Ljg5ODQzNzUgQy0yMS4xODA5NDcyNyA0NC44OTE2Njk5MiAtMjEuMTgwOTQ3MjcgNDQuODkxNjY5OTIgLTIyLjUzMzIwMzEyIDQ0Ljg4NDc2NTYyIEMtMjQuNzAzMTU0MzQgNDQuODczMDM2MTYgLTI2Ljg3MzA3MDQ3IDQ0Ljg1NTEwMjQ1IC0yOS4wNDI5Njg3NSA0NC44MzU5Mzc1IEMtMjkuMzcyOTY4NzUgNDUuNDk1OTM3NSAtMjkuNzAyOTY4NzUgNDYuMTU1OTM3NSAtMzAuMDQyOTY4NzUgNDYuODM1OTM3NSBDLTMyLjQxNzk2ODc1IDQ2Ljk2MDkzNzUgLTMyLjQxNzk2ODc1IDQ2Ljk2MDkzNzUgLTM1LjA0Mjk2ODc1IDQ2LjgzNTkzNzUgQy0zNy4wNDI5Njg3NSA0NC44MzU5Mzc1IC0zNy4wNDI5Njg3NSA0NC44MzU5Mzc1IC0zNy40MTQwNjI1IDQyLjM1NTQ2ODc1IEMtMzcuNzgyMzI5OTcgMzkuNzMzNjQ1MzEgLTM3Ljc4MjMyOTk3IDM5LjczMzY0NTMxIC0zOS44MjgxMjUgMzguNTM1MTU2MjUgQy00MC41Nzk2NDg0NCAzOC4yMDEyODkwNiAtNDEuMzMxMTcxODcgMzcuODY3NDIxODcgLTQyLjEwNTQ2ODc1IDM3LjUyMzQzNzUgQy00Ny4zNTI0NjU4MyAzNC44NTM3NjUzOCAtNTEuNDU1NzUyNzEgMzEuNTMwNDMxOTUgLTU1LjA0Mjk2ODc1IDI2LjgzNTkzNzUgQy01Ni4wNDI5Njg3NSAyMy4zMzU5Mzc1IC01Ni4wNDI5Njg3NSAyMy4zMzU5Mzc1IC01Ni4wNDI5Njg3NSAyMC44MzU5Mzc1IEMtNTEuMzM2NTk3OTUgMTYuMTI5NTY2NyAtNDUuMzAzOTE4MTcgMTQuNTc0NTc2MzMgLTM5LjA0Mjk2ODc1IDEyLjgzNTkzNzUgQy0zOC4zODI5Njg3NSAxMi44MzU5Mzc1IC0zNy43MjI5Njg3NSAxMi44MzU5Mzc1IC0zNy4wNDI5Njg3NSAxMi44MzU5Mzc1IEMtMzYuOTIxNzk2ODggMTEuOTA5MTAxNTYgLTM2LjgwMDYyNSAxMC45ODIyNjU2MiAtMzYuNjc1NzgxMjUgMTAuMDI3MzQzNzUgQy0zNi41MDgyMDMxMyA4LjgyOTgwNDY5IC0zNi4zNDA2MjUgNy42MzIyNjU2MyAtMzYuMTY3OTY4NzUgNi4zOTg0Mzc1IEMtMzYuMDA1NTQ2ODggNS4yMDM0NzY1NiAtMzUuODQzMTI1IDQuMDA4NTE1NjMgLTM1LjY3NTc4MTI1IDIuNzc3MzQzNzUgQy0zNS40NjY5NTMxMyAxLjgwNjY3OTY5IC0zNS4yNTgxMjUgMC44MzYwMTU2MyAtMzUuMDQyOTY4NzUgLTAuMTY0MDYyNSBDLTM0LjM4Mjk2ODc1IC0wLjQ5NDA2MjUgLTMzLjcyMjk2ODc1IC0wLjgyNDA2MjUgLTMzLjA0Mjk2ODc1IC0xLjE2NDA2MjUgQy0zMC4wNzc2OTExNyAxLjI4MTI3NiAtMjkuNDg3MTQ2NjEgMy4yODE5NjA5NyAtMjguODU1NDY4NzUgNy4wMjM0Mzc1IEMtMjguNjk2OTE0MDYgNy45MjQ0OTIxOSAtMjguNTM4MzU5MzggOC44MjU1NDY4OCAtMjguMzc1IDkuNzUzOTA2MjUgQy0yOC4yNjU0Mjk2OSAxMC40NDA5NzY1NiAtMjguMTU1ODU5MzcgMTEuMTI4MDQ2ODcgLTI4LjA0Mjk2ODc1IDExLjgzNTkzNzUgQy0yNy4xMjUxNTYyNSAxMS45MzM5MDYyNSAtMjYuMjA3MzQzNzUgMTIuMDMxODc1IC0yNS4yNjE3MTg3NSAxMi4xMzI4MTI1IEMtMTguMDQ1MDgyNTkgMTMuMDEyMTUwNTIgLTEyLjIzNzYzMDI1IDEzLjk0OTA5MTA3IC02LjA0Mjk2ODc1IDE3LjgzNTkzNzUgQy00LjY2MTcxODU3IDIwLjU5ODQzNzg2IC00Ljg1MjE3NTY5IDIyLjc4MzI0ODQ5IC01LjA0Mjk2ODc1IDI1LjgzNTkzNzUgQy03LjA0Mjk2ODc1IDI3LjgzNTkzNzUgLTcuMDQyOTY4NzUgMjcuODM1OTM3NSAtMTAuNjY3OTY4NzUgMjcuOTYwOTM3NSBDLTExLjc4MTcxODc1IDI3LjkxOTY4NzUgLTEyLjg5NTQ2ODc1IDI3Ljg3ODQzNzUgLTE0LjA0Mjk2ODc1IDI3LjgzNTkzNzUgQy0xMy4zODI5Njg3NSAyNi41MTU5Mzc1IC0xMi43MjI5Njg3NSAyNS4xOTU5Mzc1IC0xMi4wNDI5Njg3NSAyMy44MzU5Mzc1IEMtMTUuNzk1MjI3MTUgMjIuMTc5MDk2MTMgLTE5LjMwNjQ5OTM2IDIxLjMzMzg1NTg3IC0yMy4zNTU0Njg3NSAyMC43MTA5Mzc1IEMtMjUuMjMyMzQzNzUgMjAuNDIyMTg3NSAtMjcuMTA5MjE4NzUgMjAuMTMzNDM3NSAtMjkuMDQyOTY4NzUgMTkuODM1OTM3NSBDLTI4LjU0Nzk2ODc1IDI4LjI1MDkzNzUgLTI4LjU0Nzk2ODc1IDI4LjI1MDkzNzUgLTI4LjA0Mjk2ODc1IDM2LjgzNTkzNzUgQy0xMi4wNjE3Nzk5MSAzNy4zODI2NDE3MiAtMTIuMDYxNzc5OTEgMzcuMzgyNjQxNzIgMi4wODIwMzEyNSAzMC42NDg0Mzc1IEM0Ljc2MDcwNTQxIDI2LjYzMDQyNjI2IDQuNzc1MjY3NDcgMjMuNTI1MDYwNDMgMy45NTcwMzEyNSAxOC44MzU5Mzc1IEMxLjAxMTM1NTYzIDguNTI2MDcyODEgLTguODY3NTEyMiAyLjM4NDg3MDU4IC0xNy43MzQzNzUgLTIuNTYyNSBDLTMxLjY3NjMzMzk0IC05LjMxMTI2NDA3IC00NS42NDMxNzQyMiAtMTEuNTY4NzI4NjMgLTYxLjA0Mjk2ODc1IC0xMS4xNjQwNjI1IEMtNjEuMDQyOTY4NzUgLTEwLjE3NDA2MjUgLTYxLjA0Mjk2ODc1IC05LjE4NDA2MjUgLTYxLjA0Mjk2ODc1IC04LjE2NDA2MjUgQy02My4wMjI5Njg3NSAtOC4xNjQwNjI1IC02NS4wMDI5Njg3NSAtOC4xNjQwNjI1IC02Ny4wNDI5Njg3NSAtOC4xNjQwNjI1IEMtNjcuNzkyOTY4NzUgLTkuOTE0MDYyNSAtNjcuNzkyOTY4NzUgLTkuOTE0MDYyNSAtNjguMDQyOTY4NzUgLTEyLjE2NDA2MjUgQy02NS45Njg1NDMxOCAtMTUuNTIyNjU2MjggLTYzLjQ3ODY1NTM5IC0xNi41NTA0NzkzNSAtNTkuNzkyOTY4NzUgLTE3LjQ3NjU2MjUgQy0zOS4xODA0NTMyNSAtMjAuODM2MzExNzIgLTE1Ljg1MjQ2NDU2IC0xMy4zOTczMDI3NCAwIDAgWiBNLTQ3LjM1NTQ2ODc1IDIwLjgzNTkzNzUgQy00OC4yMzg0NzY1NiAyMS4wMjE1NjI1IC00OS4xMjE0ODQzOCAyMS4yMDcxODc1IC01MC4wMzEyNSAyMS4zOTg0Mzc1IEMtNTAuNjk1MTE3MTkgMjEuNTQyODEyNSAtNTEuMzU4OTg0MzcgMjEuNjg3MTg3NSAtNTIuMDQyOTY4NzUgMjEuODM1OTM3NSBDLTUyLjUwMDI0MDQ0IDI1LjcyNDc4Mzk5IC01Mi41MDAyNDA0NCAyNS43MjQ3ODM5OSAtNTAuNTAzOTA2MjUgMjcuNDY4NzUgQy00Ni40NjI2MDg1IDMwLjM1OTcxNTgxIC00Mi45NDE1MjEwNyAzMi42MTEyOTk0MiAtMzguMDQyOTY4NzUgMzMuODM1OTM3NSBDLTM2LjcwMzk1MDgzIDMyLjcyNDY3MDkxIC0zNi43MDM5NTA4MyAzMi43MjQ2NzA5MSAtMzYuOTQ1MzEyNSAyOS44OTQ1MzEyNSBDLTM2Ljk1NjkxNDA2IDI4LjY5OTU3MDMxIC0zNi45Njg1MTU2MyAyNy41MDQ2MDkzOCAtMzYuOTgwNDY4NzUgMjYuMjczNDM3NSBDLTM2Ljk4OTQ5MjE5IDI1LjA3NTg5ODQ0IC0zNi45OTg1MTU2MiAyMy44NzgzNTkzOCAtMzcuMDA3ODEyNSAyMi42NDQ1MzEyNSBDLTM3LjAxOTQxNDA2IDIxLjcxNzY5NTMxIC0zNy4wMzEwMTU2MyAyMC43OTA4NTkzNyAtMzcuMDQyOTY4NzUgMTkuODM1OTM3NSBDLTQwLjYzODE2MTY3IDE5LjczMjI5MjMgLTQzLjg0MDg2MTA3IDIwLjA4NjE1NDUzIC00Ny4zNTU0Njg3NSAyMC44MzU5Mzc1IFogIiBmaWxsPSIjMjIxRTIwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1NTEuMDQyOTY4NzUsNTguMTY0MDYyNSkiLz4KPHBhdGggZD0iTTAgMCBDMy4zIDAgNi42IDAgMTAgMCBDMTMuOTk1NTQ4MTcgOC40NTIxMjExMyAxNi45NDE0Njg4MSAxNy4xNzE5NjY3OSAyMCAyNiBDMjAuMzMgMTcuNDIgMjAuNjYgOC44NCAyMSAwIEMyNC42MyAwIDI4LjI2IDAgMzIgMCBDMzIgMTguNDggMzIgMzYuOTYgMzIgNTYgQzI4IDU3IDI4IDU3IDIwIDU3IEMxNy4zNiA0OS40MSAxNC43MiA0MS44MiAxMiAzNCBDMTEuNjcgNDIuMjUgMTEuMzQgNTAuNSAxMSA1OSBDNS41NTUgNTkuNDk1IDUuNTU1IDU5LjQ5NSAwIDYwIEMwIDQwLjIgMCAyMC40IDAgMCBaICIgZmlsbD0iI0Q4MUYyNSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTk1LDUyKSIvPgo8cGF0aCBkPSJNMCAwIEMxLjE3MDQ2ODc1IDAuMDI3MDcwMzEgMi4zNDA5Mzc1IDAuMDU0MTQwNjMgMy41NDY4NzUgMC4wODIwMzEyNSBDNC40Mzg5MDYyNSAwLjExNjgzNTk0IDUuMzMwOTM3NSAwLjE1MTY0MDYyIDYuMjUgMC4xODc1IEM3LjUzODE4NzMxIDYuMjE4NDU0OTcgOC44MTk3NDQ4OSAxMi4yNTA3NjY0NyAxMC4wOTUyMTQ4NCAxOC4yODQ0MjM4MyBDMTAuNTI5OTIzMzUgMjAuMzM2MjQxNDggMTAuOTY2NDMxOTEgMjIuMzg3Njc4NjMgMTEuNDA0Nzg1MTYgMjQuNDM4NzIwNyBDMTIuMDM1MDI5NTggMjcuMzg5MTUwNjYgMTIuNjU4NzU5NzQgMzAuMzQwODk0MzcgMTMuMjgxMjUgMzMuMjkyOTY4NzUgQzEzLjQ3ODExNDAxIDM0LjIwNzczNDgzIDEzLjY3NDk3ODAzIDM1LjEyMjUwMDkyIDEzLjg3NzgwNzYyIDM2LjA2NDk4NzE4IEMxNC4wNTc5OTQzOCAzNi45MjU1MDE4NiAxNC4yMzgxODExNSAzNy43ODYwMTY1NCAxNC40MjM4MjgxMiAzOC42NzI2MDc0MiBDMTQuNTgzNzEyMTYgMzkuNDI1Mzk0NzQgMTQuNzQzNTk2MTkgNDAuMTc4MTgyMDcgMTQuOTA4MzI1MiA0MC45NTM3ODExMyBDMTUuMjUgNDMuMTg3NSAxNS4yNSA0My4xODc1IDE1LjI1IDQ4LjE4NzUgQzExLjI5IDQ4LjE4NzUgNy4zMyA0OC4xODc1IDMuMjUgNDguMTg3NSBDMi45MiA0NS44Nzc1IDIuNTkgNDMuNTY3NSAyLjI1IDQxLjE4NzUgQy0yLjcgNDEuNTE3NSAtNy42NSA0MS44NDc1IC0xMi43NSA0Mi4xODc1IEMtMTMuNDEgNDQuMTY3NSAtMTQuMDcgNDYuMTQ3NSAtMTQuNzUgNDguMTg3NSBDLTE5LjM3IDQ4LjE4NzUgLTIzLjk5IDQ4LjE4NzUgLTI4Ljc1IDQ4LjE4NzUgQy0yNi44MDgzMTEyNiA0Mi4yMDY0MzQ4NSAtMjQuNzAyMzE0NTggMzYuMzU1OTk3NzMgLTIyLjMxNjQwNjI1IDMwLjUzOTA2MjUgQy0yMS45OTcxOTcxMSAyOS43NTk4NTQ0MyAtMjEuNjc3OTg3OTggMjguOTgwNjQ2MzYgLTIxLjM0OTEwNTgzIDI4LjE3NzgyNTkzIEMtMjAuNjc5NDY4MTMgMjYuNTQ4NjI2IC0yMC4wMDc5ODYzNCAyNC45MjAxODI4OSAtMTkuMzM0NzE2OCAyMy4yOTI0ODA0NyBDLTE4LjY0OTcxMDY3IDIxLjYzMDYwMDMgLTE3Ljk3MDA3MDg4IDE5Ljk2NjQ5ODY1IC0xNy4yOTU2NTQzIDE4LjMwMDI5Mjk3IEMtMTYuMzEzOTk1MTggMTUuODc1MDE3NSAtMTUuMzE3MDg2OTUgMTMuNDU2NTQxMzggLTE0LjMxNjQwNjI1IDExLjAzOTA2MjUgQy0xNC4wMTgzNTU4NyAxMC4yOTUzMjM3OSAtMTMuNzIwMzA1NDggOS41NTE1ODUwOCAtMTMuNDEzMjIzMjcgOC43ODUzMDg4NCBDLTEwLjMyNjYxNzczIDEuNDMzOTIzMTMgLTcuOTE5NDc2MjUgLTAuMjM3NTg0MjkgMCAwIFogTS0zLjc1IDE1LjE4NzUgQy01LjQgMjAuMTM3NSAtNy4wNSAyNS4wODc1IC04Ljc1IDMwLjE4NzUgQy02LjExIDMwLjE4NzUgLTMuNDcgMzAuMTg3NSAtMC43NSAzMC4xODc1IEMtMS40MDM0OTYzMyAyMi42MzcxMTU3OCAtMS40MDM0OTYzMyAyMi42MzcxMTU3OCAtMi43NSAxNS4xODc1IEMtMy4wOCAxNS4xODc1IC0zLjQxIDE1LjE4NzUgLTMuNzUgMTUuMTg3NSBaICIgZmlsbD0iIzIzNDM5QSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTcwLjc1LDUzLjgxMjUpIi8+CjxwYXRoIGQ9Ik0wIDAgQzIuNzg5Mjg3NzggMi4zMDgzNzYwOSAzLjc1MTc2ODg4IDQuMjY1OTI4MzQgNC4yNzM0Mzc1IDcuOTEwMTU2MjUgQzQuNjM2ODE4NzQgMTUuNjExMDQzMzQgMS45NDAyMDM5IDIxLjI4NjM5NDY0IC0yLjc5Njg3NSAyNy4yNjk1MzEyNSBDLTkuMDAxNDUwMzQgMzMuOTU4MDYzNDcgLTE1LjA5NjEwOTIxIDM3LjE0MTAyMzg5IC0yNC4yNSAzNy41IEMtMjguMDQyMTE1NTYgMzcuMzY0OTExOTEgLTI5Ljc2NDgxODA0IDM3LjEzMTcwMTkgLTMzLjEyNSAzNS4yNSBDLTM2LjYxNDUyNjY5IDMxLjA2MjU2Nzk3IC0zNy40NTgyNTE2IDI3Ljc5OTc2MzM3IC0zNy4zMDg1OTM3NSAyMi40Mjk2ODc1IEMtMzYuMzE4MDI0MjMgMTQuNjMwNTE5ODYgLTMxLjc1MTQwMDU4IDguMTU2MDQwNzUgLTI2IDMgQy0xNy42OTY1MDc2NiAtMi42NTI1NDYzMSAtOS4yMjAwNTQ5MyAtNS42NTc3NjA5OCAwIDAgWiAiIGZpbGw9IiMwNjg4MkYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwNDUsNzkpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuNzQ5ODUzMjUgLTAuMDg3MTc0NyA3LjQ5OTQ0NTU1IC0wLjE0MDQ1MDAzIDExLjI1IC0wLjE4NzUgQzEyLjMxMzQ3NjU2IC0wLjIxMjYzNjcyIDEzLjM3Njk1MzEyIC0wLjIzNzc3MzQ0IDE0LjQ3MjY1NjI1IC0wLjI2MzY3MTg4IEMxNS40OTc0NjA5NCAtMC4yNzMzMzk4NCAxNi41MjIyNjU2MyAtMC4yODMwMDc4MSAxNy41NzgxMjUgLTAuMjkyOTY4NzUgQzE4LjUyMDc1MTk1IC0wLjMwODY3OTIgMTkuNDYzMzc4OTEgLTAuMzI0Mzg5NjUgMjAuNDM0NTcwMzEgLTAuMzQwNTc2MTcgQzIzLjU2MjEwMzM5IDAuMDc0NjIyNTkgMjQuODI1NjM1MDMgMC43MTY2NzQ2NSAyNyAzIEMyNy45MTMwODU5NCA1LjYzNTQ5ODA1IDI3LjkxMzA4NTk0IDUuNjM1NDk4MDUgMjguNDg0Mzc1IDguNzYxNzE4NzUgQzI4LjgwMzQxNzk3IDEwLjQzOTExMTMzIDI4LjgwMzQxNzk3IDEwLjQzOTExMTMzIDI5LjEyODkwNjI1IDEyLjE1MDM5MDYyIEMyOS4zMzM4NjcxOSAxMy4zMTc2MzY3MiAyOS41Mzg4MjgxMiAxNC40ODQ4ODI4MSAyOS43NSAxNS42ODc1IEMyOS45NzA0Mjk2OSAxNi44NjYzNDc2NiAzMC4xOTA4NTkzOCAxOC4wNDUxOTUzMSAzMC40MTc5Njg3NSAxOS4yNTk3NjU2MiBDMzAuOTYwMTAyNjQgMjIuMTcwNzg4OTEgMzEuNDg2NzY4MjIgMjUuMDgzNzY2MzEgMzIgMjggQzM1LjA3NTc1MDg3IDIxLjMyMzQ4NDU3IDM4LjA0NTYyMTcyIDE0LjYyMjgwNzQ2IDQwLjgxMjUgNy44MTI1IEM0MS4xMjM4MDg1OSA3LjA1MTMwODU5IDQxLjQzNTExNzE5IDYuMjkwMTE3MTkgNDEuNzU1ODU5MzggNS41MDU4NTkzOCBDNDIuNTA1ODE1MTcgMy42NzEzNTIxMyA0My4yNTMxOTk4MiAxLjgzNTc5NDExIDQ0IDAgQzQ4LjI5IDAgNTIuNTggMCA1NyAwIEM1NS44NzQ5NzQ1OCA2Ljc1MDE1MjU0IDU1Ljg3NDk3NDU4IDYuNzUwMTUyNTQgNTQuMzQxNzk2ODggMTAuMzIxMjg5MDYgQzU0LjAwNDc0NzMxIDExLjExNTIxMDU3IDUzLjY2NzY5Nzc1IDExLjkwOTEzMjA4IDUzLjMyMDQzNDU3IDEyLjcyNzExMTgyIEM1Mi45NTY4Nzg2NiAxMy41NjQ4MjExNyA1Mi41OTMzMjI3NSAxNC40MDI1MzA1MiA1Mi4yMTg3NSAxNS4yNjU2MjUgQzUxLjg0NTIwMzg2IDE2LjE0MDIzMzc2IDUxLjQ3MTY1NzcxIDE3LjAxNDg0MjUzIDUxLjA4Njc5MTk5IDE3LjkxNTk1NDU5IEM0OS44OTczNDQ2IDIwLjY5NjY1Mjc4IDQ4LjY5ODc0NTQ1IDIzLjQ3MzI5OTM5IDQ3LjUgMjYuMjUgQzQ2LjY5MzQyMDAxIDI4LjEzMjU1OTY1IDQ1Ljg4NzQyNDAyIDMwLjAxNTM2OTYzIDQ1LjA4MjAzMTI1IDMxLjg5ODQzNzUgQzQzLjYxMDkxMDIyIDM1LjMzMjU2NDA1IDQyLjEzODAzMjE4IDM4Ljc2NTkwNDg3IDQwLjY1ODIwMzEyIDQyLjE5NjI4OTA2IEM0MC4zNjE0MzY3NyA0Mi44ODQzNDYzMSA0MC4wNjQ2NzA0MSA0My41NzI0MDM1NiAzOS43NTg5MTExMyA0NC4yODEzMTEwNCBDMzkuMjA1MDIxMiA0NS41MzU2OTMxMSAzOC42MTMyMzIxNyA0Ni43NzM1MzU2NyAzOCA0OCBDMzMuMzggNDggMjguNzYgNDggMjQgNDggQzIzLjcxODAxNzU4IDQ2Ljg2OTgxNDQ1IDIzLjQzNjAzNTE2IDQ1LjczOTYyODkxIDIzLjE0NTUwNzgxIDQ0LjU3NTE5NTMxIEMyMi4wOTM1MjM1MyA0MC4zNzQ2MTE1MyAyMS4wMjMxNzA3NiAzNi4xNzg4ODk2NSAxOS45NDcyNjU2MiAzMS45ODQzNzUgQzE5LjQ4NDU3MjAzIDMwLjE2OTg5MDMxIDE5LjAyNjgzOTQ1IDI4LjM1NDEzMjkyIDE4LjU3NDIxODc1IDI2LjUzNzEwOTM4IEMxNy45MjE5MzU4OSAyMy45MjIyNTYxNiAxNy4yNTE4MjE4MSAyMS4zMTI1MzE3MyAxNi41NzgxMjUgMTguNzAzMTI1IEMxNi4yODA5ODYwMiAxNy40ODcyODcyOSAxNi4yODA5ODYwMiAxNy40ODcyODcyOSAxNS45Nzc4NDQyNCAxNi4yNDY4ODcyMSBDMTQuODEwMjA5MzQgMTEuODA0OTMzNDYgMTMuNzk5Njc2MzYgOC44OTA1NzQxMSAxMCA2IEM3LjQ0MzcyNDc1IDQuODk3OTA2NjcgNy40NDM3MjQ3NSA0Ljg5NzkwNjY3IDQuNzUgNC4yNSBDMy44NTc5Njg3NSA0LjAwNzY1NjI1IDIuOTY1OTM3NSAzLjc2NTMxMjUgMi4wNDY4NzUgMy41MTU2MjUgQzEuMzcxNDA2MjUgMy4zNDU0Njg3NSAwLjY5NTkzNzUgMy4xNzUzMTI1IDAgMyBDMCAyLjAxIDAgMS4wMiAwIDAgWiAiIGZpbGw9IiMyMTI5NjUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM2LDU0KSIvPgo8cGF0aCBkPSJNMCAwIEMzLjYzIDAgNy4yNiAwIDExIDAgQzE1IDkuNjI1IDE1IDkuNjI1IDE1IDEzIEMxNS42NiAxMyAxNi4zMiAxMyAxNyAxMyBDMTcuMTkzMzU5MzggMTIuMzk2NzE4NzUgMTcuMzg2NzE4NzUgMTEuNzkzNDM3NSAxNy41ODU5Mzc1IDExLjE3MTg3NSBDMTcuODQ2MzI4MTIgMTAuMzcyNjU2MjUgMTguMTA2NzE4NzUgOS41NzM0Mzc1IDE4LjM3NSA4Ljc1IEMxOC43NTc4NTE1NiA3LjU2NjY0MDYyIDE4Ljc1Nzg1MTU2IDcuNTY2NjQwNjIgMTkuMTQ4NDM3NSA2LjM1OTM3NSBDMjAgNCAyMCA0IDIyIDAgQzI1LjYzIDAgMjkuMjYgMCAzMyAwIEMzMS42MTIzNzc3OCA0LjQ4OTM2NjAxIDMwLjA5OTAyNzU4IDguODM1MTMyMDUgMjguMjA3MDMxMjUgMTMuMTM2NzE4NzUgQzI3LjcyNjY1NDA1IDE0LjI0Mjg1NTIyIDI3LjcyNjY1NDA1IDE0LjI0Mjg1NTIyIDI3LjIzNjU3MjI3IDE1LjM3MTMzNzg5IEMyNi41ODgzNzkzNiAxNi44NTIwMjc5OSAyNS45MjY0NjI4MyAxOC4zMjY4MDAwNiAyNS4yNDk3NTU4NiAxOS43OTQ2Nzc3MyBDMjEuMjM0Nzg2MTQgMjkuMDI3NTEyNzMgMjUuMDc1MDY3NzkgMzYuMzYzMTg5NTkgMjguNTYyNSA0NS4yNSBDMjkuNDAxNTk1MTQgNDcuMzk5MzA1OTEgMzAuMjM2NDQwNzggNDkuNTUwMjc3MTYgMzEuMDY2NDA2MjUgNTEuNzAzMTI1IEMzMS40MzcwOTIyOSA1Mi42NDgzMzAwOCAzMS44MDc3NzgzMiA1My41OTM1MzUxNiAzMi4xODk2OTcyNyA1NC41NjczODI4MSBDMzMgNTcgMzMgNTcgMzMgNjAgQzMxLjU2MTYzMjQ5IDU5Ljg4NTQxMzA3IDMwLjEyNDI5MDM0IDU5Ljc1NzkwODg0IDI4LjY4NzUgNTkuNjI1IEMyNy44ODY5OTIxOSA1OS41NTUzOTA2MyAyNy4wODY0ODQzOCA1OS40ODU3ODEyNSAyNi4yNjE3MTg3NSA1OS40MTQwNjI1IEMyNCA1OSAyNCA1OSAyMSA1NyBDMTkuNjEzMjgxMjUgNTMuOTYwOTM3NSAxOS42MTMyODEyNSA1My45NjA5Mzc1IDE4LjMxMjUgNTAuMzc1IEMxNy44NzU1MDc4MSA0OS4xODY0ODQzNyAxNy40Mzg1MTU2MyA0Ny45OTc5Njg3NSAxNi45ODgyODEyNSA0Ni43NzM0Mzc1IEMxNi42NjIxNDg0NCA0NS44NTgyMDMxMyAxNi4zMzYwMTU2MyA0NC45NDI5Njg3NSAxNiA0NCBDMTQuMjExNzgyMjYgNDYuNjgyMzI2NjEgMTIuNzk4NTczOTYgNDkuMzAyODg5NjEgMTEuMzc1IDUyLjE4NzUgQzEwLjkyODk4NDM4IDUzLjA4ODU1NDY5IDEwLjQ4Mjk2ODc1IDUzLjk4OTYwOTM4IDEwLjAyMzQzNzUgNTQuOTE3OTY4NzUgQzkuNjg1NzAzMTIgNTUuNjA1MDM5MDYgOS4zNDc5Njg3NSA1Ni4yOTIxMDkzNyA5IDU3IEM1LjcgNTYuNjcgMi40IDU2LjM0IC0xIDU2IEMtMC4zOTQ5ODQ5MyA0OS4xNzY3NzQ1NCAyLjkyNjY1MjAyIDQzLjQ2Njc3Nzg3IDUuOTM3NSAzNy40MzE2NDA2MiBDOC40NDU2MTQ0IDMyLjE0NzgyNjM3IDkuNzA2Nzk0NDIgMjguODM0MjUxNjYgOCAyMyBDNi43NTQ5MDE0NiAxOS41MzQxMTc5NSA1LjM3Mjc0NjExIDE2LjE0MTA0NzgxIDMuOTM3NSAxMi43NSBDMy4xOTE5Mjc4NyAxMC45NzU5MjA2OSAyLjQ1MDgyOTQ5IDkuMTk5OTUyNjcgMS43MTQ4NDM3NSA3LjQyMTg3NSBDMS4zODYwNTIyNSA2LjY0NDI0ODA1IDEuMDU3MjYwNzQgNS44NjY2MjEwOSAwLjcxODUwNTg2IDUuMDY1NDI5NjkgQzAgMyAwIDMgMCAwIFogIiBmaWxsPSIjRDgxRTI1IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMTgzLDUyKSIvPgo8cGF0aCBkPSJNMCAwIEMtMC42NiAzLjYzIC0xLjMyIDcuMjYgLTIgMTEgQy0yLjgyNSAxMC44MzUgLTMuNjUgMTAuNjcgLTQuNSAxMC41IEMtMTEuNDA5NDk0MjQgOS40MzI1NTU0MyAtMTEuNDA5NDk0MjQgOS40MzI1NTU0MyAtMTggMTEgQy0xNy45MDQ4MDU0NiAxMi44OTU3NjM2NiAtMTcuOTA0ODA1NDYgMTIuODk1NzYzNjYgLTE3IDE1IEMtMTQuNTcyODYxMyAxNi44NzM4MTgyMSAtMTQuNTcyODYxMyAxNi44NzM4MTgyMSAtMTEuNjI1IDE4LjUgQy03LjkzODczNzE5IDIwLjYzOTc4MzE2IC01LjIyOTM2OTIyIDIyLjMxNTc1MDIyIC0zIDI2IEMtMS41MDg4MTc1MSAzMS42NDUxOTA4NSAtMi4xNzg0MTgzNiAzNC45MjExNTMwNiAtNSA0MCBDLTkuMzQ2NDcyNTcgNDUuMTQ3MTM4NTcgLTEzLjQ5MjA4MjkgNDcuMDc2ODA4NDEgLTIwLjEyNSA0Ny43NSBDLTI1Ljk4NTQzMDQyIDQ4LjIyMDQyOTExIC0zMS4zMDM1NDk3NiA0Ny4zMzMyMTE3NiAtMzcgNDYgQy0zOC4wOTg5ODcwMiA0Mi43MDMwMzg5NSAtMzcuODcxMjQ0NDQgNDEuNTk1MDUwOTcgLTM3LjA2MjUgMzguMzEyNSBDLTM2Ljg2Nzg1MTU2IDM3LjUwNDI1NzgxIC0zNi42NzMyMDMxMyAzNi42OTYwMTU2MyAtMzYuNDcyNjU2MjUgMzUuODYzMjgxMjUgQy0zNi4zMTY2Nzk2OSAzNS4yNDgzOTg0NCAtMzYuMTYwNzAzMTIgMzQuNjMzNTE1NjMgLTM2IDM0IEMtMzQuODQ1IDM0LjMzIC0zMy42OSAzNC42NiAtMzIuNSAzNSBDLTI4LjE4MjA3NzU3IDM2LjA3MzcyODQ5IC0yNC40NDM3NDM0NCAzNi4zMDEyNzA3NCAtMjAgMzYgQy0xOS4wMSAzNS4zNCAtMTguMDIgMzQuNjggLTE3IDM0IEMtMTcuMTc4MjU1OTkgMzIuMDY3MDg1MjEgLTE3LjE3ODI1NTk5IDMyLjA2NzA4NTIxIC0xOCAzMCBDLTE5LjkwMzM3ODEzIDI4LjYwODcxNTU2IC0xOS45MDMzNzgxMyAyOC42MDg3MTU1NiAtMjIuMjUgMjcuNTYyNSBDLTMxLjA3MTA4MzE3IDIyLjkxMzE3MTEzIC0zMS4wNzEwODMxNyAyMi45MTMxNzExMyAtMzIuNjYwMTU2MjUgMTcuOTI5Njg3NSBDLTMzLjUwOTcyNjg3IDEzLjA2MzIxNTAxIC0zMy4wODExMzgwMSA5LjYxMDg4NDM3IC0zMC4yOTI5Njg3NSA1LjUgQy0yMi4zNjg4Mzc3IC0zLjY5Mjk0OTYyIC0xMC42NjIyMzUzMyAtMi42NjU1NTg4MyAwIDAgWiAiIGZpbGw9IiMyMjM5ODUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE0Niw1NSkiLz4KPHBhdGggZD0iTTAgMCBDNC4yNTM4MDEzOCAxLjUxOTIxNDc4IDUuODUwNjA1NjkgNC4xMzEwOTAyNCA4IDggQzEwLjIxNjIxNjM0IDE0LjEzODE3MjIyIDExLjE3ODUwNDM3IDIwLjIzMzA3NjcgOC41NjI1IDI2LjM3NSBDNyAyOSA3IDI5IDYgMzAgQzMuNjM2NzE4NzUgMzAuMjk2ODc1IDMuNjM2NzE4NzUgMzAuMjk2ODc1IDEgMzAgQy0wLjczMDQ2ODc1IDI4LjM5MDYyNSAtMC43MzA0Njg3NSAyOC4zOTA2MjUgLTIuMTg3NSAyNi4yNSBDLTIuOTIwMzMyMDMgMjUuMjA1ODU5MzggLTIuOTIwMzMyMDMgMjUuMjA1ODU5MzggLTMuNjY3OTY4NzUgMjQuMTQwNjI1IEMtNC45MTMwODMwNCAyMi4xMzk2Nzg4OCAtNS45ODkwNDQ2MiAyMC4xMjczMTg0MyAtNyAxOCBDLTcuMTk5MTYwMTYgMTkuMjY0NTcwMzEgLTcuMTk5MTYwMTYgMTkuMjY0NTcwMzEgLTcuNDAyMzQzNzUgMjAuNTU0Njg3NSBDLTcuNTc4OTQ1MzEgMjEuNjUwMzkwNjIgLTcuNzU1NTQ2ODggMjIuNzQ2MDkzNzUgLTcuOTM3NSAyMy44NzUgQy04LjExMTUyMzQ0IDI0Ljk2NTU0Njg4IC04LjI4NTU0Njg4IDI2LjA1NjA5Mzc1IC04LjQ2NDg0Mzc1IDI3LjE3OTY4NzUgQy05IDMwIC05IDMwIC0xMCAzMiBDLTExLjg3NSAzMS43NSAtMTEuODc1IDMxLjc1IC0xNCAzMSBDLTE1LjI1IDI4LjkzNzUgLTE1LjI1IDI4LjkzNzUgLTE2IDI3IEMtMTYuNDMzMTI1IDI3LjQ3NDM3NSAtMTYuODY2MjUgMjcuOTQ4NzUgLTE3LjMxMjUgMjguNDM3NSBDLTIxLjI2ODUzMTg1IDMyLjEwMDQ5MjQ1IC0yNi43NTQ4NDI1IDMxLjMyNjM3NjY4IC0zMS44MjAzMTI1IDMxLjI4MTI1IEMtMzYuMjA3MDY0MDkgMzAuODkzMjMyNjYgLTM3LjkwMzMwOTI4IDMwLjA5NjY5MDcyIC00MSAyNyBDLTQyLjU2MjUgMjQuNSAtNDIuNTYyNSAyNC41IC00MyAyMiBDLTQxLjYyNSAxOS42ODc1IC00MS42MjUgMTkuNjg3NSAtNDAgMTggQy00MS4zMiAxNy4wMSAtNDIuNjQgMTYuMDIgLTQ0IDE1IEMtNDQgMTEuNzUgLTQ0IDExLjc1IC00MyA4IEMtMzcuODIzNzMwOTQgMy44MDUyMDc0OSAtMzIuMDE2MTEwNTQgMy40NTA1OTcyMiAtMjUuNjI1IDMuNjg3NSBDLTI0LjgxOTMzNTk0IDMuNjk3MTY3OTcgLTI0LjAxMzY3MTg4IDMuNzA2ODM1OTQgLTIzLjE4MzU5Mzc1IDMuNzE2Nzk2ODggQy0xNy4zNDEzMjczMSAzLjgyOTMzNjM1IC0xNy4zNDEzMjczMSAzLjgyOTMzNjM1IC0xNSA1IEMtMTUuMzEyNSA2LjkzNzUgLTE1LjMxMjUgNi45Mzc1IC0xNiA5IEMtMjAuMjg5NzAxMzQgMTAuNDI5OTAwNDUgLTI0LjU3MTM0MzI0IDEwLjQzODEyMTc2IC0yOS4wNjY0MDYyNSAxMC43MTg3NSBDLTMxLjkzMTY1NzQ2IDEwLjgxNTkwNjYxIC0zMS45MzE2NTc0NiAxMC44MTU5MDY2MSAtMzQgMTIgQy0zMy4wMzU3ODEyNSAxMi4xMDk1NzAzMSAtMzIuMDcxNTYyNSAxMi4yMTkxNDA2MiAtMzEuMDc4MTI1IDEyLjMzMjAzMTI1IEMtMjkuODE0ODQzNzUgMTIuNDkwNTg1OTQgLTI4LjU1MTU2MjUgMTIuNjQ5MTQwNjMgLTI3LjI1IDEyLjgxMjUgQy0yNS4zNzA1NDY4NyAxMy4wMzg3MzA0NyAtMjUuMzcwNTQ2ODcgMTMuMDM4NzMwNDcgLTIzLjQ1MzEyNSAxMy4yNjk1MzEyNSBDLTIwLjA1NDQ1OTUzIDEzLjk4ODQ3OTcxIC0xOC40MjUxMDM5MSAxNC41NjkwMDk5MSAtMTYgMTcgQy0xNS42NyAxNy45OSAtMTUuMzQgMTguOTggLTE1IDIwIEMtMTQuODc4ODI4MTMgMTkuMzI0NTMxMjUgLTE0Ljc1NzY1NjI1IDE4LjY0OTA2MjUgLTE0LjYzMjgxMjUgMTcuOTUzMTI1IEMtMTQuNDY1MjM0MzggMTcuMDYxMDkzNzUgLTE0LjI5NzY1NjI1IDE2LjE2OTA2MjUgLTE0LjEyNSAxNS4yNSBDLTEzLjk2MjU3ODEzIDE0LjM2ODI4MTI1IC0xMy44MDAxNTYyNSAxMy40ODY1NjI1IC0xMy42MzI4MTI1IDEyLjU3ODEyNSBDLTEzLjAzMjAzNzM2IDEwLjEzMDUyMjU2IC0xMi4yMjAwMjg4MyA4LjE5NDAwMTQzIC0xMSA2IEMtOC43Njk1MzEyNSA2LjEyMTA5Mzc1IC04Ljc2OTUzMTI1IDYuMTIxMDkzNzUgLTYgNyBDLTMuNzYxNzE4NzUgOS43MjI2NTYyNSAtMy43NjE3MTg3NSA5LjcyMjY1NjI1IC0xLjY4NzUgMTMuMDYyNSBDLTAuOTkwMTE3MTkgMTQuMTY3MjI2NTYgLTAuMjkyNzM0MzggMTUuMjcxOTUzMTIgMC40MjU3ODEyNSAxNi40MTAxNTYyNSBDMS4yMDUwMTk1MyAxNy42OTIxMjg5MSAxLjIwNTAxOTUzIDE3LjY5MjEyODkxIDIgMTkgQzEuODAwODM5ODQgMTcuODA1MDM5MDYgMS44MDA4Mzk4NCAxNy44MDUwMzkwNiAxLjU5NzY1NjI1IDE2LjU4NTkzNzUgQzEuMDY1MTA0MTcgMTMuMzkwNjI1IDAuNTMyNTUyMDggMTAuMTk1MzEyNSAwIDcgQy0wLjIwNzUzOTA2IDUuODk5MTQwNjMgLTAuNDE1MDc4MTMgNC43OTgyODEyNSAtMC42Mjg5MDYyNSAzLjY2NDA2MjUgQy0wLjc1MTM2NzE5IDIuNzg0OTIxODcgLTAuODczODI4MTMgMS45MDU3ODEyNSAtMSAxIEMtMC42NyAwLjY3IC0wLjM0IDAuMzQgMCAwIFogTS0yOCAxOCBDLTI2LjE4Nzc3NDY2IDIwLjA2MjQ5OTQgLTI2LjE4Nzc3NDY2IDIwLjA2MjQ5OTQgLTI0IDIyIEMtMjMuMDEgMjIgLTIyLjAyIDIyIC0yMSAyMiBDLTIxLjMzIDIxLjAxIC0yMS42NiAyMC4wMiAtMjIgMTkgQy0yNC45NyAxOC41MDUgLTI0Ljk3IDE4LjUwNSAtMjggMTggWiBNLTM5IDIyIEMtMzkgMjIuNjYgLTM5IDIzLjMyIC0zOSAyNCBDLTM2LjAzIDI0LjMzIC0zMy4wNiAyNC42NiAtMzAgMjUgQy0zMi4zNTk2ODc0NCAyMi45MDI1MDAwNSAtMzMuNTQ2MTY5OTQgMjIuMDMwOTQyOTYgLTM2Ljc1IDIxLjgxMjUgQy0zNy40OTI1IDIxLjg3NDM3NSAtMzguMjM1IDIxLjkzNjI1IC0zOSAyMiBaICIgZmlsbD0iIzIyMUUyMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjIwLDY3KSIvPgo8cGF0aCBkPSJNMCAwIEMyLjA1NDY4NzUgLTAuMTk5MjE4NzUgMi4wNTQ2ODc1IC0wLjE5OTIxODc1IDUuODY3MTg3NSAwLjM2MzI4MTI1IEM4LjI4Mjg5NDcyIDIuNDI4NzM2NjggMTAuMDk2NDE2NDkgNC43MzM5NTQ2IDExLjg2NzE4NzUgNy4zNjMyODEyNSBDMTIuMTQ5NDkyMTkgNi44NDYzNjcxOSAxMi40MzE3OTY4NyA2LjMyOTQ1MzEzIDEyLjcyMjY1NjI1IDUuNzk2ODc1IEMxNC4yNzE2ODgxMyAzLjQ3NTU5ODQ4IDE1LjU3MTg3NDIgMS45NzEyNTAyOCAxNy44NjcxODc1IDAuMzYzMjgxMjUgQzI2LjQ3NDM3MzUgLTAuNzg0MzQzNTUgMzQuOTQxNzAyNzcgMi4yOTMwNDg0MyA0Mi44NjcxODc1IDUuMzYzMjgxMjUgQzQxLjE2MTc1MzAxIDkuMTA0MjM0MzIgMzkuMjkzODYwOCAxMS4wMjMxMTQxMiAzNS44NjcxODc1IDEzLjM2MzI4MTI1IEMzNC44NzcxODc1IDEzLjM2MzI4MTI1IDMzLjg4NzE4NzUgMTMuMzYzMjgxMjUgMzIuODY3MTg3NSAxMy4zNjMyODEyNSBDMzIuMjA3MTg3NSAxMi4zNzMyODEyNSAzMS41NDcxODc1IDExLjM4MzI4MTI1IDMwLjg2NzE4NzUgMTAuMzYzMjgxMjUgQzI4LjY3MjY0MDY5IDkuNzgzMzQ0MjYgMjguNjcyNjQwNjkgOS43ODMzNDQyNiAyNi4yNDIxODc1IDkuNjc1NzgxMjUgQzI1LjQyNDkyMTg4IDkuNjEwMDM5MDYgMjQuNjA3NjU2MjUgOS41NDQyOTY4OCAyMy43NjU2MjUgOS40NzY1NjI1IEMyMi44MjU4OTg0NCA5LjQyMDQ4ODI4IDIyLjgyNTg5ODQ0IDkuNDIwNDg4MjggMjEuODY3MTg3NSA5LjM2MzI4MTI1IEMyMS43NTg4NzYwNCA5Ljk5OTk5MjUyIDIxLjY1MDU2NDU4IDEwLjYzNjcwMzggMjEuNTM4OTcwOTUgMTEuMjkyNzA5MzUgQzIwLjQxMzg1NTQzIDE3Ljg5NjI5MTI1IDE5LjI3NjQ4MDM1IDI0LjQ5NzY3NjE0IDE4LjEzMTgzNTk0IDMxLjA5NzkwMDM5IEMxNy43MDU4MDczNiAzMy41NjQxNTA1NiAxNy4yODI5NDkwNyAzNi4wMzA5NTA1MSAxNi44NjMyODEyNSAzOC40OTgyOTEwMiBDMTYuMjYwODYwODcgNDIuMDM2ODAwMzYgMTUuNjQ3MjEwNTMgNDUuNTczMjAwOSAxNS4wMzEyNSA0OS4xMDkzNzUgQzE0Ljg0NDcwODU2IDUwLjIxOTc3NjQ2IDE0LjY1ODE2NzExIDUxLjMzMDE3NzkyIDE0LjQ2NTk3MjkgNTIuNDc0MjI3OTEgQzE0LjI4NTkzNzE5IDUzLjQ5NTIxMDcyIDE0LjEwNTkwMTQ5IDU0LjUxNjE5MzU0IDEzLjkyMDQxMDE2IDU1LjU2ODExNTIzIEMxMy42ODcyNDU5NCA1Ni45MjM3OTg2IDEzLjY4NzI0NTk0IDU2LjkyMzc5ODYgMTMuNDQ5MzcxMzQgNTguMzA2ODY5NTEgQzEzLjI1NzI1MDY3IDU4Ljk4NTQ4NTM4IDEzLjA2NTEzIDU5LjY2NDEwMTI2IDEyLjg2NzE4NzUgNjAuMzYzMjgxMjUgQzExLjg3NzE4NzUgNjAuODU4MjgxMjUgMTEuODc3MTg3NSA2MC44NTgyODEyNSAxMC44NjcxODc1IDYxLjM2MzI4MTI1IEM5LjU4MDQ1Mjg0IDU0LjQ1OTA5MjQzIDguMjk5Mjc3MDIgNDcuNTUzODg4ODYgNy4wMjE5NzI2NiA0MC42NDc5NDkyMiBDNi41ODY3MzE3NyAzOC4yOTg0Mjc0MSA2LjE1MDIxNTc5IDM1Ljk0OTE0MTQ1IDUuNzEyNDAyMzQgMzMuNjAwMDk3NjYgQzUuMDgzNTYyMzcgMzAuMjI0ODk1MzcgNC40NTkzMDI5NCAyNi44NDg4NzMzNSAzLjgzNTkzNzUgMjMuNDcyNjU2MjUgQzMuNTQwNjQxNDggMjEuODk1OTAxMTggMy41NDA2NDE0OCAyMS44OTU5MDExOCAzLjIzOTM3OTg4IDIwLjI4NzI5MjQ4IEMzLjA1OTE5MzEyIDE5LjMwNjU3Nzc2IDIuODc5MDA2MzUgMTguMzI1ODYzMDQgMi42OTMzNTkzOCAxNy4zMTU0Mjk2OSBDMi41MzM0NzUzNCAxNi40NTM4MzI0IDIuMzczNTkxMzEgMTUuNTkyMjM1MTEgMi4yMDg4NjIzIDE0LjcwNDUyODgxIEMxLjg2NzE4NzUgMTIuMzYzMjgxMjUgMS44NjcxODc1IDEyLjM2MzI4MTI1IDEuODY3MTg3NSA4LjM2MzI4MTI1IEMtMS43NjI4MTI1IDkuMDIzMjgxMjUgLTUuMzkyODEyNSA5LjY4MzI4MTI1IC05LjEzMjgxMjUgMTAuMzYzMjgxMjUgQy05LjQ2MjgxMjUgMTEuMzUzMjgxMjUgLTkuNzkyODEyNSAxMi4zNDMyODEyNSAtMTAuMTMyODEyNSAxMy4zNjMyODEyNSBDLTE1LjA4OTc3ODMxIDEyLjEyNDAzOTggLTE3LjI0OTM5NzE2IDEwLjU3NzUwMzY3IC0yMC4xMzI4MTI1IDYuMzYzMjgxMjUgQy0xMy40NzU0Nzc3IDMuMTIxMTc0OTQgLTcuMjY2ODA3MzkgMS4yMzc3NTI5MSAwIDAgWiAiIGZpbGw9IiNFODIwMjYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE3NzUuMTMyODEyNSwzNS42MzY3MTg3NSkiLz4KPHBhdGggZD0iTTAgMCBDOC41OCAwIDE3LjE2IDAgMjYgMCBDMjYgMy4zIDI2IDYuNiAyNiAxMCBDMjAuNzIgMTAgMTUuNDQgMTAgMTAgMTAgQzEwIDEzLjYzIDEwIDE3LjI2IDEwIDIxIEMxMy45NiAyMSAxNy45MiAyMSAyMiAyMSBDMjIgMjQuMyAyMiAyNy42IDIyIDMxIEMxOC4wNCAzMSAxNC4wOCAzMSAxMCAzMSBDMTAgMzUuMjkgMTAgMzkuNTggMTAgNDQgQzE3LjkyIDQzLjUwNSAxNy45MiA0My41MDUgMjYgNDMgQzI2IDQ2LjMgMjYgNDkuNiAyNiA1MyBDMjIuODY0NjI0MDIgNTQuMDQ1MTI1MzMgMjAuMjI4NTQ5MDIgNTQuMzE1Mzc3MTMgMTYuOTM3NSA1NC41NjI1IEMxNS44NzQwMjM0NCA1NC42NDYyODkwNiAxNC44MTA1NDY4OCA1NC43MzAwNzgxMyAxMy43MTQ4NDM3NSA1NC44MTY0MDYyNSBDOS4xNDgzOTI5NSA1NS4wNDIwODc4NCA0LjU3MjAyNDE4IDU1IDAgNTUgQzAgMzYuODUgMCAxOC43IDAgMCBaICIgZmlsbD0iI0Q4MUUyNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAzNSw1MikiLz4KPHBhdGggZD0iTTAgMCBDMS45MTAxNTYyNSAwLjgyMDMxMjUgMS45MTAxNTYyNSAwLjgyMDMxMjUgNC41MzUxNTYyNSAyLjMyMDMxMjUgQzQuNTM1MTU2MjUgNC45NjAzMTI1IDQuNTM1MTU2MjUgNy42MDAzMTI1IDQuNTM1MTU2MjUgMTAuMzIwMzEyNSBDMS43NzIzOTQ0OCA5Ljc5NzYyNzg0IC0wLjc5MDkzMTM1IDkuMjExNjE2NjMgLTMuNDY0ODQzNzUgOC4zMjAzMTI1IEMtNS4wMjYwMjgwMyA4LjI1MjkwMzg1IC02LjU4OTg2ODk1IDguMjM1MTY3OTQgLTguMTUyMzQzNzUgOC4yNTc4MTI1IEMtOC45NjA1ODU5NCA4LjI2NjgzNTk0IC05Ljc2ODgyODEzIDguMjc1ODU5MzcgLTEwLjYwMTU2MjUgOC4yODUxNTYyNSBDLTExLjIxNjQ0NTMxIDguMjk2NzU3ODEgLTExLjgzMTMyODEzIDguMzA4MzU5MzggLTEyLjQ2NDg0Mzc1IDguMzIwMzEyNSBDLTEyLjc5NDg0Mzc1IDkuMzEwMzEyNSAtMTMuMTI0ODQzNzUgMTAuMzAwMzEyNSAtMTMuNDY0ODQzNzUgMTEuMzIwMzEyNSBDLTEyLjU4NDQxNDA2IDExLjcwNzAzMTI1IC0xMS43MDM5ODQzNyAxMi4wOTM3NSAtMTAuNzk2ODc1IDEyLjQ5MjE4NzUgQy05LjYzNTQyOTY5IDEzLjAxMjk2ODc1IC04LjQ3Mzk4NDM4IDEzLjUzMzc1IC03LjI3NzM0Mzc1IDE0LjA3MDMxMjUgQy01LjU1NDUxMTcyIDE0LjgzNjAxNTYzIC01LjU1NDUxMTcyIDE0LjgzNjAxNTYzIC0zLjc5Njg3NSAxNS42MTcxODc1IEMwLjI0MTM3MzEyIDE3LjY4MTI4NjE5IDMuNTY0NTg1NyAxOS42ODc5ODkzIDUuOTEwMTU2MjUgMjMuNjMyODEyNSBDNi45OTYzOTk0NiAyOC4zMDM2NTgzIDYuMzE4NTczOSAzMS44ODQwNDY4MSA0LjAzNTE1NjI1IDM2LjA3MDMxMjUgQy0wLjE5NDIwMDc5IDM5Ljg3NjczMzg0IC00LjYxMjE4MDA4IDQxLjI1NzA5NTU4IC0xMC4yODUxNTYyNSA0MS4zODI4MTI1IEMtMTUuNjc4ODQ0MzEgNDEuMDMwMDkxNzUgLTE5Ljg2NjQ0MTQ4IDQwLjE3ODc3ODc4IC0yNC40NjQ4NDM3NSAzNy4zMjAzMTI1IEMtMjQuNDY0ODQzNzUgMzQuMDIwMzEyNSAtMjQuNDY0ODQzNzUgMzAuNzIwMzEyNSAtMjQuNDY0ODQzNzUgMjcuMzIwMzEyNSBDLTIzLjE2NTQ2ODc1IDI3Ljk4MDMxMjUgLTIxLjg2NjA5Mzc1IDI4LjY0MDMxMjUgLTIwLjUyNzM0Mzc1IDI5LjMyMDMxMjUgQy0xNS41OTQwNTE2OSAzMS41NDQyMDkyNCAtMTEuODI1MTI2MDMgMzEuNjYwNjQ3ODggLTYuNDY0ODQzNzUgMzEuMzIwMzEyNSBDLTYuNDY0ODQzNzUgMzAuMDAwMzEyNSAtNi40NjQ4NDM3NSAyOC42ODAzMTI1IC02LjQ2NDg0Mzc1IDI3LjMyMDMxMjUgQy03LjQxNzQ2MDk0IDI2Ljk1Njc5Njg3IC04LjM3MDA3ODEyIDI2LjU5MzI4MTI1IC05LjM1MTU2MjUgMjYuMjE4NzUgQy0yMi40OTU3MTQwNSAyMS4wMzAxNzczIC0yMi40OTU3MTQwNSAyMS4wMzAxNzczIC0yNS40NjQ4NDM3NSAxNS4zMjAzMTI1IEMtMjYuMjE3MDIwNTkgMTEuNDI4OTQ4NjQgLTI1LjgyMjM5NTM5IDguMjE0MTkxNTkgLTI0LjMzOTg0Mzc1IDQuNTA3ODEyNSBDLTE4LjQ5MTUxODczIC0yLjMxNTIzMzM1IC04LjEzNzk4MzIgLTIuMjQ0MDcxNDQgMCAwIFogIiBmaWxsPSIjMDA4NDI5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxOTY5LjQ2NDg0Mzc1LDQwLjY3OTY4NzUpIi8+CjxwYXRoIGQ9Ik0wIDAgQzguOTEgMCAxNy44MiAwIDI3IDAgQzI3IDMuMyAyNyA2LjYgMjcgMTAgQzIxLjM5IDEwIDE1Ljc4IDEwIDEwIDEwIEMxMCAxMy42MyAxMCAxNy4yNiAxMCAyMSBDMTQuMjkgMjEgMTguNTggMjEgMjMgMjEgQzIzIDI0LjMgMjMgMjcuNiAyMyAzMSBDMTguNzEgMzEgMTQuNDIgMzEgMTAgMzEgQzEwIDM3LjkzIDEwIDQ0Ljg2IDEwIDUyIEM2LjcgNTIgMy40IDUyIDAgNTIgQzAgMzQuODQgMCAxNy42OCAwIDAgWiAiIGZpbGw9IiNEODFFMjYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDExMDEsNTIpIi8+CjxwYXRoIGQ9Ik0wIDAgQzIuOTcgMCA1Ljk0IDAgOSAwIEM5IDEzLjUzIDkgMjcuMDYgOSA0MSBDNS4zNyA0MSAxLjc0IDQxIC0yIDQxIEMtMy4yMTY4NzUgNDEuMjQ3NSAtNC40MzM3NSA0MS40OTUgLTUuNjg3NSA0MS43NSBDLTEwLjMxMDAyNjQxIDQyLjA5ODg2OTkyIC0xMy4zMDg5OTE4NSA0MC43MzUwMDM3OSAtMTcgMzggQy0yMC42ODY4MTg5NSAzMy4xNjEwNTAxMyAtMjAuNjk0NzYzNjEgMjcuODUzMTQ1NTEgLTIwIDIyIEMtMTguNzI2MDcyMzggMTguMzEyMzE0NzcgLTE3Ljc0NDY5MDYyIDE2LjU4MzY3NjQzIC0xNC42ODc1IDE0LjE4NzUgQy05LjYzMTE5NDU5IDExLjk1MzMxODU0IC02LjQ1NjIyNjA3IDExLjkwODc1NDc5IC0xIDEzIEMtMC42NyA4LjcxIC0wLjM0IDQuNDIgMCAwIFogTS05LjQzNzUgMjEuMDYyNSBDLTExLjI1OTI1OTU5IDI0LjQ4NzQwODAyIC0xMS42MzY3NDE4MyAyNi4xNzk1NDkgLTExIDMwIEMtOS40NTY2NDk3MSAzMi45NTA0NzU1MyAtOS40NTY2NDk3MSAzMi45NTA0NzU1MyAtNyAzNSBDLTQuNDE0MTc4NzIgMzUuNTg0MDIxMzMgLTQuNDE0MTc4NzIgMzUuNTg0MDIxMzMgLTIgMzUgQzAuMzI4NjYyMjkgMzMuMTExNTM4MTcgMC4zMjg2NjIyOSAzMy4xMTE1MzgxNyAwLjE5NTMxMjUgMjkuOTYwOTM3NSBDMC4xNzIxMDkzOCAyOC43Nzc1NzgxMiAwLjE0ODkwNjI1IDI3LjU5NDIxODc1IDAuMTI1IDI2LjM3NSBDMC4xMDY5NTMxMyAyNS4xODY0ODQzNyAwLjA4ODkwNjI1IDIzLjk5Nzk2ODc1IDAuMDcwMzEyNSAyMi43NzM0Mzc1IEMwLjA0NzEwOTM4IDIxLjg1ODIwMzEzIDAuMDIzOTA2MjUgMjAuOTQyOTY4NzUgMCAyMCBDLTUuMTAxNDUzNyAxOC41Nzg2MzU2MiAtNS4xMDE0NTM3IDE4LjU3ODYzNTYyIC05LjQzNzUgMjEuMDYyNSBaICIgZmlsbD0iIzAwODQyOSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjEzMSw0MCkiLz4KPHBhdGggZD0iTTAgMCBDOS45IDAgMTkuOCAwIDMwIDAgQzMwIDMuMyAzMCA2LjYgMzAgMTAgQzI2LjcgMTAgMjMuNCAxMCAyMCAxMCBDMjAgMjMuODYgMjAgMzcuNzIgMjAgNTIgQzE1LjA1IDUyLjQ5NSAxNS4wNSA1Mi40OTUgMTAgNTMgQzEwIDM4LjgxIDEwIDI0LjYyIDEwIDEwIEM2LjcgMTAgMy40IDEwIDAgMTAgQzAgNi43IDAgMy40IDAgMCBaICIgZmlsbD0iI0Q4MUUyNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA2Niw1MikiLz4KPHBhdGggZD0iTTAgMCBDLTAuNDgxMTQ5MSA1Ljc3Mzc4OTI1IC0yLjE4NDY3MTgxIDkuOTU4NTk4MzYgLTUgMTUgQy00LjMxOTM3NSAxNC4yOTg3NSAtMy42Mzg3NSAxMy41OTc1IC0yLjkzNzUgMTIuODc1IEMtMS45NjMyMDUxNCAxMS45MTE3MTQxMyAtMC45ODM1MTk0NiAxMC45NTM4NjU2MSAwIDEwIEMwLjU1NDI5Njg3IDkuNDYxMTcxODggMS4xMDg1OTM3NSA4LjkyMjM0Mzc1IDEuNjc5Njg3NSA4LjM2NzE4NzUgQzUuMjUwOTM2OCA1LjA4MTYzODE0IDcuODk2NjgzMzIgMi44ODQwMTU1MyAxMyAzIEMxNS4wMDY0OTYwNyA0LjUzNjM3NTAxIDE1Ljg3Mzg5MDQ5IDUuNTg4MTQ4NyAxNi42MTcxODc1IDguMDE1NjI1IEMxNy4yNTE1NjExIDEzLjUxMzUyOTUzIDE2Ljg0OTMwMTA3IDE3LjA2MTIxMTQ3IDE0IDIyIEMxMS4wNTUwNzk0MyAyNS40MDk5MDgwMyA4LjEyMTcwMjE1IDI4LjEzNTQyMDQ2IDQgMzAgQzEuNjY3MTQ1MiAzMC4wNDcyNTM5OSAtMC42NjcyNDM5MyAzMC4wNTE4OTk3MyAtMyAzMCBDLTMuMjY1NTQ2ODggMzEuMDczNzg5MDYgLTMuNTMxMDkzNzUgMzIuMTQ3NTc4MTIgLTMuODA0Njg3NSAzMy4yNTM5MDYyNSBDLTQuMTYxMzk0MjEgMzQuNjkwMTIwMSAtNC41MTgxNjg2NiAzNi4xMjYzMTcxMiAtNC44NzUgMzcuNTYyNSBDLTUuMDQ5MDIzNDQgMzguMjY2OTcyNjYgLTUuMjIzMDQ2ODggMzguOTcxNDQ1MzEgLTUuNDAyMzQzNzUgMzkuNjk3MjY1NjIgQy02LjUxMjk0ODE1IDQ0LjE2MDI0OTk4IC03LjcxMjAxMjE2IDQ4LjU4NDg3MDUyIC05IDUzIEMtMTMuODc1IDUxLjI1IC0xMy44NzUgNTEuMjUgLTE1IDQ5IEMtMTUuODA3NzM2NjkgNDEuNjExMTk1NTcgLTE0LjQ0MzM4Mzc0IDM1LjkyMzE3NjkzIC0xMS44NzEwOTM3NSAyOS4wNDI5Njg3NSBDLTEwLjkzNjk5MDk5IDI1Ljc3OTg5MjMxIC0xMC44OTM4OTA4MiAyMy4yNTE1MDY5MSAtMTEuMDYyNSAxOS44NzUgQy0xMS4zNDcwMDEzMyAxMi4zOTk0ODI0MiAtOC41MjkxMDMxNSA3LjAzNDkyMzc4IC0zLjgxMjUgMS4zNzUgQy0yIDAgLTIgMCAwIDAgWiBNMTAgMTAgQzcuOTU1NDM5NDEgMTIuMTcyNjQ2NTUgNy45NTU0Mzk0MSAxMi4xNzI2NDY1NSA1Ljg3NSAxNC44NzUgQzUuMTUwNTQ2ODggMTUuNzc5OTIxODcgNC40MjYwOTM3NSAxNi42ODQ4NDM3NSAzLjY3OTY4NzUgMTcuNjE3MTg3NSBDMS44MDc5NDc2NiAxOS43ODY1NTgxMSAxLjgwNzk0NzY2IDE5Ljc4NjU1ODExIDIgMjIgQzYuMDE1MzA1MDUgMjEuMDg3NDMwNjcgNy43MTEyODI3NSAyMC4zNDk0OTk4MyAxMC4zNzUgMTcuMTI1IEMxMi4zMDc1Njg0OSAxMy45OTU1NjM5MiAxMi4zMDc1Njg0OSAxMy45OTU1NjM5MiAxMiAxMCBDMTEuMzQgMTAgMTAuNjggMTAgMTAgMTAgWiAiIGZpbGw9IiMyMjFFMjAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDY2NSw3MCkiLz4KPHBhdGggZD0iTTAgMCBDMy4zIDAgNi42IDAgMTAgMCBDMTAgMTQuMTkgMTAgMjguMzggMTAgNDMgQzEzLjk2IDQzIDE3LjkyIDQzIDIyIDQzIEMyMy4zMiA0My4zMyAyNC42NCA0My42NiAyNiA0NCBDMjYgNDcuMyAyNiA1MC42IDI2IDU0IEMxMy4xMyA1My41MDUgMTMuMTMgNTMuNTA1IDAgNTMgQzAgMzUuNTEgMCAxOC4wMiAwIDAgWiAiIGZpbGw9IiNEODFFMjYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDExMzMsNTIpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuMyAwIDYuNiAwIDEwIDAgQzEwLjMzIDQuNjIgMTAuNjYgOS4yNCAxMSAxNCBDMTIuNTQ2ODc1IDEzLjQ0MzEyNSAxMi41NDY4NzUgMTMuNDQzMTI1IDE0LjEyNSAxMi44NzUgQzE4LjM5OTA1MzgzIDExLjkwOTg5MTA3IDIwLjEwMjI4MDU4IDEyLjEzOTcyNDgyIDI0IDE0IEMyNS45NTA0Njk0MiAxNS42MTQxODE1OSAyNi44NzAxODY5MyAxNi43NDAzNzM4NiAyOCAxOSBDMjguMDcxODE4MjEgMjEuNzE3NjAxMDggMjguMDkyOTk1MDYgMjQuNDA4NTkzODggMjguMDYyNSAyNy4xMjUgQzI4LjA1Nzk4ODI4IDI3Ljg3OTEwMTU2IDI4LjA1MzQ3NjU2IDI4LjYzMzIwMzEyIDI4LjA0ODgyODEyIDI5LjQxMDE1NjI1IEMyOC4wMzcwMzQ5OSAzMS4yNzM0NzEyNyAyOC4wMTkwOTk0MiAzMy4xMzY3NDU1NSAyOCAzNSBDMjMuNTQ1IDM1LjQ5NSAyMy41NDUgMzUuNDk1IDE5IDM2IEMxOC45Mzk0MTQwNiAzNS4wODQ3NjU2MyAxOC44Nzg4MjgxMiAzNC4xNjk1MzEyNSAxOC44MTY0MDYyNSAzMy4yMjY1NjI1IEMxOC43MzI2MTcxOSAzMi4wMzgwNDY4NyAxOC42NDg4MjgxMiAzMC44NDk1MzEyNSAxOC41NjI1IDI5LjYyNSBDMTguNDgxMjg5MDYgMjguNDQxNjQwNjMgMTguNDAwMDc4MTIgMjcuMjU4MjgxMjUgMTguMzE2NDA2MjUgMjYuMDM5MDYyNSBDMTguMTg5MTUwNjQgMjMuMDg0ODEwOTkgMTguMTg5MTUwNjQgMjMuMDg0ODEwOTkgMTcgMjEgQzE1LjMzMzg4MDk1IDIwLjk1NzI3OSAxMy42NjYxNzExNSAyMC45NTkzNjE2OCAxMiAyMSBDMTAuNDUwNDk3MzIgMjIuNTQ5NTAyNjggMTAuNzgzNDQ4MDcgMjQuMDk5OTA1OTQgMTAuNjgzNTkzNzUgMjYuMjUzOTA2MjUgQzEwLjY0MTY5OTIyIDI3LjEwNzkxMDE2IDEwLjU5OTgwNDY5IDI3Ljk2MTkxNDA2IDEwLjU1NjY0MDYyIDI4Ljg0MTc5Njg4IEMxMC41MTczMjQyMiAyOS43Mzk2Mjg5MSAxMC40NzgwMDc4MSAzMC42Mzc0NjA5NCAxMC40Mzc1IDMxLjU2MjUgQzEwLjM5NDMxNjQxIDMyLjQ2NDE5OTIyIDEwLjM1MTEzMjgxIDMzLjM2NTg5ODQ0IDEwLjMwNjY0MDYyIDM0LjI5NDkyMTg4IEMxMC4yMDAyMjAxNiAzNi41Mjk3NTE1NiAxMC4wOTk1NzUxOSAzOC43NjQ4NTQ4NiAxMCA0MSBDNi43IDQxIDMuNCA0MSAwIDQxIEMwIDI3LjQ3IDAgMTMuOTQgMCAwIFogIiBmaWxsPSIjMDA4NDI5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDA1LDQwKSIvPgo8cGF0aCBkPSJNMCAwIEM0LjI5IDAgOC41OCAwIDEzIDAgQzkuOTk1NDE0NiAxNi4wODQxMjA5OCA2Ljc1MDQyOTQ2IDMyLjA3MjY0NDI3IDMgNDggQy0xLjI5IDQ4IC01LjU4IDQ4IC0xMCA0OCBDLTkuMzUyMDc5OTYgNDIuMjQzMTY0OTggLTguMzkyNDE1OTEgMzYuNjQxMDIxMyAtNy4xODc1IDMwLjk3NjU2MjUgQy03LjAxMzcxODI2IDMwLjE0OTE3NTcyIC02LjgzOTkzNjUyIDI5LjMyMTc4ODk0IC02LjY2MDg4ODY3IDI4LjQ2OTMyOTgzIEMtNi4yOTYwMjY4NiAyNi43MzYyMTU3NCAtNS45Mjk1NTA3IDI1LjAwMzQ0MDc3IC01LjU2MTUyMzQ0IDIzLjI3MDk5NjA5IEMtNC45OTczNjgxOSAyMC42MTI1OTg0NyAtNC40Mzk3NTU1NCAxNy45NTI4ODU2NSAtMy44ODI4MTI1IDE1LjI5Mjk2ODc1IEMtMy41MjY0Mjg0MSAxMy42MDQwODUwMSAtMy4xNjk2NzA5OSAxMS45MTUyOCAtMi44MTI1IDEwLjIyNjU2MjUgQy0yLjY0NTgwODExIDkuNDMwNzc3ODkgLTIuNDc5MTE2MjEgOC42MzQ5OTMyOSAtMi4zMDczNzMwNSA3LjgxNTA5Mzk5IEMtMS4xMTUxOTMxMyAyLjIzMDM4NjI2IC0xLjExNTE5MzEzIDIuMjMwMzg2MjYgMCAwIFogIiBmaWxsPSIjMjIzMTc1IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg5OCw1NCkiLz4KPHBhdGggZD0iTTAgMCBDMCAzIDAgMyAtMSA1IEMtMS4yMTM3NzcyMSAxMC42MDcwMzIxMyAtMS4yMTM3NzcyMSAxMC42MDcwMzIxMyAwIDE2IEMwLjc1NDE0MjM1IDIyLjQ5MDU2OTM3IC0wLjI2NzY1MDE5IDI1LjU4MjA3Mjg1IC00IDMxIEMtMy45Mjc0OTIxNCAzNC41NTI4ODQ5NCAtMy4zMTc3NDE2NCAzNi40OTE2MTMzNyAtMS40Mzc1IDM5LjUgQzAuNDMyMjMyNTQgNDIuNzUxNzA4NzYgMC40OTI4MjA0OCA0NC4yNjg2NDQ5NCAwIDQ4IEMtMS4xNzkwNDA1IDUxLjQwNDQxNTYzIC0yLjU0MTk2MzU0IDU0LjcwNjM5OTc4IC00IDU4IEMtMTMuMDQyMzMyOTIgNTUuOTEzMzA3NzkgLTE5LjIzMTExMzk5IDQ5LjIyNDI2NTc5IC0yNC42ODc1IDQyLjExMzI4MTI1IEMtMjUuOTc2NzY1MDIgNDAuMDM3NDExMDkgLTI2LjU2ODUwMjU3IDM4LjM4OTQxNzA0IC0yNyAzNiBDLTIyLjM3NSAzMyAtMjIuMzc1IDMzIC0xOSAzMyBDLTE5IDMzLjk5IC0xOSAzNC45OCAtMTkgMzYgQy0xNi4wMjk4MjMwNiAzNS4zNzE4OTgyNyAtMTYuMDI5ODIzMDYgMzUuMzcxODk4MjcgLTEzIDM0IEMtMTEuODAxNjE3OTEgMzEuNjcxNDU1MzcgLTExLjgwMTYxNzkxIDMxLjY3MTQ1NTM3IC0xMSAyOSBDLTEwLjMyMzI0MjE5IDI4LjI5NDg4MjgxIC05LjY0NjQ4NDM4IDI3LjU4OTc2NTYyIC04Ljk0OTIxODc1IDI2Ljg2MzI4MTI1IEMtNi4yODY2NTkzNyAyMi45NTIxNDY5MyAtNi42NDc5NDA5OCAyMC4wOTMyNzg3OCAtNi45Mzc1IDE1LjUgQy03LjQ2Nzc4NzQgNi4zMzQ3MzQyNSAtNy40Njc3ODc0IDYuMzM0NzM0MjUgLTQgMiBDLTEuODEyNSAwLjY4NzUgLTEuODEyNSAwLjY4NzUgMCAwIFogIiBmaWxsPSIjMTg3MjRFIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzQ4LDYwKSIvPgo8cGF0aCBkPSJNMCAwIEM0LjIyNzM1OTE0IDUuMDI2MTMzNCA0LjM0Mzc1IDYuNjc1NjQ0OTEgNC4zNDM3NSAxMy41OTc2NTYyNSBDLTEuOTI2MjUgMTMuNTk3NjU2MjUgLTguMTk2MjUgMTMuNTk3NjU2MjUgLTE0LjY1NjI1IDEzLjU5NzY1NjI1IEMtMTIuMzAwNDg3NzkgMTguNzcwMzg3NjYgLTEyLjMwMDQ4Nzc5IDE4Ljc3MDM4NzY2IC04LjUzMTI1IDE5LjU5NzY1NjI1IEMtMy43NTI5OTc1NyAxOS41OTc2NTYyNSAtMC4wNTEzNDIxNSAxOC4zNjE2NzI4MyA0LjM0Mzc1IDE2LjU5NzY1NjI1IEM0LjY1NjI1IDE5LjQxMDE1NjI1IDQuNjU2MjUgMTkuNDEwMTU2MjUgNC4zNDM3NSAyMi41OTc2NTYyNSBDMC45MDEyMjIwNSAyNS45MjU0MzMyNyAtMy40MTQ1NjU0OCAyNi4zMjk5Njg0IC04LjAyMzQzNzUgMjYuNjYwMTU2MjUgQy0xMy42ODcyNjY0IDI2LjUyNTcwMzM0IC0xOC4xMzQxNTE4MiAyNS4xMTk3NTQ0MyAtMjIuMTU2MjUgMjEuMDk3NjU2MjUgQy0yNC43NzM1ODM1MyAxNi43MzU0MzM3IC0yNS4zMTY1NTAzOCAxMi41OTU3NjMyOCAtMjQuNjU2MjUgNy41OTc2NTYyNSBDLTIzLjI5NDg1NjcgMy44NjEyMjM1NSAtMjEuNDAxMzMxNDIgMS4xNzA3OTU4IC0xOC4yMTg3NSAtMS4yNzczNDM3NSBDLTEyLjMxODQ0Njg5IC0zLjg2NzcyMDcyIC01LjI1NTA1Mjk0IC00LjQ0OTQ0MzQxIDAgMCBaIE0tMTMuNjU2MjUgNC41OTc2NTYyNSBDLTEzLjk4NjI1IDUuOTE3NjU2MjUgLTE0LjMxNjI1IDcuMjM3NjU2MjUgLTE0LjY1NjI1IDguNTk3NjU2MjUgQy0xMS4wMjYyNSA4LjU5NzY1NjI1IC03LjM5NjI1IDguNTk3NjU2MjUgLTMuNjU2MjUgOC41OTc2NTYyNSBDLTQuOTgzMjM1NTkgMy42NzQ2NDYzMyAtNC45ODMyMzU1OSAzLjY3NDY0NjMzIC03LjUzMTI1IDIuNjYwMTU2MjUgQy0xMC4yMTA5NzMzNSAyLjU4MTM0MDg2IC0xMS40ODU2NTkxNSAzLjAyNTg0OTA4IC0xMy42NTYyNSA0LjU5NzY1NjI1IFogIiBmaWxsPSIjMDA4NDI5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDkxLjY1NjI1LDU1LjQwMjM0Mzc1KSIvPgo8cGF0aCBkPSJNMCAwIEMzLjUyMDkwNTk1IDQuNTExMTYwNzUgMyA2LjQxMTcwNDg5IDMgMTIuNTYyNSBDLTMuMjcgMTIuNTYyNSAtOS41NCAxMi41NjI1IC0xNiAxMi41NjI1IEMtMTMuNjQ0MjM3NzkgMTcuNzM1MjMxNDEgLTEzLjY0NDIzNzc5IDE3LjczNTIzMTQxIC05Ljg3NSAxOC41NjI1IEMtNS4wOTY3NDc1NyAxOC41NjI1IC0xLjM5NTA5MjE1IDE3LjMyNjUxNjU4IDMgMTUuNTYyNSBDMy4zMTI1IDE4LjM3NSAzLjMxMjUgMTguMzc1IDMgMjEuNTYyNSBDLTAuNDQyNTI3OTUgMjQuODkwMjc3MDIgLTQuNzU4MzE1NDggMjUuMjk0ODEyMTUgLTkuMzY3MTg3NSAyNS42MjUgQy0xNS4wMzEwMTY0IDI1LjQ5MDU0NzA5IC0xOS40Nzc5MDE4MiAyNC4wODQ1OTgxOCAtMjMuNSAyMC4wNjI1IEMtMjYuMTE3MzMzNTMgMTUuNzAwMjc3NDUgLTI2LjY2MDMwMDM4IDExLjU2MDYwNzAzIC0yNiA2LjU2MjUgQy0yNC42Mzg2MDY3IDIuODI2MDY3MyAtMjIuNzQ1MDgxNDIgMC4xMzU2Mzk1NSAtMTkuNTYyNSAtMi4zMTI1IEMtMTIuNjA1NTU1NjYgLTUuMzY2NzY4MjUgLTUuOTgyNDU3MiAtNC44NjA3NDY0OCAwIDAgWiBNLTE1IDMuNTYyNSBDLTE1LjMzIDQuODgyNSAtMTUuNjYgNi4yMDI1IC0xNiA3LjU2MjUgQy0xMi4zNyA3LjU2MjUgLTguNzQgNy41NjI1IC01IDcuNTYyNSBDLTYuMzI2OTg1NTkgMi42Mzk0OTAwOCAtNi4zMjY5ODU1OSAyLjYzOTQ5MDA4IC04Ljg3NSAxLjYyNSBDLTExLjU1NDcyMzM1IDEuNTQ2MTg0NjEgLTEyLjgyOTQwOTE1IDEuOTkwNjkyODMgLTE1IDMuNTYyNSBaICIgZmlsbD0iIzAwODQyOSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjE2OSw1Ni40Mzc1KSIvPgo8cGF0aCBkPSJNMCAwIEMzLjMgMCA2LjYgMCAxMCAwIEMxMCAxOC4xNSAxMCAzNi4zIDEwIDU1IEM3LjAzIDU1IDQuMDYgNTUgMSA1NSBDMCA1NCAwIDU0IC0wLjEyMDI1NDUyIDUxLjgyOTY5NjY2IEMtMC4xMTgwMzM5MSA1MC44NzI2MTMwNyAtMC4xMTU4MTMyOSA0OS45MTU1Mjk0OCAtMC4xMTM1MjUzOSA0OC45Mjk0NDMzNiBDLTAuMTEzNDQ5ODYgNDcuODQ4Mzk4MjggLTAuMTEzMzc0MzMgNDYuNzY3MzUzMjEgLTAuMTEzMjk2NTEgNDUuNjUzNTQ5MTkgQy0wLjEwODEzNTIyIDQ0LjQ3NzUyNjQgLTAuMTAyOTczOTQgNDMuMzAxNTAzNiAtMC4wOTc2NTYyNSA0Mi4wODk4NDM3NSBDLTAuMDk2MjQxMyA0MC44OTI2NzIyNyAtMC4wOTQ4MjYzNSAzOS42OTU1MDA3OSAtMC4wOTMzNjg1MyAzOC40NjIwNTEzOSBDLTAuMDg3NzQ5NzkgMzQuNjIwNTA5MzQgLTAuMDc1MTk0MTEgMzAuNzc5MDI0NTcgLTAuMDYyNSAyNi45Mzc1IEMtMC4wNTc0ODc0MSAyNC4zNDA0OTU2MyAtMC4wNTI5MjQwOSAyMS43NDM0OTAzNSAtMC4wNDg4MjgxMiAxOS4xNDY0ODQzOCBDLTAuMDM3Nzc0MjcgMTIuNzY0MzAwNjggLTAuMDIwNDk3MDggNi4zODIxNjAwNyAwIDAgWiAiIGZpbGw9IiNEODFGMjUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDExNjYsNTIpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuMyAwIDYuNiAwIDEwIDAgQzEwIDAuNjYgMTAgMS4zMiAxMCAyIEMxMC45OSAxLjM0IDExLjk4IDAuNjggMTMgMCBDMTYuMzkyMTAyODcgLTAuNTQ2MTg2MDYgMTkuNjA2NTQzNSAtMC41MzU4MDg5MiAyMyAwIEMyNi42MTk5NTgyMSAyLjY1OTU2MTEzIDI4LjIwNjgzODE3IDQuNjQ4NDIzNTEgMjkgOSBDMjkuMDc4MTg2MzYgMTAuNTEzOTU2OTYgMjkuMTA3ODk5MDkgMTIuMDMwOTM1MDcgMjkuMDk3NjU2MjUgMTMuNTQ2ODc1IEMyOS4wOTQ0MzM1OSAxNC4zOTEyMTA5NCAyOS4wOTEyMTA5NCAxNS4yMzU1NDY4NyAyOS4wODc4OTA2MiAxNi4xMDU0Njg3NSBDMjkuMDc5NTExNzIgMTYuOTc4MTY0MDYgMjkuMDcxMTMyODEgMTcuODUwODU5MzcgMjkuMDYyNSAxOC43NSBDMjkuMDU3OTg4MjggMTkuNjM4MTY0MDYgMjkuMDUzNDc2NTYgMjAuNTI2MzI4MTIgMjkuMDQ4ODI4MTIgMjEuNDQxNDA2MjUgQzI5LjAzNzA3NDIyIDIzLjYyNzYzMzE2IDI5LjAxOTEzOTY2IDI1LjgxMzgyNTI4IDI5IDI4IEMyNS43IDI4IDIyLjQgMjggMTkgMjggQzE4LjUwNSAxOC4xIDE4LjUwNSAxOC4xIDE4IDggQzE2LjY4IDcuNjcgMTUuMzYgNy4zNCAxNCA3IEMxMy4wMSA3LjY2IDEyLjAyIDguMzIgMTEgOSBDMTAuNDE0MDczNjYgMTIuMTE2MTA1NTQgMTAuNDE0MDczNjYgMTIuMTE2MTA1NTQgMTAuMzEyNSAxNS42MjUgQzEwLjI0Njc1NzgxIDE2LjgxMzUxNTYzIDEwLjE4MTAxNTYzIDE4LjAwMjAzMTI1IDEwLjExMzI4MTI1IDE5LjIyNjU2MjUgQzEwLjA3NTg5ODQ0IDIwLjE0MTc5Njg3IDEwLjAzODUxNTYyIDIxLjA1NzAzMTI1IDEwIDIyIEM2LjcgMjEuNjcgMy40IDIxLjM0IDAgMjEgQzAgMTQuMDcgMCA3LjE0IDAgMCBaICIgZmlsbD0iIzAwODQyOSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjAzNiw1MykiLz4KPHBhdGggZD0iTTAgMCBDNy44MjQzNDA1OCAtMC4xMTcwMzA3NCA3LjgyNDM0MDU4IC0wLjExNzAzMDc0IDEwLjQ4ODI4MTI1IDIuNDE0MDYyNSBDMTIuNzg3NDM3MTMgNi4yMDk3NTk4NSAxMy43NDA2OTg2IDkuNTU1ODA4MzkgMTMgMTQgQzExLjk1MTAwNjYgMTUuNzE2NTM0NjYgMTAuOTAxMjc3MjcgMTcuNDMyNzI1OTggOS44MzIwMzEyNSAxOS4xMzY3MTg3NSBDOC4yODEzNDc3OCAyMi42MDkzNzYxMSA5LjE2NDUxNTkyIDI1LjM1OTY3NjUzIDEwIDI5IEMxMC4zNTA2MjUgMjkuNzAxMjUgMTAuNzAxMjUgMzAuNDAyNSAxMS4wNjI1IDMxLjEyNSBDMTIuMzk2NjM0OTIgMzMuNzkzMjY5ODUgMTIuMTk1NTczOTMgMzYuMDY2MzkwOTggMTIgMzkgQzExIDQwIDExIDQwIDguMTI4OTA2MjUgNDAuMTMyODEyNSBDNi45NTE5OTIxOSA0MC4xMzAyMzQzOCA1Ljc3NTA3ODEyIDQwLjEyNzY1NjI1IDQuNTYyNSA0MC4xMjUgQzMuMzg4MTY0MDYgNDAuMTI3NTc4MTIgMi4yMTM4MjgxMiA0MC4xMzAxNTYyNSAxLjAwMzkwNjI1IDQwLjEzMjgxMjUgQy0yIDQwIC0yIDQwIC00IDM5IEMtMy4yNDgxNzUxOCAzMS40ODE3NTE4MiAtMy4yNDgxNzUxOCAzMS40ODE3NTE4MiAtMS45Mzc1IDI4LjkzNzUgQy0wLjQzNzQ4NjY0IDI1LjgzNzQ3MjM5IC0wLjY0OTM5MDYgMjMuMzg5MjI0MiAtMSAyMCBDLTIuMzE0MzE2OTUgMTcuOTg3NDUyMTggLTMuNjQ3MjE4ODUgMTUuOTg2ODk3MzEgLTUgMTQgQy01Ljg1NTE0NzQgOS42MjkyNDY2MSAtNC43NjA4MzQzNiA3LjI4MzU1ODE3IC0yLjUgMy42MjUgQy0xLjY3OTQ5NTggMi40MDc5MTg3NiAtMC44NTAyODE2NCAxLjE5NjQ2NzczIDAgMCBaICIgZmlsbD0iI0ZBRkJGQiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM1Nyw4MikiLz4KPHBhdGggZD0iTTAgMCBDMy45MDkzODcwMyAzLjczOTQxMzY4IDMuOTA5Mzg3MDMgMy43Mzk0MTM2OCA0LjEzMjgxMjUgNi44NDc2NTYyNSBDNC4xMzAyMzQzOCA3LjU3ODU1NDY5IDQuMTI3NjU2MjUgOC4zMDk0NTMxMyA0LjEyNSA5LjA2MjUgQzQuMTIzNzEwOTQgOS44NjU1ODU5NCA0LjEyMjQyMTg4IDEwLjY2ODY3MTg4IDQuMTIxMDkzNzUgMTEuNDk2MDkzNzUgQzQuMDAyNzk5MjggMTMuOTQyMTE4MSAzLjYyMDk4NDQgMTYuMjE4MTI5NDkgMy4xODc1IDE4LjYyNSBDMi43MDMyNTg3MiAyMi4yNzU5MjQ0MiAzLjIxMzk4MTIzIDIzLjg4MzIwMTQgNS40Mzc1IDI2LjgxMjUgQzUuOTEwNTg1OTQgMjcuMzM0NTcwMzEgNi4zODM2NzE4NyAyNy44NTY2NDA2MiA2Ljg3MTA5Mzc1IDI4LjM5NDUzMTI1IEM4IDMwIDggMzAgOCAzNCBDOC42NiAzNCA5LjMyIDM0IDEwIDM0IEM3Ljk4MzAzMjM0IDI5LjA1NjczNDA2IDcuOTgzMDMyMzQgMjkuMDU2NzM0MDYgNS4yNSAyNC41IEMzLjUwMjExMTMyIDIxLjAwNDIyMjYzIDQuMzAxODA1ODYgMTguODA4MzMxNjUgNSAxNSBDNS4yMjA5MzE1MSAxMC40OTc1NjgxMyA1LjIzOTU1NzQ5IDYuMzU4MTI2NzUgNCAyIEM3LjQ0NTAwNjYgNC45MzU2NjQyMyA3LjU3NDgyNDY0IDcuMjU3NDQyOTQgNy45Njg3NSAxMS41OTc2NTYyNSBDNy45OTg4MzUyIDEzLjkxMDQ1NTggNy43MDc4ODYzOCAxNS44NjYzODczNSA3LjI1IDE4LjEyNSBDNi45ODQxMjA2MSAyMi4yNDYxMzA1MyA3LjEwOTg0MDQyIDIyLjY4NTU3NDIyIDkuNDM3NSAyNS43NSBDOS45MTA1ODU5NCAyNi4yODEwOTM3NSAxMC4zODM2NzE4NyAyNi44MTIxODc1IDEwLjg3MTA5Mzc1IDI3LjM1OTM3NSBDMTIgMjkgMTIgMjkgMTIgMzMgQzE0LjMxIDMzLjY2IDE2LjYyIDM0LjMyIDE5IDM1IEMxOSAzNS45OSAxOSAzNi45OCAxOSAzOCBDMTkuNjM5Mzc1IDM4LjI4ODc1IDIwLjI3ODc1IDM4LjU3NzUgMjAuOTM3NSAzOC44NzUgQzIzIDQwIDIzIDQwIDI0IDQyIEMxOS4yNDAwNTc5OSA0OC4wNjgxMzc5OSAxMy45MjU3ODgzNiA1My40MjgxMzM2MyA3IDU3IEM0IDU2IDQgNTYgMi43OTY4NzUgNTMuOTI1NzgxMjUgQy0wLjc2MDI4NTczIDQ1LjA0NjE1MjQyIC0wLjc2MDI4NTczIDQ1LjA0NjE1MjQyIDEgNDAgQzEuNTE1NjI1IDM5LjE3NSAyLjAzMTI1IDM4LjM1IDIuNTYyNSAzNy41IEM0LjM4NzAyNzU2IDM0LjMyNjkwODU4IDQuNTE2NDQxMTggMzIuNjE1MDg4MjUgNCAyOSBDMy4zNCAyOC4wMzA2MjUgMi42OCAyNy4wNjEyNSAyIDI2LjA2MjUgQy0wLjQxMDU3NzgyIDIyLjM3MTMwMjcyIC0wLjQwODMyNzU1IDIwLjMyODI3MTk5IDAgMTYgQzAuMzMgMTUuMDEgMC42NiAxNC4wMiAxIDEzIEMxLjA5MjQ3MzgxIDExLjUyMzEzODg5IDEuMTI5OTkwNzEgMTAuMDQyMjQ0OTkgMS4xMjUgOC41NjI1IEMxLjEyODg2NzE5IDcuNDE5NzQ2MDkgMS4xMjg4NjcxOSA3LjQxOTc0NjA5IDEuMTMyODEyNSA2LjI1MzkwNjI1IEMxLjAwMjc2MDE1IDQuMDQ2ODQxNDEgMC42MDg1NjE5OSAyLjEyMDMwNzI0IDAgMCBaICIgZmlsbD0iIzI5N0Q1QiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM3NCw2MSkiLz4KPHBhdGggZD0iTTAgMCBDMCAyLjY0IDAgNS4yOCAwIDggQy0wLjk5IDcuNjcgLTEuOTggNy4zNCAtMyA3IEMtNi41NTg4MDA1MSA2LjYyNjg5OTk1IC05LjgyNzU4NTIyIDYuMzQwNTE2NjkgLTEzIDguMTI1IEMtMTQuNDYyMjEyMTcgMTAuODY2NjQ3ODEgLTE0LjMxODMzNzMzIDEyLjk0Mzk2MTYyIC0xNCAxNiBDLTEyLjMyMDg1NTg1IDE5LjIyNTQwMTU2IC0xMi4zMjA4NTU4NSAxOS4yMjU0MDE1NiAtOS4zMTI1IDE5Ljc1IEMtNS43MDcwOTgyNCAyMC4wMjIxMDU3OSAtMi41NTAxMDA2NiAxOS42MzkwMTgxMiAxIDE5IEMxIDIxLjMxIDEgMjMuNjIgMSAyNiBDLTYuMzQ1MjM2NzIgMjguMjcwMzQ1ODkgLTEyLjM4MTY4ODY4IDI4Ljg3NjE2MTQyIC0xOS4zNzUgMjUuMjUgQy0yMi44MjkzNDgyMSAyMi4yODkxMzAxIC0yNC42OTA4NzcyNCAyMC4yNzgzNDkyMiAtMjUuMzE2NDA2MjUgMTUuNjY3OTY4NzUgQy0yNS41ODIxMzY1MiA5Ljk1MDQ4MTkxIC0yNC45Njg0NzE1MiA2LjM5NzQ5NTQ3IC0yMSAyIEMtMTQuMTcwMDE0MTEgLTMuMjEyMzU3NjUgLTcuODE4OTkzNjcgLTEuODY5NzU5MzYgMCAwIFogIiBmaWxsPSIjMDA4NDI5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDAyLDU0KSIvPgo8cGF0aCBkPSJNMCAwIEMzIDMuMTkwMzcxOTkgMyAzLjE5MDM3MTk5IDMgNiBDLTAuMDkyNjI3NjcgNy41NDYzMTM4NCAtMy4zNjcwODkxIDcuMzkwNjA3MTYgLTYuNzg1MTU2MjUgNy42MjEwOTM3NSBDLTcuODgxNTAzOTEgNy44MDg2NTIzNCAtNy44ODE1MDM5MSA3LjgwODY1MjM0IC05IDggQy05LjMzIDguNjYgLTkuNjYgOS4zMiAtMTAgMTAgQy03LjY5IDEwLjMzIC01LjM4IDEwLjY2IC0zIDExIEMtMi40Mzc1IDEyLjkzNzUgLTIuNDM3NSAxMi45Mzc1IC0yIDE1IEMtMyAxNiAtMyAxNiAtNS4yODUxNTYyNSAxNi4wOTc2NTYyNSBDLTYuNjU5OTQxNDEgMTYuMDgwMjUzOTEgLTYuNjU5OTQxNDEgMTYuMDgwMjUzOTEgLTguMDYyNSAxNi4wNjI1IEMtOC45ODE2MDE1NiAxNi4wNTM0NzY1NiAtOS45MDA3MDMxMiAxNi4wNDQ0NTMxMyAtMTAuODQ3NjU2MjUgMTYuMDM1MTU2MjUgQy0xMS41NTc5Mjk2OSAxNi4wMjM1NTQ2OSAtMTIuMjY4MjAzMTMgMTYuMDExOTUzMTMgLTEzIDE2IEMtMTMuMzMgMTcuNjUgLTEzLjY2IDE5LjMgLTE0IDIxIEMtMTIuNzYyNSAyMC42NDkzNzUgLTExLjUyNSAyMC4yOTg3NSAtMTAuMjUgMTkuOTM3NSBDLTcuMDk2NzA4IDE5LjA0NDA2NzI3IC01LjEzMjI1ODM2IDE4Ljk5MTE4NzA2IC0yIDIwIEMtMS42NyAyMS4zMiAtMS4zNCAyMi42NCAtMSAyNCBDLTcuMDgzMDUwMzggMjguMTkwNTQ1ODIgLTExLjYyMjE1Nzc3IDI5Ljk3NTQ2ODkgLTE5IDI5IEMtMjEuMDYyNSAyNy4zNzUgLTIxLjA2MjUgMjcuMzc1IC0yMiAyNSBDLTIyLjU2NDA4OTkgMjAuMDM2MDA4OTIgLTIxLjQ2ODAwNjg0IDE1LjcxMzA3NDU4IC0yMCAxMSBDLTE4LjM3NSA5IC0xOC4zNzUgOSAtMTcgOCBDLTE3LjQ5NSA3LjU2Njg3NSAtMTcuOTkgNy4xMzM3NSAtMTguNSA2LjY4NzUgQy0yMCA1IC0yMCA1IC0yMCAyIEMtNi4wODE1NDUwNiAtMS4zMTY3MzgyIC02LjA4MTU0NTA2IC0xLjMxNjczODIgMCAwIFogIiBmaWxsPSIjMjIxRTIwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2NTIsNzEpIi8+CjxwYXRoIGQ9Ik0wIDAgQzIgMiAyIDIgMi4zMTI1IDUuMTg3NSBDMS45Njk4MjgxOCA5LjM2ODA5NjIyIDAuNjY2NjA4NjQgMTIuMTgwNjg4NTMgLTEgMTYgQy0xLjU4NzYzMjQ0IDIwLjExMzQyNzEgLTEuMzMwNDM1NTggMjEuNTA0MzQ2NjQgMSAyNSBDMy4zMzQ1ODYzNSAyOC41MDE4Nzk1MyAzLjY3MjYwNzI3IDI5Ljg4MDI4MDQ3IDMgMzQgQzEuOTUxMDA2NiAzNS43MTY1MzQ2NiAwLjkwMTI3NzI3IDM3LjQzMjcyNTk4IC0wLjE2Nzk2ODc1IDM5LjEzNjcxODc1IEMtMS43MTg2NTIyMiA0Mi42MDkzNzYxMSAtMC44MzU0ODQwOCA0NS4zNTk2NzY1MyAwIDQ5IEMwLjM1MDYyNSA0OS43MDEyNSAwLjcwMTI1IDUwLjQwMjUgMS4wNjI1IDUxLjEyNSBDMi4zODM4NTAwOCA1My43Njc3MDAxNyAyLjEzMjA5ODM3IDU2LjA5MzgzNTkxIDIgNTkgQzEuMDEgNTkgMC4wMiA1OSAtMSA1OSBDLTEuMjg4NzUgNTcuNzgzMTI1IC0xLjU3NzUgNTYuNTY2MjUgLTEuODc1IDU1LjMxMjUgQy0yLjQ4MDE5MTExIDUyLjgzMDc4MTA3IC0zLjEwNzk3MDM0IDUwLjc2NzAxMTM3IC00LjE4NzUgNDguNDM3NSBDLTUuMzQyMzE4NDQgNDQuOTczMDQ0NjggLTQuODE4NjU2ODYgNDIuNTI2NTIxODcgLTQgMzkgQy0zLjIyNjU2MjUgMzcuNzMxNTYyNSAtMy4yMjY1NjI1IDM3LjczMTU2MjUgLTIuNDM3NSAzNi40Mzc1IEMtMC42MTEwNTMyMSAzMy4zNDA0ODE1MiAtMC41NTY2MDA4MSAzMS41NDcxOTM1MyAtMSAyOCBDLTIuNDI2MjE2ODQgMjUuMjg4NzM2MTYgLTIuNDI2MjE2ODQgMjUuMjg4NzM2MTYgLTQgMjMgQy00IDIyLjM0IC00IDIxLjY4IC00IDIxIEMtNi45NyAyMSAtOS45NCAyMSAtMTMgMjEgQy0xNi44OTY3Nzg1MSAyNy4wMDIyMTQ0NSAtMTYuODk2Nzc4NTEgMjcuMDAyMjE0NDUgLTE3IDM0IEMtMTYuMzQgMzQuOTY5Mzc1IC0xNS42OCAzNS45Mzg3NSAtMTUgMzYuOTM3NSBDLTEyLjUzNTY0NjkzIDQwLjcxMTA0MDY0IC0xMi40NTUwODUxNiA0Mi41NjI4MzYyOCAtMTMgNDcgQy0xMy45MzU3ODk5NSA0OS4zNTk4MTgxMyAtMTQuOTMzNDc4MDggNTEuNjk2MzEyNjQgLTE2IDU0IEMtMTYuNjkxNDA1MjIgNTYuNzc4ODg2MTMgLTE2LjY5MTQwNTIyIDU2Ljc3ODg4NjEzIC0xNyA1OSBDLTE3Ljk5IDU5IC0xOC45OCA1OSAtMjAgNTkgQy0yMC4yNTgxMzMwMiA1NS4zODYxMzc3NCAtMjAuMTY4MTU2NjcgNTMuMzI5MzA2OCAtMTguNSA1MC4wNjI1IEMtMTYuNjczNDE0OTMgNDYuMzMzMjIyMTUgLTE2LjQ4NjE3MTMzIDQ0LjExMDYyOTM5IC0xNyA0MCBDLTE4LjMxNDMxNjk1IDM3Ljk4NzQ1MjE4IC0xOS42NDcyMTg4NSAzNS45ODY4OTczMSAtMjEgMzQgQy0yMS41IDMxIC0yMS41IDMxIC0yMSAyOCBDLTIwLjMxOTM3NSAyNy4wNzE4NzUgLTE5LjYzODc1IDI2LjE0Mzc1IC0xOC45Mzc1IDI1LjE4NzUgQy0xNi4yOTQzMTIzNCAyMC44MzkwMjk5NyAtMTYuODYxMjA4MTUgMTcuODI0MTczMzMgLTE4IDEzIEMtMTguNjU5OTY3OSAxMS4zMzA2Njk0MiAtMTkuMzI1NTg4NjkgOS42NjM1NDc5IC0yMCA4IEMtMjAuMTI1IDQuNjg3NSAtMjAuMTI1IDQuNjg3NSAtMjAgMiBDLTE5LjM0IDIgLTE4LjY4IDIgLTE4IDIgQy0xOCAyLjY2IC0xOCAzLjMyIC0xOCA0IEMtMTYuNjggNCAtMTUuMzYgNCAtMTQgNCBDLTE0IDQuNjYgLTE0IDUuMzIgLTE0IDYgQy0xNC45OSA2IC0xNS45OCA2IC0xNyA2IEMtMTUuOTcwMjgxNCAxMS4yMzU1MDE3NyAtMTUuOTcwMjgxNCAxMS4yMzU1MDE3NyAtMTMuNzUgMTYgQy0xMC45NzQxNDAxOSAxNy41ODYyMDU2MSAtOS4xMjcxMzUyNSAxNy41MTA1NTI2OSAtNiAxNyBDLTIuMzk2ODM5NzggMTMuNjg4OTg3OTEgLTEuNDQ3Mjk0NzYgMTAuODA4NDE4NyAtMSA2IEMtMy4zMSA2LjMzIC01LjYyIDYuNjYgLTggNyBDLTguMDQyNzIxIDUuMzMzODgwOTUgLTguMDQwNjM4MzIgMy42NjYxNzExNSAtOCAyIEMtNS45NTQ0Nzk1OCAtMC4wNDU1MjA0MiAtMi43Mjk0MTkxNCAwLjIzOTQyMjczIDAgMCBaICIgZmlsbD0iIzIyNzg1NSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM3MCw2MikiLz4KPHBhdGggZD0iTTAgMCBDMC45NDg3NSAwLjY2IDEuODk3NSAxLjMyIDIuODc1IDIgQzMuMzAxNTM3MjcgNi4zNTA2ODAxOCAzLjQ1MjcyODcyIDguMjkzODg3MTIgMC42MjUgMTEuNzUgQy0wLjI4MjUgMTIuNDkyNSAtMS4xOSAxMy4yMzUgLTIuMTI1IDE0IEMtMi43MDYzNjcxOSAxNC41MTY5MTQwNiAtMy4yODc3MzQzOCAxNS4wMzM4MjgxMiAtMy44ODY3MTg3NSAxNS41NjY0MDYyNSBDLTYuNzk2MjA2MzYgMTcuNDI5OTAwMDYgLTkuMjc0ODQ0NzUgMTcuNzMzMjU1NzkgLTEyLjY4NzUgMTguMTg3NSBDLTEzLjgyMzE2NDA2IDE4LjM0NjA1NDY5IC0xNC45NTg4MjgxMiAxOC41MDQ2MDkzOCAtMTYuMTI4OTA2MjUgMTguNjY3OTY4NzUgQy0xOS4xMjUgMTkgLTE5LjEyNSAxOSAtMjIuMTI1IDE5IEMtMjMuOTMxNDYxMTggMTUuMzg3MDc3NjQgLTI1LjEyNSAxMi45OTMwMDYgLTI1LjEyNSA4LjkzNzUgQy0yMy41NjkwNzIyNyA0LjM2Njk2MjI5IC0yMS4wMzM3Mjg5IDEuMTk5NzcyNDUgLTE2LjkzNzUgLTEuMzc1IEMtMTEuMDE1MDAyNTMgLTIuNjkxMTEwNTUgLTUuMzkzODE5MTMgLTMuMDkxNTc5MjYgMCAwIFogTS0xOC4xMjUgNSBDLTE4Ljc4NSA2LjMyIC0xOS40NDUgNy42NCAtMjAuMTI1IDkgQy0xOC44MDUgNy42OCAtMTcuNDg1IDYuMzYgLTE2LjEyNSA1IEMtMTYuNzg1IDUgLTE3LjQ0NSA1IC0xOC4xMjUgNSBaIE0tMTIuMTI1IDkgQy0xMy45NTgwMDkwOSAxMS4xMDU3NTY0MyAtMTMuOTU4MDA5MDkgMTEuMTA1NzU2NDMgLTE1LjEyNSAxMyBDLTkuMzI4NzM4OTMgMTIuNjAwMjU3ODYgLTUuNzEwMjc1MzcgMTEuODk3NDg0MDcgLTEuMTI1IDggQy0xLjEyNSA3LjAxIC0xLjEyNSA2LjAyIC0xLjEyNSA1IEMtNS45NTc3NzI2OCA0LjQzMTQzODUxIC04LjM2ODA4Njg2IDYuMDU5ODA3MTEgLTEyLjEyNSA5IFogIiBmaWxsPSIjMjIxRTIwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1ODUuMTI1LDQ5KSIvPgo8cGF0aCBkPSJNMCAwIEMyLjk3IDAgNS45NCAwIDkgMCBDOS4zMyAxLjMyIDkuNjYgMi42NCAxMCA0IEMxMC41MTU2MjUgMy4zNCAxMS4wMzEyNSAyLjY4IDExLjU2MjUgMiBDMTQuODI2NDEzMTkgLTAuNjc4MDgyNjIgMTYuODgzOTk1MjUgLTAuMzgxMTExNTUgMjEgMCBDMjEuNjYgMC4zMyAyMi4zMiAwLjY2IDIzIDEgQzIyLjY3IDMuNjQgMjIuMzQgNi4yOCAyMiA5IEMxOSAxMCAxOSAxMCAxNy4wNjI1IDkuMzEyNSBDMTYuMzgxODc1IDkuMjA5Mzc1IDE1LjcwMTI1IDkuMTA2MjUgMTUgOSBDMTEuNjQ5OTE3OTUgMTEuNzc1NzgyMjcgMTAuMTM2Mzk1ODYgMTMuNjg5OTI2MiA5LjY4MzU5Mzc1IDE4LjAzOTA2MjUgQzkuNjAyMzgyODEgMTkuMjIyNDIxODcgOS41MjExNzE4OCAyMC40MDU3ODEyNSA5LjQzNzUgMjEuNjI1IEM5LjM1MzcxMDk0IDIyLjgxMzUxNTYzIDkuMjY5OTIxODcgMjQuMDAyMDMxMjUgOS4xODM1OTM3NSAyNS4yMjY1NjI1IEM5LjEyMzAwNzgxIDI2LjE0MTc5Njg3IDkuMDYyNDIxODcgMjcuMDU3MDMxMjUgOSAyOCBDNi4wMyAyOCAzLjA2IDI4IDAgMjggQzAgMTguNzYgMCA5LjUyIDAgMCBaICIgZmlsbD0iIzAwODQyOSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjE3Niw1MykiLz4KPHBhdGggZD0iTTAgMCBDMC40OTUgMS40ODUgMC40OTUgMS40ODUgMSAzIEMwLjAxIDMuOTkgLTAuOTggNC45OCAtMiA2IEMtMi43MjcwMzEyNSA1LjczNDQ1MzEzIC0zLjQ1NDA2MjUgNS40Njg5MDYyNSAtNC4yMDMxMjUgNS4xOTUzMTI1IEMtMjUuMTQ4Njk1MTMgLTIuMTYyNDkwMzQgLTQ1LjE2MzM2MjQ5IC0xLjA2MjQxOCAtNjYgNiBDLTY2LjMzIDQuMzUgLTY2LjY2IDIuNyAtNjcgMSBDLTQ4Ljc3Mzk1ODUzIC05LjkzNTYyNDg4IC0xOC43MTE0Nzg5MyAtOC4zODU4NDYyMiAwIDAgWiAiIGZpbGw9IiNFODIwMjYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4MjAsMzUpIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuNjYgMCAxLjMyIDAgMiAwIEMyLjMzIDEuNjUgMi42NiAzLjMgMyA1IEM0LjY1IDUgNi4zIDUgOCA1IEM3LjAxIDYuNDg1IDcuMDEgNi40ODUgNiA4IEM1LjgzMjg2NDMxIDEwLjYyNTMxNTI0IDUuODMyODY0MzEgMTAuNjI1MzE1MjQgNiAxMyBDNi45MDc1IDEyLjQ4NDM3NSA3LjgxNSAxMS45Njg3NSA4Ljc1IDExLjQzNzUgQzEyIDEwIDEyIDEwIDE0LjM3NSAxMC4zMTI1IEMxNC45MTEyNSAxMC41MzkzNzUgMTUuNDQ3NSAxMC43NjYyNSAxNiAxMSBDMTUuNjcgMTIuMzIgMTUuMzQgMTMuNjQgMTUgMTUgQzE2Ljk4IDE0LjY3IDE4Ljk2IDE0LjM0IDIxIDE0IEMxOS42OCAxNi42NCAxOC4zNiAxOS4yOCAxNyAyMiBDMTYuMjM4MTY0MDYgMjEuNzgzNDM3NSAxNS40NzYzMjgxMyAyMS41NjY4NzUgMTQuNjkxNDA2MjUgMjEuMzQzNzUgQzMuNTQ5MjExNDUgMTguMzM5MTEzMiAtMy45OTQ5NjA1MyAxOC41NDQyMTE5MSAtMTUgMjIgQy0xNi4zMiAxOS4zNiAtMTcuNjQgMTYuNzIgLTE5IDE0IEMtMTYuNjkgMTQuMzMgLTE0LjM4IDE0LjY2IC0xMiAxNSBDLTEyLjY2IDEzLjM1IC0xMy4zMiAxMS43IC0xNCAxMCBDLTEwLjI4MTExNzYxIDEwLjUwNzEyMDMzIC03LjI2NTQ1NzYxIDExLjExNjA4MjE1IC00IDEzIEMtMy43OTkxMzU1NyA5LjI4NDAwODA5IC0zLjg0ODA1NjMgOC4yMjc5MTU1NSAtNiA1IEMtNC4zNSA1IC0yLjcgNSAtMSA1IEMtMC42NyAzLjM1IC0wLjM0IDEuNyAwIDAgWiAiIGZpbGw9IiNGM0Y4RjYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNjAsMzcpIi8+CjxwYXRoIGQ9Ik0wIDAgQzEuNzQyMTY3OTcgMC4wNTQxNDA2MyAxLjc0MjE2Nzk3IDAuMDU0MTQwNjMgMy41MTk1MzEyNSAwLjEwOTM3NSBDNC4zOTk5NjA5NCAwLjE1NTc4MTI1IDUuMjgwMzkwNjMgMC4yMDIxODc1IDYuMTg3NSAwLjI1IEM1Ljg1NzUgMS45IDUuNTI3NSAzLjU1IDUuMTg3NSA1LjI1IEMzLjIwNzUgNS41OCAxLjIyNzUgNS45MSAtMC44MTI1IDYuMjUgQy0xLjA1MDMzMjAzIDcuMzU0MDgyMDMgLTEuMDUwMzMyMDMgNy4zNTQwODIwMyAtMS4yOTI5Njg3NSA4LjQ4MDQ2ODc1IEMtMi43NDE2MTc3NyAxNC41MzkxODMxOCAtMy44MTM2MDk0MSAxOC40MDQ2OTk1NSAtOC44MTI1IDIyLjI1IEMtMTEuNTc3MDIwMzMgMjMuNjMyMjYwMTYgLTEzLjg1ODYzNjMgMjMuMzQ1MjUzODcgLTE2LjkzNzUgMjMuMzEyNSBDLTE4LjAzMzIwMzEyIDIzLjMwMzQ3NjU2IC0xOS4xMjg5MDYyNSAyMy4yOTQ0NTMxMyAtMjAuMjU3ODEyNSAyMy4yODUxNTYyNSBDLTIxLjUyMjM4MjgxIDIzLjI2Nzc1MzkxIC0yMS41MjIzODI4MSAyMy4yNjc3NTM5MSAtMjIuODEyNSAyMy4yNSBDLTIyLjQ4MjUgMjEuNiAtMjIuMTUyNSAxOS45NSAtMjEuODEyNSAxOC4yNSBDLTE5LjgzMjUgMTcuOTIgLTE3Ljg1MjUgMTcuNTkgLTE1LjgxMjUgMTcuMjUgQy0xNS41ODE3NTc4MSAxNi4zNTc5Njg3NSAtMTUuMzUxMDE1NjIgMTUuNDY1OTM3NSAtMTUuMTEzMjgxMjUgMTQuNTQ2ODc1IEMtMTQuNzg3MTQ4NDQgMTMuMzc2NDA2MjUgLTE0LjQ2MTAxNTYzIDEyLjIwNTkzNzUgLTE0LjEyNSAxMSBDLTEzLjgxMTc1NzgxIDkuODM5ODQzNzUgLTEzLjQ5ODUxNTYyIDguNjc5Njg3NSAtMTMuMTc1NzgxMjUgNy40ODQzNzUgQy0xMC40NDExMzY5OSAwLjk5NjQ1MTA5IC02Ljc2ODAwODc1IC0wLjI3MzQ1NDkgMCAwIFogIiBmaWxsPSIjRjVGOUY2IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDM2LjgxMjUsODQuNzUpIi8+CjxwYXRoIGQ9Ik0wIDAgQzIuOTcgMCA1Ljk0IDAgOSAwIEM5IDkuMjQgOSAxOC40OCA5IDI4IEM2LjAzIDI4IDMuMDYgMjggMCAyOCBDMCAxOC43NiAwIDkuNTIgMCAwIFogIiBmaWxsPSIjMDA4NDJBIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDk5LDUzKSIvPgo8cGF0aCBkPSJNMCAwIEM0LjgwODE5NTIyIDAuMDEzNzU3MzUgNC44MDgxOTUyMiAwLjAxMzc1NzM1IDcuODEyNSAyLjg3NSBDOC40OTMxMjUgNC4xMTI1IDguNDkzMTI1IDQuMTEyNSA5LjE4NzUgNS4zNzUgQzYuODc3NSA1LjcwNSA0LjU2NzUgNi4wMzUgMi4xODc1IDYuMzc1IEMxLjg1NzUgOC4wMjUgMS41Mjc1IDkuNjc1IDEuMTg3NSAxMS4zNzUgQzQuNjUyNSAxMC44OCA0LjY1MjUgMTAuODggOC4xODc1IDEwLjM3NSBDOC42ODA5ODE3NSAxNC41MjAyNDY3MSA4LjMyNjA0MzA3IDE2LjE1NDk2MSA2LjA2MjUgMTkuNzUgQzMuMTg3NSAyMi4zNzUgMy4xODc1IDIyLjM3NSAwLjE4NzUgMjMuMTI1IEMtNC4xMzU1MDE1OSAyMi4wNDQyNDk2IC01LjQ3Mjc4ODMxIDIwLjA5MTAxMjY4IC03LjgxMjUgMTYuMzc1IEMtOC4xMjUgMTMgLTguMTI1IDEzIC03LjgxMjUgMTAuMzc1IEMtNS41MDI1IDEwLjM3NSAtMy4xOTI1IDEwLjM3NSAtMC44MTI1IDEwLjM3NSBDLTEuMTQyNSA5LjA1NSAtMS40NzI1IDcuNzM1IC0xLjgxMjUgNi4zNzUgQy00Ljc4MjUgNS44OCAtNC43ODI1IDUuODggLTcuODEyNSA1LjM3NSBDLTUuNjI4MjEwMTUgMC44NjA4MDA5NyAtNS4wOTkzMDg2NyAwLjE5NDExNzE3IDAgMCBaICIgZmlsbD0iI0U1RUZFQiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM2MC44MTI1LDU3LjYyNSkiLz4KPHBhdGggZD0iTTAgMCBDMTUuNTEgMCAzMS4wMiAwIDQ3IDAgQzQ3IDEuNjUgNDcgMy4zIDQ3IDUgQzMxLjQ5IDUgMTUuOTggNSAwIDUgQzAgMy4zNSAwIDEuNyAwIDAgWiAiIGZpbGw9IiMxRTcwQzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1OTUsNzIpIi8+CjxwYXRoIGQ9Ik0wIDAgQzQuNjIgMCA5LjI0IDAgMTQgMCBDMTQgMS4zMiAxNCAyLjY0IDE0IDQgQzEwLjcgNCA3LjQgNCA0IDQgQzQgNS45OCA0IDcuOTYgNCAxMCBDNy4zIDEwIDEwLjYgMTAgMTQgMTAgQzE0IDExLjMyIDE0IDEyLjY0IDE0IDE0IEMxMC43IDE0IDcuNCAxNCA0IDE0IEM0IDE1Ljk4IDQgMTcuOTYgNCAyMCBDNy4zIDIwIDEwLjYgMjAgMTQgMjAgQzE0LjMzIDIxLjMyIDE0LjY2IDIyLjY0IDE1IDI0IEMxMC4wNSAyNCA1LjEgMjQgMCAyNCBDMCAxNi4wOCAwIDguMTYgMCAwIFogIiBmaWxsPSIjMDA4NDI5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDU2LDg1KSIvPgo8cGF0aCBkPSJNMCAwIEMxNC41MiAwIDI5LjA0IDAgNDQgMCBDNDMuMzQgMS42NSA0Mi42OCAzLjMgNDIgNSBDMjguMTQgNSAxNC4yOCA1IDAgNSBDMCAzLjM1IDAgMS43IDAgMCBaICIgZmlsbD0iIzFFNzBDMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU0MSw5NCkiLz4KPHBhdGggZD0iTTAgMCBDMTMuODYgMCAyNy43MiAwIDQyIDAgQzQyLjY2IDEuNjUgNDMuMzIgMy4zIDQ0IDUgQzI5LjQ4IDUgMTQuOTYgNSAwIDUgQzAgMy4zNSAwIDEuNyAwIDAgWiAiIGZpbGw9IiMxRTcwQzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1NDEsNTcpIi8+CjxwYXRoIGQ9Ik0wIDAgQzEuOTUxOTMyMjEgNS44NTU3OTY2MyAzLjYyOTIyNzk1IDE1LjU1OTg2NzYxIDAuOTE0MDYyNSAyMS4yOTI5Njg3NSBDMC40NDc0MjE4NyAyMS44MzU2NjQwNiAtMC4wMTkyMTg3NSAyMi4zNzgzNTkzOCAtMC41IDIyLjkzNzUgQy0zLjIyMjkwNTM0IDI1LjY1Mjg1NDI2IC0zLjIyMjkwNTM0IDI1LjY1Mjg1NDI2IC0zLjExMzI4MTI1IDI4LjQwNjI1IEMtMi44NDc1MjI1NiAzMC42NDI3NjQ2OSAtMi41MDI2MTIyNCAzMi44MDU0MjU3OCAtMiAzNSBDLTYuNjI1IDM4IC02LjYyNSAzOCAtMTAgMzggQy0xMC4zMyAzOS4zMiAtMTAuNjYgNDAuNjQgLTExIDQyIEMtMTIuMzIgNDIgLTEzLjY0IDQyIC0xNSA0MiBDLTE2LjcwMzEyNSA0MC4xMDE1NjI1IC0xNi43MDMxMjUgNDAuMTAxNTYyNSAtMTguMjUgMzcuNjI1IEMtMTguNzcwNzgxMjUgMzYuODEyODkwNjIgLTE5LjI5MTU2MjUgMzYuMDAwNzgxMjUgLTE5LjgyODEyNSAzNS4xNjQwNjI1IEMtMjEgMzMgLTIxIDMzIC0yMSAzMSBDLTE4LjA5NDUxMTE4IDI4Ljk1ODMwNTE1IC0xNi41OTg1Nzk1NCAyOCAtMTMgMjggQy0xMyAyOC45OSAtMTMgMjkuOTggLTEzIDMxIEMtMTAuMDI5ODIzMDYgMzAuMzcxODk4MjcgLTEwLjAyOTgyMzA2IDMwLjM3MTg5ODI3IC03IDI5IEMtNS44MDE2MTc5MSAyNi42NzE0NTUzNyAtNS44MDE2MTc5MSAyNi42NzE0NTUzNyAtNSAyNCBDLTQuMzI1ODIwMzEgMjMuMjk4NzUgLTMuNjUxNjQwNjMgMjIuNTk3NSAtMi45NTcwMzEyNSAyMS44NzUgQy0wLjI3MTkxNzk2IDE3LjkzMDQwMjQ0IC0wLjU4MDIxNDc2IDE0Ljk1NDI2NzczIC0wLjgxMjUgMTAuMzEyNSBDLTEuMDkwOTg5MDUgMi4xODE5NzgxMSAtMS4wOTA5ODkwNSAyLjE4MTk3ODExIDAgMCBaICIgZmlsbD0iI0VCRjNFRiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM0Miw2NSkiLz4KPHBhdGggZD0iTTAgMCBDLTAuNDAyODE3NzEgNS44NDA4NTY3NCAtMS4xMTI3NzkgOS4zNzczNTg4MSAtNSAxNCBDLTguMjkwNzY2NiAxNi43MTg0NTkzNyAtMTAuMDk2NDA4NjQgMTcuOTMzMDY3MzEgLTE0LjM3NSAxOC4yNSBDLTE1LjI0MTI1IDE4LjE2NzUgLTE2LjEwNzUgMTguMDg1IC0xNyAxOCBDLTE2LjY2ODA5NTE4IDExLjY5MzgwODQyIC0xNS41MDUxNjQ5NyA3LjU2NTU1NTkzIC0xMSAzIEMtNy4yMTg5MzIxOCAwLjU1ODA2MDM3IC00LjQ5MzYzOTc2IC0wLjM5NjQ5NzYzIDAgMCBaICIgZmlsbD0iIzAwMDAwMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzQ1LDM3KSIvPgo8cGF0aCBkPSJNMCAwIEM0Ljc1MDUzNTExIC0wLjA3NDM1MjIyIDkuNTAwNzI4ODcgLTAuMTI4Njk2OTEgMTQuMjUxNzA4OTggLTAuMTY0Nzk0OTIgQzE1Ljg2NjY3Nzg5IC0wLjE3OTg0ODc2IDE3LjQ4MTYwNjEzIC0wLjIwMDI5NjQ4IDE5LjA5NjQzNTU1IC0wLjIyNjMxODM2IEMyMS40MjI0NjU1NSAtMC4yNjI4NTI4NiAyMy43NDc5NTM0MSAtMC4yNzk3NjAxNSAyNi4wNzQyMTg3NSAtMC4yOTI5Njg3NSBDMjcuMTUxMDcxODUgLTAuMzE2MTk0NTMgMjcuMTUxMDcxODUgLTAuMzE2MTk0NTMgMjguMjQ5Njc5NTcgLTAuMzM5ODg5NTMgQzMyLjY1ODMwNTk5IC0wLjM0MTM1Nzg4IDM1LjUyNjI3Nzc5IDAuMjE1ODYwOTQgMzkgMyBDMzkgMy42NiAzOSA0LjMyIDM5IDUgQzI2LjEzIDUgMTMuMjYgNSAwIDUgQzAgMy4zNSAwIDEuNyAwIDAgWiAiIGZpbGw9IiMxRTcwQzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1NDEsNTApIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuNjYgMCAxLjMyIDAgMiAwIEM1LjE4NDE5OTU5IDMuNzk2NTQ1NjcgNS4zODczNDU0OCA3LjExNjc2MjIgNS4yMzgyODEyNSAxMS44NjMyODEyNSBDNC45NDYwNDkxMyAxNC40ODM3ODg5NyA0LjA0MjM4MTk1IDE2LjU4OTQ5MTczIDMgMTkgQzIuNDgyMDk2ODIgMjMuMDU2OTA4MjUgMi42OTk5NDI5NCAyNC41NDk5MTQ0MSA1IDI4IEM3LjMzNDU4NjM1IDMxLjUwMTg3OTUzIDcuNjcyNjA3MjcgMzIuODgwMjgwNDcgNyAzNyBDNi4zNDg5OTE3IDM4LjE2Njk1MjY0IDUuNjU4MzE0NjEgMzkuMzEyMzI1OTggNC45Mzc1IDQwLjQzNzUgQzMuMTY4MTQxMTcgNDMuMjg2MDQyMjIgMi45OTk2OTkxNiA0My45ODI4NTIyOSAzLjA2MjUgNDcuNTYyNSBDNC4wMDI5NTg2MSA1MS4wMTA4NDgyMyA1LjM3ODg4Njc3IDUzLjgyODI1NjcyIDcgNTcgQzcgNTguMzIgNyA1OS42NCA3IDYxIEM1LjAyIDYxLjQ5NSA1LjAyIDYxLjQ5NSAzIDYyIEMyLjcxMTI1IDYwLjc4MzEyNSAyLjQyMjUgNTkuNTY2MjUgMi4xMjUgNTguMzEyNSBDMS41MTk4MDg4OSA1NS44MzA3ODEwNyAwLjg5MjAyOTY2IDUzLjc2NzAxMTM3IC0wLjE4NzUgNTEuNDM3NSBDLTEuMzQyMzE4NDQgNDcuOTczMDQ0NjggLTAuODE4NjU2ODYgNDUuNTI2NTIxODcgMCA0MiBDMC43NzM0Mzc1IDQwLjczMTU2MjUgMC43NzM0Mzc1IDQwLjczMTU2MjUgMS41NjI1IDM5LjQzNzUgQzMuNDExMzY2MjEgMzYuMzAyNDY1OTkgMy41MTMyNzU5MiAzNC41OTI5MzE0MSAzIDMxIEMyLjM0IDMwLjAxIDEuNjggMjkuMDIgMSAyOCBDLTEuMzMwNDM1NTggMjQuNTA0MzQ2NjQgLTEuNTg3NjMyNDQgMjMuMTEzNDI3MSAtMSAxOSBDLTAuNTA1IDE3Ljg2NTYyNSAtMC4wMSAxNi43MzEyNSAwLjUgMTUuNTYyNSBDMi41NDM3NjAwOCAxMC43MDg1Njk4MSAyLjY5NzAxMDU0IDcuMDQ3NDY4NDUgMSAyLjA2MjUgQzAuNjcgMS4zODE4NzUgMC4zNCAwLjcwMTI1IDAgMCBaICIgZmlsbD0iI0U5RjFFRSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM2OSw1OSkiLz4KPHBhdGggZD0iTTAgMCBDMS4zMiAwLjMzIDIuNjQgMC42NiA0IDEgQzUuMTU2NjQ3MzcgNi40ODI2OTA2OSA1LjExNDE2MjU1IDExLjgwMzM5Mjc0IDUuMDYyNSAxNy4zNzUgQzUuMDU3OTg4MjggMTguMzAxODM1OTQgNS4wNTM0NzY1NiAxOS4yMjg2NzE4OCA1LjA0ODgyODEyIDIwLjE4MzU5Mzc1IEM1LjAzNzExNTc0IDIyLjQ1NTc5NzA5IDUuMDIwNzEzNzIgMjQuNzI3ODYzODggNSAyNyBDMy4zNSAyNy4zMyAxLjcgMjcuNjYgMCAyOCBDLTIuNjA1MTM5NTkgMjQuMDkyMjkwNjIgLTIuMjkzNjc1NjUgMjAuNzc3NzA5MjEgLTIuMjUgMTYuMjUgQy0yLjI1NzczNDM4IDE1LjQ2MzY3MTg4IC0yLjI2NTQ2ODc1IDE0LjY3NzM0Mzc1IC0yLjI3MzQzNzUgMTMuODY3MTg3NSBDLTIuMjU2ODM4MzYgOC44NzA4NDc1NSAtMS41OTU2NjE5NSA0LjczNjMyOTkxIDAgMCBaICIgZmlsbD0iIzIyMUUyMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTY5LDcxKSIvPgo8cGF0aCBkPSJNMCAwIEMxLjY3NTQyOTc2IDAuMjg2MDQ4OTggMy4zNDM4NTM0MyAwLjYxNzgxMjMzIDUgMSBDNi4wNjgwODM3NCA3LjI3NDk5MTk3IDcuMDQzNjc4MzkgMTMuODY4OTY0ODMgNSAyMCBDNC40NDQ5NTIwOSAyNS44ODM1MDc4OCA1Ljc0ODA2MTcyIDI4LjIyMzcxNTY1IDkgMzMgQzkuNjgyNDU2MDcgMzcuMDA5NDI5NCA5LjA2MjU0MzA2IDM5LjEyMDM1OTYxIDYuOTM3NSA0Mi40Mzc1IEM1LjE4NzQ3ODQxIDQ1LjI2MTExNjM5IDQuOTk5MzU1NTggNDUuOTYzOTEyNyA1LjA2MjUgNDkuNSBDNi4wNjQxNTYzNSA1My4yMzk1MTcwMiA3LjQxMDgyMDg0IDU2LjQ3NjE2Nzk1IDkgNjAgQzkgNjAuNjYgOSA2MS4zMiA5IDYyIEM4LjAxIDYyIDcuMDIgNjIgNiA2MiBDNS4xMjcyMDEzOCA2MC4xMzM2MDAxOSA0LjI3NzQ4OTczIDU4LjI1NjM5Mzg5IDMuNDM3NSA1Ni4zNzUgQzIuOTYxODM1OTQgNTUuMzMwODU5MzggMi40ODYxNzE4OCA1NC4yODY3MTg3NSAxLjk5NjA5Mzc1IDUzLjIxMDkzNzUgQzAuODc4NDcyMzMgNDkuNjA4MjUxOTcgMS4wMTg2Mjk2NiA0Ny42MDg1ODA1MSAyIDQ0IEMyLjUxNTYyNSA0My4xNzUgMy4wMzEyNSA0Mi4zNSAzLjU2MjUgNDEuNSBDNS4zODcwMjc1NiAzOC4zMjY5MDg1OCA1LjUxNjQ0MTE4IDM2LjYxNTA4ODI1IDUgMzMgQzQuMzE5Mzc1IDMyLjA3MTg3NSAzLjYzODc1IDMxLjE0Mzc1IDIuOTM3NSAzMC4xODc1IEMwLjMyMzM1MDI2IDI1Ljg4NjgwMjA0IDAuODgyMTgxNzcgMjIuNzc3MDAxIDIgMTggQzIuMzMgMTcuMzQgMi42NiAxNi42OCAzIDE2IEMzLjQxNzQwMjY4IDExLjA1OTExNzE1IDMuNDg3NDY4NzMgNi40MjIxNjY2NCAxIDIgQzAuMzQgMS42NyAtMC4zMiAxLjM0IC0xIDEgQy0wLjY3IDAuNjcgLTAuMzQgMC4zNCAwIDAgWiAiIGZpbGw9IiMxRDc1NTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNzAsNTcpIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuMzMgMC42NiAwLjY2IDEuMzIgMSAyIEMwLjY3IDIuNjYgMC4zNCAzLjMyIDAgNCBDMC4wMjM3OTA0IDYuMzExMDc4NzggMC4wMjM3OTA0IDYuMzExMDc4NzggMC4zMTI1IDguODc1IEMwLjM5MTEzMjgxIDkuNzM4NjcxODcgMC40Njk3NjU2MyAxMC42MDIzNDM3NSAwLjU1MDc4MTI1IDExLjQ5MjE4NzUgQzEuMDAzMjA3MjQgMTQuMDE3OTA0NzUgMS44MTI2MDgzMyAxNS43NDgyMTM0IDMgMTggQzMuNzA0NDkyODkgMjMuNDAxMTEyMTcgMS45Mjk0NDIzOSAyNS42MDU4MzY0MiAtMSAzMCBDLTEuNjc4NzgwNTkgMzQuMDcyNjgzNTYgLTEuMzQxNzI0MDYgMzUuNDk4MDkyNzkgMSAzOC45Mzc1IEMzLjQ1MjU5MTI5IDQyLjY5MzAzMDQxIDMuNTUxNTQyOTEgNDQuNTg3NjU2NyAzIDQ5IEMyLjA2NTUzNDY1IDUxLjAzMTQ0NjQxIDEuMDY3NzUyMjQgNTMuMDM1MzM1ODcgMCA1NSBDLTAuNjk5MDc0MTQgNTcuNzM1NzI1ODUgLTAuNjk5MDc0MTQgNTcuNzM1NzI1ODUgLTEgNjAgQy0yLjMyIDU5LjY3IC0zLjY0IDU5LjM0IC01IDU5IEMtNC41MjI2OTE2MiA1Ny41NDEwNTc0IC00LjA0MzA4OTU4IDU2LjA4Mjg2NTA0IC0zLjU2MjUgNTQuNjI1IEMtMy4xNjIyNDYwOSA1My40MDY4MzU5NCAtMy4xNjIyNDYwOSA1My40MDY4MzU5NCAtMi43NTM5MDYyNSA1Mi4xNjQwNjI1IEMtMiA1MCAtMiA1MCAtMSA0OCBDLTAuNTQzMTA3NzYgNDQuMDcwNzI2NzUgLTAuOTU5NzA3MDkgNDEuNzM5NDU4MTMgLTMgMzguNDM3NSBDLTUuNzU4MjkzODQgMzMuNjk2NjgyNDYgLTUuNzU4MjkzODQgMzMuNjk2NjgyNDYgLTUgMzAgQy00LjM0IDI5LjA1MTI1IC0zLjY4IDI4LjEwMjUgLTMgMjcuMTI1IEMtMC41ODgzOTUzIDIzLjM1Njg2NzY2IC0wLjUyMDEwNzIzIDIxLjM5OTAxNzAyIC0xIDE3IEMtMS4zMyAxNi4xOTU2MjUgLTEuNjYgMTUuMzkxMjUgLTIgMTQuNTYyNSBDLTMuNDY1MDU4MjkgMTAuODA4Mjg4MTIgLTMuMzIwMjAxNTkgOC4wMzQ1NDAwMiAtMyA0IEMtMS41IDEuNSAtMS41IDEuNSAwIDAgWiAiIGZpbGw9IiNGMUY2RjQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNTEsNjApIi8+CjxwYXRoIGQ9Ik0wIDAgQzMgMSAzIDEgNSA0IEM1IDQuOTkgNSA1Ljk4IDUgNyBDNS42NiA2LjY3IDYuMzIgNi4zNCA3IDYgQzguNTQwMjM5OTYgNS45MzA0OTQ1OSAxMC4wODMzNDk4OCA1LjkxNTQ3NjQzIDExLjYyNSA1LjkzNzUgQzEyLjg1MDg5ODQ0IDUuOTUxMDM1MTYgMTIuODUwODk4NDQgNS45NTEwMzUxNiAxNC4xMDE1NjI1IDUuOTY0ODQzNzUgQzE1LjA0MTI4OTA2IDUuOTgyMjQ2MDkgMTUuMDQxMjg5MDYgNS45ODIyNDYwOSAxNiA2IEMxNS4yMzY4NzUgNi43NDI1IDE0LjQ3Mzc1IDcuNDg1IDEzLjY4NzUgOC4yNSBDMTEuMDU1OTU5NzIgMTAuNzU4MDE3NDUgMTEuMDU1OTU5NzIgMTAuNzU4MDE3NDUgOS42NTIzNDM3NSAxMy4wOTc2NTYyNSBDNy41MTM0ODk4OSAxNS41NjAxMTkyIDYuMDYwMDUxNDUgMTUuNzE4NTYzODUgMi44NzUgMTYuMTg3NSBDLTAuMzYzMTQzNTQgMTYuNDU4MzM3OTMgLTAuMzYzMTQzNTQgMTYuNDU4MzM3OTMgLTMgMTggQy00LjY2NjE3MTE1IDE4LjA0MDYzODMyIC02LjMzMzg4MDk1IDE4LjA0MjcyMSAtOCAxOCBDLTcuMjU5NDMzNTkgMTYuOTMwNzIyNjYgLTcuMjU5NDMzNTkgMTYuOTMwNzIyNjYgLTYuNTAzOTA2MjUgMTUuODM5ODQzNzUgQy0xLjU0NzYwNyA4LjUwMTAxOTAzIC0xLjU0NzYwNyA4LjUwMTAxOTAzIDAgMCBaICIgZmlsbD0iI0VGRjVGMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTMyNiw1NSkiLz4KPHBhdGggZD0iTTAgMCBDMS44NzUgMS4xMjUgMS44NzUgMS4xMjUgMyAzIEMzLjY4NzUgNi4xODc1IDMuNjg3NSA2LjE4NzUgNCA5IEMwLjM3IDkgLTMuMjYgOSAtNyA5IEMtNi4wMSA5Ljk5IC01LjAyIDEwLjk4IC00IDEyIEMtMC4zNTQ1ODE1NSAxMS43NjUyMjgwMSAtMC4zNTQ1ODE1NSAxMS43NjUyMjgwMSAzIDExIEMyLjY3IDEyLjY1IDIuMzQgMTQuMyAyIDE2IEMtNC4yNDE1OTc5NyAxNy4zNDYyMjcwMSAtNC4yNDE1OTc5NyAxNy4zNDYyMjcwMSAtNy44NzUgMTUuNjg3NSBDLTEwIDE0IC0xMCAxNCAtMTEgMTIgQy0xMS41NzE0Mjg1NyA0LjkxNDI4NTcxIC0xMS41NzE0Mjg1NyA0LjkxNDI4NTcxIC05LjQzNzUgMS41IEMtNi4wODk2NTY1MSAtMC41NjAyMTEzOCAtMy44NTk4NTc1MyAtMC40OTEyNTQ1OSAwIDAgWiBNLTUgMyBDLTUuOTkgNC40ODUgLTUuOTkgNC40ODUgLTcgNiBDLTQuNjkgNiAtMi4zOCA2IDAgNiBDLTAuNjYgNS4wMSAtMS4zMiA0LjAyIC0yIDMgQy0yLjk5IDMgLTMuOTggMyAtNSAzIFogIiBmaWxsPSIjMDA4NDI5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMTAwLDkzKSIvPgo8cGF0aCBkPSJNMCAwIEMxMC44OSAwIDIxLjc4IDAgMzMgMCBDMzIuNjcgMS4zMiAzMi4zNCAyLjY0IDMyIDQgQzI5LjA3ODAyMzEgNS40NjA5ODg0NSAyNi41MDEwNjUyNSA1LjExMTM0OTAxIDIzLjI0MjE4NzUgNS4wOTc2NTYyNSBDMjIuMjQ3NjEwMzIgNS4wOTU1MzM4MyAyMi4yNDc2MTAzMiA1LjA5NTUzMzgzIDIxLjIzMjk0MDY3IDUuMDkzMzY4NTMgQzE5LjExMzU4MTM3IDUuMDg3NzY3NTQgMTYuOTk0MzI3NDEgNS4wNzUyMTUgMTQuODc1IDUuMDYyNSBDMTMuNDM4ODAzNjEgNS4wNTc0ODUxMiAxMi4wMDI2MDU1NiA1LjA1MjkyMjE5IDEwLjU2NjQwNjI1IDUuMDQ4ODI4MTIgQzcuMDQ0MjM2NTUgNS4wMzc3OTc4MiAzLjUyMjEyODU1IDUuMDIwNTMyNTkgMCA1IEMwIDMuMzUgMCAxLjcgMCAwIFogIiBmaWxsPSIjMUU3MEMwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNTQ5LDcyKSIvPgo8cGF0aCBkPSJNMCAwIEM0LjIxNzQ5MjE5IC0wLjA3NDE5MTM0IDguNDM0NjM4MTEgLTAuMTI4NjIwNCAxMi42NTI1ODc4OSAtMC4xNjQ3OTQ5MiBDMTQuMDg3MjI1NTIgLTAuMTc5ODc1ODkgMTUuNTIxODE3MDggLTAuMjAwMzQzOCAxNi45NTYyOTg4MyAtMC4yMjYzMTgzNiBDMTkuMDE5MTU4NTkgLTAuMjYyNzM0MzcgMjEuMDgxNDA4NTggLTAuMjc5NzMyNDMgMjMuMTQ0NTMxMjUgLTAuMjkyOTY4NzUgQzI1LjAwNjIxOTQ4IC0wLjMxNjUzNDQyIDI1LjAwNjIxOTQ4IC0wLjMxNjUzNDQyIDI2LjkwNTUxNzU4IC0wLjM0MDU3NjE3IEMzMCAwIDMwIDAgMzEuOTI4NDY2OCAxLjM5MzMxMDU1IEMzMyAzIDMzIDMgMzMgNSBDMjIuMTEgNSAxMS4yMiA1IDAgNSBDMCAzLjM1IDAgMS43IDAgMCBaICIgZmlsbD0iIzFGNzBDMSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU0OSw3OSkiLz4KPHBhdGggZD0iTTAgMCBDMC42NiAwIDEuMzIgMCAyIDAgQzIuMDg2MzY3MTkgMC41Njg0NzY1NiAyLjE3MjczNDM3IDEuMTM2OTUzMTIgMi4yNjE3MTg3NSAxLjcyMjY1NjI1IEMzLjM1MjcwNTM2IDcuNzE4MDc4MSA1LjI4MTQzMTU2IDExLjIwNTAwMzg1IDkgMTYgQzkgMTYuNjYgOSAxNy4zMiA5IDE4IEM4LjI3NTU0Njg3IDE3Ljg0NjYwMTU2IDcuNTUxMDkzNzUgMTcuNjkzMjAzMTIgNi44MDQ2ODc1IDE3LjUzNTE1NjI1IEM0LjA3MzM2NjA3IDE2Ljk3MzE0OTc3IDQuMDczMzY2MDcgMTYuOTczMTQ5NzcgMS41NzAzMTI1IDE2Ljc0NjA5Mzc1IEMtNC45MDkwNjM1OCAxNS45Mjg0MDg5MSAtNy44MDY5NTYzOCAxMy44OTExMzYyMyAtMTEuODIwMzEyNSA4Ljc3NzM0Mzc1IEMtMTMgNyAtMTMgNyAtMTMgNiBDLTYuMzc1IDUuODc1IC02LjM3NSA1Ljg3NSAtMyA3IEMtMi44NzYyNSA2LjQwMTg3NSAtMi43NTI1IDUuODAzNzUgLTIuNjI1IDUuMTg3NSBDLTIgMyAtMiAzIDAgMCBaICIgZmlsbD0iI0YyRjdGNSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM5NCw1NSkiLz4KPHBhdGggZD0iTTAgMCBDMSAyIDEgMiAwLjkzNzUgNS44MTI1IEMwLjg3OTY0ODA4IDkuMzg2NDYzMTggMS42NDA2MzE3NyAxMS42ODY1Mzk5NCAzIDE1IEMzLjQ3NzIyODgxIDE5LjM3NDU5NzM5IDMuNDk4NjQwNDQgMjEuMjg5ODE1MTMgMC45Mzc1IDI0LjkzNzUgQy0xLjA1MTY1MDY5IDI4LjA4MTY0MTQxIC0xLjI4MzkwMDM2IDI4LjY1NDU4MTU5IC0wLjkzNzUgMzIuMTI1IEMtMC4wNDE1OTEyMiAzNS44MjgwODk2MSAwLjc4Mzk2MDg3IDM3LjEwOTUxNDE4IDMgNDAgQzMuNjQwNzA0NzggNDQuOTEyMDY5OTQgMi4yODAwNjUxNiA0Ny43MTM0Nzc1IDAgNTIgQy0wLjY5OTA3NDE0IDU0LjczNTcyNTg1IC0wLjY5OTA3NDE0IDU0LjczNTcyNTg1IC0xIDU3IEMtMS45OSA1NyAtMi45OCA1NyAtNCA1NyBDLTMuMjQ3ODEzNDEgNTAuNDgxMDQ5NTYgLTMuMjQ3ODEzNDEgNTAuNDgxMDQ5NTYgLTEuOTM3NSA0Ny45Mzc1IEMtMC41NTU0NjYzNyA0NS4wODEyOTcxNyAtMC42Mjk3ODY4MiA0My4xNDY4MTIgLTEgNDAgQy0xLjkyMzQ0MjExIDM4LjIzNzkyNDggLTEuOTIzNDQyMTEgMzguMjM3OTI0OCAtMy4wNjI1IDM2LjUgQy00LjcyOTM3MDExIDMzLjgyMjM2ODIyIC01LjAwMjU5OTI2IDMzLjEzMjU2MjEgLTQuOTM3NSAyOS44MTI1IEMtNCAyNyAtNCAyNyAtMi40Mzc1IDI1LjE4NzUgQy0wLjE2NjczOTU4IDIxLjczMTk5NTAyIC0wLjYxNDU0MzE5IDE4LjAyNTA1ODY1IC0xIDE0IEMtMS4zMyAxMy4wMSAtMS42NiAxMi4wMiAtMiAxMSBDLTIuMTY3OTY4NzUgOS4wNjI1IC0yLjE2Nzk2ODc1IDkuMDYyNSAtMi4xODc1IDcgQy0yLjIwMTY3OTY5IDYuMzE5Mzc1IC0yLjIxNTg1OTM4IDUuNjM4NzUgLTIuMjMwNDY4NzUgNC45Mzc1IEMtMiAzIC0yIDMgMCAwIFogIiBmaWxsPSIjMTQ3MDRCIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzQ4LDYyKSIvPgo8cGF0aCBkPSJNMCAwIEMxMi44NyAwIDI1Ljc0IDAgMzkgMCBDMzUuMDM1MDk2OTkgMy45NjQ5MDMwMSAzNS4wMzUwOTY5OSAzLjk2NDkwMzAxIDMwLjY1MTg1NTQ3IDQuMTEzNTI1MzkgQzI5LjIyMzYyMzAzIDQuMTEzMzY2ODggMjcuNzk1Mzg0NTggNC4xMDc3MDczNSAyNi4zNjcxODc1IDQuMDk3NjU2MjUgQzI1LjIzOTQzNDA1IDQuMDk1NTMzODMgMjUuMjM5NDM0MDUgNC4wOTU1MzM4MyAyNC4wODg4OTc3MSA0LjA5MzM2ODUzIEMyMS42ODQyMjQ5IDQuMDg3NzY0NjUgMTkuMjc5NjQ0NzMgNC4wNzUyMTE1NyAxNi44NzUgNC4wNjI1IEMxNS4yNDYwOTUwOSA0LjA1NzQ4NTUgMTMuNjE3MTg4NzMgNC4wNTI5MjI1IDExLjk4ODI4MTI1IDQuMDQ4ODI4MTIgQzcuOTkyMTUxNzMgNC4wMzc3OTM5NyAzLjk5NjA5MTU4IDQuMDIwNTI2NzkgMCA0IEMwIDIuNjggMCAxLjM2IDAgMCBaICIgZmlsbD0iIzFGNzBDMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU0MSwxMDIpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuNDQ1MDA2NiAyLjkzNTY2NDIzIDMuNTc0ODI0NjQgNS4yNTc0NDI5NCAzLjk2ODc1IDkuNTk3NjU2MjUgQzMuOTk4ODM1MiAxMS45MTA0NTU4IDMuNzA3ODg2MzggMTMuODY2Mzg3MzUgMy4yNSAxNi4xMjUgQzIuOTg0MTIwNjEgMjAuMjQ2MTMwNTMgMy4xMDk4NDA0MiAyMC42ODU1NzQyMiA1LjQzNzUgMjMuNzUgQzUuOTEwNTg1OTQgMjQuMjgxMDkzNzUgNi4zODM2NzE4NyAyNC44MTIxODc1IDYuODcxMDkzNzUgMjUuMzU5Mzc1IEM4IDI3IDggMjcgOCAzMSBDMTAuMzEgMzEuNjYgMTIuNjIgMzIuMzIgMTUgMzMgQzE1IDMzLjk5IDE1IDM0Ljk4IDE1IDM2IEMxNi4zMiAzNi42NiAxNy42NCAzNy4zMiAxOSAzOCBDMTkgMzguOTkgMTkgMzkuOTggMTkgNDEgQzE3LjkxNzE4NzUgNDAuNDc0MDYyNSAxNy45MTcxODc1IDQwLjQ3NDA2MjUgMTYuODEyNSAzOS45Mzc1IEMxNC4wNzY4ODc3IDM4Ljc1NjQ4MjEyIDE0LjA3Njg4NzcgMzguNzU2NDgyMTIgMTEuNSAzOS41NjI1IEM5IDQwIDkgNDAgNi4xODc1IDM4LjU2MjUgQzUuNDY1NjI1IDM4LjA0Njg3NSA0Ljc0Mzc1IDM3LjUzMTI1IDQgMzcgQzQuMTk1MjkyOTcgMzYuMTY0Njg3NSA0LjE5NTI5Mjk3IDM2LjE2NDY4NzUgNC4zOTQ1MzEyNSAzNS4zMTI1IEM1LjMwMzg2MTMxIDMwLjQ2NzI5MzAxIDUuMzAzODYxMzEgMzAuNDY3MjkzMDEgMy45MTc5Njg3NSAyNS44NjcxODc1IEMyLjk3NDUwMDc2IDI0LjU0MTY1Mzk2IDIuMDI5MTkzNjQgMjMuMjE3NDI3NDggMS4wODIwMzEyNSAyMS44OTQ1MzEyNSBDLTAuNjgwNTA5NzQgMTguODA4NDkzNzggMC4yMzQyODE5NyAxNi4zNTczNzkwNyAxIDEzIEMxLjA4MjI5MTcgMTEuNDM5MTEyMjkgMS4xMjI0NDU5OSA5Ljg3NTU1MzM3IDEuMTI1IDguMzEyNSBDMS4xMjg4NjcxOSA3LjIyMzg4NjcyIDEuMTI4ODY3MTkgNy4yMjM4ODY3MiAxLjEzMjgxMjUgNi4xMTMyODEyNSBDMC45OTc4MDczMiAzLjk2NTExMDU5IDAuNTg3NzI5NCAyLjA2NjM4MTk1IDAgMCBaICIgZmlsbD0iI0VGRjVGMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM3OCw2MykiLz4KPHBhdGggZD0iTTAgMCBDOS4yNCAwIDE4LjQ4IDAgMjggMCBDMjggMS42NSAyOCAzLjMgMjggNSBDMTguNzYgNSA5LjUyIDUgMCA1IEMwIDMuMzUgMCAxLjcgMCAwIFogIiBmaWxsPSIjMUU3MEMxIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNTEwLDk0KSIvPgo8cGF0aCBkPSJNMCAwIEM5LjI0IDAgMTguNDggMCAyOCAwIEMyOCAxLjY1IDI4IDMuMyAyOCA1IEMxOC43NiA1IDkuNTIgNSAwIDUgQzAgMy4zNSAwIDEuNyAwIDAgWiAiIGZpbGw9IiMxRTcwQzEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1MTAsNTcpIi8+CjxwYXRoIGQ9Ik0wIDAgQzkuMjQgMCAxOC40OCAwIDI4IDAgQzI4IDEuNjUgMjggMy4zIDI4IDUgQzE4Ljc2IDUgOS41MiA1IDAgNSBDMCAzLjM1IDAgMS43IDAgMCBaICIgZmlsbD0iIzFGNzBDMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTUxMCw1MCkiLz4KPHBhdGggZD0iTTAgMCBDMCAzIDAgMyAtMSA1IEMtMS4yMTM3NzcyMSAxMC42MDcwMzIxMyAtMS4yMTM3NzcyMSAxMC42MDcwMzIxMyAwIDE2IEMwLjc1NDE0MjM1IDIyLjQ5MDU2OTM3IC0wLjI2NzY1MDE5IDI1LjU4MjA3Mjg1IC00IDMxIEMtMy45Mjc0OTIxNCAzNC41NTI4ODQ5NCAtMy4zMTc3NDE2NCAzNi40OTE2MTMzNyAtMS40Mzc1IDM5LjUgQzAuNDMyMjMyNTQgNDIuNzUxNzA4NzYgMC40OTI4MjA0OCA0NC4yNjg2NDQ5NCAwIDQ4IEMtMS4xNzkwNDA1IDUxLjQwNDQxNTYzIC0yLjU0MTk2MzU0IDU0LjcwNjM5OTc4IC00IDU4IEMtNC45OSA1Ny42NyAtNS45OCA1Ny4zNCAtNyA1NyBDLTYuNTc1MjcyMSA1NC40NTE2MzI2IC02LjE4NjYwNjY3IDUyLjM0MDI4Mjc1IC00LjkzNzUgNTAuMDYyNSBDLTMuNjI5MDkzODEgNDcuMTg0MDA2MzkgLTMuNjg2MTgxNDMgNDUuMTM4MTg1NzMgLTQgNDIgQy00LjQ5NSA0MS4wMSAtNC45OSA0MC4wMiAtNS41IDM5IEMtNy4yMTc0NTA3IDM1LjU2NTA5ODYgLTcuNTUyMzU3MzMgMzMuNzg3NTkzMTMgLTcgMzAgQy01Ljk4MjkyOTY5IDI4LjY2Nzc1MzkxIC01Ljk4MjkyOTY5IDI4LjY2Nzc1MzkxIC00Ljk0NTMxMjUgMjcuMzA4NTkzNzUgQy0yLjU3NzgwMDU3IDIzLjI4MTkyMTg1IC0yLjgyMDAzNjc0IDIwLjUwMjM1NDg2IC0zLjQzNzUgMTYuMDYyNSBDLTQuMjQwNTQ3MzkgMTAuMDc2NjY0NDYgLTMuNzgyNzc2OTMgNi4zMjc0MTg5MSAtMSAxIEMtMC42NyAwLjY3IC0wLjM0IDAuMzQgMCAwIFogIiBmaWxsPSIjRTRFRUVBIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzQ4LDYwKSIvPgo8cGF0aCBkPSJNMCAwIEMzLjkwOTM4NzAzIDMuNzM5NDEzNjggMy45MDkzODcwMyAzLjczOTQxMzY4IDQuMTMyODEyNSA2Ljg0NzY1NjI1IEM0LjEzMDIzNDM4IDcuNTc4NTU0NjkgNC4xMjc2NTYyNSA4LjMwOTQ1MzEzIDQuMTI1IDkuMDYyNSBDNC4xMjI0MjE4OCA5Ljg2MzAwNzgxIDQuMTE5ODQzNzUgMTAuNjYzNTE1NjMgNC4xMTcxODc1IDExLjQ4ODI4MTI1IEM0LjAwMTcwMTk1IDEzLjk2MzUyMTY0IDMuNjUxMDI0NzkgMTYuMzA3MDIyNDggMy4yNSAxOC43NSBDMi43NjIwMjY5NSAyMi40MjA4OTQxOCAyLjc2MjAyNjk1IDIyLjQyMDg5NDE4IDQuOTM3NSAyNS41NjI1IEM1Ljk1ODQzNzUgMjYuNzY5MDYyNSA1Ljk1ODQzNzUgMjYuNzY5MDYyNSA3IDI4IEM4LjA0NzU1MTk0IDMzLjMxNDE0MzcgNi44NDIyMzI0NCAzNi40OTk3OTg2MyA0IDQxIEMzLjM3MDk3MDM5IDQ1LjkyNzM5ODU3IDQuNzQ3ODkzNDUgNDguNjgzNDYyNDQgNyA1MyBDNyA1NC4zMiA3IDU1LjY0IDcgNTcgQzQgNTYgNCA1NiAyLjc5Njg3NSA1My45MjU3ODEyNSBDLTAuNzYwMjg1NzMgNDUuMDQ2MTUyNDIgLTAuNzYwMjg1NzMgNDUuMDQ2MTUyNDIgMSA0MCBDMS41MTU2MjUgMzkuMTc1IDIuMDMxMjUgMzguMzUgMi41NjI1IDM3LjUgQzQuMzg3MDI3NTYgMzQuMzI2OTA4NTggNC41MTY0NDExOCAzMi42MTUwODgyNSA0IDI5IEMzLjM0IDI4LjAzMDYyNSAyLjY4IDI3LjA2MTI1IDIgMjYuMDYyNSBDLTAuNDEwNTc3ODIgMjIuMzcxMzAyNzIgLTAuNDA4MzI3NTUgMjAuMzI4MjcxOTkgMCAxNiBDMC4zMyAxNS4wMSAwLjY2IDE0LjAyIDEgMTMgQzEuMDkyNDczODEgMTEuNTIzMTM4ODkgMS4xMjk5OTA3MSAxMC4wNDIyNDQ5OSAxLjEyNSA4LjU2MjUgQzEuMTI4ODY3MTkgNy40MTk3NDYwOSAxLjEyODg2NzE5IDcuNDE5NzQ2MDkgMS4xMzI4MTI1IDYuMjUzOTA2MjUgQzEuMDAyNzYwMTUgNC4wNDY4NDE0MSAwLjYwODU2MTk5IDIuMTIwMzA3MjQgMCAwIFogIiBmaWxsPSIjRTZGMEVDIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzc0LDYxKSIvPgo8cGF0aCBkPSJNMCAwIEM4LjI1IDAgMTYuNSAwIDI1IDAgQzI1LjY2IDEuNjUgMjYuMzIgMy4zIDI3IDUgQzE4LjA5IDUgOS4xOCA1IDAgNSBDMCAzLjM1IDAgMS43IDAgMCBaICIgZmlsbD0iIzFFNzBDMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU4Nyw1NykiLz4KPHBhdGggZD0iTTAgMCBDOC4yNSAwIDE2LjUgMCAyNSAwIEMyNSAxLjY1IDI1IDMuMyAyNSA1IEMxNi40MiA1IDcuODQgNSAtMSA1IEMtMC42NyAzLjM1IC0wLjM0IDEuNyAwIDAgWiAiIGZpbGw9IiMxRTcwQzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MjQsNTcpIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuNjYgMCAxLjMyIDAgMiAwIEMyLjMzIDEuNjUgMi42NiAzLjMgMyA1IEM0LjY1IDUgNi4zIDUgOCA1IEM3LjAxIDYuNDg1IDcuMDEgNi40ODUgNiA4IEM1LjgzMjg2NDMxIDEwLjYyNTMxNTI0IDUuODMyODY0MzEgMTAuNjI1MzE1MjQgNiAxMyBDNi42NiAxMy4zMyA3LjMyIDEzLjY2IDggMTQgQzcuMzQgMTQgNi42OCAxNCA2IDE0IEM2IDE0LjY2IDYgMTUuMzIgNiAxNiBDMi43IDE2IC0wLjYgMTYgLTQgMTYgQy00IDE1LjM0IC00IDE0LjY4IC00IDE0IEMtNC42NiAxMy42NyAtNS4zMiAxMy4zNCAtNiAxMyBDLTUuMzQgMTMgLTQuNjggMTMgLTQgMTMgQy0zLjc5OTEzNTU3IDkuMjg0MDA4MDkgLTMuODQ4MDU2MyA4LjIyNzkxNTU1IC02IDUgQy00LjM1IDUgLTIuNyA1IC0xIDUgQy0wLjY3IDMuMzUgLTAuMzQgMS43IDAgMCBaICIgZmlsbD0iI0Q4RTdFMSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM2MCwzNykiLz4KPHBhdGggZD0iTTAgMCBDMCAxLjY1IDAgMy4zIDAgNSBDLTAuNzYzMTI1IDQuNzczMTI1IC0xLjUyNjI1IDQuNTQ2MjUgLTIuMzEyNSA0LjMxMjUgQy0zLjE5OTM3NSA0LjIwOTM3NSAtNC4wODYyNSA0LjEwNjI1IC01IDQgQy02LjgzNTQ3OTkgNS4zMzM3ODU3NSAtNi44MzU0Nzk5IDUuMzMzNzg1NzUgLTggNyBDLTcuMzQgOC42NSAtNi42OCAxMC4zIC02IDEyIEMtMy42OSAxMiAtMS4zOCAxMiAxIDEyIEMxIDEzLjMyIDEgMTQuNjQgMSAxNiBDLTUuMjAwODE5NjcgMTcuMzM3NDMxNjkgLTUuMjAwODE5NjcgMTcuMzM3NDMxNjkgLTguODEyNSAxNS44MTI1IEMtMTEuMTQwMzY2MTcgMTMuODgzNjk2NiAtMTIuMTcyMjU2MTEgMTIuODk3MTAzNjEgLTEzIDEwIEMtMTIuODU1NzAyNCA2LjUzNjg1NzUgLTEyLjM0NTYyNDk3IDQuNTI1MzQ5OTYgLTEwLjQzNzUgMS42MjUgQy02Ljg1NzUyODY3IC0wLjc2MTY0NzU1IC00LjI0ODUyOTc0IC0wLjI4MzIzNTMyIDAgMCBaICIgZmlsbD0iIzAwODQyOSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjE5Miw5MykiLz4KPHBhdGggZD0iTTAgMCBDMCAwLjk5IDAgMS45OCAwIDMgQzEuNjUgMyAzLjMgMyA1IDMgQzUgNC4zMiA1IDUuNjQgNSA3IEMzLjM1IDcgMS43IDcgMCA3IEMwIDkuOTcgMCAxMi45NCAwIDE2IEMxLjY1IDE1LjY3IDMuMyAxNS4zNCA1IDE1IEM1IDE2LjMyIDUgMTcuNjQgNSAxOSBDMS43MTMwMzc2NyAxOS43OTk1MzEzOCAwLjI4OTc2ODA4IDIwLjA5NjU4OTM2IC0zIDE5IEMtNC4yNjIzNzczMSAxNi40NzUyNDUzOCAtNC4wOTg1NjQwNCAxNC42ODc5OTUzNCAtNC4wNjI1IDExLjg3NSBDLTQuMDUzNDc2NTYgMTAuOTY0OTIxODggLTQuMDQ0NDUzMTMgMTAuMDU0ODQzNzUgLTQuMDM1MTU2MjUgOS4xMTcxODc1IEMtNC4wMjM1NTQ2OSA4LjQxODUxNTYyIC00LjAxMTk1MzEzIDcuNzE5ODQzNzUgLTQgNyBDLTQuOTkgNyAtNS45OCA3IC03IDcgQy0zLjg2MjA2ODk3IDAgLTMuODYyMDY4OTcgMCAwIDAgWiAiIGZpbGw9IiMwMDg0MjkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIxMzcsOTApIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuMzMgMS42NSAwLjY2IDMuMyAxIDUgQzAuMDUxMjUgNC43OTM3NSAtMC44OTc1IDQuNTg3NSAtMS44NzUgNC4zNzUgQy0zLjQyMTg3NSA0LjE4OTM3NSAtMy40MjE4NzUgNC4xODkzNzUgLTUgNCBDLTcuMzQ5NzM4MTggNS44OTc1NTE0NCAtNy4zNDk3MzgxOCA1Ljg5NzU1MTQ0IC03LjEyNSA5LjEyNSBDLTcuMDYzMTI1IDEwLjU0ODEyNSAtNy4wNjMxMjUgMTAuNTQ4MTI1IC03IDEyIEMtNC4zNiAxMiAtMS43MiAxMiAxIDEyIEMxIDEzLjMyIDEgMTQuNjQgMSAxNiBDLTUuMzI5OTc5ODggMTcuMjE3MzAzODIgLTUuMzI5OTc5ODggMTcuMjE3MzAzODIgLTguMzEyNSAxNi4yNSBDLTEwIDE1IC0xMCAxNSAtMTIgMTIgQy0xMi40NDUwNTU3NiA3Ljk5NDQ5ODEzIC0xMi4zNDMxOTE2NyA1LjY3MjA4MzY5IC0xMC41IDIuMDYyNSBDLTYuODg4MjI0MDkgLTAuOTE3MjE1MTMgLTQuNTg5MTk0MjEgLTAuMzgyNDMyODUgMCAwIFogIiBmaWxsPSIjMDA4NDI5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMTIyLDkzKSIvPgo8cGF0aCBkPSJNMCAwIEM3LjU5IDAgMTUuMTggMCAyMyAwIEMyMy4zMyAxLjY1IDIzLjY2IDMuMyAyNCA1IEMxNi4wOCA1IDguMTYgNSAwIDUgQzAgMy4zNSAwIDEuNyAwIDAgWiAiIGZpbGw9IiMxRjcwQzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1ODcsNTApIi8+CjxwYXRoIGQ9Ik0wIDAgQzcuMjYgMCAxNC41MiAwIDIyIDAgQzIyIDEuNjUgMjIgMy4zIDIyIDUgQzE0LjQxIDUgNi44MiA1IC0xIDUgQy0wLjY3IDMuMzUgLTAuMzQgMS43IDAgMCBaICIgZmlsbD0iIzFGNzBDMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTYyNyw1MCkiLz4KPHBhdGggZD0iTTAgMCBDMy45NiAwIDcuOTIgMCAxMiAwIEMxMiAzLjY2NjY2NjY3IDEyIDcuMzMzMzMzMzMgMTIgMTEgQzguMDQgMTEgNC4wOCAxMSAwIDExIEMwIDcuMzMzMzMzMzMgMCAzLjY2NjY2NjY3IDAgMCBaICIgZmlsbD0iI0U4MjAyNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTc4MiwxMTYpIi8+CjxwYXRoIGQ9Ik0wIDAgQzkuMjQgMCAxOC40OCAwIDI4IDAgQzI4IDEuMzIgMjggMi42NCAyOCA0IEMxOC43NiA0IDkuNTIgNCAwIDQgQzAgMi42OCAwIDEuMzYgMCAwIFogIiBmaWxsPSIjMUU3MEMwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNTEwLDEwMikiLz4KPHBhdGggZD0iTTAgMCBDMCAxLjY1IDAgMy4zIDAgNSBDLTAuNTU1NTg1OTQgNC41MTQwMjM0NCAtMS4xMTExNzE4OCA0LjAyODA0Njg4IC0xLjY4MzU5Mzc1IDMuNTI3MzQzNzUgQy00LjM3OTY1MzUgMS43NDk2NzE5NyAtNS44NjQwNjM4NiAxLjU2NzMyNDE5IC05LjA2MjUgMS41NjI1IEMtOS45MTk3MjY1NiAxLjU0MzE2NDA2IC0xMC43NzY5NTMxMyAxLjUyMzgyODEzIC0xMS42NjAxNTYyNSAxLjUwMzkwNjI1IEMtMTQuMTc3NTgwNDEgMS43OTY0NDEzNyAtMTQuMTc3NTgwNDEgMS43OTY0NDEzNyAtMTUuODA4NTkzNzUgNC4wMjczNDM3NSBDLTE2LjM5ODMzOTg0IDUuMDAzODA4NTkgLTE2LjM5ODMzOTg0IDUuMDAzODA4NTkgLTE3IDYgQy0xNS4wMiA2IC0xMy4wNCA2IC0xMSA2IEMtMTAuNjcgNy42NSAtMTAuMzQgOS4zIC0xMCAxMSBDLTExLjMyIDExIC0xMi42NCAxMSAtMTQgMTEgQy0xNCAxMC4zNCAtMTQgOS42OCAtMTQgOSBDLTE1LjMyIDkgLTE2LjY0IDkgLTE4IDkgQy0xOC4zMyA3LjM1IC0xOC42NiA1LjcgLTE5IDQgQy0xOS42NiA0LjY2IC0yMC4zMiA1LjMyIC0yMSA2IEMtMjEgNC4wMiAtMjEgMi4wNCAtMjEgMCBDLTEzLjk3OTM2NDY0IC0yLjM5MDAwMzUzIC02Ljg1MjIxNDU0IC0zLjUzNjYyNjg2IDAgMCBaICIgZmlsbD0iIzE5NzM0RiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM3MCw1NykiLz4KPHBhdGggZD0iTTAgMCBDNi45MyAwIDEzLjg2IDAgMjEgMCBDMjEgMS42NSAyMSAzLjMgMjEgNSBDMTQuMDcgNSA3LjE0IDUgMCA1IEMwIDMuMzUgMCAxLjcgMCAwIFogIiBmaWxsPSIjMUU3MEMwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjI5LDk0KSIvPgo8cGF0aCBkPSJNMCAwIEMwIDAuOTkgMCAxLjk4IDAgMyBDLTAuOTkgMyAtMS45OCAzIC0zIDMgQy0zIDMuNjYgLTMgNC4zMiAtMyA1IEMtMi4wMSA1LjMzIC0xLjAyIDUuNjYgMCA2IEMwIDcuMzIgMCA4LjY0IDAgMTAgQy02LjYyNSAxMi44NzUgLTYuNjI1IDEyLjg3NSAtMTAgMTQgQy0xMS4xOTI4NzQxMSAxMC4xMjMxNTkxMyAtMTIgNy4wODM3ODA3NyAtMTIgMyBDLTEwLjc1MzM2NjY5IDIuNDkxNjY0MDkgLTkuNTAyNTA2MTMgMS45OTM2ODg1NSAtOC4yNSAxLjUgQy03LjU1MzkwNjI1IDEuMjIxNTYyNSAtNi44NTc4MTI1IDAuOTQzMTI1IC02LjE0MDYyNSAwLjY1NjI1IEMtNCAwIC00IDAgMCAwIFogIiBmaWxsPSIjMUM3NTUxIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzI5LDgwKSIvPgo8cGF0aCBkPSJNMCAwIEM2LjYgMCAxMy4yIDAgMjAgMCBDMjAgMS42NSAyMCAzLjMgMjAgNSBDMTMuNCA1IDYuOCA1IDAgNSBDMCAzLjM1IDAgMS43IDAgMCBaICIgZmlsbD0iIzFFNzBDMSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU4Nyw5NCkiLz4KPHBhdGggZD0iTTAgMCBDMS4zMiAwIDIuNjQgMCA0IDAgQzQgNy45MiA0IDE1Ljg0IDQgMjQgQzIuNjggMjQgMS4zNiAyNCAwIDI0IEMwIDE2LjA4IDAgOC4xNiAwIDAgWiAiIGZpbGw9IiMwMDg0MjkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwNzcsODUpIi8+CjxwYXRoIGQ9Ik0wIDAgQzEuNjA4NzUgLTAuMDIwNjI1IDMuMjE3NSAtMC4wNDEyNSA0Ljg3NSAtMC4wNjI1IEM1Ljc3OTkyMTg4IC0wLjA3NDEwMTU2IDYuNjg0ODQzNzUgLTAuMDg1NzAzMTIgNy42MTcxODc1IC0wLjA5NzY1NjI1IEMxMCAwIDEwIDAgMTIgMSBDMTEuMzQgMi4zMiAxMC42OCAzLjY0IDEwIDUgQzguMzUgNSA2LjcgNSA1IDUgQzQuNjcgOC42MyA0LjM0IDEyLjI2IDQgMTYgQzIuNjggMTYgMS4zNiAxNiAwIDE2IEMwIDEwLjcyIDAgNS40NCAwIDAgWiAiIGZpbGw9IiMwMDg0MjkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIxNDksOTMpIi8+CjxwYXRoIGQ9Ik0wIDAgQzYuMjcgMCAxMi41NCAwIDE5IDAgQzE4LjY3IDEuNjUgMTguMzQgMy4zIDE4IDUgQzEyLjM5IDUgNi43OCA1IDEgNSBDMC42NyAzLjM1IDAuMzQgMS43IDAgMCBaICIgZmlsbD0iIzFGNzBDMSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTYwOSw3OSkiLz4KPHBhdGggZD0iTTAgMCBDNi45MyAwIDEzLjg2IDAgMjEgMCBDMjEgMS4zMiAyMSAyLjY0IDIxIDQgQzEzLjc0IDQgNi40OCA0IC0xIDQgQy0wLjY3IDIuNjggLTAuMzQgMS4zNiAwIDAgWiAiIGZpbGw9IiMxRTcwQzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MjEsNjUpIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuODEyNSAyLjE4NzUgMC44MTI1IDIuMTg3NSAxIDUgQy0xLjEyNSA3Ljg3NSAtMS4xMjUgNy44NzUgLTQgMTAgQy02LjgxMjUgOS44MTI1IC02LjgxMjUgOS44MTI1IC05IDkgQy05Ljc1IDYuNzUgLTkuNzUgNi43NSAtMTAgNCBDLTcuMTk2NDEzNTIgLTAuMTQ5MzA3OTkgLTQuODI5NDYzOCAtMC40MzkwNDIxNiAwIDAgWiAiIGZpbGw9IiMwMDg0MjkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIxMDgsNDApIi8+CjxwYXRoIGQ9Ik0wIDAgQzYuOTMgMCAxMy44NiAwIDIxIDAgQzIxIDEuMzIgMjEgMi42NCAyMSA0IEMxNC4wNyA0IDcuMTQgNCAwIDQgQzAgMi42OCAwIDEuMzYgMCAwIFogIiBmaWxsPSIjMUU3MEMwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjI5LDEwMikiLz4KPHBhdGggZD0iTTAgMCBDNi42IDAgMTMuMiAwIDIwIDAgQzIwLjMzIDEuMzIgMjAuNjYgMi42NCAyMSA0IEMxNC4wNyA0IDcuMTQgNCAwIDQgQzAgMi42OCAwIDEuMzYgMCAwIFogIiBmaWxsPSIjMUU3MEMwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNTk1LDY1KSIvPgo8cGF0aCBkPSJNMCAwIEM2LjYgMCAxMy4yIDAgMjAgMCBDMjAgMS4zMiAyMCAyLjY0IDIwIDQgQzEzLjQgNCA2LjggNCAwIDQgQzAgMi42OCAwIDEuMzYgMCAwIFogIiBmaWxsPSIjMUU3MEMxIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNTg3LDEwMikiLz4KPHBhdGggZD0iTTAgMCBDMC4zMyAwLjY2IDAuNjYgMS4zMiAxIDIgQzAuNjcgMi42NiAwLjM0IDMuMzIgMCA0IEMwLjAyMzc5MDQgNi4zMTEwNzg3OCAwLjAyMzc5MDQgNi4zMTEwNzg3OCAwLjMxMjUgOC44NzUgQzAuMzkxMTMyODEgOS43Mzg2NzE4NyAwLjQ2OTc2NTYzIDEwLjYwMjM0Mzc1IDAuNTUwNzgxMjUgMTEuNDkyMTg3NSBDMS4wMDMyMDcyNCAxNC4wMTc5MDQ3NSAxLjgxMjYwODMzIDE1Ljc0ODIxMzQgMyAxOCBDMy42ODc1MDI5NCAyMy4yNzA4NTU4NiAyLjE2OTQxODg1IDI1Ljg0MDEzNzc1IC0xIDMwIEMtMS42NiAyOS42NyAtMi4zMiAyOS4zNCAtMyAyOSBDLTIuNTA1IDI3Ljk3OTA2MjUgLTIuNTA1IDI3Ljk3OTA2MjUgLTIgMjYuOTM3NSBDLTAuNTQwNjAwMTQgMjIuNjUwNTEyOSAtMC4yNjA1MDE3MyAxOC44MDI1MjcwNCAtMiAxNC41NjI1IEMtMy40NjUwNTgyOSAxMC44MDgyODgxMiAtMy4zMjAyMDE1OSA4LjAzNDU0MDAyIC0zIDQgQy0xLjUgMS41IC0xLjUgMS41IDAgMCBaICIgZmlsbD0iI0U1RUZFQiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM1MSw2MCkiLz4KPHBhdGggZD0iTTAgMCBDMC4zMyAwIDAuNjYgMCAxIDAgQzAuOTg4Mzk4NDQgMC43NTAyMzQzNyAwLjk3Njc5Njg3IDEuNTAwNDY4NzUgMC45NjQ4NDM3NSAyLjI3MzQzNzUgQzAuOTE5NjU0NTMgNy4zOTkxODY2NiAwLjk4NDI4NjYxIDEyLjMwMTE4MTk1IDEuNzUgMTcuMzc1IEMyLjE5NjY0NjM5IDIxLjE0NzM1MTI3IDIuMTA3NDI3NTkgMjEuODEwMjExMjYgMC4xMjUgMjUuMzEyNSBDLTAuOTI2ODc1IDI2LjY0MjgxMjUgLTAuOTI2ODc1IDI2LjY0MjgxMjUgLTIgMjggQy0yLjc4MjE1NTg4IDMwLjcyODI1MDQgLTIuNzgyMTU1ODggMzAuNzI4MjUwNCAtMyAzMyBDLTMuOTkgMzMgLTQuOTggMzMgLTYgMzMgQy01LjY2Mzk0OTIgMjkuMzg3NDUzODUgLTUuNDU0NzA0MzIgMjcuNDg1NTg5OSAtMi45Mjk2ODc1IDI0Ljc4OTA2MjUgQy0wLjM4MTE3MzczIDIxLjEwNTU4MzA5IC0wLjgyNDUyNDMzIDE4LjI5NzIzMDcyIC0xLjM3NSAxNC4wNjI1IEMtMS45OTMyNTI0NiA4Ljg4OTQ2NTc5IC0yLjA0NDM3NzU4IDQuOTExMTE3NTYgMCAwIFogIiBmaWxsPSIjMkE3RDVDIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzQ0LDYyKSIvPgo8cGF0aCBkPSJNMCAwIEMzLjE2MTE1Nzc2IDEuMzY5ODM1MDMgMy45OTI3MDkyIDEuOTg5MDYzOCA2IDUgQzYuNTMwNzQ3NDEgMTAuNTE5NzczMDggNS4zMDE0OTUxMSAxNC4wMjg3NzA1NSAzIDE5IEMyLjMwODU5NDc4IDIxLjc3ODg4NjEzIDIuMzA4NTk0NzggMjEuNzc4ODg2MTMgMiAyNCBDMS4wMSAyNCAwLjAyIDI0IC0xIDI0IEMtMS4yNTgxMzMwMiAyMC4zODYxMzc3NCAtMS4xNjgxNTY2NyAxOC4zMjkzMDY4IDAuNSAxNS4wNjI1IEMyLjczMzE5NzQyIDEwLjUwMzA1NTI2IDIuNjIzNDM0NjEgNi44MzEzMzkxNiAxIDIuMDYyNSBDMC42NyAxLjM4MTg3NSAwLjM0IDAuNzAxMjUgMCAwIFogIiBmaWxsPSIjMTc3MjREIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzUxLDk3KSIvPgo8cGF0aCBkPSJNMCAwIEMwLjMzIDAuOTkgMC42NiAxLjk4IDEgMyBDMC41MDUgMy45MDc1IDAuMDEgNC44MTUgLTAuNSA1Ljc1IEMtMi4zNzE1ODI0MSA5LjgwNTA5NTIzIC0yLjA1NTkwNDQyIDExLjcwMDk2MDU3IC0xIDE2IEMtMC4wODA4Mzc4IDE4LjM3NzMwOTU2IDAuOTUxMzM0NzMgMjAuNjc0Njk4NzUgMiAyMyBDMiAyMy42NiAyIDI0LjMyIDIgMjUgQzEuMDEgMjUgMC4wMiAyNSAtMSAyNSBDLTEuODcyNzk4NjIgMjMuMTMzNjAwMTkgLTIuNzIyNTEwMjcgMjEuMjU2MzkzODkgLTMuNTYyNSAxOS4zNzUgQy00LjI3NTk5NjA5IDE3LjgwODc4OTA2IC00LjI3NTk5NjA5IDE3LjgwODc4OTA2IC01LjAwMzkwNjI1IDE2LjIxMDkzNzUgQy02LjEzMjU2NzY4IDEyLjU3MjY2NDE5IC02LjAzOTIzNjQyIDEwLjYzNzMyNzQ1IC01IDcgQy0zLjU1NDMxMTQ1IDQuNDMwOTQwMzUgLTEuODIzMDY5ODYgMi4zMzcyNjkwNSAwIDAgWiAiIGZpbGw9IiMxMzZGNEEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNzcsOTQpIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuNjYgMCAxLjMyIDAgMiAwIEM1LjE4NDE5OTU5IDMuNzk2NTQ1NjcgNS4zODczNDU0OCA3LjExNjc2MjIgNS4yMzgyODEyNSAxMS44NjMyODEyNSBDNC45NDYwNDkxMyAxNC40ODM3ODg5NyA0LjA0MjM4MTk1IDE2LjU4OTQ5MTczIDMgMTkgQzIuNzkzNDQ5MzQgMjIuNDQyNTEwOTcgMi45MDYxNjA2OSAyNC43MTg0ODIwOCA0IDI4IEMyLjA2MjUgMjcuNjI1IDIuMDYyNSAyNy42MjUgMCAyNyBDLTEuNDIxNTEzNDUgMjQuMTU2OTczMDkgLTEuMjM5MjI2MDYgMjIuMTY5NzQ1MjggLTEgMTkgQy0wLjUwNSAxNy44NjU2MjUgLTAuMDEgMTYuNzMxMjUgMC41IDE1LjU2MjUgQzIuNTQzNzYwMDggMTAuNzA4NTY5ODEgMi42OTcwMTA1NCA3LjA0NzQ2ODQ1IDEgMi4wNjI1IEMwLjY3IDEuMzgxODc1IDAuMzQgMC43MDEyNSAwIDAgWiAiIGZpbGw9IiNEREVBRTUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNjksNTkpIi8+CjxwYXRoIGQ9Ik0wIDAgQzIgMiAyIDIgMi4yNSA1LjMxMjUgQzIuMDE4NjM0NTIgOC43MjUxNDA4NCAxLjQ3NjUyODggMTAuOTU0NjU5MzUgMCAxNCBDLTAuNjYgMTMuMzQgLTEuMzIgMTIuNjggLTIgMTIgQy0xLjYyNSA4Ljg3NSAtMS42MjUgOC44NzUgLTEgNiBDLTMuMzEgNi4zMyAtNS42MiA2LjY2IC04IDcgQy04LjA0MjcyMSA1LjMzMzg4MDk1IC04LjA0MDYzODMyIDMuNjY2MTcxMTUgLTggMiBDLTUuOTU0NDc5NTggLTAuMDQ1NTIwNDIgLTIuNzI5NDE5MTQgMC4yMzk0MjI3MyAwIDAgWiAiIGZpbGw9IiMwQzZCNDUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNzAsNjIpIi8+CjxwYXRoIGQ9Ik0wIDAgQzQuMjkgMCA4LjU4IDAgMTMgMCBDMTMgMS42NSAxMyAzLjMgMTMgNSBDOC43MSA1IDQuNDIgNSAwIDUgQzAgMy4zNSAwIDEuNyAwIDAgWiAiIGZpbGw9IiMxRTcwQzEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MjksNzkpIi8+CjxwYXRoIGQ9Ik0wIDAgQzEuMzIgMCAyLjY0IDAgNCAwIEM0IDUuMjggNCAxMC41NiA0IDE2IEMyLjY4IDE2IDEuMzYgMTYgMCAxNiBDMCAxMC43MiAwIDUuNDQgMCAwIFogIiBmaWxsPSIjMDA4NDI5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMTY5LDkzKSIvPgo8cGF0aCBkPSJNMCAwIEM0LjI5IDAgOC41OCAwIDEzIDAgQzEyLjY3IDAuOTkgMTIuMzQgMS45OCAxMiAzIEMxMC42OCAzIDkuMzYgMyA4IDMgQzggNS42NCA4IDguMjggOCAxMSBDNy4wMSAxMSA2LjAyIDExIDUgMTEgQzUgOC4zNiA1IDUuNzIgNSAzIEMzLjM1IDIuNjcgMS43IDIuMzQgMCAyIEMwIDEuMzQgMCAwLjY4IDAgMCBaICIgZmlsbD0iI0U4MjAyNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTc0OSwxMTYpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuOTYgMCA3LjkyIDAgMTIgMCBDMTIgMS42NSAxMiAzLjMgMTIgNSBDOC4wNCA1IDQuMDggNSAwIDUgQzAgMy4zNSAwIDEuNyAwIDAgWiAiIGZpbGw9IiMxRTcwQzEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1OTUsNzkpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuOTYgMCA3LjkyIDAgMTIgMCBDMTIgMS42NSAxMiAzLjMgMTIgNSBDOC4wNCA1IDQuMDggNSAwIDUgQzAgMy4zNSAwIDEuNyAwIDAgWiAiIGZpbGw9IiMxRTcwQzEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1MTgsNzkpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuOTYgMCA3LjkyIDAgMTIgMCBDMTIgMS42NSAxMiAzLjMgMTIgNSBDOC4wNCA1IDQuMDggNSAwIDUgQzAgMy4zNSAwIDEuNyAwIDAgWiAiIGZpbGw9IiMxRjcwQzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1MTgsNzIpIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuOTkgMCAxLjk4IDAgMyAwIEMzIDIuNjQgMyA1LjI4IDMgOCBDNS42NCA4IDguMjggOCAxMSA4IEMxMC42NyA4Ljk5IDEwLjM0IDkuOTggMTAgMTEgQzYuNyAxMSAzLjQgMTEgMCAxMSBDMCA3LjM3IDAgMy43NCAwIDAgWiAiIGZpbGw9IiNFODIwMjYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE3OTgsMTE2KSIvPgo8cGF0aCBkPSJNMCAwIEMwLjEyMTE3MTg4IDAuNjAzMjgxMjUgMC4yNDIzNDM3NSAxLjIwNjU2MjUgMC4zNjcxODc1IDEuODI4MTI1IEMwLjUzNDc2NTYzIDIuNjI3MzQzNzUgMC43MDIzNDM3NSAzLjQyNjU2MjUgMC44NzUgNC4yNSBDMS4wMzc0MjE4OCA1LjAzODkwNjI1IDEuMTk5ODQzNzUgNS44Mjc4MTI1IDEuMzY3MTg3NSA2LjY0MDYyNSBDMS45MTcxMzYxNyA5LjAxNDkwNDM4IDEuOTE3MTM2MTcgOS4wMTQ5MDQzOCAzLjA2MjUgMTEuMDkzNzUgQzQuMzcxMjUzNjQgMTMuNzU0ODgyNCA0LjEzMjY4NDUxIDE2LjA4MDk0MDc2IDQgMTkgQzMuMDEgMTkgMi4wMiAxOSAxIDE5IEMwLjcxMTI1IDE3Ljc4MzEyNSAwLjQyMjUgMTYuNTY2MjUgMC4xMjUgMTUuMzEyNSBDLTAuNDgzNjM3NyAxMi44NDMxNjk5MSAtMS4xMzkxMzY4MSAxMC42Njc2MTc2MyAtMi4xMjUgOC4zMTI1IEMtMy4xMDE2MzIyIDUuNzMxNDAwNjMgLTMuMTU2Mzg1NjggMy43MzY3NDk0NSAtMyAxIEMtMSAwIC0xIDAgMCAwIFogIiBmaWxsPSIjMEU2QzQ3IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzY4LDEwMikiLz4KPHBhdGggZD0iTTAgMCBDNC45NSAwIDkuOSAwIDE1IDAgQzE0LjM0IDEuMzIgMTMuNjggMi42NCAxMyA0IEM5LjA0IDQgNS4wOCA0IDEgNCBDMC42NyAyLjY4IDAuMzQgMS4zNiAwIDAgWiAiIGZpbGw9IiMxRTcwQzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MTEsODcpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuNjI1NDM5MjIgMC41MTc5MTk4OSA3LjI1MDczNjc2IDEuMDM2Mzk3MjcgMTAuODc1IDEuNTYyNSBDMTIuOTMwODIyNzEgMS44NzcxMDUwMiAxMi45MzA4MjI3MSAxLjg3NzEwNTAyIDE1IDIgQzE1IDMuNjUgMTUgNS4zIDE1IDcgQzkuNTQ1MjA4MTUgNi40MzE3OTI1MiA1LjA4OTQwNzQ0IDUuMDUzNjIwNTUgMCAzIEMwIDIuMDEgMCAxLjAyIDAgMCBaICIgZmlsbD0iI0VFRjRGMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM5MSw3MykiLz4KPHBhdGggZD0iTTAgMCBDMy42MyAwIDcuMjYgMCAxMSAwIEMxMSAyLjMxIDExIDQuNjIgMTEgNyBDMTAuMzQgNyA5LjY4IDcgOSA3IEM5IDUuNjggOSA0LjM2IDkgMyBDNy4wMiAzIDUuMDQgMyAzIDMgQzIuNjcgNC4zMiAyLjM0IDUuNjQgMiA3IEMxLjM0IDcgMC42OCA3IDAgNyBDMCA0LjY5IDAgMi4zOCAwIDAgWiAiIGZpbGw9IiNFODIwMjYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4MTMsMTIwKSIvPgo8cGF0aCBkPSJNMCAwIEM0LjI5IDAgOC41OCAwIDEzIDAgQzEzIDEuMzIgMTMgMi42NCAxMyA0IEM4LjcxIDQgNC40MiA0IDAgNCBDMCAyLjY4IDAgMS4zNiAwIDAgWiAiIGZpbGw9IiMxRjcwQzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MjksODcpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuOTYgMCA3LjkyIDAgMTIgMCBDMTIuMzMgMS4zMiAxMi42NiAyLjY0IDEzIDQgQzguNzEgNCA0LjQyIDQgMCA0IEMwIDIuNjggMCAxLjM2IDAgMCBaICIgZmlsbD0iIzFFNzBDMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU3Miw4NykiLz4KPHBhdGggZD0iTTAgMCBDMy40NDQ0NzI5OSAyLjkzNTIwOTUxIDMuNTc3ODc2MSA1LjI1NjU4Mjc0IDMuOTY0ODQzNzUgOS41OTc2NTYyNSBDMy45OTg0NTQwNiAxMS44OTQzNjEgMy43Mzc5MTUwOSAxMy44NzUxMjQzMyAzLjMxMjUgMTYuMTI1IEMyLjkwNDY5NjM3IDIxLjE4MTc2NSA0LjE4MDYwNDkgMjIuODk5MDYxNjcgNyAyNyBDNi4zNCAyNy4zMyA1LjY4IDI3LjY2IDUgMjggQy0wLjA2ODA5Mzg0IDIxLjI0ODM4NzEgLTAuMDY4MDkzODQgMjEuMjQ4Mzg3MSAwLjE4NzUgMTYuNTYyNSBDMC40NTU2MjUgMTUuMzg2ODc1IDAuNzIzNzUgMTQuMjExMjUgMSAxMyBDMS4wODIyOTE3IDExLjQzOTExMjI5IDEuMTIyNDQ1OTkgOS44NzU1NTMzNyAxLjEyNSA4LjMxMjUgQzEuMTI4ODY3MTkgNy4yMjM4ODY3MiAxLjEyODg2NzE5IDcuMjIzODg2NzIgMS4xMzI4MTI1IDYuMTEzMjgxMjUgQzAuOTk3ODA3MzIgMy45NjUxMTA1OSAwLjU4NzcyOTQgMi4wNjYzODE5NSAwIDAgWiAiIGZpbGw9IiNEMEUyREIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNzgsNjMpIi8+CjxwYXRoIGQ9Ik0wIDAgQzQuMjkgMCA4LjU4IDAgMTMgMCBDMTIuNjcgMS4zMiAxMi4zNCAyLjY0IDEyIDQgQzguMDQgNCA0LjA4IDQgMCA0IEMwIDIuNjggMCAxLjM2IDAgMCBaICIgZmlsbD0iIzFFNzBDMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU3Miw2NSkiLz4KPHBhdGggZD0iTTAgMCBDMCAwLjk5IDAgMS45OCAwIDMgQy0xLjU3OTY3ODA3IDMuNjc1MjgyMjMgLTMuMTYzOTE5MDMgNC4zMzk4OTY5NCAtNC43NSA1IEMtNi4wNzI1NzgxMyA1LjU1Njg3NSAtNi4wNzI1NzgxMyA1LjU1Njg3NSAtNy40MjE4NzUgNi4xMjUgQy0xMCA3IC0xMCA3IC0xNCA3IEMtMTQgNS42OCAtMTQgNC4zNiAtMTQgMyBDLTQuNTg5OTc3MjIgLTAuNDQ0MTkxMzQgLTQuNTg5OTc3MjIgLTAuNDQ0MTkxMzQgMCAwIFogIiBmaWxsPSIjRUZGNUYzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzMxLDczKSIvPgo8cGF0aCBkPSJNMCAwIEMzLjk2IDAgNy45MiAwIDEyIDAgQzEyIDEuMzIgMTIgMi42NCAxMiA0IEM4LjA0IDQgNC4wOCA0IDAgNCBDMCAyLjY4IDAgMS4zNiAwIDAgWiAiIGZpbGw9IiMxRTcwQzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1OTUsODcpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuOTYgMCA3LjkyIDAgMTIgMCBDMTIgMS4zMiAxMiAyLjY0IDEyIDQgQzguMDQgNCA0LjA4IDQgMCA0IEMwIDIuNjggMCAxLjM2IDAgMCBaICIgZmlsbD0iIzFFNzBDMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTU0OSw4NykiLz4KPHBhdGggZD0iTTAgMCBDMy45NiAwIDcuOTIgMCAxMiAwIEMxMiAxLjMyIDEyIDIuNjQgMTIgNCBDOC4wNCA0IDQuMDggNCAwIDQgQzAgMi42OCAwIDEuMzYgMCAwIFogIiBmaWxsPSIjMUU3MEMwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNTE4LDg3KSIvPgo8cGF0aCBkPSJNMCAwIEMzLjk2IDAgNy45MiAwIDEyIDAgQzEyIDEuMzIgMTIgMi42NCAxMiA0IEM4LjA0IDQgNC4wOCA0IDAgNCBDMCAyLjY4IDAgMS4zNiAwIDAgWiAiIGZpbGw9IiMxRTcwQzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE1NDksNjUpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuOTYgMCA3LjkyIDAgMTIgMCBDMTIgMS4zMiAxMiAyLjY0IDEyIDQgQzguMDQgNCA0LjA4IDQgMCA0IEMwIDIuNjggMCAxLjM2IDAgMCBaICIgZmlsbD0iIzFFNzBDMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTUxOCw2NSkiLz4KPHBhdGggZD0iTTAgMCBDMy4zNzQ2MjcxNSAwLjU0NzIzNjgzIDUuMDgyMzUgMS4wNTQ5IDggMyBDNy4zNCA0Ljk4IDYuNjggNi45NiA2IDkgQzQgOCAyIDcgMCA2IEMwIDQuMDIgMCAyLjA0IDAgMCBaICIgZmlsbD0iIzFENzY1MiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM5Myw5MykiLz4KPHBhdGggZD0iTTAgMCBDMCAzIDAgMyAtMSA1IEMtMS4yMTM3NzcyMSAxMC42MDcwMzIxMyAtMS4yMTM3NzcyMSAxMC42MDcwMzIxMyAwIDE2IEMwLjEyNzgxNzg2IDE4LjY3Mzk0OTY0IDAuMDQzOTE4NzEgMjEuMzIwOTU4NTcgMCAyNCBDLTAuNjYgMjQgLTEuMzIgMjQgLTIgMjQgQy0zLjcyNzI5MzA0IDE3LjI5MDY3OTkxIC00Ljc4MjM1NDYyIDEwLjgxODQwMzYgLTMgNCBDLTEuNDQ5MjE4NzUgMS43MTA5Mzc1IC0xLjQ0OTIxODc1IDEuNzEwOTM3NSAwIDAgWiAiIGZpbGw9IiNEOUU4RTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNDgsNjApIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuMzMgMCAwLjY2IDAgMSAwIEMxIDEuNjUgMSAzLjMgMSA1IEMxLjg4Njg3NSA0LjY5MDYyNSAyLjc3Mzc1IDQuMzgxMjUgMy42ODc1IDQuMDYyNSBDOS4xNjA2NzE0NiAyLjMwNjk1NDQ0IDkuMTYwNjcxNDYgMi4zMDY5NTQ0NCAxMiAyIEMxMi45OSAyLjY2IDEzLjk4IDMuMzIgMTUgNCBDMTQuNjcgNC42NiAxNC4zNCA1LjMyIDE0IDYgQzExLjY4MDI1NzY2IDYuNDE3NTUzNjIgOS4zNDIxNDIwNyA2LjczNTU2NDYgNyA3IEM1LjA1MDkzNzUgNy4yNzg0Mzc1IDUuMDUwOTM3NSA3LjI3ODQzNzUgMy4wNjI1IDcuNTYyNSBDMi4wNTE4NzUgNy43MDY4NzUgMS4wNDEyNSA3Ljg1MTI1IDAgOCBDMCA1LjM2IDAgMi43MiAwIDAgWiAiIGZpbGw9IiMxODcyNEUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzMTcsNjgpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuMzMzMzMzMzMgMCA2LjY2NjY2NjY3IDAgMTAgMCBDMTAgMS45OCAxMCAzLjk2IDEwIDYgQzcuMzYgNiA0LjcyIDYgMiA2IEMyIDQuNjggMiAzLjM2IDIgMiBDMS4zNCAyIDAuNjggMiAwIDIgQzAgMS4zNCAwIDAuNjggMCAwIFogIiBmaWxsPSIjMDA2NDNDIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzg1LDExNykiLz4KPHBhdGggZD0iTTAgMCBDMi45NyAwIDUuOTQgMCA5IDAgQzguNjcgMS42NSA4LjM0IDMuMyA4IDUgQzUuNjkgNSAzLjM4IDUgMSA1IEMwLjY3IDMuMzUgMC4zNCAxLjcgMCAwIFogIiBmaWxsPSIjMUU3MEMxIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNjE0LDk0KSIvPgo8cGF0aCBkPSJNMCAwIEMwIDAuOTkgMCAxLjk4IDAgMyBDLTMuNjMgNC4zMiAtNy4yNiA1LjY0IC0xMSA3IEMtMTEuMzMgNS42OCAtMTEuNjYgNC4zNiAtMTIgMyBDLTEwLjc1MzM2NjY5IDIuNDkxNjY0MDkgLTkuNTAyNTA2MTMgMS45OTM2ODg1NSAtOC4yNSAxLjUgQy03LjU1MzkwNjI1IDEuMjIxNTYyNSAtNi44NTc4MTI1IDAuOTQzMTI1IC02LjE0MDYyNSAwLjY1NjI1IEMtNCAwIC00IDAgMCAwIFogIiBmaWxsPSIjRUZGNUYyIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzI5LDgwKSIvPgo8cGF0aCBkPSJNMCAwIEMxLjA3MDc3Mzc1IDMuMjEyMzIxMjUgMSA1LjYzOTM3ODA3IDEgOSBDMS4zMyA5Ljk5IDEuNjYgMTAuOTggMiAxMiBDMS4wMSAxMiAwLjAyIDEyIC0xIDEyIEMtMS4zMyAxMC4zNSAtMS42NiA4LjcgLTIgNyBDLTMuOTggNyAtNS45NiA3IC04IDcgQy03LjIzNjg3NSA2LjQwMTg3NSAtNi40NzM3NSA1LjgwMzc1IC01LjY4NzUgNS4xODc1IEMtMy42NTE2NDI1IDMuNTMwNDA2NjggLTEuODAyMTcyMSAxLjg5NzAyMzI2IDAgMCBaICIgZmlsbD0iIzBENkI0NSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM2OCw3NSkiLz4KPHBhdGggZD0iTTAgMCBDMS4yMDE1NzEzMSAzLjYwNDcxMzkzIDEuNTQ5ODEzNDggNy4xMTUwMzA4OCAxLjg3NSAxMC44NzUgQzEuOTYwMDc4MTMgMTEuNTgyNjk1MzEgMi4wNDUxNTYyNSAxMi4yOTAzOTA2MyAyLjEzMjgxMjUgMTMuMDE5NTMxMjUgQzIuNDc2OTI2MjggMTcuMjE5MjgzNTEgMi4yMzk3Mzc5MiAxOC43MTA2NjExMyAtMC40OTIxODc1IDIyLjAwNzgxMjUgQy0xLjMxOTc2NTYyIDIyLjY2NTIzNDM3IC0yLjE0NzM0Mzc1IDIzLjMyMjY1NjI1IC0zIDI0IEMtMi4xMjUgMjAuMTI1IC0yLjEyNSAyMC4xMjUgLTEgMTkgQy0wLjkzOTY4OTYzIDE1LjM4NTE0NzQyIC0wLjk4MDA1NDkzIDExLjc4NDEzNTc2IC0xLjAzOTA2MjUgOC4xNjk5MjE4OCBDLTEuMTAwMTMzMTUgMi4yMDAyNjYyOSAtMS4xMDAxMzMxNSAyLjIwMDI2NjI5IDAgMCBaICIgZmlsbD0iI0RERUFFNSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM0Miw2NSkiLz4KPHBhdGggZD0iTTAgMCBDMSAyIDEgMiAwLjkzNzUgNS42ODc1IEMwLjg2OTQ3NzA3IDkuODIxNzgyMyAxLjY5NjU0Mzg5IDEzLjA4OTYzMTY4IDMgMTcgQzIuMzQgMTcgMS42OCAxNyAxIDE3IEMwLjY3IDE4LjMyIDAuMzQgMTkuNjQgMCAyMSBDLTEuMzk3NzM2NjEgMTQuOTA5ODYxOSAtMi40MzkxOTg3NCA5LjI1ODU4MjExIC0yIDMgQy0xLjM0IDIuMDEgLTAuNjggMS4wMiAwIDAgWiAiIGZpbGw9IiMyMTc4NTUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNDgsNjIpIi8+CjxwYXRoIGQ9Ik0wIDAgQzQuMTk0Njk1NzEgMC41OTkyNDIyNCA4LjAwOTk5ODM0IDEuNTc0OTk5NDEgMTIgMyBDMTIgMy45OSAxMiA0Ljk4IDEyIDYgQzcuNjgyMjU0MiA1LjQ5MjAyOTkxIDMuOTY2OTc4ODYgNC44MDMxNzIyMSAwIDMgQzAgMi4wMSAwIDEuMDIgMCAwIFogIiBmaWxsPSIjRTdGMEVDIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzkzLDgwKSIvPgo8cGF0aCBkPSJNMCAwIEMxLjY3NTQyOTc2IDAuMjg2MDQ4OTggMy4zNDM4NTM0MyAwLjYxNzgxMjMzIDUgMSBDNS44NDY4MTEzMyA2LjA4MDg2Nzk2IDYuMDkwMzgwOTkgMTAuODQ4MjgzNzcgNiAxNiBDNS4zNCAxNiA0LjY4IDE2IDQgMTYgQzMuOTUxMDE1NjMgMTUuNDA4MzIwMzEgMy45MDIwMzEyNSAxNC44MTY2NDA2MyAzLjg1MTU2MjUgMTQuMjA3MDMxMjUgQzMuMjYxOTU4IDcuODg5NzQ5MDkgMy4yNjE5NTggNy44ODk3NDkwOSAxIDIgQzAuMzQgMS42NyAtMC4zMiAxLjM0IC0xIDEgQy0wLjY3IDAuNjcgLTAuMzQgMC4zNCAwIDAgWiAiIGZpbGw9IiMxNzcyNEUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNzAsNTcpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuNjA4ODEzMSAwLjgzNTA2MTE3IDMuNjA4ODEzMSAwLjgzNTA2MTE3IDUuODEyNSAtMC41IEM1LjgxMjUgMS4xNSA1LjgxMjUgMi44IDUuODEyNSA0LjUgQzMuNDc5MTY2NjcgNC4xNjY2NjY2NyAxLjE0NTgzMzMzIDMuODMzMzMzMzMgLTEuMTg3NSAzLjUgQy0yLjQ2NjI1IDMuMzU1NjI1IC0zLjc0NSAzLjIxMTI1IC01LjA2MjUgMy4wNjI1IEMtNi4wOTM3NSAyLjg3Njg3NSAtNy4xMjUgMi42OTEyNSAtOC4xODc1IDIuNSBDLTguNTE3NSAxLjg0IC04Ljg0NzUgMS4xOCAtOS4xODc1IDAuNSBDLTUuOTIyMjU5MDcgLTAuNDE4MzQ5MDEgLTMuMzE1NTMyMDkgLTAuNDc3MDk4NDIgMCAwIFogIiBmaWxsPSIjMUI3NDUxIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzk5LjE4NzUsNzEuNSkiLz4KPHBhdGggZD0iTTAgMCBDMi45NyAwIDUuOTQgMCA5IDAgQzguNjcgMS4zMiA4LjM0IDIuNjQgOCA0IEM1LjAzIDQgMi4wNiA0IC0xIDQgQy0wLjY3IDIuNjggLTAuMzQgMS4zNiAwIDAgWiAiIGZpbGw9IiNEQ0VERTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwNDAsOTIpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuOTYgMCA3LjkyIDAgMTIgMCBDMTEuNjcgMC45OSAxMS4zNCAxLjk4IDExIDMgQzcuNyAzIDQuNCAzIDEgMyBDMC42NyAyLjAxIDAuMzQgMS4wMiAwIDAgWiAiIGZpbGw9IiNFNzIwMjYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE3NjYsMTIwKSIvPgo8cGF0aCBkPSJNMCAwIEMzLjk2IDAgNy45MiAwIDEyIDAgQzExLjY3IDAuOTkgMTEuMzQgMS45OCAxMSAzIEM3LjcgMyA0LjQgMyAxIDMgQzAuNjcgMi4wMSAwLjM0IDEuMDIgMCAwIFogIiBmaWxsPSIjRTkyMDI2IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNzY2LDExNikiLz4KPHBhdGggZD0iTTAgMCBDOS40MTAwMjI3OCAtMC4zNjkwMjA1IDkuNDEwMDIyNzggLTAuMzY5MDIwNSAxNCAyIEMxNCAzLjY1IDE0IDUuMyAxNCA3IEMxMy41MDUgNi41MjU2MjUgMTMuMDEgNi4wNTEyNSAxMi41IDUuNTYyNSBDOS45MzI3MzUyOSAzLjk1Nzk1OTU1IDguODAwMzY5MDkgMy43NDk5ODYwOSA1Ljg3NSAzLjUgQzQuNTk2MjUgMy4zMzUgMy4zMTc1IDMuMTcgMiAzIEMxLjM0IDIuMDEgMC42OCAxLjAyIDAgMCBaICIgZmlsbD0iIzNEODk2QiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM1Niw1NSkiLz4KPHBhdGggZD0iTTAgMCBDMC4yODQ4ODI4MSAwLjU3NDkyMTg4IDAuNTY5NzY1NjIgMS4xNDk4NDM3NSAwLjg2MzI4MTI1IDEuNzQyMTg3NSBDMS41OTM5MzI5NyAzLjE5MzQ0NzYyIDIuMzQwMTUwNTEgNC42MzcwMzEgMy4xMDU0Njg3NSA2LjA3MDMxMjUgQzMuNDYyNTM5MDYgNi43NDgzNTkzOCAzLjgxOTYwOTM4IDcuNDI2NDA2MjUgNC4xODc1IDguMTI1IEM0LjU1MjMwNDY5IDguODA4MjAzMTMgNC45MTcxMDkzOCA5LjQ5MTQwNjI1IDUuMjkyOTY4NzUgMTAuMTk1MzEyNSBDNS41MjYyODkwNiAxMC43OTA4NTkzNyA1Ljc1OTYwOTM4IDExLjM4NjQwNjI1IDYgMTIgQzUuNjcgMTIuNjYgNS4zNCAxMy4zMiA1IDE0IEM0LjM0IDE0IDMuNjggMTQgMyAxNCBDLTEuMDc4Nzc0NjIgNS45NjQ5ODkwNiAtMS4wNzg3NzQ2MiA1Ljk2NDk4OTA2IC0wLjc1IDEuOTM3NSBDLTAuNTAyNSAxLjI5ODEyNSAtMC4yNTUgMC42NTg3NSAwIDAgWiAiIGZpbGw9IiMwQzZCNDUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNzgsMTAzKSIvPgo8cGF0aCBkPSJNMCAwIEMzLjk2IDAgNy45MiAwIDEyIDAgQzExLjAxIDEuNDg1IDExLjAxIDEuNDg1IDEwIDMgQzguMTI1IDMuMzI4MTI1IDguMTI1IDMuMzI4MTI1IDYgMy4yNSBDNS4yOTg3NSAzLjIzNDUzMTI1IDQuNTk3NSAzLjIxOTA2MjUgMy44NzUgMy4yMDMxMjUgQzIgMyAyIDMgMCAyIEMwIDEuMzQgMCAwLjY4IDAgMCBaICIgZmlsbD0iI0U4MjAyNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTc2NiwxMjQpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuNjMgMCA3LjI2IDAgMTEgMCBDMTAuNjcgMC45OSAxMC4zNCAxLjk4IDEwIDMgQzcuMDMgMyA0LjA2IDMgMSAzIEMwLjY3IDIuMDEgMC4zNCAxLjAyIDAgMCBaICIgZmlsbD0iI0U4MjAyNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTgxMywxMTYpIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuNDk1IDAuMzkxODc1IDAuOTkgMC43ODM3NSAxLjUgMS4xODc1IEMwLjE2NjY2NjY3IDEuODU0MTY2NjcgLTEuMTY2NjY2NjcgMi41MjA4MzMzMyAtMi41IDMuMTg3NSBDLTMuNDkgMy43NDQzNzUgLTMuNDkgMy43NDQzNzUgLTQuNSA0LjMxMjUgQy02LjUgNS4xODc1IC02LjUgNS4xODc1IC0xMC41IDUuMTg3NSBDLTEwLjUgNC4xOTc1IC0xMC41IDMuMjA3NSAtMTAuNSAyLjE4NzUgQy0zLjI4Nzc0NjE3IC0xLjA2ODUxNzUxIC0zLjI4Nzc0NjE3IC0xLjA2ODUxNzUxIDAgMCBaICIgZmlsbD0iIzEyNkY0QSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTMyNy41LDc3LjgxMjUpIi8+CjxwYXRoIGQ9Ik0wIDAgQzIuNjQgMCA1LjI4IDAgOCAwIEM3LjY3IDEuMzIgNy4zNCAyLjY0IDcgNCBDNC42OSA0IDIuMzggNCAwIDQgQzAgMi42OCAwIDEuMzYgMCAwIFogIiBmaWxsPSIjRDdFQkRFIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDA5LDk2KSIvPgo8cGF0aCBkPSJNMCAwIEMzLjU1NzgwMTk2IDAuNjA5OTA4OTEgNi42ODI4NTg5IDEuNTc4MzY4MSAxMCAzIEM5LjY3IDMuOTkgOS4zNCA0Ljk4IDkgNiBDNS44NTI2MjgxOCA1LjMwMDU4NDA0IDIuOTc0MTExMjQgNC4yMzkyMTMwMiAwIDMgQzAgMi4wMSAwIDEuMDIgMCAwIFogIiBmaWxsPSIjREZFQkU2IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzk0LDg3KSIvPgo8cGF0aCBkPSJNMCAwIEMtMSAzIC0xIDMgLTIuODQ3NjU2MjUgNC4xNjc5Njg3NSBDLTMuNTc4NTU0NjkgNC41MDQ0MTQwNiAtNC4zMDk0NTMxMiA0Ljg0MDg1OTM3IC01LjA2MjUgNS4xODc1IEMtNS43OTU5NzY1NiA1LjUzMTY3OTY5IC02LjUyOTQ1MzEyIDUuODc1ODU5MzggLTcuMjg1MTU2MjUgNi4yMzA0Njg3NSBDLTguMTM0MDAzOTEgNi42MTEzODY3MiAtOC4xMzQwMDM5MSA2LjYxMTM4NjcyIC05IDcgQy05LjMzIDUuNjggLTkuNjYgNC4zNiAtMTAgMyBDLTYuMjcwMzQ4NjEgMC45NjU2NDQ2OSAtNC4zMzA5NDk1OCAwIDAgMCBaICIgZmlsbD0iI0U4RjFFRCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTMyOCw4NykiLz4KPHBhdGggZD0iTTAgMCBDMi4zOTI3MzIzNSAzLjU4OTA5ODUzIDMuMTUzMTA5ODYgNS4yNjMxMzQ3OCAzLjE4NzUgOS41IEMzLjIwMTY3OTY5IDEwLjI5NDA2MjUgMy4yMTU4NTkzOCAxMS4wODgxMjUgMy4yMzA0Njg3NSAxMS45MDYyNSBDMyAxNCAzIDE0IDEgMTYgQy0wLjE1NzAzOTggMTIuNTI4ODgwNTkgLTAuMDMzOTY0ODkgOS43NzM2ODM0NiAwLjA2MjUgNi4xNTYyNSBDMC4wOTg0MjE3OSAzLjgxNDI1MTIzIDAuMDk4NDIxNzkgMy44MTQyNTEyMyAtMSAxIEMtMC42NyAwLjY3IC0wLjM0IDAuMzQgMCAwIFogIiBmaWxsPSIjMjI3OTU2IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzc3LDYyKSIvPgo8cGF0aCBkPSJNMCAwIEMwLjY2IDAuMzMgMS4zMiAwLjY2IDIgMSBDMS4zNCAzLjk3IDAuNjggNi45NCAwIDEwIEMtMC45OSA5LjY3IC0xLjk4IDkuMzQgLTMgOSBDLTIuNDQyNzEwODcgNS42NTYyNjUyNSAtMS42NDgyNjExMSAyLjk2Njg3MDAxIDAgMCBaICIgZmlsbD0iI0RDRUFFNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM0NCwxMDgpIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuMjcyODY2ODIgMi43ODE5MzY4IDQuOTY0Mjc2OTcgNi4yNzk1NDA2NyA3IDEwIEM2LjAxIDEwLjMzIDUuMDIgMTAuNjYgNCAxMSBDMy4zMjU5MTY5MiA5LjczMzA4NDkzIDIuNjYwOTk1MDMgOC40NjEyOTI1MSAyIDcuMTg3NSBDMS42Mjg3NSA2LjQ3OTgwNDY5IDEuMjU3NSA1Ljc3MjEwOTM3IDAuODc1IDUuMDQyOTY4NzUgQzAgMyAwIDMgMCAwIFogIiBmaWxsPSIjRDVFNURGIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzc5LDEwNCkiLz4KPHBhdGggZD0iTTAgMCBDMi42NCAwIDUuMjggMCA4IDAgQzcuMzQgMS4zMiA2LjY4IDIuNjQgNiA0IEMzLjAzIDMuNTA1IDMuMDMgMy41MDUgMCAzIEMwIDIuMDEgMCAxLjAyIDAgMCBaICIgZmlsbD0iI0ZDRkRGQyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjAzOCw5OSkiLz4KPHBhdGggZD0iTTAgMCBDMCAwLjk5IDAgMS45OCAwIDMgQy0zLjQ2NSA0LjQ4NSAtMy40NjUgNC40ODUgLTcgNiBDLTcuMzMgNS4wMSAtNy42NiA0LjAyIC04IDMgQy0zLjM3NSAwIC0zLjM3NSAwIDAgMCBaICIgZmlsbD0iI0Q2RTZERiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTMyOSw5MykiLz4KPHBhdGggZD0iTTAgMCBDLTAuNzUgNy43NSAtMC43NSA3Ljc1IC0zIDEwIEMtNC40NzgzMjI2IDcuMDQzMzU0ODEgLTQuMDYwMzI3ODMgNC4yNTc3MDI2MyAtNCAxIEMtMiAwIC0yIDAgMCAwIFogIiBmaWxsPSIjMkM3RTVEIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzcyLDY2KSIvPgo8cGF0aCBkPSJNMCAwIEMwLjkzMDQ1OTMzIDIuNTUxNDQ4MjQgMS4wODU2NDA5MSAzLjc0MDA2NDc4IDAuMjIyNjU2MjUgNi4zNTkzNzUgQy0wLjE2MDE5NTMxIDcuMTQ4MjgxMjUgLTAuNTQzMDQ2ODggNy45MzcxODc1IC0wLjkzNzUgOC43NSBDLTEuNTA3OTEwMTYgOS45NDg4MjgxMyAtMS41MDc5MTAxNiA5Ljk0ODgyODEzIC0yLjA4OTg0Mzc1IDExLjE3MTg3NSBDLTIuMzkwMTk1MzEgMTEuNzc1MTU2MjUgLTIuNjkwNTQ2ODggMTIuMzc4NDM3NSAtMyAxMyBDLTMuNjYgMTIuNjcgLTQuMzIgMTIuMzQgLTUgMTIgQy00LjQ2MjMxMTI4IDguMTI4NjQxMiAtMy40MjI1MjcgNi4wMjgxNTg3NSAtMSAzIEMtMC42NyAyLjAxIC0wLjM0IDEuMDIgMCAwIFogIiBmaWxsPSIjRENFOUU0IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzQyLDEwMykiLz4KPHBhdGggZD0iTTAgMCBDMC45OSAwLjMzIDEuOTggMC42NiAzIDEgQzIuNTQ2MjUgMS43NDI1IDIuMDkyNSAyLjQ4NSAxLjYyNSAzLjI1IEMwLjMxMzU5MjA0IDUuNDY5MzA1NzggLTAuODgyODA4MDMgNy42Nzk2NzgyMiAtMiAxMCBDLTMuMDYzNTE2NzUgNi42MTYwODMwNyAtMy4yMTQ0Mjk4MiA1LjQxOTUzNjYgLTEuNTYyNSAyLjE4NzUgQy0xLjA0Njg3NSAxLjQ2NTYyNSAtMC41MzEyNSAwLjc0Mzc1IDAgMCBaICIgZmlsbD0iI0RCRTlFMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM3OCw5NikiLz4KPHBhdGggZD0iTTAgMCBDMCAwLjk5IDAgMS45OCAwIDMgQy0yLjUgNC42ODc1IC0yLjUgNC42ODc1IC01IDYgQy01LjY2IDUuMDEgLTYuMzIgNC4wMiAtNyAzIEMtMy4zNzUgMCAtMy4zNzUgMCAwIDAgWiAiIGZpbGw9IiMwRDZDNDYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzMjksOTYpIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuNjYgMCAxLjMyIDAgMiAwIEMyIDAuNjYgMiAxLjMyIDIgMiBDMy4zMiAyIDQuNjQgMiA2IDIgQzYgMi42NiA2IDMuMzIgNiA0IEM0LjY4IDQgMy4zNiA0IDIgNCBDMS42NyA1LjMyIDEuMzQgNi42NCAxIDggQy0wLjM1NDM5NjY4IDUuMjkxMjA2NjUgLTAuMDY1MDE0NTEgMi45OTA2NjczMiAwIDAgWiAiIGZpbGw9IiMxOTczNEYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNTAsNjQpIi8+CjxwYXRoIGQ9Ik0wIDAgQzEuMzIgMC42NiAyLjY0IDEuMzIgNCAyIEM0IDIuOTkgNCAzLjk4IDQgNSBDMSA1IDEgNSAtMC42ODc1IDMuNSBDLTEuMTIwNjI1IDMuMDA1IC0xLjU1Mzc1IDIuNTEgLTIgMiBDLTEuMzQgMS4zNCAtMC42OCAwLjY4IDAgMCBaICIgZmlsbD0iIzE1NzI0QyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM5MiwxMDEpIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuOTkgMC4zMyAxLjk4IDAuNjYgMyAxIEMyLjM0IDMuOTcgMS42OCA2Ljk0IDEgMTAgQzAuMDEgOS4wMSAtMC45OCA4LjAyIC0yIDcgQy0xLjM0IDQuNjkgLTAuNjggMi4zOCAwIDAgWiAiIGZpbGw9IiMyOTdENUIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNzMsNzMpIi8+CjxwYXRoIGQ9Ik0wIDAgQzIgMC42NjY2NjY2NyA0IDEuMzMzMzMzMzMgNiAyIEM1LjY3IDIuNjYgNS4zNCAzLjMyIDUgNCBDMi4zNTEzOTU3MyA0LjU5MzU1NjE0IC0wLjI5MTk3MzIyIDQuNzQyMDkyNjkgLTMgNSBDLTIuNjI1IDMuMDYyNSAtMi42MjUgMy4wNjI1IC0yIDEgQy0xLjM0IDAuNjcgLTAuNjggMC4zNCAwIDAgWiAiIGZpbGw9IiMzMzgzNjMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzMjYsNzApIi8+CjxwYXRoIGQ9Ik0wIDAgQzIuMzEgMCA0LjYyIDAgNyAwIEM3IDEuMzIgNyAyLjY0IDcgNCBDNS42OCA0IDQuMzYgNCAzIDQgQzMgMy4zNCAzIDIuNjggMyAyIEMyLjAxIDIgMS4wMiAyIDAgMiBDMCAxLjM0IDAgMC42OCAwIDAgWiAiIGZpbGw9IiM2N0EyOEEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNTMsNjQpIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuOTkgMCAxLjk4IDAgMyAwIEMyLjY4NzUgMS44NzUgMi42ODc1IDEuODc1IDIgNCBDMS4wMSA0LjY2IDAuMDIgNS4zMiAtMSA2IEMtMS42MjUgNC4xMjUgLTEuNjI1IDQuMTI1IC0yIDIgQy0xLjM0IDEuMzQgLTAuNjggMC42OCAwIDAgWiAiIGZpbGw9IiMxNDcwNEIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzMjgsMTAxKSIvPgo8cGF0aCBkPSJNMCAwIEM0Ljc1IDEuODc1IDQuNzUgMS44NzUgNyAzIEM2LjY3IDMuOTkgNi4zNCA0Ljk4IDYgNiBDMy45NjE2NjU3NiA0LjcyNjA0MTEgMS45NjE0Nzg3NCAzLjM4OTM4MDc3IDAgMiBDMCAxLjM0IDAgMC42OCAwIDAgWiAiIGZpbGw9IiNFOEYxRUUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzOTQsOTMpIi8+CjxwYXRoIGQ9Ik0wIDAgQzEuOTggMCAzLjk2IDAgNiAwIEM2IDAuOTkgNiAxLjk4IDYgMyBDMy42OSAzIDEuMzggMyAtMSAzIEMtMC42NyAyLjAxIC0wLjM0IDEuMDIgMCAwIFogIiBmaWxsPSIjRjhGQkY5IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDEyLDkwKSIvPgo8cGF0aCBkPSJNMCAwIEMwLjMzIDEuMzIgMC42NiAyLjY0IDEgNCBDMS42NiA0IDIuMzIgNCAzIDQgQzMuNjYgNS42NSA0LjMyIDcuMyA1IDkgQzMuMDYyNSA4LjYyNSAzLjA2MjUgOC42MjUgMSA4IEMtMC4zNTQzOTY2OCA1LjI5MTIwNjY1IC0wLjA2NTAxNDUxIDIuOTkwNjY3MzIgMCAwIFogIiBmaWxsPSIjRDRFNERFIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzY4LDc4KSIvPgo8cGF0aCBkPSJNMCAwIEMwLjk5IDAuMzMgMS45OCAwLjY2IDMgMSBDMi4zNCAzLjMxIDEuNjggNS42MiAxIDggQzAuMzQgOCAtMC4zMiA4IC0xIDggQy0xLjEyNSAyLjI1IC0xLjEyNSAyLjI1IDAgMCBaICIgZmlsbD0iI0VGRjVGMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM3MCw3NCkiLz4KPHBhdGggZD0iTTAgMCBDMi4wMDcyMDkyMyAwLjI4Njc0NDE4IDQuMDA4NTk0NCAwLjYxODY2NzAxIDYgMSBDNiAxLjY2IDYgMi4zMiA2IDMgQzQuMzUgMyAyLjcgMyAxIDMgQzEgMy45OSAxIDQuOTggMSA2IEMwLjM0IDYgLTAuMzIgNiAtMSA2IEMtMS4wNDI3MjEgNC4zMzM4ODA5NSAtMS4wNDA2MzgzMiAyLjY2NjE3MTE1IC0xIDEgQy0wLjY3IDAuNjcgLTAuMzQgMC4zNCAwIDAgWiAiIGZpbGw9IiM3MkE5OTMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNjMsNjMpIi8+CjxwYXRoIGQ9Ik0wIDAgQzEuOTM3NSAwLjY4NzUgMS45Mzc1IDAuNjg3NSA0IDIgQzQuNzUgNC42MjUgNC43NSA0LjYyNSA1IDcgQzQuMzQgNyAzLjY4IDcgMyA3IEMwIDIuNjE1Mzg0NjIgMCAyLjYxNTM4NDYyIDAgMCBaICIgZmlsbD0iIzBDNkI0NSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTM1MSw5NykiLz4KPHBhdGggZD0iTTAgMCBDMS4zMiAwIDIuNjQgMCA0IDAgQzQgMC45OSA0IDEuOTggNCAzIEMyLjAyIDMuNjYgMC4wNCA0LjMyIC0yIDUgQy0xLjM0IDMuMzUgLTAuNjggMS43IDAgMCBaICIgZmlsbD0iI0U2RjBFQyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTMyNSw4MCkiLz4KPHBhdGggZD0iTTAgMCBDMS4zMiAwIDIuNjQgMCA0IDAgQzMuNjcgMS4zMiAzLjM0IDIuNjQgMyA0IEMyLjAxIDQgMS4wMiA0IDAgNCBDMCAyLjY4IDAgMS4zNiAwIDAgWiAiIGZpbGw9IiMwMDg0MjgiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIxNjksODcpIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuOTkgMCAxLjk4IDAgMyAwIEMyLjM0IDEuMzIgMS42OCAyLjY0IDEgNCBDMC42NyAyLjY4IDAuMzQgMS4zNiAwIDAgWiAiIGZpbGw9IiMxRTcwQzEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2MTcsMTAyKSIvPgo8L3N2Zz4K" style="\n            width: 742.5px;\n            position: relative;\n            top: 107px;\n            left: 32px;\n            ">\n            <a href=' + accountURL + ' style="\n        float: left;\n        border-radius: 56px;\n        background: #0D6EFD;\n        padding-top: 8px;\n        width: 280px;\n        height: 38px;\n        text-align: center;\n        position: relative;\n        top: 127px;\n        left: 274px;\n        font-size: 16px;\n        color: white;\n        text-decoration: none;\n        letter-spacing: 0.02em;\n    ">Claim your FREE account</a>\n            <div style="\n    font-size: 14px;\n    position: relative;\n    top: 180px;\n    left: 19px;\n    letter-spacing: 0.02em;\n    font-weight: 500;\n    line-height: 125%;\n">have a Syncfusion<sup>®</sup> account? <a href="https://www.syncfusion.com/account/login?ReturnUrl=/account/login" style="text-decoration: none;\ncolor: #0D6EFD;\nfont-weight: 500;">Sign In</a></div>\n        </div>\n    </div>';
  if (typeof document !== "undefined" && !isNullOrUndefined(document)) {
    var errorBackground = createElement("div", {
      innerHTML: bannerTemplate
    });
    document.body.appendChild(errorBackground);
  }
};

// node_modules/@syncfusion/ej2-base/src/component.js
var __extends2 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var componentCount = 0;
var lastPageID;
var lastHistoryLen = 0;
var instancecount = 0;
var isvalid = true;
var isBannerAdded = false;
var versionBasedStatePersistence = false;
var Component = (
  /** @class */
  (function(_super) {
    __extends2(Component4, _super);
    function Component4(options, selector) {
      var _this = _super.call(this, options, selector) || this;
      _this.randomId = uniqueID();
      _this.isStringTemplate = false;
      _this.needsID = false;
      _this.isReactHybrid = false;
      _this.isAngular = false;
      _this.isReact = false;
      _this.isVue = false;
      if (isNullOrUndefined(_this.enableRtl)) {
        _this.setProperties({ "enableRtl": rightToLeft }, true);
      }
      if (isNullOrUndefined(_this.locale)) {
        _this.setProperties({ "locale": defaultCulture }, true);
      }
      _this.moduleLoader = new ModuleLoader(_this);
      _this.localObserver = new Observer(_this);
      onIntlChange.on("notifyExternalChange", _this.detectFunction, _this, _this.randomId);
      if (typeof window !== "undefined" && typeof document !== "undefined" && !validateLicense()) {
        if (componentList.indexOf(_this.getModuleName()) !== -1) {
          instancecount = instancecount + 1;
          if (instancecount > 5) {
            isvalid = false;
          }
        }
      }
      if (!isUndefined(selector)) {
        _this.appendTo();
      }
      return _this;
    }
    Component4.prototype.requiredModules = function() {
      return [];
    };
    Component4.prototype.destroy = function() {
      if (this.isDestroyed) {
        return;
      }
      if (this.enablePersistence) {
        this.setPersistData();
        this.detachUnloadEvent();
      }
      this.localObserver.destroy();
      if (this.refreshing) {
        return;
      }
      removeClass([this.element], ["e-control"]);
      this.trigger("destroyed", { cancel: false });
      _super.prototype.destroy.call(this);
      this.moduleLoader.clean();
      onIntlChange.off("notifyExternalChange", this.detectFunction, this.randomId);
    };
    Component4.prototype.refresh = function() {
      this.refreshing = true;
      this.moduleLoader.clean();
      this.destroy();
      this.clearChanges();
      if (this.enablePersistence) {
        this.attachUnloadEvent();
      }
      this.localObserver = new Observer(this);
      this.preRender();
      this.injectModules();
      this.render();
      this.refreshing = false;
    };
    Component4.prototype.accessMount = function() {
      if (this.mount && !this.isReactHybrid) {
        this.mount();
      }
    };
    Component4.prototype.getRootElement = function() {
      if (this.isReactHybrid) {
        return this.actualElement;
      } else {
        return this.element;
      }
    };
    Component4.prototype.getLocalData = function() {
      var eleId = this.getModuleName() + this.element.id;
      if (versionBasedStatePersistence) {
        return window.localStorage.getItem(eleId + this.ej2StatePersistenceVersion);
      } else {
        return window.localStorage.getItem(eleId);
      }
    };
    Component4.prototype.attachUnloadEvent = function() {
      this.handleUnload = this.handleUnload.bind(this);
      window.addEventListener("pagehide", this.handleUnload);
    };
    Component4.prototype.handleUnload = function() {
      this.setPersistData();
    };
    Component4.prototype.detachUnloadEvent = function() {
      window.removeEventListener("pagehide", this.handleUnload);
    };
    Component4.prototype.appendTo = function(selector) {
      if (!isNullOrUndefined(selector) && typeof selector === "string") {
        this.element = select(selector, document);
      } else if (!isNullOrUndefined(selector)) {
        this.element = selector;
      }
      if (!isNullOrUndefined(this.element)) {
        var moduleClass = "e-" + this.getModuleName().toLowerCase();
        addClass([this.element], ["e-control", moduleClass]);
        this.isProtectedOnChange = false;
        if (this.needsID && !this.element.id) {
          this.element.id = this.getUniqueID(this.getModuleName());
        }
        if (this.enablePersistence) {
          this.mergePersistData();
          this.attachUnloadEvent();
        }
        var inst = getValue("ej2_instances", this.element);
        if (!inst || inst.indexOf(this) === -1) {
          _super.prototype.addInstance.call(this);
        }
        this.preRender();
        this.injectModules();
        var ignoredComponents = {
          schedule: "all",
          diagram: "all",
          PdfViewer: "all",
          grid: ["logger"],
          richtexteditor: ["link", "table", "image", "audio", "video", "formatPainter", "emojiPicker", "pasteCleanup", "htmlEditor", "toolbar", "importExport", "codeBlock"],
          treegrid: ["filter"],
          gantt: ["tooltip"],
          chart: ["Export", "Zoom"],
          accumulationchart: ["Export"],
          "query-builder": "all"
        };
        var component = this.getModuleName();
        if (this.requiredModules && (!ignoredComponents["" + component] || ignoredComponents["" + component] !== "all")) {
          var modulesRequired = this.requiredModules();
          for (var _i = 0, _a = this.moduleLoader.getNonInjectedModules(modulesRequired); _i < _a.length; _i++) {
            var module = _a[_i];
            var moduleName = module.name ? module.name : module.member;
            if (ignoredComponents["" + component] && ignoredComponents["" + component].indexOf(module.member) !== -1) {
              continue;
            }
            var componentName = component.charAt(0).toUpperCase() + component.slice(1);
            console.warn('[WARNING] :: Module "' + moduleName + '" is not available in ' + componentName + " component! You either misspelled the module name or forgot to load it.");
          }
        }
        if (!isvalid && !isBannerAdded) {
          createLicenseOverlay();
          isBannerAdded = true;
        }
        this.render();
        if (!this.mount) {
          this.trigger("created");
        } else {
          this.accessMount();
        }
      }
    };
    Component4.prototype.renderComplete = function(wrapperElement) {
      if (isBlazor()) {
        var sfBlazor = "sfBlazor";
        window["" + sfBlazor].renderComplete(this.element, wrapperElement);
      }
      this.isRendered = true;
    };
    Component4.prototype.dataBind = function() {
      this.injectModules();
      _super.prototype.dataBind.call(this);
    };
    Component4.prototype.on = function(event, handler, context) {
      if (typeof event === "string") {
        this.localObserver.on(event, handler, context);
      } else {
        for (var _i = 0, event_1 = event; _i < event_1.length; _i++) {
          var arg = event_1[_i];
          this.localObserver.on(arg.event, arg.handler, arg.context);
        }
      }
    };
    Component4.prototype.off = function(event, handler) {
      if (typeof event === "string") {
        this.localObserver.off(event, handler);
      } else {
        for (var _i = 0, event_2 = event; _i < event_2.length; _i++) {
          var arg = event_2[_i];
          this.localObserver.off(arg.event, arg.handler);
        }
      }
    };
    Component4.prototype.notify = function(property, argument) {
      if (this.isDestroyed !== true) {
        this.localObserver.notify(property, argument);
      }
    };
    Component4.prototype.getInjectedModules = function() {
      return this.injectedModules;
    };
    Component4.Inject = function() {
      var moduleList = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        moduleList[_i] = arguments[_i];
      }
      if (!this.prototype.injectedModules) {
        this.prototype.injectedModules = [];
      }
      for (var i = 0; i < moduleList.length; i++) {
        if (this.prototype.injectedModules.indexOf(moduleList[parseInt(i.toString(), 10)]) === -1) {
          this.prototype.injectedModules.push(moduleList[parseInt(i.toString(), 10)]);
        }
      }
    };
    Component4.prototype.createElement = function(tagName, prop, isVDOM) {
      return createElement(tagName, prop);
    };
    Component4.prototype.triggerStateChange = function(handler, argument) {
      if (this.isReactHybrid) {
        this.setState();
        this.currentContext = { calls: handler, args: argument };
      }
    };
    Component4.prototype.injectModules = function() {
      if (this.injectedModules && this.injectedModules.length) {
        this.moduleLoader.inject(this.requiredModules(), this.injectedModules);
      }
    };
    Component4.prototype.detectFunction = function(args) {
      var prop = Object.keys(args);
      if (prop.length) {
        this[prop[0]] = args[prop[0]];
      }
    };
    Component4.prototype.mergePersistData = function() {
      var data;
      if (versionBasedStatePersistence) {
        data = window.localStorage.getItem(this.getModuleName() + this.element.id + this.ej2StatePersistenceVersion);
      } else {
        data = window.localStorage.getItem(this.getModuleName() + this.element.id);
      }
      if (!(isNullOrUndefined(data) || data === "")) {
        this.setProperties(JSON.parse(data), true);
      }
    };
    Component4.prototype.setPersistData = function() {
      if (!this.isDestroyed) {
        if (versionBasedStatePersistence) {
          window.localStorage.setItem(this.getModuleName() + this.element.id + this.ej2StatePersistenceVersion, this.getPersistData());
        } else {
          window.localStorage.setItem(this.getModuleName() + this.element.id, this.getPersistData());
        }
      }
    };
    Component4.prototype.renderReactTemplates = function(callback) {
      if (!isNullOrUndefined(callback)) {
        callback();
      }
    };
    Component4.prototype.clearTemplate = function(templateName, index, callback) {
      if (!isNullOrUndefined(callback)) {
        callback();
      }
    };
    Component4.prototype.getUniqueID = function(definedName) {
      if (this.isHistoryChanged()) {
        componentCount = 0;
      }
      lastPageID = this.pageID(location.href);
      lastHistoryLen = history.length;
      return definedName + "_" + lastPageID + "_" + componentCount++;
    };
    Component4.prototype.pageID = function(url) {
      var hash = 0;
      if (url.length === 0) {
        return hash;
      }
      for (var i = 0; i < url.length; i++) {
        var char = url.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return Math.abs(hash);
    };
    Component4.prototype.isHistoryChanged = function() {
      return lastPageID !== this.pageID(location.href) || lastHistoryLen !== history.length;
    };
    Component4.prototype.addOnPersist = function(options) {
      var _this = this;
      var persistObj = {};
      for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
        var key = options_1[_i];
        var objValue = getValue(key, this);
        if (!isUndefined(objValue)) {
          setValue(key, this.getActualProperties(objValue), persistObj);
        }
      }
      return JSON.stringify(persistObj, function(key2, value) {
        return _this.getActualProperties(value);
      });
    };
    Component4.prototype.getActualProperties = function(obj) {
      if (obj instanceof ChildProperty) {
        return getValue("properties", obj);
      } else {
        return obj;
      }
    };
    Component4.prototype.ignoreOnPersist = function(options) {
      return JSON.stringify(this.iterateJsonProperties(this.properties, options));
    };
    Component4.prototype.iterateJsonProperties = function(obj, ignoreList) {
      var newObj = {};
      var _loop_1 = function(key2) {
        if (ignoreList.indexOf(key2) === -1) {
          var value = obj["" + key2];
          if (typeof value === "object" && !(value instanceof Array)) {
            var newList = ignoreList.filter(function(str) {
              var regExp3 = RegExp;
              return new regExp3(key2 + ".").test(str);
            }).map(function(str) {
              return str.replace(key2 + ".", "");
            });
            newObj["" + key2] = this_1.iterateJsonProperties(this_1.getActualProperties(value), newList);
          } else {
            newObj["" + key2] = value;
          }
        }
      };
      var this_1 = this;
      for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var key = _a[_i];
        _loop_1(key);
      }
      return newObj;
    };
    __decorate2([
      Property(false)
    ], Component4.prototype, "enablePersistence", void 0);
    __decorate2([
      Property()
    ], Component4.prototype, "enableRtl", void 0);
    __decorate2([
      Property()
    ], Component4.prototype, "locale", void 0);
    Component4 = __decorate2([
      NotifyPropertyChanges
    ], Component4);
    return Component4;
  })(Base)
);
(function() {
  if (typeof window !== "undefined") {
    window.addEventListener(
      "popstate",
      /* istanbul ignore next */
      function() {
        componentCount = 0;
      }
    );
  }
})();

// node_modules/@syncfusion/ej2-base/src/draggable.js
var __extends3 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var defaultPosition = { left: 0, top: 0, bottom: 0, right: 0 };
var isDraggedObject = { isDragged: false };
var Position = (
  /** @class */
  (function(_super) {
    __extends3(Position2, _super);
    function Position2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate3([
      Property(0)
    ], Position2.prototype, "left", void 0);
    __decorate3([
      Property(0)
    ], Position2.prototype, "top", void 0);
    return Position2;
  })(ChildProperty)
);
var Draggable = (
  /** @class */
  (function(_super) {
    __extends3(Draggable2, _super);
    function Draggable2(element, options) {
      var _this = _super.call(this, options, element) || this;
      _this.dragLimit = Draggable_1.getDefaultPosition();
      _this.borderWidth = Draggable_1.getDefaultPosition();
      _this.padding = Draggable_1.getDefaultPosition();
      _this.diffX = 0;
      _this.prevLeft = 0;
      _this.prevTop = 0;
      _this.dragProcessStarted = false;
      _this.eleTop = 0;
      _this.tapHoldTimer = 0;
      _this.externalInitialize = false;
      _this.diffY = 0;
      _this.parentScrollX = 0;
      _this.parentScrollY = 0;
      _this.droppables = {};
      _this.bind();
      return _this;
    }
    Draggable_1 = Draggable2;
    Draggable2.prototype.bind = function() {
      this.toggleEvents();
      if (Browser.isIE) {
        addClass([this.element], "e-block-touch");
      }
      this.droppables[this.scope] = {};
    };
    Draggable2.getDefaultPosition = function() {
      return extend({}, defaultPosition);
    };
    Draggable2.prototype.toggleEvents = function(isUnWire) {
      var ele;
      if (!isUndefined(this.handle)) {
        ele = select(this.handle, this.element);
      }
      var handler = this.enableTapHold && Browser.isDevice && Browser.isTouch ? this.mobileInitialize : this.initialize;
      if (isUnWire) {
        EventHandler.remove(ele || this.element, Browser.isSafari() ? "touchstart" : Browser.touchStartEvent, handler);
      } else {
        EventHandler.add(ele || this.element, Browser.isSafari() ? "touchstart" : Browser.touchStartEvent, handler, this);
      }
    };
    Draggable2.prototype.mobileInitialize = function(evt) {
      var _this = this;
      var target = evt.currentTarget;
      this.tapHoldTimer = setTimeout(function() {
        _this.externalInitialize = true;
        _this.removeTapholdTimer();
        _this.initialize(evt, target);
      }, this.tapHoldThreshold);
      EventHandler.add(document, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.removeTapholdTimer, this);
      EventHandler.add(document, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.removeTapholdTimer, this);
    };
    Draggable2.prototype.removeTapholdTimer = function() {
      clearTimeout(this.tapHoldTimer);
      EventHandler.remove(document, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.removeTapholdTimer);
      EventHandler.remove(document, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.removeTapholdTimer);
    };
    Draggable2.prototype.getScrollableParent = function(element, axis) {
      var scroll = { "vertical": "scrollHeight", "horizontal": "scrollWidth" };
      var client = { "vertical": "clientHeight", "horizontal": "clientWidth" };
      if (isNullOrUndefined(element)) {
        return null;
      }
      if (element[scroll["" + axis]] > element[client["" + axis]]) {
        if (axis === "vertical" ? element.scrollTop > 0 : element.scrollLeft > 0) {
          if (axis === "vertical") {
            this.parentScrollY = this.parentScrollY + (this.parentScrollY === 0 ? element.scrollTop : element.scrollTop - this.parentScrollY);
            this.tempScrollHeight = element.scrollHeight;
          } else {
            this.parentScrollX = this.parentScrollX + (this.parentScrollX === 0 ? element.scrollLeft : element.scrollLeft - this.parentScrollX);
            this.tempScrollWidth = element.scrollWidth;
          }
          if (!isNullOrUndefined(element)) {
            return this.getScrollableParent(element.parentNode, axis);
          } else {
            return element;
          }
        } else {
          return this.getScrollableParent(element.parentNode, axis);
        }
      } else {
        return this.getScrollableParent(element.parentNode, axis);
      }
    };
    Draggable2.prototype.getScrollableValues = function() {
      this.parentScrollX = 0;
      this.parentScrollY = 0;
      var isModalDialog = this.element.classList.contains("e-dialog") && this.element.classList.contains("e-dlg-modal");
      var verticalScrollParent = this.getScrollableParent(this.element.parentNode, "vertical");
      var horizontalScrollParent = this.getScrollableParent(this.element.parentNode, "horizontal");
    };
    Draggable2.prototype.initialize = function(evt, curTarget) {
      this.currentStateTarget = evt.target;
      if (this.isDragStarted()) {
        return;
      } else {
        this.isDragStarted(true);
        this.externalInitialize = false;
      }
      this.target = evt.currentTarget || curTarget;
      this.dragProcessStarted = false;
      if (this.abort) {
        var abortSelectors = this.abort;
        if (typeof abortSelectors === "string") {
          abortSelectors = [abortSelectors];
        }
        for (var i = 0; i < abortSelectors.length; i++) {
          if (!isNullOrUndefined(closest(evt.target, abortSelectors[parseInt(i.toString(), 10)]))) {
            if (this.isDragStarted()) {
              this.isDragStarted(true);
            }
            return;
          }
        }
      }
      if (this.preventDefault && !isUndefined(evt.changedTouches) && evt.type !== "touchstart") {
        evt.preventDefault();
      }
      this.element.setAttribute("aria-grabbed", "true");
      var intCoord = this.getCoordinates(evt);
      this.initialPosition = { x: intCoord.pageX, y: intCoord.pageY };
      if (!this.clone) {
        var pos = this.element.getBoundingClientRect();
        this.getScrollableValues();
        if (evt.clientX === evt.pageX) {
          this.parentScrollX = 0;
        }
        if (evt.clientY === evt.pageY) {
          this.parentScrollY = 0;
        }
        this.relativeXPosition = intCoord.pageX - (pos.left + this.parentScrollX);
        this.relativeYPosition = intCoord.pageY - (pos.top + this.parentScrollY);
      }
      if (this.externalInitialize) {
        this.intDragStart(evt);
      } else {
        EventHandler.add(document, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.intDragStart, this);
        EventHandler.add(document, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDestroy, this);
      }
      this.toggleEvents(true);
      if (evt.type !== "touchstart" && this.isPreventSelect) {
        document.body.classList.add("e-prevent-select");
      }
      this.externalInitialize = false;
      EventHandler.trigger(document.documentElement, Browser.isSafari() ? "touchstart" : Browser.touchStartEvent, evt);
    };
    Draggable2.prototype.intDragStart = function(evt) {
      this.removeTapholdTimer();
      var isChangeTouch = !isUndefined(evt.changedTouches);
      if (isChangeTouch && evt.changedTouches.length !== 1) {
        return;
      }
      var intCordinate = this.getCoordinates(evt);
      var pos;
      var styleProp = getComputedStyle(this.element);
      this.margin = {
        left: parseInt(styleProp.marginLeft, 10),
        top: parseInt(styleProp.marginTop, 10),
        right: parseInt(styleProp.marginRight, 10),
        bottom: parseInt(styleProp.marginBottom, 10)
      };
      var element = this.element;
      if (this.clone && this.dragTarget) {
        var intClosest = closest(evt.target, this.dragTarget);
        if (!isNullOrUndefined(intClosest)) {
          element = intClosest;
        }
      }
      if (this.isReplaceDragEle) {
        element = this.currentStateCheck(evt.target, element);
      }
      this.offset = this.calculateParentPosition(element);
      this.position = this.getMousePosition(evt, this.isDragScroll);
      var x = this.initialPosition.x - intCordinate.pageX;
      var y = this.initialPosition.y - intCordinate.pageY;
      var distance = Math.sqrt(x * x + y * y);
      if (distance >= this.distance || this.externalInitialize) {
        var ele = this.getHelperElement(evt);
        if (!ele || isNullOrUndefined(ele)) {
          return;
        }
        if (isChangeTouch) {
          evt.preventDefault();
        }
        var dragTargetElement = this.helperElement = ele;
        this.parentClientRect = this.calculateParentPosition(dragTargetElement.offsetParent);
        if (this.dragStart) {
          var curTarget = this.getProperTargetElement(evt);
          var args = {
            event: evt,
            element,
            target: curTarget,
            bindEvents: isBlazor() ? this.bindDragEvents.bind(this) : null,
            dragElement: dragTargetElement
          };
          this.trigger("dragStart", args);
        }
        if (this.dragArea) {
          this.setDragArea();
        } else {
          this.dragLimit = { left: 0, right: 0, bottom: 0, top: 0 };
          this.borderWidth = { top: 0, left: 0 };
        }
        pos = { left: this.position.left - this.parentClientRect.left, top: this.position.top - this.parentClientRect.top };
        if (this.clone && !this.enableTailMode) {
          this.diffX = this.position.left - this.offset.left;
          this.diffY = this.position.top - this.offset.top;
        }
        this.getScrollableValues();
        var styles = getComputedStyle(element);
        var marginTop = parseFloat(styles.marginTop);
        if (this.clone && marginTop !== 0) {
          pos.top += marginTop;
        }
        this.eleTop = !isNaN(parseFloat(styles.top)) ? parseFloat(styles.top) - this.offset.top : 0;
        if (this.enableScrollHandler && !this.clone) {
          pos.top -= this.parentScrollY;
          pos.left -= this.parentScrollX;
        }
        var posValue = this.getProcessedPositionValue({
          top: pos.top - this.diffY + "px",
          left: pos.left - this.diffX + "px"
        });
        if (this.dragArea && typeof this.dragArea !== "string" && this.dragArea.classList.contains("e-kanban-content") && this.dragArea.style.position === "relative") {
          pos.top += this.dragArea.scrollTop;
        }
        this.dragElePosition = { top: pos.top, left: pos.left };
        setStyleAttribute(dragTargetElement, this.getDragPosition({ position: "absolute", left: posValue.left, top: posValue.top }));
        EventHandler.remove(document, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.intDragStart);
        EventHandler.remove(document, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDestroy);
        if (!isBlazor()) {
          this.bindDragEvents(dragTargetElement);
        }
      }
    };
    Draggable2.prototype.bindDragEvents = function(dragTargetElement) {
      if (isVisible(dragTargetElement)) {
        EventHandler.add(document, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.intDrag, this);
        EventHandler.add(document, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDragStop, this);
        this.setGlobalDroppables(false, this.element, dragTargetElement);
      } else {
        this.toggleEvents();
        document.body.classList.remove("e-prevent-select");
      }
    };
    Draggable2.prototype.elementInViewport = function(el) {
      this.top = el.offsetTop;
      this.left = el.offsetLeft;
      this.width = el.offsetWidth;
      this.height = el.offsetHeight;
      while (el.offsetParent) {
        el = el.offsetParent;
        this.top += el.offsetTop;
        this.left += el.offsetLeft;
      }
      return this.top >= window.pageYOffset && this.left >= window.pageXOffset && this.top + this.height <= window.pageYOffset + window.innerHeight && this.left + this.width <= window.pageXOffset + window.innerWidth;
    };
    Draggable2.prototype.getProcessedPositionValue = function(value) {
      if (this.queryPositionInfo) {
        return this.queryPositionInfo(value);
      }
      return value;
    };
    Draggable2.prototype.calculateParentPosition = function(ele) {
      if (isNullOrUndefined(ele)) {
        return { left: 0, top: 0 };
      }
      var rect = ele.getBoundingClientRect();
      var style = getComputedStyle(ele);
      return {
        left: rect.left + window.pageXOffset - parseInt(style.marginLeft, 10),
        top: rect.top + window.pageYOffset - parseInt(style.marginTop, 10)
      };
    };
    Draggable2.prototype.intDrag = function(evt) {
      if (!isUndefined(evt.changedTouches) && evt.changedTouches.length !== 1) {
        return;
      }
      if (this.clone && evt.changedTouches && Browser.isDevice && Browser.isTouch) {
        evt.preventDefault();
      }
      var left;
      var top;
      this.position = this.getMousePosition(evt, this.isDragScroll);
      var docHeight = this.getDocumentWidthHeight("Height");
      if (docHeight < this.position.top) {
        this.position.top = docHeight;
      }
      var docWidth = this.getDocumentWidthHeight("Width");
      if (docWidth < this.position.left) {
        this.position.left = docWidth;
      }
      if (this.drag) {
        var curTarget = this.getProperTargetElement(evt);
        this.trigger("drag", { event: evt, element: this.element, target: curTarget });
      }
      var eleObj = this.checkTargetElement(evt);
      if (eleObj.target && eleObj.instance) {
        var flag = true;
        if (this.hoverObject) {
          if (this.hoverObject.instance !== eleObj.instance) {
            this.triggerOutFunction(evt, eleObj);
          } else {
            flag = false;
          }
        }
        if (flag) {
          eleObj.instance.dragData[this.scope] = this.droppables[this.scope];
          eleObj.instance.intOver(evt, eleObj.target);
          this.hoverObject = eleObj;
        }
      } else if (this.hoverObject) {
        this.triggerOutFunction(evt, eleObj);
      }
      var helperElement = this.droppables[this.scope].helper;
      this.parentClientRect = this.calculateParentPosition(this.helperElement.offsetParent);
      var tLeft = this.parentClientRect.left;
      var tTop = this.parentClientRect.top;
      var intCoord = this.getCoordinates(evt);
      var pagex = intCoord.pageX;
      var pagey = intCoord.pageY;
      var dLeft = this.position.left - this.diffX;
      var dTop = this.position.top - this.diffY;
      var styles = getComputedStyle(helperElement);
      if (this.dragArea) {
        if (this.enableAutoScroll) {
          this.setDragArea();
        }
        if (this.pageX !== pagex || this.skipDistanceCheck) {
          var helperWidth = helperElement.offsetWidth + (parseFloat(styles.marginLeft) + parseFloat(styles.marginRight));
          if (this.dragLimit.left > dLeft && dLeft > 0) {
            left = this.dragLimit.left;
          } else if (this.dragLimit.right + window.pageXOffset < dLeft + helperWidth && dLeft > 0) {
            left = dLeft - (dLeft - this.dragLimit.right) + window.pageXOffset - helperWidth;
          } else {
            left = dLeft < 0 ? this.dragLimit.left : dLeft;
          }
        }
        if (this.pageY !== pagey || this.skipDistanceCheck) {
          var helperHeight = helperElement.offsetHeight + (parseFloat(styles.marginTop) + parseFloat(styles.marginBottom));
          if (this.dragLimit.top > dTop && dTop > 0) {
            top = this.dragLimit.top;
          } else if (this.dragLimit.bottom + window.pageYOffset < dTop + helperHeight && dTop > 0) {
            top = dTop - (dTop - this.dragLimit.bottom) + window.pageYOffset - helperHeight;
          } else {
            top = dTop < 0 ? this.dragLimit.top : dTop;
          }
        }
      } else {
        left = dLeft;
        top = dTop;
      }
      var iTop = tTop + this.borderWidth.top;
      var iLeft = tLeft + this.borderWidth.left;
      if (this.dragProcessStarted) {
        if (isNullOrUndefined(top)) {
          top = this.prevTop;
        }
        if (isNullOrUndefined(left)) {
          left = this.prevLeft;
        }
      }
      var draEleTop;
      var draEleLeft;
      if (this.helperElement.classList.contains("e-treeview")) {
        if (this.dragArea) {
          this.dragLimit.top = this.clone ? this.dragLimit.top : 0;
          draEleTop = top - iTop < 0 ? this.dragLimit.top : top - this.borderWidth.top;
          draEleLeft = left - iLeft < 0 ? this.dragLimit.left : left - this.borderWidth.left;
        } else {
          draEleTop = top - this.borderWidth.top;
          draEleLeft = left - this.borderWidth.left;
        }
      } else {
        if (this.dragArea) {
          var isDialogEle = this.helperElement.classList.contains("e-dialog");
          this.dragLimit.top = this.clone ? this.dragLimit.top : 0;
          draEleTop = top - iTop < 0 ? this.dragLimit.top : top - iTop;
          draEleLeft = left - iLeft < 0 ? isDialogEle ? left - (iLeft - this.borderWidth.left) : this.dragElePosition.left : left - iLeft;
        } else {
          draEleTop = top - iTop;
          draEleLeft = left - iLeft;
        }
      }
      var marginTop = parseFloat(getComputedStyle(this.element).marginTop);
      if (marginTop > 0) {
        if (this.clone) {
          draEleTop += marginTop;
          if (dTop < 0) {
            if (marginTop + dTop >= 0) {
              draEleTop = marginTop + dTop;
            } else {
              draEleTop -= marginTop;
            }
          }
          if (this.dragArea) {
            draEleTop = this.dragLimit.bottom < draEleTop ? this.dragLimit.bottom : draEleTop;
          }
        }
        if (top - iTop < 0) {
          if (dTop + marginTop + (helperElement.offsetHeight - iTop) >= 0) {
            var tempDraEleTop = this.dragLimit.top + dTop - iTop;
            if (tempDraEleTop + marginTop + iTop < 0) {
              draEleTop -= marginTop + iTop;
            } else {
              draEleTop = tempDraEleTop;
            }
          } else {
            draEleTop -= marginTop + iTop;
          }
        }
      }
      if (this.dragArea && this.helperElement.classList.contains("e-treeview")) {
        var helperHeight = helperElement.offsetHeight + (parseFloat(styles.marginTop) + parseFloat(styles.marginBottom));
        draEleTop = draEleTop + helperHeight > this.dragLimit.bottom ? this.dragLimit.bottom - helperHeight : draEleTop;
      }
      if (this.enableScrollHandler && !this.clone) {
        draEleTop -= this.parentScrollY;
        draEleLeft -= this.parentScrollX;
      }
      if (this.dragArea && typeof this.dragArea !== "string" && this.dragArea.classList.contains("e-kanban-content") && this.dragArea.style.position === "relative") {
        draEleTop += this.dragArea.scrollTop;
      }
      var dragValue = this.getProcessedPositionValue({ top: draEleTop + "px", left: draEleLeft + "px" });
      if (this.isPreventScroll) {
        dragValue = this.getProcessedPositionValue({
          top: this.position.top - this.parentClientRect.top - 2 + "px",
          left: this.position.left - this.parentClientRect.left - 2 + "px"
        });
      }
      setStyleAttribute(helperElement, this.getDragPosition(dragValue));
      if (!this.elementInViewport(helperElement) && this.enableAutoScroll && !this.helperElement.classList.contains("e-treeview")) {
        this.helperElement.scrollIntoView();
      }
      var elements = document.querySelectorAll(":hover");
      if (this.enableAutoScroll && this.helperElement.classList.contains("e-treeview")) {
        if (elements.length === 0) {
          elements = this.getPathElements(evt);
        }
        var scrollParent = this.getScrollParent(elements, false);
        if (this.elementInViewport(this.helperElement)) {
          this.getScrollPosition(scrollParent, draEleTop);
        } else if (!this.elementInViewport(this.helperElement)) {
          elements = [].slice.call(document.querySelectorAll(":hover"));
          if (elements.length === 0) {
            elements = this.getPathElements(evt);
          }
          scrollParent = this.getScrollParent(elements, true);
          this.getScrollPosition(scrollParent, draEleTop);
        }
      }
      this.dragProcessStarted = true;
      this.prevLeft = left;
      this.prevTop = top;
      this.position.left = left;
      this.position.top = top;
      this.pageX = pagex;
      this.pageY = pagey;
    };
    Draggable2.prototype.getScrollParent = function(node, reverse) {
      var nodeEl = reverse ? node.reverse() : node;
      var hasScroll;
      for (var i = nodeEl.length - 1; i >= 0; i--) {
        hasScroll = window.getComputedStyle(nodeEl[parseInt(i.toString(), 10)])["overflow-y"];
        if ((hasScroll === "auto" || hasScroll === "scroll") && nodeEl[parseInt(i.toString(), 10)].scrollHeight > nodeEl[parseInt(i.toString(), 10)].clientHeight) {
          return nodeEl[parseInt(i.toString(), 10)];
        }
      }
      hasScroll = window.getComputedStyle(document.scrollingElement)["overflow-y"];
      if (hasScroll === "visible") {
        document.scrollingElement.style.overflow = "auto";
        return document.scrollingElement;
      }
    };
    Draggable2.prototype.getScrollPosition = function(nodeEle, draEleTop) {
      if (nodeEle && nodeEle === document.scrollingElement) {
        if (nodeEle.clientHeight + document.scrollingElement.scrollTop - this.helperElement.clientHeight < draEleTop && nodeEle.getBoundingClientRect().height + this.parentClientRect.top > draEleTop) {
          nodeEle.scrollTop += this.helperElement.clientHeight;
        } else if (nodeEle.scrollTop > draEleTop - this.helperElement.clientHeight) {
          nodeEle.scrollTop -= this.helperElement.clientHeight;
        }
      } else if (nodeEle && nodeEle !== document.scrollingElement) {
        var docScrollTop = document.scrollingElement.scrollTop;
        var helperClientHeight = this.helperElement.clientHeight;
        if (nodeEle.clientHeight + nodeEle.getBoundingClientRect().top - helperClientHeight + docScrollTop < draEleTop) {
          nodeEle.scrollTop += this.helperElement.clientHeight;
        } else if (nodeEle.getBoundingClientRect().top > draEleTop - helperClientHeight - docScrollTop) {
          nodeEle.scrollTop -= this.helperElement.clientHeight;
        }
      }
    };
    Draggable2.prototype.getPathElements = function(evt) {
      var elementTop = evt.clientX > 0 ? evt.clientX : 0;
      var elementLeft = evt.clientY > 0 ? evt.clientY : 0;
      return document.elementsFromPoint(elementTop, elementLeft);
    };
    Draggable2.prototype.triggerOutFunction = function(evt, eleObj) {
      this.hoverObject.instance.intOut(evt, eleObj.target);
      this.hoverObject.instance.dragData[this.scope] = null;
      this.hoverObject = null;
    };
    Draggable2.prototype.getDragPosition = function(dragValue) {
      var temp = extend({}, dragValue);
      if (this.axis) {
        if (this.axis === "x") {
          delete temp.top;
        } else if (this.axis === "y") {
          delete temp.left;
        }
      }
      return temp;
    };
    Draggable2.prototype.getDocumentWidthHeight = function(str) {
      var docBody = document.body;
      var docEle = document.documentElement;
      var returnValue = Math.max(docBody["scroll" + str], docEle["scroll" + str], docBody["offset" + str], docEle["offset" + str], docEle["client" + str]);
      return returnValue;
    };
    Draggable2.prototype.intDragStop = function(evt) {
      this.dragProcessStarted = false;
      if (!isUndefined(evt.changedTouches) && evt.changedTouches.length !== 1) {
        return;
      }
      var type = ["touchend", "pointerup", "mouseup"];
      if (type.indexOf(evt.type) !== -1) {
        if (this.dragStop) {
          var curTarget = this.getProperTargetElement(evt);
          this.trigger("dragStop", { event: evt, element: this.element, target: curTarget, helper: this.helperElement });
        }
        this.intDestroy(evt);
      } else {
        this.element.setAttribute("aria-grabbed", "false");
      }
      var eleObj = this.checkTargetElement(evt);
      if (eleObj.target && eleObj.instance) {
        eleObj.instance.dragStopCalled = true;
        eleObj.instance.dragData[this.scope] = this.droppables[this.scope];
        eleObj.instance.intDrop(evt, eleObj.target);
      }
      this.setGlobalDroppables(true);
      document.body.classList.remove("e-prevent-select");
    };
    Draggable2.prototype.intDestroy = function(evt) {
      this.dragProcessStarted = false;
      this.toggleEvents();
      document.body.classList.remove("e-prevent-select");
      this.element.setAttribute("aria-grabbed", "false");
      EventHandler.remove(document, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.intDragStart);
      EventHandler.remove(document, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDragStop);
      EventHandler.remove(document, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDestroy);
      EventHandler.remove(document, Browser.isSafari() ? "touchmove" : Browser.touchMoveEvent, this.intDrag);
      if (this.isDragStarted()) {
        this.isDragStarted(true);
      }
    };
    Draggable2.prototype.onPropertyChanged = function(newProp, oldProp) {
    };
    Draggable2.prototype.getModuleName = function() {
      return "draggable";
    };
    Draggable2.prototype.isDragStarted = function(change) {
      if (change) {
        isDraggedObject.isDragged = !isDraggedObject.isDragged;
      }
      return isDraggedObject.isDragged;
    };
    Draggable2.prototype.setDragArea = function() {
      var eleWidthBound;
      var eleHeightBound;
      var top = 0;
      var left = 0;
      var ele;
      var type = typeof this.dragArea;
      if (type === "string") {
        ele = select(this.dragArea);
      } else {
        ele = this.dragArea;
      }
      if (ele) {
        var elementArea = ele.getBoundingClientRect();
        eleWidthBound = ele.scrollWidth ? ele.scrollWidth : elementArea.right - elementArea.left;
        eleHeightBound = ele.scrollHeight ? this.dragArea && !isNullOrUndefined(this.helperElement) && this.helperElement.classList.contains("e-treeview") ? ele.clientHeight : ele.scrollHeight : elementArea.bottom - elementArea.top;
        var keys2 = ["Top", "Left", "Bottom", "Right"];
        var styles = getComputedStyle(ele);
        for (var i = 0; i < keys2.length; i++) {
          var key = keys2[parseInt(i.toString(), 10)];
          var tborder = styles["border" + key + "Width"];
          var tpadding = styles["padding" + key];
          var lowerKey = key.toLowerCase();
          this.borderWidth["" + lowerKey] = isNaN(parseFloat(tborder)) ? 0 : parseFloat(tborder);
          this.padding["" + lowerKey] = isNaN(parseFloat(tpadding)) ? 0 : parseFloat(tpadding);
        }
        if (this.dragArea && !isNullOrUndefined(this.helperElement) && this.helperElement.classList.contains("e-treeview")) {
          top = elementArea.top + document.scrollingElement.scrollTop;
        } else {
          top = elementArea.top;
        }
        left = elementArea.left;
        this.dragLimit.left = left + this.borderWidth.left + this.padding.left;
        this.dragLimit.top = ele.offsetTop + this.borderWidth.top + this.padding.top;
        this.dragLimit.right = left + eleWidthBound - (this.borderWidth.right + this.padding.right);
        this.dragLimit.bottom = top + eleHeightBound - (this.borderWidth.bottom + this.padding.bottom);
      }
    };
    Draggable2.prototype.getProperTargetElement = function(evt) {
      var intCoord = this.getCoordinates(evt);
      var ele;
      var prevStyle = this.helperElement.style.pointerEvents || "";
      var isPointer = evt.type.indexOf("pointer") !== -1 && Browser.info.name === "safari" && parseInt(Browser.info.version, 10) > 12;
      if (compareElementParent(evt.target, this.helperElement) || evt.type.indexOf("touch") !== -1 || isPointer) {
        this.helperElement.style.pointerEvents = "none";
        ele = document.elementFromPoint(intCoord.clientX, intCoord.clientY);
        this.helperElement.style.pointerEvents = prevStyle;
      } else {
        ele = evt.target;
      }
      return ele;
    };
    Draggable2.prototype.currentStateCheck = function(ele, oldEle) {
      var elem;
      if (!isNullOrUndefined(this.currentStateTarget) && this.currentStateTarget !== ele) {
        elem = this.currentStateTarget;
      } else {
        elem = !isNullOrUndefined(oldEle) ? oldEle : ele;
      }
      return elem;
    };
    Draggable2.prototype.getMousePosition = function(evt, isdragscroll) {
      var dragEle = evt.srcElement !== void 0 ? evt.srcElement : evt.target;
      var intCoord = this.getCoordinates(evt);
      var pageX;
      var pageY;
      var isOffsetParent = isNullOrUndefined(dragEle.offsetParent);
      if (isdragscroll) {
        pageX = this.clone ? intCoord.pageX : intCoord.pageX + (isOffsetParent ? 0 : dragEle.offsetParent.scrollLeft) - this.relativeXPosition;
        pageY = this.clone ? intCoord.pageY : intCoord.pageY + (isOffsetParent ? 0 : dragEle.offsetParent.scrollTop) - this.relativeYPosition;
      } else {
        pageX = this.clone ? intCoord.pageX : intCoord.pageX + window.pageXOffset - this.relativeXPosition;
        pageY = this.clone ? intCoord.pageY : intCoord.pageY + window.pageYOffset - this.relativeYPosition;
      }
      if (document.scrollingElement && (!isdragscroll && !this.clone)) {
        var ele = document.scrollingElement;
        var isVerticalScroll = ele.scrollHeight > 0 && ele.scrollHeight > ele.clientHeight && ele.scrollTop > 0;
        var isHorrizontalScroll = ele.scrollWidth > 0 && ele.scrollWidth > ele.clientWidth && ele.scrollLeft > 0;
        pageX = isHorrizontalScroll ? pageX - ele.scrollLeft : pageX;
        pageY = isVerticalScroll ? pageY - ele.scrollTop : pageY;
      }
      return {
        left: pageX - (this.margin.left + this.cursorAt.left),
        top: pageY - (this.margin.top + this.cursorAt.top)
      };
    };
    Draggable2.prototype.getCoordinates = function(evt) {
      if (evt.type.indexOf("touch") > -1) {
        return evt.changedTouches[0];
      }
      return evt;
    };
    Draggable2.prototype.getHelperElement = function(evt) {
      var element;
      if (this.clone) {
        if (this.helper) {
          element = this.helper({ sender: evt, element: this.target, currentTargetElement: this.currentStateTarget });
        } else {
          element = createElement("div", { className: "e-drag-helper e-block-touch", innerHTML: "Draggable" });
          document.body.appendChild(element);
        }
      } else {
        element = this.element;
      }
      return element;
    };
    Draggable2.prototype.setGlobalDroppables = function(reset, drag, helper) {
      this.droppables[this.scope] = reset ? null : {
        draggable: drag,
        helper,
        draggedElement: this.element
      };
    };
    Draggable2.prototype.checkTargetElement = function(evt) {
      var target = this.getProperTargetElement(evt);
      var dropIns = this.getDropInstance(target);
      if (!dropIns && target && !isNullOrUndefined(target.parentNode)) {
        var parent_1 = closest(target.parentNode, ".e-droppable") || target.parentElement;
        if (parent_1) {
          dropIns = this.getDropInstance(parent_1);
        }
      }
      return { target, instance: dropIns };
    };
    Draggable2.prototype.getDropInstance = function(ele) {
      var name = "getModuleName";
      var drop;
      var eleInst = ele && ele.ej2_instances;
      if (eleInst) {
        for (var _i = 0, eleInst_1 = eleInst; _i < eleInst_1.length; _i++) {
          var inst = eleInst_1[_i];
          if (inst["" + name]() === "droppable") {
            drop = inst;
            break;
          }
        }
      }
      return drop;
    };
    Draggable2.prototype.destroy = function() {
      this.toggleEvents(true);
      _super.prototype.destroy.call(this);
    };
    var Draggable_1;
    __decorate3([
      Complex({}, Position)
    ], Draggable2.prototype, "cursorAt", void 0);
    __decorate3([
      Property(true)
    ], Draggable2.prototype, "clone", void 0);
    __decorate3([
      Property()
    ], Draggable2.prototype, "dragArea", void 0);
    __decorate3([
      Property()
    ], Draggable2.prototype, "isDragScroll", void 0);
    __decorate3([
      Property()
    ], Draggable2.prototype, "isReplaceDragEle", void 0);
    __decorate3([
      Property(true)
    ], Draggable2.prototype, "isPreventSelect", void 0);
    __decorate3([
      Property(false)
    ], Draggable2.prototype, "isPreventScroll", void 0);
    __decorate3([
      Event2()
    ], Draggable2.prototype, "drag", void 0);
    __decorate3([
      Event2()
    ], Draggable2.prototype, "dragStart", void 0);
    __decorate3([
      Event2()
    ], Draggable2.prototype, "dragStop", void 0);
    __decorate3([
      Property(1)
    ], Draggable2.prototype, "distance", void 0);
    __decorate3([
      Property()
    ], Draggable2.prototype, "handle", void 0);
    __decorate3([
      Property()
    ], Draggable2.prototype, "abort", void 0);
    __decorate3([
      Property()
    ], Draggable2.prototype, "helper", void 0);
    __decorate3([
      Property("default")
    ], Draggable2.prototype, "scope", void 0);
    __decorate3([
      Property("")
    ], Draggable2.prototype, "dragTarget", void 0);
    __decorate3([
      Property()
    ], Draggable2.prototype, "axis", void 0);
    __decorate3([
      Property()
    ], Draggable2.prototype, "queryPositionInfo", void 0);
    __decorate3([
      Property(false)
    ], Draggable2.prototype, "enableTailMode", void 0);
    __decorate3([
      Property(false)
    ], Draggable2.prototype, "skipDistanceCheck", void 0);
    __decorate3([
      Property(true)
    ], Draggable2.prototype, "preventDefault", void 0);
    __decorate3([
      Property(false)
    ], Draggable2.prototype, "enableAutoScroll", void 0);
    __decorate3([
      Property(false)
    ], Draggable2.prototype, "enableTapHold", void 0);
    __decorate3([
      Property(750)
    ], Draggable2.prototype, "tapHoldThreshold", void 0);
    __decorate3([
      Property(false)
    ], Draggable2.prototype, "enableScrollHandler", void 0);
    Draggable2 = Draggable_1 = __decorate3([
      NotifyPropertyChanges
    ], Draggable2);
    return Draggable2;
  })(Base)
);

// node_modules/@syncfusion/ej2-base/src/droppable.js
var __extends4 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Droppable = (
  /** @class */
  (function(_super) {
    __extends4(Droppable2, _super);
    function Droppable2(element, options) {
      var _this = _super.call(this, options, element) || this;
      _this.mouseOver = false;
      _this.dragData = {};
      _this.dragStopCalled = false;
      _this.bind();
      return _this;
    }
    Droppable2.prototype.bind = function() {
      this.wireEvents();
    };
    Droppable2.prototype.wireEvents = function() {
      EventHandler.add(this.element, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDrop, this);
    };
    Droppable2.prototype.onPropertyChanged = function(newProp, oldProp) {
    };
    Droppable2.prototype.getModuleName = function() {
      return "droppable";
    };
    Droppable2.prototype.intOver = function(event, element) {
      if (!this.mouseOver) {
        var drag = this.dragData[this.scope];
        this.trigger("over", { event, target: element, dragData: drag });
        this.mouseOver = true;
      }
    };
    Droppable2.prototype.intOut = function(event, element) {
      if (this.mouseOver) {
        this.trigger("out", { evt: event, target: element });
        this.mouseOver = false;
      }
    };
    Droppable2.prototype.intDrop = function(evt, element) {
      if (!this.dragStopCalled) {
        return;
      } else {
        this.dragStopCalled = false;
      }
      var accept = true;
      var drag = this.dragData[this.scope];
      var isDrag = drag ? drag.helper && isVisible(drag.helper) : false;
      var area;
      if (isDrag) {
        area = this.isDropArea(evt, drag.helper, element);
        if (this.accept) {
          accept = matches(drag.helper, this.accept);
        }
      }
      if (isDrag && this.drop && area.canDrop && accept) {
        this.trigger("drop", { event: evt, target: area.target, droppedElement: drag.helper, dragData: drag });
      }
      this.mouseOver = false;
    };
    Droppable2.prototype.isDropArea = function(evt, helper, element) {
      var area = { canDrop: true, target: element || evt.target };
      var isTouch = evt.type === "touchend";
      if (isTouch || area.target === helper) {
        helper.style.display = "none";
        var coord = isTouch ? evt.changedTouches[0] : evt;
        var ele = document.elementFromPoint(coord.clientX, coord.clientY);
        area.canDrop = false;
        area.canDrop = compareElementParent(ele, this.element);
        if (area.canDrop) {
          area.target = ele;
        }
        helper.style.display = "";
      }
      return area;
    };
    Droppable2.prototype.destroy = function() {
      EventHandler.remove(this.element, Browser.isSafari() ? "touchend" : Browser.touchEndEvent, this.intDrop);
      _super.prototype.destroy.call(this);
    };
    __decorate4([
      Property()
    ], Droppable2.prototype, "accept", void 0);
    __decorate4([
      Property("default")
    ], Droppable2.prototype, "scope", void 0);
    __decorate4([
      Event2()
    ], Droppable2.prototype, "drop", void 0);
    __decorate4([
      Event2()
    ], Droppable2.prototype, "over", void 0);
    __decorate4([
      Event2()
    ], Droppable2.prototype, "out", void 0);
    Droppable2 = __decorate4([
      NotifyPropertyChanges
    ], Droppable2);
    return Droppable2;
  })(Base)
);

// node_modules/@syncfusion/ej2-base/src/keyboard.js
var __extends5 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var keyCode = {
  "backspace": 8,
  "tab": 9,
  "enter": 13,
  "shift": 16,
  "control": 17,
  "alt": 18,
  "pause": 19,
  "capslock": 20,
  "space": 32,
  "escape": 27,
  "pageup": 33,
  "pagedown": 34,
  "end": 35,
  "home": 36,
  "leftarrow": 37,
  "uparrow": 38,
  "rightarrow": 39,
  "downarrow": 40,
  "insert": 45,
  "delete": 46,
  "f1": 112,
  "f2": 113,
  "f3": 114,
  "f4": 115,
  "f5": 116,
  "f6": 117,
  "f7": 118,
  "f8": 119,
  "f9": 120,
  "f10": 121,
  "f11": 122,
  "f12": 123,
  "semicolon": 186,
  "plus": 187,
  "comma": 188,
  "minus": 189,
  "dot": 190,
  "forwardslash": 191,
  "graveaccent": 192,
  "openbracket": 219,
  "backslash": 220,
  "closebracket": 221,
  "singlequote": 222
};
var KeyboardEvents = (
  /** @class */
  (function(_super) {
    __extends5(KeyboardEvents2, _super);
    function KeyboardEvents2(element, options) {
      var _this = _super.call(this, options, element) || this;
      _this.keyPressHandler = function(e) {
        var isAltKey = e.altKey;
        var isCtrlKey = e.ctrlKey;
        var isShiftKey = e.shiftKey;
        var curkeyCode = e.which;
        var keys2 = Object.keys(_this.keyConfigs);
        for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          var configCollection = _this.keyConfigs["" + key].split(",");
          for (var _a = 0, configCollection_1 = configCollection; _a < configCollection_1.length; _a++) {
            var rconfig = configCollection_1[_a];
            var rKeyObj = KeyboardEvents_1.getKeyConfigData(rconfig.trim());
            if (isAltKey === rKeyObj.altKey && isCtrlKey === rKeyObj.ctrlKey && isShiftKey === rKeyObj.shiftKey && curkeyCode === rKeyObj.keyCode) {
              e.action = key;
              if (_this.keyAction) {
                _this.keyAction(e);
              }
            }
          }
        }
      };
      _this.bind();
      return _this;
    }
    KeyboardEvents_1 = KeyboardEvents2;
    KeyboardEvents2.prototype.destroy = function() {
      this.unwireEvents();
      _super.prototype.destroy.call(this);
    };
    KeyboardEvents2.prototype.onPropertyChanged = function(newProp, oldProp) {
    };
    KeyboardEvents2.prototype.bind = function() {
      this.wireEvents();
    };
    KeyboardEvents2.prototype.getModuleName = function() {
      return "keyboard";
    };
    KeyboardEvents2.prototype.wireEvents = function() {
      this.element.addEventListener(this.eventName, this.keyPressHandler);
    };
    KeyboardEvents2.prototype.unwireEvents = function() {
      this.element.removeEventListener(this.eventName, this.keyPressHandler);
    };
    KeyboardEvents2.getKeyConfigData = function(config) {
      if (config in this.configCache) {
        return this.configCache["" + config];
      }
      var keys2 = config.toLowerCase().split("+");
      var keyData = {
        altKey: keys2.indexOf("alt") !== -1 ? true : false,
        ctrlKey: keys2.indexOf("ctrl") !== -1 ? true : false,
        shiftKey: keys2.indexOf("shift") !== -1 ? true : false,
        keyCode: null
      };
      if (keys2[keys2.length - 1].length > 1 && !!Number(keys2[keys2.length - 1])) {
        keyData.keyCode = Number(keys2[keys2.length - 1]);
      } else {
        keyData.keyCode = KeyboardEvents_1.getKeyCode(keys2[keys2.length - 1]);
      }
      KeyboardEvents_1.configCache["" + config] = keyData;
      return keyData;
    };
    KeyboardEvents2.getKeyCode = function(keyVal) {
      return keyCode["" + keyVal] || keyVal.toUpperCase().charCodeAt(0);
    };
    var KeyboardEvents_1;
    KeyboardEvents2.configCache = {};
    __decorate5([
      Property({})
    ], KeyboardEvents2.prototype, "keyConfigs", void 0);
    __decorate5([
      Property("keyup")
    ], KeyboardEvents2.prototype, "eventName", void 0);
    __decorate5([
      Event2()
    ], KeyboardEvents2.prototype, "keyAction", void 0);
    KeyboardEvents2 = KeyboardEvents_1 = __decorate5([
      NotifyPropertyChanges
    ], KeyboardEvents2);
    return KeyboardEvents2;
  })(Base)
);

// node_modules/@syncfusion/ej2-base/src/l10n.js
var L10n = (
  /** @class */
  (function() {
    function L10n2(controlName, localeStrings, locale) {
      this.controlName = controlName;
      this.localeStrings = localeStrings;
      this.setLocale(locale || defaultCulture);
    }
    L10n2.prototype.setLocale = function(locale) {
      var intLocale = this.intGetControlConstant(L10n2.locale, locale);
      this.currentLocale = intLocale || this.localeStrings;
    };
    L10n2.load = function(localeObject) {
      this.locale = extend(this.locale, localeObject, {}, true);
    };
    L10n2.prototype.getConstant = function(prop) {
      if (!isNullOrUndefined(this.currentLocale["" + prop])) {
        return this.currentLocale["" + prop];
      } else {
        return this.localeStrings["" + prop] || "";
      }
    };
    L10n2.prototype.intGetControlConstant = function(curObject, locale) {
      if (curObject["" + locale]) {
        return curObject["" + locale][this.controlName];
      }
      return null;
    };
    L10n2.locale = {};
    return L10n2;
  })()
);

// node_modules/@syncfusion/ej2-base/src/touch.js
var __extends6 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SwipeSettings = (
  /** @class */
  (function(_super) {
    __extends6(SwipeSettings2, _super);
    function SwipeSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate6([
      Property(50)
    ], SwipeSettings2.prototype, "swipeThresholdDistance", void 0);
    return SwipeSettings2;
  })(ChildProperty)
);
var swipeRegex = /(Up|Down)/;
var Touch = (
  /** @class */
  (function(_super) {
    __extends6(Touch2, _super);
    function Touch2(element, options) {
      var _this = _super.call(this, options, element) || this;
      _this.touchAction = true;
      _this.tapCount = 0;
      _this.startEvent = function(evt) {
        if (_this.touchAction === true) {
          var point = _this.updateChangeTouches(evt);
          if (evt.changedTouches !== void 0) {
            _this.touchAction = false;
          }
          _this.isTouchMoved = false;
          _this.movedDirection = "";
          _this.startPoint = _this.lastMovedPoint = { clientX: point.clientX, clientY: point.clientY };
          _this.startEventData = point;
          _this.hScrollLocked = _this.vScrollLocked = false;
          _this.tStampStart = Date.now();
          _this.timeOutTapHold = setTimeout(function() {
            _this.tapHoldEvent(evt);
          }, _this.tapHoldThreshold);
          EventHandler.add(_this.element, Browser.touchMoveEvent, _this.moveEvent, _this);
          EventHandler.add(_this.element, Browser.touchEndEvent, _this.endEvent, _this);
          EventHandler.add(_this.element, Browser.touchCancelEvent, _this.cancelEvent, _this);
        }
      };
      _this.moveEvent = function(evt) {
        var point = _this.updateChangeTouches(evt);
        _this.movedPoint = point;
        _this.isTouchMoved = !(point.clientX === _this.startPoint.clientX && point.clientY === _this.startPoint.clientY);
        var eScrollArgs = {};
        if (_this.isTouchMoved) {
          clearTimeout(_this.timeOutTapHold);
          _this.calcScrollPoints(evt);
          var scrollArg = {
            startEvents: _this.startEventData,
            originalEvent: evt,
            startX: _this.startPoint.clientX,
            startY: _this.startPoint.clientY,
            distanceX: _this.distanceX,
            distanceY: _this.distanceY,
            scrollDirection: _this.scrollDirection,
            velocity: _this.getVelocity(point)
          };
          eScrollArgs = extend(eScrollArgs, {}, scrollArg);
          _this.trigger("scroll", eScrollArgs);
          _this.lastMovedPoint = { clientX: point.clientX, clientY: point.clientY };
        }
      };
      _this.cancelEvent = function(evt) {
        clearTimeout(_this.timeOutTapHold);
        clearTimeout(_this.timeOutTap);
        _this.tapCount = 0;
        _this.swipeFn(evt);
        EventHandler.remove(_this.element, Browser.touchCancelEvent, _this.cancelEvent);
      };
      _this.endEvent = function(evt) {
        _this.swipeFn(evt);
        if (!_this.isTouchMoved) {
          if (typeof _this.tap === "function") {
            _this.trigger("tap", { originalEvent: evt, tapCount: ++_this.tapCount });
            _this.timeOutTap = setTimeout(function() {
              _this.tapCount = 0;
            }, _this.tapThreshold);
          }
        }
        _this.modeclear();
      };
      _this.swipeFn = function(evt) {
        clearTimeout(_this.timeOutTapHold);
        clearTimeout(_this.timeOutTap);
        var point = _this.updateChangeTouches(evt);
        var diffX = point.clientX - _this.startPoint.clientX;
        var diffY = point.clientY - _this.startPoint.clientY;
        diffX = Math.floor(diffX < 0 ? -1 * diffX : diffX);
        diffY = Math.floor(diffY < 0 ? -1 * diffY : diffX);
        _this.isTouchMoved = diffX > 1 || diffY > 1;
        var isFirefox = /Firefox/.test(Browser.userAgent);
        if (isFirefox && point.clientX === 0 && point.clientY === 0 && evt.type === "mouseup") {
          _this.isTouchMoved = false;
        }
        _this.endPoint = point;
        _this.calcPoints(evt);
        var swipeArgs = {
          originalEvent: evt,
          startEvents: _this.startEventData,
          startX: _this.startPoint.clientX,
          startY: _this.startPoint.clientY,
          distanceX: _this.distanceX,
          distanceY: _this.distanceY,
          swipeDirection: _this.movedDirection,
          velocity: _this.getVelocity(point)
        };
        if (_this.isTouchMoved) {
          var tDistance = _this.swipeSettings.swipeThresholdDistance;
          var eSwipeArgs = extend(void 0, _this.defaultArgs, swipeArgs);
          var canTrigger = false;
          var ele = _this.element;
          var scrollBool = _this.isScrollable(ele);
          var moved = swipeRegex.test(_this.movedDirection);
          if (tDistance < _this.distanceX && !moved || tDistance < _this.distanceY && moved) {
            if (!scrollBool) {
              canTrigger = true;
            } else {
              canTrigger = _this.checkSwipe(ele, moved);
            }
          }
          if (canTrigger) {
            _this.trigger("swipe", eSwipeArgs);
          }
        }
        _this.modeclear();
      };
      _this.modeclear = function() {
        _this.modeClear = setTimeout(function() {
          _this.touchAction = true;
        }, typeof _this.tap !== "function" ? 0 : 20);
        _this.lastTapTime = (/* @__PURE__ */ new Date()).getTime();
        EventHandler.remove(_this.element, Browser.touchMoveEvent, _this.moveEvent);
        EventHandler.remove(_this.element, Browser.touchEndEvent, _this.endEvent);
        EventHandler.remove(_this.element, Browser.touchCancelEvent, _this.cancelEvent);
      };
      _this.bind();
      return _this;
    }
    Touch2.prototype.onPropertyChanged = function(newProp, oldProp) {
    };
    Touch2.prototype.bind = function() {
      this.wireEvents();
      if (Browser.isIE) {
        this.element.classList.add("e-block-touch");
      }
    };
    Touch2.prototype.destroy = function() {
      this.unwireEvents();
      _super.prototype.destroy.call(this);
    };
    Touch2.prototype.wireEvents = function() {
      EventHandler.add(this.element, Browser.touchStartEvent, this.startEvent, this);
    };
    Touch2.prototype.unwireEvents = function() {
      EventHandler.remove(this.element, Browser.touchStartEvent, this.startEvent);
    };
    Touch2.prototype.getModuleName = function() {
      return "touch";
    };
    Touch2.prototype.isScrollable = function(element) {
      var eleStyle = getComputedStyle(element);
      var style = eleStyle.overflow + eleStyle.overflowX + eleStyle.overflowY;
      if (/(auto|scroll)/.test(style)) {
        return true;
      }
      return false;
    };
    Touch2.prototype.tapHoldEvent = function(evt) {
      this.tapCount = 0;
      this.touchAction = true;
      EventHandler.remove(this.element, Browser.touchMoveEvent, this.moveEvent);
      EventHandler.remove(this.element, Browser.touchEndEvent, this.endEvent);
      var eTapArgs = { originalEvent: evt };
      this.trigger("tapHold", eTapArgs);
      EventHandler.remove(this.element, Browser.touchCancelEvent, this.cancelEvent);
    };
    Touch2.prototype.calcPoints = function(evt) {
      var point = this.updateChangeTouches(evt);
      this.defaultArgs = { originalEvent: evt };
      this.distanceX = Math.abs(Math.abs(point.clientX) - Math.abs(this.startPoint.clientX));
      this.distanceY = Math.abs(Math.abs(point.clientY) - Math.abs(this.startPoint.clientY));
      if (this.distanceX > this.distanceY) {
        this.movedDirection = point.clientX > this.startPoint.clientX ? "Right" : "Left";
      } else {
        this.movedDirection = point.clientY < this.startPoint.clientY ? "Up" : "Down";
      }
    };
    Touch2.prototype.calcScrollPoints = function(evt) {
      var point = this.updateChangeTouches(evt);
      this.defaultArgs = { originalEvent: evt };
      this.distanceX = Math.abs(Math.abs(point.clientX) - Math.abs(this.lastMovedPoint.clientX));
      this.distanceY = Math.abs(Math.abs(point.clientY) - Math.abs(this.lastMovedPoint.clientY));
      if ((this.distanceX > this.distanceY || this.hScrollLocked === true) && this.vScrollLocked === false) {
        this.scrollDirection = point.clientX > this.lastMovedPoint.clientX ? "Right" : "Left";
        this.hScrollLocked = true;
      } else {
        this.scrollDirection = point.clientY < this.lastMovedPoint.clientY ? "Up" : "Down";
        this.vScrollLocked = true;
      }
    };
    Touch2.prototype.getVelocity = function(pnt) {
      var newX = pnt.clientX;
      var newY = pnt.clientY;
      var newT = Date.now();
      var xDist = newX - this.startPoint.clientX;
      var yDist = newY - this.startPoint.clientX;
      var interval = newT - this.tStampStart;
      return Math.sqrt(xDist * xDist + yDist * yDist) / interval;
    };
    Touch2.prototype.checkSwipe = function(ele, flag) {
      var keys2 = ["scroll", "offset"];
      var temp = flag ? ["Height", "Top"] : ["Width", "Left"];
      if (ele[keys2[0] + temp[0]] <= ele[keys2[1] + temp[0]]) {
        return true;
      }
      return ele[keys2[0] + temp[1]] === 0 || ele[keys2[1] + temp[0]] + ele[keys2[0] + temp[1]] >= ele[keys2[0] + temp[0]];
    };
    Touch2.prototype.updateChangeTouches = function(evt) {
      var point = evt.changedTouches && evt.changedTouches.length !== 0 ? evt.changedTouches[0] : evt;
      return point;
    };
    __decorate6([
      Event2()
    ], Touch2.prototype, "tap", void 0);
    __decorate6([
      Event2()
    ], Touch2.prototype, "tapHold", void 0);
    __decorate6([
      Event2()
    ], Touch2.prototype, "swipe", void 0);
    __decorate6([
      Event2()
    ], Touch2.prototype, "scroll", void 0);
    __decorate6([
      Property(350)
    ], Touch2.prototype, "tapThreshold", void 0);
    __decorate6([
      Property(750)
    ], Touch2.prototype, "tapHoldThreshold", void 0);
    __decorate6([
      Complex({}, SwipeSettings)
    ], Touch2.prototype, "swipeSettings", void 0);
    Touch2 = __decorate6([
      NotifyPropertyChanges
    ], Touch2);
    return Touch2;
  })(Base)
);

// node_modules/@syncfusion/ej2-base/src/template.js
var LINES = new RegExp("\\n|\\r|\\s\\s+", "g");
var QUOTES = new RegExp(/'|"/g);
var IF_STMT = new RegExp("if ?\\(");
var ELSEIF_STMT = new RegExp("else if ?\\(");
var ELSE_STMT = new RegExp("else");
var FOR_STMT = new RegExp("for ?\\(");
var IF_OR_FOR = new RegExp("(/if|/for)");
var CALL_FUNCTION = new RegExp("\\((.*)\\)", "");
var NOT_NUMBER = new RegExp("^[0-9]+$", "g");
var WORD = new RegExp(`[\\w"'.\\s+]+`, "g");
var DBL_QUOTED_STR = new RegExp('"(.*?)"', "g");
var WORDIF = new RegExp(`[\\w"'@#$.\\s-+]+`, "g");
var exp = new RegExp("\\${([^}]*)}", "g");
var ARR_OBJ = /^\..*/gm;
var SINGLE_SLASH = /\\/gi;
var DOUBLE_SLASH = /\\\\/gi;
var WORDFUNC = new RegExp(`[\\w"'@#$.\\s+]+`, "g");
var WINDOWFUNC = /\window\./gm;
function compile(template, helper, ignorePrefix) {
  if (typeof template === "function") {
    return template;
  } else {
    var argName = "data";
    var evalExpResult = evalExp(template, argName, helper, ignorePrefix);
    var condtion = `var valueRegEx = (/value=\\'([A-Za-z0-9 _]*)((.)([\\w)(!-;?-■\\s]+)['])/g);
        var hrefRegex = (/(?:href)([\\s='"./]+)([\\w-./?=&\\\\#"]+)((.)([\\w)(!-;/?-■\\s]+)['])/g);
        if(str.match(valueRegEx)){
            var check = str.match(valueRegEx);
            var str1 = str;
            for (var i=0; i < check.length; i++) {
                var check1 = str.match(valueRegEx)[i].split('value=')[1];
                var change = check1.match(/^'/) !== null ? check1.replace(/^'/, '"') : check1;
                change =change.match(/.$/)[0] === '\\'' ? change.replace(/.$/,'"') : change;
                str1 = str1.replace(check1, change);
            }
            str = str.replace(str, str1);
        }
        else if (str.match(/(?:href='')/) === null) {
            if(str.match(hrefRegex)) {
                var check = str.match(hrefRegex);
                var str1 = str;
                for (var i=0; i < check.length; i++) {
                    var check1 = str.match(hrefRegex)[i].split('href=')[1];
                    if (check1) {
                        var change = check1.match(/^'/) !== null ? check1.replace(/^'/, '"') : check1;
                        change =change.match(/.$/)[0] === '\\'' ? change.replace(/.$/,'"') : change;
                        str1 = str1.replace(check1, change);
                    }
                }
                str = str.replace(str, str1);
            }
        }
        `;
    var fnCode = 'var str="' + evalExpResult + '";' + condtion + " return str;";
    var fn = new Function(argName, fnCode);
    return fn.bind(helper);
  }
}
function evalExp(str, nameSpace, helper, ignorePrefix) {
  var varCOunt = 0;
  var localKeys = [];
  var isClass = str.match(/class="([^"]+|)\s{2}/g);
  var singleSpace = "";
  if (isClass) {
    isClass.forEach(function(value) {
      singleSpace = value.replace(/\s\s+/g, " ");
      str = str.replace(value, singleSpace);
    });
  }
  if (exp.test(str)) {
    var insideBraces = false;
    var outputString = "";
    for (var i = 0; i < str.length; i++) {
      if (str[i + ""] === "$" && str[i + 1] === "{") {
        insideBraces = true;
      } else if (str[i + ""] === "}") {
        insideBraces = false;
      }
      outputString += str[i + ""] === '"' && !insideBraces ? '\\"' : str[i + ""];
    }
    str = outputString;
  } else {
    str = str.replace(/\\?"/g, '\\"');
  }
  return str.replace(LINES, "").replace(DBL_QUOTED_STR, "'$1'").replace(exp, function(match, cnt, offset, matchStr) {
    var SPECIAL_CHAR = /@|#|\$/gm;
    var matches2 = cnt.match(CALL_FUNCTION);
    if (matches2) {
      var rlStr = matches2[1];
      if (ELSEIF_STMT.test(cnt)) {
        cnt = '";} ' + cnt.replace(matches2[1], rlStr.replace(WORD, function(str2) {
          str2 = str2.trim();
          return addNameSpace(str2, !QUOTES.test(str2) && localKeys.indexOf(str2) === -1, nameSpace, localKeys, ignorePrefix);
        })) + '{ \n str = str + "';
      } else if (IF_STMT.test(cnt)) {
        cnt = '"; ' + cnt.replace(matches2[1], rlStr.replace(WORDIF, function(strs) {
          return HandleSpecialCharArrObj(strs, nameSpace, localKeys, ignorePrefix);
        })) + '{ \n str = str + "';
      } else if (FOR_STMT.test(cnt)) {
        var rlStr_1 = matches2[1].split(" of ");
        cnt = '"; ' + cnt.replace(matches2[1], function(mtc) {
          localKeys.push(rlStr_1[0]);
          localKeys.push(rlStr_1[0] + "Index");
          varCOunt = varCOunt + 1;
          return "var i" + varCOunt + "=0; i" + varCOunt + " < " + addNameSpace(rlStr_1[1], true, nameSpace, localKeys, ignorePrefix) + ".length; i" + varCOunt + "++";
        }) + "{ \n " + rlStr_1[0] + "= " + addNameSpace(rlStr_1[1], true, nameSpace, localKeys, ignorePrefix) + "[i" + varCOunt + "]; \n var " + rlStr_1[0] + "Index=i" + varCOunt + '; \n str = str + "';
      } else {
        var fnStr = cnt.split("(");
        var fNameSpace = helper && Object.prototype.hasOwnProperty.call(helper, fnStr[0]) ? "this." : "global";
        fNameSpace = /\./.test(fnStr[0]) ? "" : fNameSpace;
        var ftArray = matches2[1].split(",");
        if (matches2[1].length !== 0 && !/data/.test(ftArray[0]) && !/window./.test(ftArray[0])) {
          matches2[1] = fNameSpace === "global" ? nameSpace + "." + matches2[1] : matches2[1];
        }
        var splRegexp = /@|\$|#/gm;
        var arrObj = /\]\./gm;
        if (WINDOWFUNC.test(cnt) && arrObj.test(cnt) || splRegexp.test(cnt)) {
          var splArrRegexp = /@|\$|#|\]\./gm;
          if (splArrRegexp.test(cnt)) {
            cnt = '"+ ' + (fNameSpace === "global" ? "" : fNameSpace) + cnt.replace(matches2[1], rlStr.replace(WORDFUNC, function(strs) {
              return HandleSpecialCharArrObj(strs, nameSpace, localKeys, ignorePrefix);
            })) + '+ "';
          }
        } else {
          cnt = '" + ' + (fNameSpace === "global" ? "" : fNameSpace) + cnt.replace(rlStr, addNameSpace(matches2[1].replace(/,( |)data.|,/gi, "," + nameSpace + ".").replace(/,( |)data.window/gi, ",window"), fNameSpace === "global" ? false : true, nameSpace, localKeys, ignorePrefix)) + '+"';
        }
      }
    } else if (ELSE_STMT.test(cnt)) {
      cnt = '"; ' + cnt.replace(ELSE_STMT, '} else { \n str = str + "');
    } else if (cnt.match(IF_OR_FOR)) {
      cnt = cnt.replace(IF_OR_FOR, '"; \n } \n str = str + "');
    } else if (SPECIAL_CHAR.test(cnt)) {
      if (cnt.match(SINGLE_SLASH)) {
        cnt = SlashReplace(cnt);
      }
      cnt = '"+' + NameSpaceForspecialChar(cnt, localKeys.indexOf(cnt) === -1, nameSpace, localKeys) + '"]+"';
    } else {
      if (cnt.match(SINGLE_SLASH)) {
        cnt = SlashReplace(cnt);
        cnt = '"+' + NameSpaceForspecialChar(cnt, localKeys.indexOf(cnt) === -1, nameSpace, localKeys) + '"]+"';
      } else {
        cnt = cnt !== "" ? '"+' + addNameSpace(cnt.replace(/,/gi, "+" + nameSpace + "."), localKeys.indexOf(cnt) === -1, nameSpace, localKeys, ignorePrefix) + '+"' : "${}";
      }
    }
    return cnt;
  });
}
function addNameSpace(str, addNS, nameSpace, ignoreList, ignorePrefix) {
  return addNS && !NOT_NUMBER.test(str) && ignoreList.indexOf(str.split(".")[0]) === -1 && !ignorePrefix && str !== "true" && str !== "false" ? nameSpace + "." + str : str;
}
function NameSpaceArrObj(str, addNS, nameSpace, ignoreList) {
  var arrObjReg = /^\..*/gm;
  return addNS && !NOT_NUMBER.test(str) && ignoreList.indexOf(str.split(".")[0]) === -1 && !arrObjReg.test(str) ? nameSpace + "." + str : str;
}
function NameSpaceForspecialChar(str, addNS, nameSpace, ignoreList) {
  return addNS && !NOT_NUMBER.test(str) && ignoreList.indexOf(str.split(".")[0]) === -1 ? nameSpace + '["' + str : str;
}
function SlashReplace(tempStr) {
  var double = "\\\\";
  if (tempStr.match(DOUBLE_SLASH)) {
    return tempStr;
  } else {
    return tempStr.replace(SINGLE_SLASH, double);
  }
}
function HandleSpecialCharArrObj(str, nameSpaceNew, keys2, ignorePrefix) {
  str = str.trim();
  var windowFunc = /\window\./gm;
  if (!windowFunc.test(str)) {
    var quotes = /'|"/gm;
    var splRegexp = /@|\$|#/gm;
    if (splRegexp.test(str)) {
      str = NameSpaceForspecialChar(str, keys2.indexOf(str) === -1, nameSpaceNew, keys2) + '"]';
    }
    if (ARR_OBJ.test(str)) {
      return NameSpaceArrObj(str, !quotes.test(str) && keys2.indexOf(str) === -1, nameSpaceNew, keys2);
    } else {
      return addNameSpace(str, !quotes.test(str) && keys2.indexOf(str) === -1, nameSpaceNew, keys2, ignorePrefix);
    }
  } else {
    return str;
  }
}

// node_modules/@syncfusion/ej2-base/src/template-engine.js
var HAS_ROW = /^[\n\r.]+<tr|^<tr/;
var HAS_SVG = /^[\n\r.]+<svg|^<path|^<g/;
var blazorTemplates = {};
function getRandomId() {
  return "-" + Math.random().toString(36).substr(2, 5);
}
function compile2(templateString, helper, ignorePrefix) {
  var compiler = engineObj.compile(templateString, helper, ignorePrefix);
  return function(data, component, propName, templateId, isStringTemplate, index, element, root) {
    var result = compiler(data, component, propName, element, root);
    var blazorTemplateId = "BlazorTemplateId";
    if (isBlazor() && !isStringTemplate) {
      var randomId = getRandomId();
      var blazorId = templateId + randomId;
      if (!blazorTemplates["" + templateId]) {
        blazorTemplates["" + templateId] = [];
      }
      if (!isNullOrUndefined(index)) {
        var keys2 = Object.keys(blazorTemplates["" + templateId][parseInt(index.toString(), 10)]);
        for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          if (key !== blazorTemplateId && data["" + key]) {
            blazorTemplates["" + templateId][parseInt(index.toString(), 10)]["" + key] = data["" + key];
          }
          if (key === blazorTemplateId) {
            blazorId = blazorTemplates["" + templateId][parseInt(index.toString(), 10)]["" + key];
          }
        }
      } else {
        data["" + blazorTemplateId] = blazorId;
        blazorTemplates["" + templateId].push(data);
      }
      return propName === "rowTemplate" ? [createElement("tr", { id: blazorId, className: "e-blazor-template" })] : [createElement("div", { id: blazorId, className: "e-blazor-template" })];
    }
    if (typeof result === "string") {
      if (HAS_SVG.test(result)) {
        var ele = createElement("svg", { innerHTML: result });
        return ele.childNodes;
      } else {
        var ele = createElement(HAS_ROW.test(result) ? "table" : "div", { innerHTML: result });
        return ele.childNodes;
      }
    } else {
      return result;
    }
  };
}
function updateBlazorTemplate(templateId, templateName, comp, isEmpty, callBack) {
  if (isBlazor()) {
    var ejsIntrop = "sfBlazor";
    window["" + ejsIntrop].updateTemplate(templateName, blazorTemplates["" + templateId], templateId, comp, callBack);
    if (isEmpty !== false) {
      blazorTemplates["" + templateId] = [];
    }
  }
}
function resetBlazorTemplate(templateId, templateName, index) {
  var templateDiv = document.getElementById(templateId);
  if (templateDiv) {
    var innerTemplates = templateDiv.getElementsByClassName("blazor-inner-template");
    for (var i = 0; i < innerTemplates.length; i++) {
      var tempId = " ";
      if (!isNullOrUndefined(index)) {
        tempId = innerTemplates[parseInt(index.toString(), 10)].getAttribute("data-templateId");
      } else {
        tempId = innerTemplates[parseInt(i.toString(), 10)].getAttribute("data-templateId");
      }
      var tempElement = document.getElementById(tempId);
      if (tempElement) {
        var length_1 = tempElement.childNodes.length;
        for (var j = 0; j < length_1; j++) {
          if (!isNullOrUndefined(index)) {
            innerTemplates[parseInt(index.toString(), 10)].appendChild(tempElement.childNodes[0]);
            i = innerTemplates.length;
          } else {
            innerTemplates[parseInt(i.toString(), 10)].appendChild(tempElement.childNodes[0]);
          }
        }
      }
    }
  }
}
function setTemplateEngine(classObj) {
  engineObj.compile = classObj.compile;
}
function getTemplateEngine() {
  return engineObj.compile;
}
var Engine = (
  /** @class */
  (function() {
    function Engine2() {
    }
    Engine2.prototype.compile = function(templateString, helper, ignorePrefix) {
      if (helper === void 0) {
        helper = {};
      }
      return compile(templateString, helper);
    };
    return Engine2;
  })()
);
var engineObj = { compile: new Engine().compile };

// node_modules/@syncfusion/ej2-base/src/sanitize-helper.js
var removeTags = [
  "script",
  "style",
  "iframe[src]",
  'link[href*="javascript:"]',
  'object[type="text/x-scriptlet"]',
  'object[data^="data:text/html;base64"]',
  'img[src^="data:text/html;base64"]',
  '[src^="javascript:"]',
  '[dynsrc^="javascript:"]',
  '[lowsrc^="javascript:"]',
  '[type^="application/x-shockwave-flash"]'
];
var removeAttrs = [
  { attribute: "href", selector: '[href*="javascript:"]' },
  { attribute: "href", selector: "a[href]" },
  { attribute: "background", selector: '[background^="javascript:"]' },
  { attribute: "style", selector: '[style*="javascript:"]' },
  { attribute: "style", selector: '[style*="expression("]' },
  { attribute: "href", selector: 'a[href^="data:text/html;base64"]' }
];
var jsEvents = [
  "onchange",
  "onclick",
  "onmouseover",
  "onmouseout",
  "onkeydown",
  "onload",
  "onerror",
  "onblur",
  "onfocus",
  "onbeforeload",
  "onbeforeunload",
  "onkeyup",
  "onsubmit",
  "onafterprint",
  "onbeforeonload",
  "onbeforeprint",
  "oncanplay",
  "oncanplaythrough",
  "oncontextmenu",
  "ondblclick",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onended",
  "onformchange",
  "onforminput",
  "onhaschange",
  "oninput",
  "oninvalid",
  "onkeypress",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onmessage",
  "onmousedown",
  "onmousemove",
  "onmouseup",
  "onmousewheel",
  "onoffline",
  "onoine",
  "ononline",
  "onpagehide",
  "onpageshow",
  "onpause",
  "onplay",
  "onplaying",
  "onpopstate",
  "onprogress",
  "onratechange",
  "onreadystatechange",
  "onredo",
  "onresize",
  "onscroll",
  "onseeked",
  "onseeking",
  "onselect",
  "onstalled",
  "onstorage",
  "onsuspend",
  "ontimeupdate",
  "onundo",
  "onunload",
  "onvolumechange",
  "onwaiting",
  "onmouseenter",
  "onmouseleave",
  "onstart",
  "onpropertychange",
  "oncopy",
  "ontoggle",
  "onpointerout",
  "onpointermove",
  "onpointerleave",
  "onpointerenter",
  "onpointerrawupdate",
  "onpointerover",
  "onbeforecopy",
  "onbeforecut",
  "onbeforeinput"
];
var SanitizeHtmlHelper = (
  /** @class */
  (function() {
    function SanitizeHtmlHelper2() {
    }
    SanitizeHtmlHelper2.beforeSanitize = function() {
      return {
        selectors: {
          tags: removeTags,
          attributes: removeAttrs
        }
      };
    };
    SanitizeHtmlHelper2.sanitize = function(value) {
      if (isNullOrUndefined(value)) {
        return value;
      }
      var item = this.beforeSanitize();
      var output = this.serializeValue(item, value);
      return output;
    };
    SanitizeHtmlHelper2.serializeValue = function(item, value) {
      this.removeAttrs = item.selectors.attributes;
      this.removeTags = item.selectors.tags;
      this.wrapElement = document.createElement("div");
      this.wrapElement.innerHTML = value;
      this.removeXssTags();
      this.removeJsEvents();
      this.removeXssAttrs();
      var tempEleValue = this.wrapElement.innerHTML;
      this.removeElement();
      this.wrapElement = null;
      return tempEleValue.replace(/&amp;/g, "&");
    };
    SanitizeHtmlHelper2.removeElement = function() {
      var nodes = this.wrapElement.children;
      for (var j = 0; j < nodes.length; j++) {
        var attribute = nodes[parseInt(j.toString(), 10)].attributes;
        for (var i = 0; i < attribute.length; i++) {
          this.wrapElement.children[parseInt(j.toString(), 10)].removeAttribute(attribute[parseInt(i.toString(), 10)].localName);
        }
      }
    };
    SanitizeHtmlHelper2.removeXssTags = function() {
      var elements = this.wrapElement.querySelectorAll(this.removeTags.join(","));
      if (elements.length > 0) {
        elements.forEach(function(element) {
          detach(element);
        });
      } else {
        return;
      }
    };
    SanitizeHtmlHelper2.removeJsEvents = function() {
      var elements = this.wrapElement.querySelectorAll("[" + jsEvents.join("],[") + "]");
      if (elements.length > 0) {
        elements.forEach(function(element) {
          jsEvents.forEach(function(attr) {
            if (element.hasAttribute(attr)) {
              element.removeAttribute(attr);
            }
          });
        });
      } else {
        return;
      }
    };
    SanitizeHtmlHelper2.removeXssAttrs = function() {
      var _this = this;
      this.removeAttrs.forEach(function(item, index) {
        var elements = _this.wrapElement.querySelectorAll(item.selector);
        if (elements.length > 0) {
          if (item.selector === "a[href]") {
            elements.forEach(function(element) {
              if (element.getAttribute(item.attribute).replace(/\t|\s|&/, "").indexOf("javascript:alert") !== -1) {
                element.removeAttribute(item.attribute);
              }
            });
          } else {
            elements.forEach(function(element) {
              element.removeAttribute(item.attribute);
            });
          }
        }
      });
    };
    return SanitizeHtmlHelper2;
  })()
);

// node_modules/@syncfusion/ej2-react-base/src/component-base.js
var __extends7 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var defaulthtmlkeys = [
  "alt",
  "className",
  "disabled",
  "form",
  "id",
  "readOnly",
  "style",
  "tabIndex",
  "title",
  "type",
  "name",
  "onClick",
  "onFocus",
  "onBlur"
];
var delayUpdate = ["accordion", "tab", "splitter"];
var isColEName2 = /\]/;
var ComponentBase = (
  /** @class */
  (function(_super) {
    __extends7(ComponentBase2, _super);
    function ComponentBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.mountingState = false;
      _this.attrKeys = [];
      _this.cachedTimeOut = 0;
      _this.isAppendCalled = false;
      _this.initRenderCalled = false;
      _this.isReactForeceUpdate = false;
      _this.isReact = true;
      _this.isshouldComponentUpdateCalled = false;
      _this.isCreated = false;
      return _this;
    }
    ComponentBase2.prototype.componentDidMount = function() {
      this.refreshChild(true);
      this.canDelayUpdate = delayUpdate.indexOf(this.getModuleName()) !== -1;
      this.renderReactComponent();
      if (this.portals && this.portals.length) {
        this.mountingState = true;
        this.renderReactTemplates();
        this.mountingState = false;
      }
    };
    ComponentBase2.prototype.componentDidUpdate = function(prev) {
      if (!this.isshouldComponentUpdateCalled && this.initRenderCalled && !this.isReactForeceUpdate) {
        if (prev !== this.props) {
          this.isshouldComponentUpdateCalled = true;
          this.updateProperties(this.props, false, prev);
        }
      }
    };
    ComponentBase2.prototype.renderReactComponent = function() {
      var ele = this.reactElement;
      if (ele && !this.isAppendCalled) {
        this.isAppendCalled = true;
        this.appendTo(ele);
      }
    };
    ComponentBase2.prototype.shouldComponentUpdate = function(nextProps) {
      this.isshouldComponentUpdateCalled = true;
      if (!this.initRenderCalled) {
        this.updateProperties(nextProps, true);
        return true;
      }
      if (!this.isAppendCalled) {
        clearTimeout(this.cachedTimeOut);
        this.isAppendCalled = true;
        this.appendTo(this.reactElement);
      }
      this.updateProperties(nextProps);
      return true;
    };
    ComponentBase2.prototype.updateProperties = function(nextProps, silent, prev) {
      var _this = this;
      var dProps = extend({}, nextProps);
      var keys2 = Object.keys(nextProps);
      var prevProps = extend({}, prev || this.props);
      var statelessTemplates = !isNullOrUndefined(prevProps["statelessTemplates"]) ? prevProps["statelessTemplates"] : !isNullOrUndefined(this["statelessTemplateProps"]) ? this["statelessTemplateProps"] : [];
      for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
        var propkey = keys_1[_i];
        var isClassName = propkey === "className";
        if (propkey === "children") {
          continue;
        }
        if (!isClassName && !isNullOrUndefined(this.htmlattributes["" + propkey]) && this.htmlattributes["" + propkey] !== dProps["" + propkey]) {
          this.htmlattributes["" + propkey] = dProps["" + propkey];
        }
        if (this.compareValues(prevProps["" + propkey], nextProps["" + propkey])) {
          delete dProps["" + propkey];
        } else if (this.attrKeys.indexOf(propkey) !== -1) {
          if (isClassName) {
            this.clsName = true;
            var propsClsName = prevProps["" + propkey].split(" ");
            for (var i = 0; i < propsClsName.length; i++) {
              this.element.classList.remove(propsClsName[parseInt(i.toString(), 10)]);
            }
            var dpropsClsName = dProps["" + propkey].split(" ");
            for (var j = 0; j < dpropsClsName.length; j++) {
              this.element.classList.add(dpropsClsName[parseInt(j.toString(), 10)]);
            }
          } else if (propkey !== "disabled" && !Object.prototype.hasOwnProperty.call(this.properties, propkey)) {
            delete dProps["" + propkey];
          }
        } else if (propkey === "value" && nextProps["" + propkey] === this["" + propkey]) {
          delete dProps["" + propkey];
        } else if (statelessTemplates.indexOf(propkey) > -1 && (propkey === "content" && typeof dProps["" + propkey] === "function" || nextProps["" + propkey].toString() === this["" + propkey].toString())) {
          delete dProps["" + propkey];
        }
      }
      if (dProps["children"]) {
        delete dProps["children"];
      }
      if (this.initRenderCalled && (this.canDelayUpdate || prevProps.delayUpdate)) {
        setTimeout(function() {
          _this.refreshProperties(dProps, nextProps, silent);
        });
      } else {
        this.refreshProperties(dProps, nextProps, silent);
      }
    };
    ComponentBase2.prototype.refreshProperties = function(dProps, nextProps, silent) {
      var statelessTemplates = !isNullOrUndefined(this.props["statelessTemplates"]) ? this.props["statelessTemplates"] : [];
      if (Object.keys(dProps).length) {
        if (!silent) {
          this.processComplexTemplate(dProps, this);
        }
        this.setProperties(dProps, silent);
      }
      if (statelessTemplates.indexOf("directiveTemplates") === -1) {
        this.refreshChild(silent, nextProps);
      }
    };
    ComponentBase2.prototype.processComplexTemplate = function(curObject, context) {
      var compTemplate = context.complexTemplate;
      if (compTemplate) {
        for (var prop in compTemplate) {
          if (Object.prototype.hasOwnProperty.call(compTemplate, prop)) {
            var PropVal = compTemplate["" + prop];
            if (curObject["" + prop]) {
              setValue(PropVal, getValue(prop, curObject), curObject);
            }
          }
        }
      }
    };
    ComponentBase2.prototype.getDefaultAttributes = function() {
      var _this = this;
      this.isReact = true;
      var propKeys = Object.keys(this.props);
      var ignoreProps = ["children", "statelessTemplates", "immediateRender", "isLegacyTemplate", "delayUpdate"];
      if (!this.htmlattributes) {
        this.htmlattributes = {};
      }
      this.attrKeys = defaulthtmlkeys.concat(this.controlAttributes || []);
      for (var _i = 0, propKeys_1 = propKeys; _i < propKeys_1.length; _i++) {
        var prop = propKeys_1[_i];
        if (prop.indexOf("data-") !== -1 || prop.indexOf("aria-") !== -1 || this.attrKeys.indexOf(prop) !== -1 || Object.keys(this.properties).indexOf("" + prop) === -1 && ignoreProps.indexOf("" + prop) === -1) {
          if (this.htmlattributes["" + prop] !== this.props["" + prop]) {
            this.htmlattributes["" + prop] = this.props["" + prop];
          }
        }
      }
      if (!this.htmlattributes.ref) {
        this.htmlattributes.ref = function(ele) {
          _this.reactElement = ele;
        };
        var keycompoentns = [
          "autocomplete",
          "combobox",
          "dropdownlist",
          "dropdowntree",
          "multiselect",
          "listbox",
          "colorpicker",
          "numerictextbox",
          "textbox",
          "smarttextarea",
          "uploader",
          "maskedtextbox",
          "slider",
          "datepicker",
          "datetimepicker",
          "daterangepicker",
          "timepicker",
          "checkbox",
          "switch",
          "radio",
          "rating",
          "textarea",
          "multicolumncombobox"
        ];
        if (keycompoentns.indexOf(this.getModuleName()) !== -1) {
          this.htmlattributes.key = "" + ComponentBase2.reactUid;
          ComponentBase2.reactUid++;
          if (this.type && !this.htmlattributes["type"]) {
            this.htmlattributes["type"] = this.multiline ? "hidden" : this.type;
          }
          if (this.name && !this.htmlattributes["name"]) {
            this.htmlattributes["name"] = this.name;
          }
        }
      }
      if (this.clsName) {
        var clsList = this.element.classList;
        var className = this.htmlattributes["className"];
        for (var i = 0; i < clsList.length; i++) {
          if (className.indexOf(clsList[parseInt(i.toString(), 10)]) === -1) {
            this.htmlattributes["className"] = this.htmlattributes["className"] + " " + clsList[parseInt(i.toString(), 10)];
          }
        }
      }
      return this.htmlattributes;
    };
    ComponentBase2.prototype.trigger = function(eventName, eventProp, successHandler) {
      var _this = this;
      if (this.isDestroyed !== true && this.modelObserver) {
        if (isColEName2.test(eventName)) {
          var handler = getValue(eventName, this);
          if (handler) {
            handler.call(this, eventProp);
            if (successHandler) {
              successHandler.call(this, eventProp);
            }
          } else if (successHandler) {
            successHandler.call(this, eventProp);
          }
        }
        if (eventName === "change" || eventName === "input") {
          if (this.props.onChange && eventProp.event) {
            this.props.onChange.call(void 0, {
              syntheticEvent: eventProp.event,
              nativeEvent: { text: eventProp.value },
              value: eventProp.value,
              target: this
            });
          }
        }
        var prevDetection = this.isProtectedOnChange;
        this.isProtectedOnChange = false;
        if (eventName === "created") {
          setTimeout(function() {
            _this.isCreated = true;
            if (!_this.isDestroyed) {
              _this.modelObserver.notify(eventName, eventProp, successHandler);
            }
          }, 10);
        } else {
          this.modelObserver.notify(eventName, eventProp, successHandler);
        }
        this.isProtectedOnChange = prevDetection;
      }
    };
    ComponentBase2.prototype.compareValues = function(value1, value2) {
      var typeVal = typeof value1;
      var typeVal2 = typeof value2;
      if (typeVal === typeVal2) {
        if (value1 === value2) {
          return true;
        }
        if ((!isNullOrUndefined(value1) && value1.constructor) !== (!isNullOrUndefined(value2) && value2.constructor)) {
          return false;
        }
        if (value1 instanceof Date || value1 instanceof RegExp || value1 instanceof String || value1 instanceof Number) {
          return value1.toString() === value2.toString();
        }
        if (isObject(value1) || Array.isArray(value1)) {
          var tempVal = value1;
          var tempVal2 = value2;
          if (isObject(tempVal)) {
            tempVal = [value1];
            tempVal2 = [value2];
          }
          return this.compareObjects(tempVal, tempVal2).status;
        }
        if (value1.moduleName && value1.moduleName === value2.moduleName && (value1.moduleName === "query" || value1.moduleName === "datamanager")) {
          if (JSON.stringify(value1) === JSON.stringify(value2)) {
            return true;
          }
        }
      }
      return false;
    };
    ComponentBase2.prototype.compareObjects = function(oldProps, newProps, propName) {
      var status = true;
      var lenSimilarity = oldProps.length === newProps.length;
      var diffArray = [];
      var templateProps = !isNullOrUndefined(this["templateProps"]) ? this["templateProps"] : [];
      if (lenSimilarity) {
        for (var i = 0, len = newProps.length; i < len; i++) {
          var curObj = {};
          var oldProp = oldProps[parseInt(i.toString(), 10)];
          var newProp = newProps[parseInt(i.toString(), 10)];
          var keys2 = Object.keys(newProp);
          if (keys2.length !== 0) {
            for (var _i = 0, keys_2 = keys2; _i < keys_2.length; _i++) {
              var key = keys_2[_i];
              var oldValue = oldProp["" + key];
              var newValue = newProp["" + key];
              if (key === "items") {
                for (var _j = 0; _j < newValue.length; _j++) {
                  if (this.getModuleName() === "richtexteditor" && typeof newValue[parseInt(_j.toString(), 10)] === "object") {
                    return { status: true };
                  }
                }
              }
              if (this.getModuleName() === "grid" && key === "field") {
                curObj["" + key] = newValue;
              }
              if (!Object.prototype.hasOwnProperty.call(oldProp, key) || !(templateProps.length > 0 && templateProps.indexOf("" + key) === -1 && typeof newValue === "function" ? this.compareValues(oldValue.toString(), newValue.toString()) : this.compareValues(oldValue, newValue))) {
                if (!propName) {
                  return { status: false };
                }
                status = false;
                curObj["" + key] = newValue;
              }
            }
          } else if (newProps[parseInt(i.toString(), 10)] === oldProps[parseInt(i.toString(), 10)]) {
            status = true;
          } else {
            if (!propName) {
              return { status: false };
            }
            status = false;
          }
          if (this.getModuleName() === "grid" && propName === "columns" && isNullOrUndefined(curObj["field"])) {
            curObj["field"] = void 0;
          }
          if (Object.keys(curObj).length) {
            diffArray.push({ index: i, value: curObj, key: propName });
          }
        }
      } else {
        status = false;
      }
      return { status, changedProperties: diffArray };
    };
    ComponentBase2.prototype.refreshChild = function(silent, props) {
      if (this.checkInjectedModules) {
        var prevModule = this.getInjectedModules() || [];
        var curModule = this.getInjectedServices() || [];
        for (var _i = 0, curModule_1 = curModule; _i < curModule_1.length; _i++) {
          var mod = curModule_1[_i];
          if (prevModule.indexOf(mod) === -1) {
            prevModule.push(mod);
          }
        }
        this.injectedModules = prevModule;
      }
      if (this.directivekeys) {
        var changedProps = [];
        var key = "";
        var directiveValue = this.validateChildren({}, this.directivekeys, props || this.props);
        if (directiveValue && Object.keys(directiveValue).length) {
          if (!silent && this.skipRefresh) {
            for (var _a = 0, _b = this.skipRefresh; _a < _b.length; _a++) {
              var fields = _b[_a];
              delete directiveValue["" + fields];
            }
          }
          if (this.prevProperties) {
            var dKeys = Object.keys(this.prevProperties);
            for (var i = 0; i < dKeys.length; i++) {
              key = dKeys[parseInt(i.toString(), 10)];
              if (!Object.prototype.hasOwnProperty.call(directiveValue, key)) {
                continue;
              }
              var compareOutput = this.compareObjects(this.prevProperties["" + key], directiveValue["" + key], key);
              if (compareOutput.status) {
                delete directiveValue["" + key];
              } else {
                if (compareOutput.changedProperties.length) {
                  changedProps = changedProps.concat(compareOutput.changedProperties);
                }
                var obj = {};
                obj["" + key] = directiveValue["" + key];
                this.prevProperties = extend(this.prevProperties, obj);
              }
            }
          } else {
            this.prevProperties = extend({}, directiveValue, {}, true);
          }
          if (changedProps.length) {
            if (this.getModuleName() === "grid" && key === "columns") {
              for (var _c1 = 0, allColumns = this.columns; _c1 < allColumns.length; _c1++) {
                var compareField1 = getValue("field", allColumns[parseInt(_c1.toString(), 10)]);
                var compareField2 = getValue(_c1 + ".value.field", changedProps);
                if (compareField1 === compareField2) {
                  var propInstance = getValue(changedProps[parseInt(_c1.toString(), 10)].key + "." + changedProps[parseInt(_c1.toString(), 10)].index, this);
                  if (propInstance && propInstance.setProperties) {
                    propInstance.setProperties(changedProps[parseInt(_c1.toString(), 10)].value);
                  } else {
                    extend(propInstance, changedProps[parseInt(_c1.toString(), 10)].value);
                  }
                } else {
                  this.setProperties(directiveValue, silent);
                }
              }
            } else {
              for (var _c = 0, changedProps_1 = changedProps; _c < changedProps_1.length; _c++) {
                var changes = changedProps_1[_c];
                var propInstance = getValue(changes.key + "." + changes.index, this);
                if (propInstance && propInstance.setProperties) {
                  propInstance.setProperties(changes.value);
                } else {
                  extend(propInstance, changes.value);
                }
              }
            }
          } else {
            this.setProperties(directiveValue, silent);
          }
        }
      }
    };
    ComponentBase2.prototype.componentWillUnmount = function() {
      clearTimeout(this.cachedTimeOut);
      var modulesName = ["dropdowntree", "checkbox"];
      var hasModule = !modulesName.indexOf(this.getModuleName()) ? document.body.contains(this.element) : true;
      if (this.initRenderCalled && this.isAppendCalled && this.element && hasModule && !this.isDestroyed && this.isCreated) {
        this.destroy();
      }
      onIntlChange.offIntlEvents();
    };
    ComponentBase2.prototype.appendReactElement = function(element, container) {
      var portal = ReactDOM.createPortal(element, container);
      if (!this.portals) {
        this.portals = [portal];
      } else {
        this.portals.push(portal);
      }
    };
    ComponentBase2.prototype.renderReactTemplates = function(callback) {
      this.isReactForeceUpdate = true;
      if (callback) {
        this.forceUpdate(callback);
      } else {
        this.forceUpdate();
      }
      this.isReactForeceUpdate = false;
    };
    ComponentBase2.prototype.clearTemplate = function(templateNames, index, callback) {
      var _this = this;
      var tempPortal = [];
      if (templateNames && templateNames.length) {
        Array.prototype.forEach.call(templateNames, function(propName) {
          var propIndexCount = 0;
          _this.portals.forEach(function(portal) {
            if (portal.propName === propName) {
              tempPortal.push(propIndexCount);
              propIndexCount++;
            }
          });
          if (!isNullOrUndefined(index) && _this.portals[index] && _this.portals[index].propName === propName) {
            _this.portals.splice(index, 1);
          } else {
            for (var i = 0; i < _this.portals.length; i++) {
              if (_this.portals[parseInt(i.toString(), 10)].propName === propName) {
                _this.portals.splice(i, 1);
                i--;
              }
            }
          }
        });
      } else {
        this.portals = [];
      }
      this.renderReactTemplates(callback);
    };
    ComponentBase2.prototype.validateChildren = function(childCache, mapper2, props) {
      var flag = false;
      var childs = React.Children.toArray(props.children);
      for (var _i = 0, childs_1 = childs; _i < childs_1.length; _i++) {
        var child = childs_1[_i];
        var ifield = this.getChildType(child);
        var key = mapper2["" + ifield];
        if (ifield && mapper2) {
          var childProps = this.getChildProps(React.Children.toArray(child.props.children), key);
          if (childProps.length) {
            flag = true;
            childCache[child.type.propertyName || ifield] = childProps;
          }
        }
      }
      if (flag) {
        return childCache;
      }
      return null;
    };
    ComponentBase2.prototype.getChildType = function(child) {
      if (child.type && child.type.isDirective) {
        return child.type.moduleName || "";
      }
      return "";
    };
    ComponentBase2.prototype.getChildProps = function(subChild, matcher) {
      var ret = [];
      for (var _i = 0, subChild_1 = subChild; _i < subChild_1.length; _i++) {
        var child = subChild_1[_i];
        var accessProp = false;
        var key = void 0;
        if (typeof matcher === "string") {
          accessProp = true;
          key = matcher;
        } else {
          key = Object.keys(matcher)[0];
        }
        var prop = child.props;
        var field = this.getChildType(child);
        if (field === key) {
          if (accessProp || !prop.children) {
            var cacheVal = extend({}, prop, {}, true);
            this.processComplexTemplate(cacheVal, child.type);
            ret.push(cacheVal);
          } else {
            var cachedValue = this.validateChildren(extend({}, prop), matcher["" + key], prop) || prop;
            if (cachedValue["children"]) {
              delete cachedValue["children"];
            }
            this.processComplexTemplate(cachedValue, child.type);
            ret.push(cachedValue);
          }
        }
      }
      return ret;
    };
    ComponentBase2.prototype.getInjectedServices = function() {
      var childs = React.Children.toArray(this.props.children);
      for (var _i = 0, childs_2 = childs; _i < childs_2.length; _i++) {
        var child = childs_2[_i];
        if (child.type && child.type.isService) {
          return child.props.services;
        }
      }
      return [];
    };
    ComponentBase2.reactUid = 1;
    return ComponentBase2;
  })(React.Component)
);

// node_modules/@syncfusion/ej2-react-base/src/util.js
function applyMixins(derivedClass, baseClass) {
  baseClass.forEach(function(baseClass2) {
    Object.getOwnPropertyNames(baseClass2.prototype).forEach(function(name) {
      if (name !== "isMounted" && name !== "replaceState" && name !== "render") {
        derivedClass.prototype["" + name] = baseClass2.prototype["" + name];
      }
    });
  });
}

// node_modules/@syncfusion/ej2-react-base/src/complex-base.js
var React2 = __toESM(require_react());
var __extends8 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var ComplexBase = (
  /** @class */
  (function(_super) {
    __extends8(ComplexBase2, _super);
    function ComplexBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ComplexBase2.prototype.render = function() {
      return null;
    };
    ComplexBase2.isDirective = true;
    return ComplexBase2;
  })(React2.PureComponent)
);

// node_modules/@syncfusion/ej2-react-base/src/services.js
var React3 = __toESM(require_react());
var __extends9 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var Inject = (
  /** @class */
  (function(_super) {
    __extends9(Inject2, _super);
    function Inject2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Inject2.prototype.render = function() {
      return null;
    };
    Inject2.isService = true;
    return Inject2;
  })(React3.PureComponent)
);

// node_modules/@syncfusion/ej2-react-base/src/template.js
var ReactDOM2 = __toESM(require_react_dom());
var React4 = __toESM(require_react());
var stringCompiler = getTemplateEngine();
function compile3(templateElement, helper) {
  if (typeof templateElement === "string" || templateElement.prototype && templateElement.prototype.CSPTemplate && typeof templateElement === "function") {
    return stringCompiler(templateElement, helper);
  } else {
    return function(data, component, prop, element) {
      var actTemplate = templateElement;
      var actData = data;
      if (typeof actTemplate === "object") {
        actTemplate = templateElement.template;
        actData = extend({}, data, templateElement.data || {});
      }
      var cEle;
      if (element) {
        cEle = element;
      } else {
        cEle = document.createElement("div");
      }
      var rele = React4.createElement(actTemplate, actData);
      var portal = ReactDOM2.createPortal(rele, cEle);
      portal.propName = prop;
      if (!component.portals) {
        component.portals = [portal];
      } else {
        component.portals.push(portal);
      }
      if (!element) {
        return [cEle];
      }
    };
  }
}
setTemplateEngine({ compile: compile3 });

// node_modules/@syncfusion/ej2-react-maps/src/maps/layers-directive.js
var __extends10 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var LayerDirective = (
  /** @class */
  (function(_super) {
    __extends10(LayerDirective2, _super);
    function LayerDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LayerDirective2.moduleName = "layer";
    return LayerDirective2;
  })(ComplexBase)
);
var LayersDirective = (
  /** @class */
  (function(_super) {
    __extends10(LayersDirective2, _super);
    function LayersDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LayersDirective2.propertyName = "layers";
    LayersDirective2.moduleName = "layers";
    return LayersDirective2;
  })(ComplexBase)
);

// node_modules/@syncfusion/ej2-react-maps/src/maps/initialshapeselection-directive.js
var __extends11 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var InitialShapeSelectionDirective = (
  /** @class */
  (function(_super) {
    __extends11(InitialShapeSelectionDirective2, _super);
    function InitialShapeSelectionDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    InitialShapeSelectionDirective2.moduleName = "initialShapeSelection";
    return InitialShapeSelectionDirective2;
  })(ComplexBase)
);
var InitialShapeSelectionsDirective = (
  /** @class */
  (function(_super) {
    __extends11(InitialShapeSelectionsDirective2, _super);
    function InitialShapeSelectionsDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    InitialShapeSelectionsDirective2.propertyName = "initialShapeSelection";
    InitialShapeSelectionsDirective2.moduleName = "initialShapeSelections";
    return InitialShapeSelectionsDirective2;
  })(ComplexBase)
);

// node_modules/@syncfusion/ej2-react-maps/src/maps/markersettings-directive.js
var __extends12 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var MarkerDirective = (
  /** @class */
  (function(_super) {
    __extends12(MarkerDirective2, _super);
    function MarkerDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MarkerDirective2.moduleName = "marker";
    MarkerDirective2.complexTemplate = { "tooltipSettings.template": "tooltipSettings.template" };
    return MarkerDirective2;
  })(ComplexBase)
);
var MarkersDirective = (
  /** @class */
  (function(_super) {
    __extends12(MarkersDirective2, _super);
    function MarkersDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MarkersDirective2.propertyName = "markerSettings";
    MarkersDirective2.moduleName = "markers";
    return MarkersDirective2;
  })(ComplexBase)
);

// node_modules/@syncfusion/ej2-react-maps/src/maps/bubblesettings-directive.js
var __extends13 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var BubbleDirective = (
  /** @class */
  (function(_super) {
    __extends13(BubbleDirective2, _super);
    function BubbleDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BubbleDirective2.moduleName = "bubble";
    BubbleDirective2.complexTemplate = { "tooltipSettings.template": "tooltipSettings.template" };
    return BubbleDirective2;
  })(ComplexBase)
);
var BubblesDirective = (
  /** @class */
  (function(_super) {
    __extends13(BubblesDirective2, _super);
    function BubblesDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BubblesDirective2.propertyName = "bubbleSettings";
    BubblesDirective2.moduleName = "bubbles";
    return BubblesDirective2;
  })(ComplexBase)
);

// node_modules/@syncfusion/ej2-react-maps/src/maps/colormapping-directive.js
var __extends14 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var ColorMappingDirective = (
  /** @class */
  (function(_super) {
    __extends14(ColorMappingDirective2, _super);
    function ColorMappingDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ColorMappingDirective2.moduleName = "colorMapping";
    return ColorMappingDirective2;
  })(ComplexBase)
);
var ColorMappingsDirective = (
  /** @class */
  (function(_super) {
    __extends14(ColorMappingsDirective2, _super);
    function ColorMappingsDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ColorMappingsDirective2.propertyName = "colorMapping";
    ColorMappingsDirective2.moduleName = "colorMappings";
    return ColorMappingsDirective2;
  })(ComplexBase)
);

// node_modules/@syncfusion/ej2-react-maps/src/maps/navigationlinesettings-directive.js
var __extends15 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var NavigationLineDirective = (
  /** @class */
  (function(_super) {
    __extends15(NavigationLineDirective2, _super);
    function NavigationLineDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NavigationLineDirective2.moduleName = "navigationLine";
    NavigationLineDirective2.complexTemplate = { "tooltipSettings.template": "tooltipSettings.template" };
    return NavigationLineDirective2;
  })(ComplexBase)
);
var NavigationLinesDirective = (
  /** @class */
  (function(_super) {
    __extends15(NavigationLinesDirective2, _super);
    function NavigationLinesDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NavigationLinesDirective2.propertyName = "navigationLineSettings";
    NavigationLinesDirective2.moduleName = "navigationLines";
    return NavigationLinesDirective2;
  })(ComplexBase)
);

// node_modules/@syncfusion/ej2-react-maps/src/maps/annotations-directive.js
var __extends16 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var AnnotationDirective = (
  /** @class */
  (function(_super) {
    __extends16(AnnotationDirective2, _super);
    function AnnotationDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnnotationDirective2.moduleName = "annotation";
    return AnnotationDirective2;
  })(ComplexBase)
);
var AnnotationsDirective = (
  /** @class */
  (function(_super) {
    __extends16(AnnotationsDirective2, _super);
    function AnnotationsDirective2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnnotationsDirective2.propertyName = "annotations";
    AnnotationsDirective2.moduleName = "annotations";
    return AnnotationsDirective2;
  })(ComplexBase)
);

// node_modules/@syncfusion/ej2-react-maps/src/maps/maps.component.js
var React5 = __toESM(require_react());

// node_modules/@syncfusion/ej2-svg-base/src/svg-render/svg-renderer.js
var SvgRenderer = (
  /** @class */
  (function() {
    function SvgRenderer2(rootID) {
      this.svgLink = "http://www.w3.org/2000/svg";
      this.rootId = rootID;
    }
    SvgRenderer2.prototype.getOptionValue = function(options, key) {
      return options[key];
    };
    SvgRenderer2.prototype.createSvg = function(options) {
      if (isNullOrUndefined(options.id)) {
        options.id = this.rootId + "_svg";
      }
      this.svgObj = document.getElementById(options.id);
      if (isNullOrUndefined(document.getElementById(options.id))) {
        this.svgObj = document.createElementNS(this.svgLink, "svg");
      }
      this.svgObj = this.setElementAttributes(options, this.svgObj);
      this.setSVGSize(options.width, options.height);
      return this.svgObj;
    };
    SvgRenderer2.prototype.setSVGSize = function(width, height) {
      var element = document.getElementById(this.rootId);
      var size = !isNullOrUndefined(element) ? element.getBoundingClientRect() : null;
      if (isNullOrUndefined(this.width) || this.width <= 0) {
        this.svgObj.setAttribute("width", width ? width.toString() : size.width.toString());
      } else {
        this.svgObj.setAttribute("width", this.width.toString());
      }
      if (isNullOrUndefined(this.height) || this.height <= 0) {
        this.svgObj.setAttribute("height", height ? height.toString() : "450");
      } else {
        this.svgObj.setAttribute("height", this.height.toString());
      }
    };
    SvgRenderer2.prototype.drawPath = function(options) {
      var path = document.getElementById(options.id);
      if (path === null) {
        path = document.createElementNS(this.svgLink, "path");
      }
      path = this.setElementAttributes(options, path);
      return path;
    };
    SvgRenderer2.prototype.drawLine = function(options) {
      var line = document.getElementById(options.id);
      if (line === null) {
        line = document.createElementNS(this.svgLink, "line");
      }
      line = this.setElementAttributes(options, line);
      return line;
    };
    SvgRenderer2.prototype.drawRectangle = function(options) {
      var rectangle = document.getElementById(options.id);
      if (rectangle === null) {
        rectangle = document.createElementNS(this.svgLink, "rect");
      }
      rectangle = this.setElementAttributes(options, rectangle);
      return rectangle;
    };
    SvgRenderer2.prototype.drawCircle = function(options) {
      var circle = document.getElementById(options.id);
      if (circle === null) {
        circle = document.createElementNS(this.svgLink, "circle");
      }
      circle = this.setElementAttributes(options, circle);
      return circle;
    };
    SvgRenderer2.prototype.drawPolyline = function(options) {
      var polyline = document.getElementById(options.id);
      if (polyline === null) {
        polyline = document.createElementNS(this.svgLink, "polyline");
      }
      polyline = this.setElementAttributes(options, polyline);
      return polyline;
    };
    SvgRenderer2.prototype.drawEllipse = function(options) {
      var ellipse = document.getElementById(options.id);
      if (ellipse === null) {
        ellipse = document.createElementNS(this.svgLink, "ellipse");
      }
      ellipse = this.setElementAttributes(options, ellipse);
      return ellipse;
    };
    SvgRenderer2.prototype.drawPolygon = function(options) {
      var polygon = document.getElementById(options.id);
      if (polygon === null) {
        polygon = document.createElementNS(this.svgLink, "polygon");
      }
      polygon = this.setElementAttributes(options, polygon);
      return polygon;
    };
    SvgRenderer2.prototype.drawImage = function(options) {
      var img = document.createElementNS(this.svgLink, "image");
      img.setAttributeNS(null, "height", options.height.toString());
      img.setAttributeNS(null, "width", options.width.toString());
      img.setAttributeNS("http://www.w3.org/1999/xlink", "href", options.href);
      img.setAttributeNS(null, "x", options.x.toString());
      img.setAttributeNS(null, "y", options.y.toString());
      img.setAttributeNS(null, "id", options.id);
      img.setAttributeNS(null, "visibility", options.visibility);
      if (!isNullOrUndefined(this.getOptionValue(options, "clip-path"))) {
        img.setAttributeNS(null, "clip-path", this.getOptionValue(options, "clip-path"));
      }
      if (!isNullOrUndefined(options.preserveAspectRatio)) {
        img.setAttributeNS(null, "preserveAspectRatio", options.preserveAspectRatio);
      }
      return img;
    };
    SvgRenderer2.prototype.createText = function(options, label) {
      var text = document.createElementNS(this.svgLink, "text");
      text = this.setElementAttributes(options, text);
      if (!isNullOrUndefined(label)) {
        text.textContent = label;
      }
      return text;
    };
    SvgRenderer2.prototype.createTSpan = function(options, label) {
      var tSpan = document.createElementNS(this.svgLink, "tspan");
      tSpan = this.setElementAttributes(options, tSpan);
      if (!isNullOrUndefined(label)) {
        tSpan.textContent = label;
      }
      return tSpan;
    };
    SvgRenderer2.prototype.createTitle = function(text) {
      var title = document.createElementNS(this.svgLink, "title");
      title.textContent = text;
      return title;
    };
    SvgRenderer2.prototype.createDefs = function() {
      var defs = document.createElementNS(this.svgLink, "defs");
      return defs;
    };
    SvgRenderer2.prototype.createClipPath = function(options) {
      var clipPath = document.createElementNS(this.svgLink, "clipPath");
      clipPath = this.setElementAttributes(options, clipPath);
      return clipPath;
    };
    SvgRenderer2.prototype.createForeignObject = function(options) {
      var foreignObject = document.createElementNS(this.svgLink, "foreignObject");
      foreignObject = this.setElementAttributes(options, foreignObject);
      return foreignObject;
    };
    SvgRenderer2.prototype.createGroup = function(options) {
      var group = document.createElementNS(this.svgLink, "g");
      group = this.setElementAttributes(options, group);
      return group;
    };
    SvgRenderer2.prototype.createPattern = function(options, element) {
      var pattern = document.createElementNS(this.svgLink, element);
      pattern = this.setElementAttributes(options, pattern);
      return pattern;
    };
    SvgRenderer2.prototype.createRadialGradient = function(colors, name, options) {
      var colorName;
      if (!isNullOrUndefined(colors[0].colorStop)) {
        var newOptions = {
          "id": this.rootId + "_" + name + "radialGradient",
          "cx": options.cx + "%",
          "cy": options.cy + "%",
          "r": options.r + "%",
          "fx": options.fx + "%",
          "fy": options.fy + "%"
        };
        this.drawGradient("radialGradient", newOptions, colors);
        colorName = "url(#" + this.rootId + "_" + name + "radialGradient)";
      } else {
        colorName = colors[0].color.toString();
      }
      return colorName;
    };
    SvgRenderer2.prototype.createLinearGradient = function(colors, name, options) {
      var colorName;
      if (!isNullOrUndefined(colors[0].colorStop)) {
        var newOptions = {
          "id": this.rootId + "_" + name + "linearGradient",
          "x1": options.x1 + "%",
          "y1": options.y1 + "%",
          "x2": options.x2 + "%",
          "y2": options.y2 + "%"
        };
        this.drawGradient("linearGradient", newOptions, colors);
        colorName = "url(#" + this.rootId + "_" + name + "linearGradient)";
      } else {
        colorName = colors[0].color.toString();
      }
      return colorName;
    };
    SvgRenderer2.prototype.drawGradient = function(gradientType, options, colors) {
      var defs = this.createDefs();
      var gradient = document.createElementNS(this.svgLink, gradientType);
      gradient = this.setElementAttributes(options, gradient);
      for (var i = 0; i < colors.length; i++) {
        var stop_1 = document.createElementNS(this.svgLink, "stop");
        stop_1.setAttribute("offset", colors[i].colorStop);
        stop_1.setAttribute("stop-color", colors[i].color);
        stop_1.setAttribute("stop-opacity", colors[i].opacity ? colors[i].opacity : "1");
        if (!isNullOrUndefined(colors[i].style)) {
          stop_1.style.cssText = colors[i].style;
        }
        gradient.appendChild(stop_1);
      }
      defs.appendChild(gradient);
      return defs;
    };
    SvgRenderer2.prototype.drawClipPath = function(options) {
      var defs = this.createDefs();
      var clipPath = this.createClipPath({ "id": options.id });
      options.id = options.id + "_Rect";
      var rect = this.drawRectangle(options);
      clipPath.appendChild(rect);
      defs.appendChild(clipPath);
      return defs;
    };
    SvgRenderer2.prototype.drawCircularClipPath = function(options) {
      var defs = this.createDefs();
      var clipPath = this.createClipPath({ "id": options.id });
      options.id = options.id + "_Circle";
      var circle = this.drawCircle(options);
      clipPath.appendChild(circle);
      defs.appendChild(clipPath);
      return defs;
    };
    SvgRenderer2.prototype.setElementAttributes = function(options, element) {
      var keys2 = Object.keys(options);
      for (var i = 0; i < keys2.length; i++) {
        if (keys2[i] === "style") {
          element.style.cssText = options[keys2[i]];
        } else {
          element.setAttribute(keys2[i], options[keys2[i]]);
        }
      }
      return element;
    };
    SvgRenderer2.prototype.createCanvas = function() {
      return null;
    };
    return SvgRenderer2;
  })()
);

// node_modules/@syncfusion/ej2-svg-base/src/svg-render/canvas-renderer.js
var CanvasRenderer = (
  /** @class */
  (function() {
    function CanvasRenderer2(rootID) {
      this.rootId = rootID;
    }
    CanvasRenderer2.prototype.getOptionValue = function(options, key) {
      return options[key];
    };
    CanvasRenderer2.prototype.createCanvas = function(options) {
      var canvasObj = document.createElement("canvas");
      canvasObj.setAttribute("id", this.rootId + "_canvas");
      this.ctx = canvasObj.getContext("2d");
      this.canvasObj = canvasObj;
      this.setCanvasSize(options.width, options.height);
      return this.canvasObj;
    };
    CanvasRenderer2.prototype.setCanvasSize = function(width, height) {
      var element = document.getElementById(this.rootId);
      var size = !isNullOrUndefined(element) ? element.getBoundingClientRect() : null;
      if (isNullOrUndefined(this.width)) {
        this.canvasObj.setAttribute("width", width ? width.toString() : size.width.toString());
      } else {
        this.canvasObj.setAttribute("width", this.width.toString());
      }
      if (isNullOrUndefined(this.height)) {
        this.canvasObj.setAttribute("height", height ? height.toString() : "450");
      } else {
        this.canvasObj.setAttribute("height", this.height.toString());
      }
    };
    CanvasRenderer2.prototype.setAttributes = function(options) {
      this.ctx.lineWidth = this.getOptionValue(options, "stroke-width");
      var dashArray = this.getOptionValue(options, "stroke-dasharray");
      if (!isNullOrUndefined(dashArray)) {
        var dashArrayString = dashArray.split(",");
        this.ctx.setLineDash([parseInt(dashArrayString[0], 10), parseInt(dashArrayString[1], 10)]);
      }
      this.ctx.strokeStyle = this.getOptionValue(options, "stroke");
    };
    CanvasRenderer2.prototype.drawLine = function(options) {
      this.ctx.save();
      this.ctx.beginPath();
      this.ctx.lineWidth = this.getOptionValue(options, "stroke-width");
      this.ctx.strokeStyle = options.stroke;
      this.ctx.moveTo(options.x1, options.y1);
      this.ctx.lineTo(options.x2, options.y2);
      this.ctx.stroke();
      this.ctx.restore();
    };
    CanvasRenderer2.prototype.drawRectangle = function(options, canvasTranslate) {
      var canvasCtx = this.ctx;
      var cornerRadius = options.rx;
      this.ctx.save();
      this.ctx.beginPath();
      if (canvasTranslate) {
        this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
      }
      this.ctx.globalAlpha = this.getOptionValue(options, "opacity");
      this.setAttributes(options);
      this.ctx.rect(options.x, options.y, options.width, options.height);
      if (cornerRadius !== null && cornerRadius >= 0) {
        this.drawCornerRadius(options);
      } else {
        if (options.fill === "none") {
          options.fill = "transparent";
        }
        this.ctx.fillStyle = options.fill;
        this.ctx.fillRect(options.x, options.y, options.width, options.height);
        this.ctx.stroke();
      }
      this.ctx.restore();
      this.ctx = canvasCtx;
      return this.canvasObj;
    };
    CanvasRenderer2.prototype.drawCornerRadius = function(options) {
      var cornerRadius = options.rx;
      var x = options.x;
      var y = options.y;
      var width = options.width;
      var height = options.height;
      if (options.fill === "none") {
        options.fill = "transparent";
      }
      this.ctx.fillStyle = options.fill;
      if (width < 2 * cornerRadius) {
        cornerRadius = width / 2;
      }
      if (height < 2 * cornerRadius) {
        cornerRadius = height / 2;
      }
      this.ctx.beginPath();
      this.ctx.moveTo(x + width - cornerRadius, y);
      this.ctx.arcTo(x + width, y, x + width, y + height, cornerRadius);
      this.ctx.arcTo(x + width, y + height, x, y + height, cornerRadius);
      this.ctx.arcTo(x, y + height, x, y, cornerRadius);
      this.ctx.arcTo(x, y, x + width, y, cornerRadius);
      this.ctx.closePath();
      this.ctx.fill();
      this.ctx.stroke();
    };
    CanvasRenderer2.prototype.drawPath = function(options, canvasTranslate) {
      var path = options.d;
      var dataSplit = path.split(" ");
      var borderWidth = this.getOptionValue(options, "stroke-width");
      var canvasCtx = this.ctx;
      var flag = true;
      this.ctx.save();
      this.ctx.beginPath();
      if (canvasTranslate) {
        this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
      }
      this.ctx.globalAlpha = options.opacity ? options.opacity : this.getOptionValue(options, "fill-opacity");
      this.setAttributes(options);
      for (var i = 0; i < dataSplit.length; i = i + 3) {
        var x1 = parseFloat(dataSplit[i + 1]);
        var y1 = parseFloat(dataSplit[i + 2]);
        switch (dataSplit[i]) {
          case "M":
            if (!options.innerR && !options.cx) {
              this.ctx.moveTo(x1, y1);
            }
            break;
          case "L":
            if (!options.innerR) {
              this.ctx.lineTo(x1, y1);
            }
            break;
          case "Q":
            var q1 = parseFloat(dataSplit[i + 3]);
            var q2 = parseFloat(dataSplit[i + 4]);
            this.ctx.quadraticCurveTo(x1, y1, q1, q2);
            i = i + 2;
            break;
          case "C":
            var c1 = parseFloat(dataSplit[i + 3]);
            var c2 = parseFloat(dataSplit[i + 4]);
            var c3 = parseFloat(dataSplit[i + 5]);
            var c4 = parseFloat(dataSplit[i + 6]);
            this.ctx.bezierCurveTo(x1, y1, c1, c2, c3, c4);
            i = i + 4;
            break;
          case "A":
            if (!options.innerR) {
              if (options.cx) {
                this.ctx.arc(options.cx, options.cy, options.radius, 0, 2 * Math.PI, options.counterClockWise);
              } else {
                this.ctx.moveTo(options.x, options.y);
                this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);
                this.ctx.lineTo(options.x, options.y);
              }
            } else if (flag) {
              this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);
              this.ctx.arc(options.x, options.y, options.innerR, options.end, options.start, !options.counterClockWise);
              flag = false;
            }
            i = i + 5;
            break;
          case "z":
          case "Z":
            this.ctx.closePath();
            i = i - 2;
            break;
        }
      }
      if (options.fill !== "none" && options.fill !== void 0) {
        this.ctx.fillStyle = options.fill;
        this.ctx.fill();
      }
      if (borderWidth > 0) {
        this.ctx.stroke();
      }
      this.ctx.restore();
      this.ctx = canvasCtx;
      return this.canvasObj;
    };
    CanvasRenderer2.prototype.createText = function(options, label, transX, transY, dy, isTSpan) {
      var fontWeight = this.getOptionValue(options, "font-weight");
      if (!isNullOrUndefined(fontWeight) && fontWeight.toLowerCase() === "regular") {
        fontWeight = "normal";
      }
      var fontSize = this.getOptionValue(options, "font-size");
      var fontFamily = this.getOptionValue(options, "font-family");
      var fontStyle = this.getOptionValue(options, "font-style").toLowerCase();
      var font = fontStyle + " " + fontWeight + " " + fontSize + " " + fontFamily;
      var anchor = this.getOptionValue(options, "text-anchor");
      var opacity = options.opacity !== void 0 ? options.opacity : 1;
      if (anchor === "middle") {
        anchor = "center";
      }
      this.ctx.save();
      this.ctx.fillStyle = options.fill;
      this.ctx.font = font;
      this.ctx.textAlign = anchor;
      this.ctx.globalAlpha = opacity;
      if (options.baseline) {
        this.ctx.textBaseline = options.baseline;
      }
      if (!isTSpan) {
        var txtlngth = 0;
        this.ctx.translate(options.x + txtlngth / 2 + (transX ? transX : 0), options.y + (transY ? transY : 0));
        this.ctx.rotate(options.labelRotation * Math.PI / 180);
      }
      this.ctx.fillText(label, isTSpan ? options.x : 0, isTSpan ? dy : 0);
      this.ctx.restore();
      return this.canvasObj;
    };
    CanvasRenderer2.prototype.drawCircle = function(options, canvasTranslate) {
      var canvasCtx = this.ctx;
      this.ctx.save();
      this.ctx.beginPath();
      this.ctx.arc(options.cx, options.cy, options.r, 0, 2 * Math.PI);
      this.ctx.fillStyle = options.fill;
      this.ctx.globalAlpha = options.opacity;
      this.ctx.fill();
      if (canvasTranslate) {
        this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
      }
      this.setAttributes(options);
      this.ctx.stroke();
      this.ctx.restore();
      this.ctx = canvasCtx;
      return this.canvasObj;
    };
    CanvasRenderer2.prototype.drawPolyline = function(options) {
      this.ctx.save();
      this.ctx.beginPath();
      var points = options.points.split(" ");
      for (var i = 0; i < points.length - 1; i++) {
        var point = points[i].split(",");
        var x = parseFloat(point[0]);
        var y = parseFloat(point[1]);
        if (i === 0) {
          this.ctx.moveTo(x, y);
        } else {
          this.ctx.lineTo(x, y);
        }
      }
      this.ctx.lineWidth = this.getOptionValue(options, "stroke-width");
      this.ctx.strokeStyle = options.stroke;
      this.ctx.stroke();
      this.ctx.restore();
    };
    CanvasRenderer2.prototype.drawEllipse = function(options, canvasTranslate) {
      var canvasCtx = this.ctx;
      var circumference = Math.max(options.rx, options.ry);
      var scaleX = options.rx / circumference;
      var scaleY = options.ry / circumference;
      this.ctx.save();
      this.ctx.beginPath();
      this.ctx.translate(options.cx, options.cy);
      if (canvasTranslate) {
        this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
      }
      this.ctx.save();
      this.ctx.scale(scaleX, scaleY);
      this.ctx.arc(0, 0, circumference, 0, 2 * Math.PI, false);
      this.ctx.fillStyle = options.fill;
      this.ctx.fill();
      this.ctx.restore();
      this.ctx.lineWidth = this.getOptionValue(options, "stroke-width");
      this.ctx.strokeStyle = options.stroke;
      this.ctx.stroke();
      this.ctx.restore();
      this.ctx = canvasCtx;
    };
    CanvasRenderer2.prototype.drawImage = function(options) {
      this.ctx.save();
      var imageObj = new Image();
      if (!isNullOrUndefined(options.href)) {
        imageObj.src = options.href;
        this.ctx.drawImage(imageObj, options.x, options.y, options.width, options.height);
      }
      this.ctx.restore();
    };
    CanvasRenderer2.prototype.createLinearGradient = function(colors) {
      var myGradient;
      if (!isNullOrUndefined(colors[0].colorStop)) {
        myGradient = this.ctx.createLinearGradient(0, 0, 0, this.canvasObj.height);
      }
      var color = this.setGradientValues(colors, myGradient);
      return color;
    };
    CanvasRenderer2.prototype.createRadialGradient = function(colors) {
      var myGradient;
      if (!isNullOrUndefined(colors[0].colorStop)) {
        myGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.canvasObj.height);
      }
      var colorName = this.setGradientValues(colors, myGradient);
      return colorName;
    };
    CanvasRenderer2.prototype.setGradientValues = function(colors, myGradient) {
      var colorName;
      if (!isNullOrUndefined(colors[0].colorStop)) {
        for (var i = 0; i <= colors.length - 1; i++) {
          var color = colors[i].color;
          var newColorStop = colors[i].colorStop.slice(0, -1);
          var stopColor = parseInt(newColorStop, 10) / 100;
          myGradient.addColorStop(stopColor, color);
        }
        colorName = myGradient.toString();
      } else {
        colorName = colors[0].color.toString();
      }
      return colorName;
    };
    CanvasRenderer2.prototype.setElementAttributes = function(options, element) {
      var keys2 = Object.keys(options);
      var values = Object.keys(options).map(function(key) {
        return options[key];
      });
      for (var i = 0; i < keys2.length; i++) {
        element.setAttribute(keys2[i], values[i]);
      }
      return null;
    };
    CanvasRenderer2.prototype.updateCanvasAttributes = function(options) {
      this.setElementAttributes(options, this.canvasObj);
      var ctx = this.ctx;
      if (!isNullOrUndefined(this.dataUrl)) {
        var img_1 = new Image();
        img_1.onload = function() {
          ctx.drawImage(img_1, 0, 0);
        };
        img_1.src = this.dataUrl;
      }
    };
    CanvasRenderer2.prototype.clearRect = function(rect) {
      this.ctx.restore();
      this.ctx.clearRect(rect.x, rect.y, rect.width, rect.height);
    };
    CanvasRenderer2.prototype.createGroup = function() {
      return null;
    };
    CanvasRenderer2.prototype.drawClipPath = function() {
      return null;
    };
    CanvasRenderer2.prototype.drawCircularClipPath = function() {
      return null;
    };
    CanvasRenderer2.prototype.canvasClip = function(options) {
      this.ctx.save();
      this.ctx.fillStyle = "transparent";
      this.ctx.rect(options.x, options.y, options.width, options.height);
      this.ctx.fill();
      this.ctx.clip();
    };
    CanvasRenderer2.prototype.canvasRestore = function() {
      this.ctx.restore();
    };
    CanvasRenderer2.prototype.drawPolygon = function() {
      return null;
    };
    CanvasRenderer2.prototype.createDefs = function() {
      return null;
    };
    CanvasRenderer2.prototype.createClipPath = function() {
      return null;
    };
    CanvasRenderer2.prototype.createSvg = function() {
      return null;
    };
    return CanvasRenderer2;
  })()
);

// node_modules/@syncfusion/ej2-svg-base/src/tooltip/interface.js
function getTooltipThemeColor(theme) {
  var style;
  switch (theme) {
    case "Highcontrast":
    case "HighContrast":
      style = {
        tooltipFill: "#ffffff",
        tooltipBoldLabel: "#000000",
        tooltipLightLabel: "#000000",
        tooltipHeaderLine: "#969696",
        textStyle: { fontFamily: "Segoe UI", color: "#000000", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "MaterialDark":
    case "FabricDark":
    case "BootstrapDark":
      style = {
        tooltipFill: theme === "MaterialDark" ? "#F4F4F4" : theme === "FabricDark" ? "#A19F9D" : "#F0F0F0",
        tooltipBoldLabel: theme === "MaterialDark" ? "rgba(18, 18, 18, 1)" : theme === "FabricDark" ? "#DADADA" : "#1A1A1A",
        tooltipLightLabel: theme === "MaterialDark" ? "rgba(18, 18, 18, 1)" : theme === "FabricDark" ? "#DADADA" : "#1A1A1A",
        tooltipHeaderLine: "#9A9A9A",
        textStyle: theme === "MaterialDark" ? { fontFamily: "Roboto", color: "rgba(18, 18, 18, 1)", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" } : theme === "FabricDark" ? { fontFamily: "Segoe UI", color: "#DADADA", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" } : { fontFamily: "Helvetica", color: "#1A1A1A", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "Bootstrap4":
      style = {
        tooltipFill: "#212529",
        tooltipBoldLabel: "#F9FAFB",
        tooltipLightLabel: "#F9FAFB",
        tooltipHeaderLine: "rgba(255, 255, 255, 0.2)",
        textStyle: { fontFamily: "Helvetica", color: "#F9FAFB", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "Tailwind3":
      style = {
        tooltipFill: "#111827",
        tooltipBoldLabel: "#F9FAFB",
        tooltipLightLabel: "#F9FAFB",
        tooltipHeaderLine: "#D1D5DB",
        textStyle: { fontFamily: "Inter", color: "#F9FAFB", fontWeight: "500", size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "Tailwind3Dark":
      style = {
        tooltipFill: "#F9FAFB",
        tooltipBoldLabel: "#1F2937",
        tooltipLightLabel: "#1F2937",
        tooltipHeaderLine: "#374151",
        textStyle: { fontFamily: "Inter", color: "#1F2937", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "Tailwind":
      style = {
        tooltipFill: "#111827",
        tooltipBoldLabel: "#F9FAFB",
        tooltipLightLabel: "#F9FAFB",
        tooltipHeaderLine: "#6B7280",
        textStyle: { fontFamily: "Inter", color: "#F9FAFB", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "TailwindDark":
      style = {
        tooltipFill: "#E9ECEF",
        tooltipBoldLabel: "#1F2937",
        tooltipLightLabel: "#1F2937",
        tooltipHeaderLine: "#9CA3AF",
        textStyle: { fontFamily: "Inter", color: "#1F2937", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "Bootstrap5":
      style = {
        tooltipFill: "#000000E5",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#FFFFFF",
        textStyle: { fontFamily: "Segoe UI", color: "#FFFFFF", fontWeight: null, size: "12px", headerTextSize: "16px", boldTextSize: "14px" }
      };
      break;
    case "Bootstrap5Dark":
      style = {
        tooltipFill: "#FFFFFFE5",
        tooltipBoldLabel: "#212529",
        tooltipLightLabel: "#212529",
        tooltipHeaderLine: "#212529",
        textStyle: { fontFamily: "Helvetica", color: "#212529", fontWeight: null, size: "12px", headerTextSize: "16px", boldTextSize: "14px" }
      };
      break;
    case "Fluent":
      style = {
        tooltipFill: "#FFFFFF",
        tooltipBoldLabel: "#323130",
        tooltipLightLabel: "#323130",
        tooltipHeaderLine: "#D2D0CE",
        textStyle: { fontFamily: "Segoe UI", color: "#323130", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "FluentDark":
      style = {
        tooltipFill: "#323130",
        tooltipBoldLabel: "#F3F2F2",
        tooltipLightLabel: "#F3F2F1",
        tooltipHeaderLine: "#3B3A39",
        textStyle: { fontFamily: "Segoe UI", color: "#F3F2F1", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "Fluent2":
      style = {
        tooltipFill: "#FFFFFF",
        tooltipBoldLabel: "#242424",
        tooltipLightLabel: "#242424",
        tooltipHeaderLine: "#D2D0CE",
        textStyle: { fontFamily: "Segoe UI", color: "#242424", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "Fluent2Dark":
      style = {
        tooltipFill: "#292929",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#3B3A39",
        textStyle: { fontFamily: "Segoe UI", color: "#FFFFFF", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "Fluent2HighContrast":
      style = {
        tooltipFill: "#000000",
        tooltipBoldLabel: "#FFFFFF",
        tooltipLightLabel: "#FFFFFF",
        tooltipHeaderLine: "#3B3A39",
        textStyle: { fontFamily: "Segoe UI", color: "#FFFFFF", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "Material3":
      style = {
        tooltipFill: "#313033",
        tooltipBoldLabel: "#F4EFF4",
        tooltipLightLabel: "#F4EFF4",
        tooltipHeaderLine: "#F4EFF4",
        textStyle: { fontFamily: "Roboto", color: "#F4EFF4", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    case "Material3Dark":
      style = {
        tooltipFill: "#E6E1E5",
        tooltipBoldLabel: "#313033",
        tooltipLightLabel: "#313033",
        tooltipHeaderLine: "#313033",
        textStyle: { fontFamily: "Roboto", color: "#313033", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
    default:
      style = {
        tooltipFill: theme === "Material" ? "#000816" : theme === "Fabric" ? "#FFFFFF" : "#212529",
        tooltipBoldLabel: theme === "Material" ? "rgba(249, 250, 251, 1)" : theme === "Fabric" ? "#333333" : "#F9FAFB",
        tooltipLightLabel: theme === "Material" ? "rgba(249, 250, 251, 1)" : theme === "Fabric" ? "#333333" : "#F9FAFB",
        tooltipHeaderLine: theme === "Fabric" ? "#D2D0CE" : "#ffffff",
        textStyle: theme === "Material" ? { fontFamily: "Roboto", color: "rgba(249, 250, 251, 1)", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" } : theme === "Fabric" ? { fontFamily: "Segoe UI", color: "#333333", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" } : { fontFamily: "Helvetica", color: "#F9FAFB", fontWeight: null, size: "12px", headerTextSize: "12px", boldTextSize: "12px" }
      };
      break;
  }
  return style;
}

// node_modules/@syncfusion/ej2-svg-base/src/tooltip/helper.js
var __extends17 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
function measureText(text, font, themeFontStyle, isHeader) {
  var breakText = text || "";
  var htmlObject = document.getElementById("chartmeasuretext");
  if (htmlObject === null) {
    htmlObject = createElement("text", { id: "chartmeasuretext" });
    document.body.appendChild(htmlObject);
  }
  if (typeof text === "string" && (text.indexOf("<") > -1 || text.indexOf(">") > -1)) {
    var textArray = text.split(" ");
    for (var i = 0; i < textArray.length; i++) {
      if (textArray[i].indexOf("<br/>") === -1) {
        textArray[i] = textArray[i].replace(/[<>]/g, "&");
      }
    }
    text = textArray.join(" ");
  }
  htmlObject.innerHTML = breakText.indexOf("<br>") > -1 || breakText.indexOf("<br/>") > -1 ? breakText : text;
  htmlObject.style.position = "fixed";
  htmlObject.style.fontSize = font.size || (isHeader ? themeFontStyle.headerTextSize : themeFontStyle.size);
  htmlObject.style.fontStyle = font.fontStyle || themeFontStyle.fontStyle;
  htmlObject.style.fontFamily = font.fontFamily || themeFontStyle.fontFamily;
  htmlObject.style.visibility = "hidden";
  htmlObject.style.top = "-100";
  htmlObject.style.left = "0";
  htmlObject.style.whiteSpace = "nowrap";
  htmlObject.style.lineHeight = "normal";
  var fontWidth = htmlObject.clientWidth;
  var fontHeight = htmlObject.clientHeight;
  var fontWeight = htmlObject.style.fontWeight;
  htmlObject.style.fontWeight = font.fontWeight || themeFontStyle.fontWeight;
  return new Size(htmlObject.style.fontWeight === "bold" && fontWeight === "normal" ? Math.max(fontWidth, htmlObject.clientWidth) : htmlObject.clientWidth, htmlObject.style.fontWeight === "bold" && fontWeight === "normal" ? Math.max(fontHeight, htmlObject.clientHeight) : htmlObject.clientHeight);
}
function withInAreaBounds(x, y, areaBounds, width, height) {
  if (width === void 0) {
    width = 0;
  }
  if (height === void 0) {
    height = 0;
  }
  return x >= areaBounds.x - width && x <= areaBounds.x + areaBounds.width + width && y >= areaBounds.y - height && y <= areaBounds.y + areaBounds.height + height;
}
function findDirection(rX, rY, rect, arrowLocation, arrowPadding, top, bottom, left, tipX, tipY, controlName) {
  if (controlName === void 0) {
    controlName = "";
  }
  var direction = "";
  var startX = rect.x;
  var startY = rect.y;
  var width = rect.x + rect.width;
  var height = rect.y + rect.height;
  if (top) {
    direction = direction.concat("M " + startX + " " + (startY + rY) + " Q " + startX + " " + startY + " " + (startX + rX) + " " + startY + "  L " + (width - rX) + " " + startY + " Q " + width + " " + startY + " " + width + " " + (startY + rY));
    direction = direction.concat(" L " + width + " " + (height - rY) + " Q " + width + " " + height + " " + (width - rX) + " " + height);
    if (arrowPadding !== 0) {
      if (controlName === "RangeNavigator") {
        if (arrowLocation.x - arrowPadding > width / 2) {
          direction = direction.concat(" L " + (arrowLocation.x + arrowPadding) + " " + height);
          direction = direction.concat(" L " + (tipX + arrowPadding) + " " + (height + arrowPadding) + " L " + arrowLocation.x + " " + height);
        } else {
          direction = direction.concat(" L " + arrowLocation.x + " " + height);
          direction = direction.concat(" L " + (tipX - arrowPadding) + " " + (height + arrowPadding) + " L " + (arrowLocation.x - arrowPadding) + " " + height);
        }
      } else {
        direction = direction.concat(" L " + (arrowLocation.x + arrowPadding) + " " + height);
        direction = direction.concat(" L " + tipX + " " + (height + arrowPadding) + " L " + (arrowLocation.x - arrowPadding) + " " + height);
      }
    }
    if (arrowLocation.x - arrowPadding > startX) {
      direction = direction.concat(" L " + (startX + rX) + " " + height + " Q " + startX + " " + height + " " + startX + " " + (height - rY) + " z");
    } else {
      if (arrowPadding === 0) {
        direction = direction.concat(" L " + (startX + rX) + " " + height + " Q " + startX + " " + height + " " + startX + " " + (height - rY) + " z");
      } else {
        direction = direction.concat(" L " + startX + " " + (height + rY) + " z");
      }
    }
  } else if (bottom) {
    direction = direction.concat("M " + startX + " " + (startY + rY) + " Q " + startX + " " + startY + " " + (startX + rX) + " " + startY + " L " + (arrowLocation.x - arrowPadding) + " " + startY);
    direction = direction.concat(" L " + tipX + " " + arrowLocation.y);
    direction = direction.concat(" L " + (arrowLocation.x + arrowPadding) + " " + startY);
    direction = direction.concat(" L " + (width - rX) + " " + startY + " Q " + width + " " + startY + " " + width + " " + (startY + rY));
    direction = direction.concat(" L " + width + " " + (height - rY) + " Q " + width + " " + height + " " + (width - rX) + " " + height + " L " + (startX + rX) + " " + height + " Q " + startX + " " + height + " " + startX + " " + (height - rY) + " z");
  } else if (left) {
    direction = direction.concat("M " + startX + " " + (startY + rY) + " Q " + startX + " " + startY + " " + (startX + rX) + " " + startY);
    direction = direction.concat(" L " + (width - rX) + " " + startY + " Q " + width + " " + startY + " " + width + " " + ((controlName === "RangeNavigator" ? 0 : startY + rY) + " L " + width + " " + (controlName === "RangeNavigator" ? 0 : arrowLocation.y - arrowPadding)));
    direction = controlName === "RangeNavigator" ? direction.concat(" L " + (width + arrowPadding) + " 0") : direction.concat(" L " + (width + arrowPadding) + " " + tipY);
    direction = controlName === "RangeNavigator" ? direction.concat(" L " + width + " " + (arrowLocation.y - rY)) : direction.concat(" L " + width + " " + (arrowLocation.y + arrowPadding));
    direction = direction.concat(" L " + width + " " + (height - rY) + " Q " + width + " " + height + " " + (width - rX) + " " + height);
    direction = direction.concat(" L " + (startX + rX) + " " + height + " Q " + startX + " " + height + " " + startX + " " + (height - rY) + " z");
  } else {
    direction = direction.concat("M " + (startX + rX) + " " + startY + " Q " + startX + " " + startY + " " + startX + " " + ((controlName === "RangeNavigator" ? 0 : startY + rY) + " L " + startX + " " + (controlName === "RangeNavigator" ? 0 : arrowLocation.y - arrowPadding)));
    direction = controlName === "RangeNavigator" ? direction.concat(" L " + (startX - arrowPadding) + " 0") : direction.concat(" L " + (startX - arrowPadding) + " " + tipY);
    direction = controlName === "RangeNavigator" ? direction.concat(" L " + startX + " " + (arrowLocation.y - rY)) : direction.concat(" L " + startX + " " + (arrowLocation.y + arrowPadding));
    direction = direction.concat(" L " + startX + " " + (height - rY) + " Q " + startX + " " + height + " " + (startX + rX) + " " + height);
    direction = direction.concat(" L " + (width - rX) + " " + height + " Q " + width + " " + height + " " + width + " " + (height - rY) + " L " + width + " " + (startY + rY) + " Q " + width + " " + startY + " " + (width - rX) + " " + startY + " z");
  }
  return direction;
}
var Size = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Size3(width, height) {
      this.width = width;
      this.height = height;
    }
    return Size3;
  })()
);
var Rect = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Rect3(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    return Rect3;
  })()
);
var Side = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Side2(bottom, right) {
      this.isRight = right;
      this.isBottom = bottom;
    }
    return Side2;
  })()
);
var CustomizeOption = (
  /** @class */
  /* @__PURE__ */ (function() {
    function CustomizeOption2(id) {
      this.id = id;
    }
    return CustomizeOption2;
  })()
);
var TextOption = (
  /** @class */
  (function(_super) {
    __extends17(TextOption3, _super);
    function TextOption3(id, x, y, anchor, text, transform, baseLine, labelRotation) {
      if (transform === void 0) {
        transform = "";
      }
      var _this = _super.call(this, id) || this;
      _this.transform = "";
      _this.baseLine = "auto";
      _this.labelRotation = 0;
      _this.x = x;
      _this.y = y;
      _this.anchor = anchor;
      _this.text = text;
      _this.transform = transform;
      _this.baseLine = baseLine;
      _this.labelRotation = labelRotation;
      return _this;
    }
    return TextOption3;
  })(CustomizeOption)
);
function getElement(id) {
  return document.getElementById(id);
}
function removeElement(id) {
  var element = getElement(id);
  if (element) {
    remove(element);
  }
}
function drawSymbol(location2, shape, size, url, options, role, label) {
  var renderer = new SvgRenderer("");
  var temp = calculateShapes(location2, size, shape, options, url);
  var htmlObject = renderer["draw" + temp.functionName](temp.renderOption);
  htmlObject.setAttribute("role", role);
  htmlObject.setAttribute("aria-label", label);
  return htmlObject;
}
function calculateShapes(location2, size, shape, options, url) {
  var path;
  var functionName = "Path";
  var width = size.width;
  var height = size.height;
  var locX = location2.x;
  var locY = location2.y;
  var x = location2.x + -width / 2;
  var y = location2.y + -height / 2;
  switch (shape) {
    case "Circle":
    case "Bubble":
      functionName = "Ellipse";
      merge(options, { "rx": width / 2, "ry": height / 2, "cx": locX, "cy": locY });
      break;
    case "Plus":
      path = "M " + x + " " + locY + " L " + (locX + width / 2) + " " + locY + " M " + locX + " " + (locY + height / 2) + " L " + locX + " " + (locY + -height / 2);
      merge(options, { "d": path, stroke: options.fill });
      break;
    case "Cross":
      path = "M " + x + " " + (locY + -height / 2) + " L " + (locX + width / 2) + " " + (locY + height / 2) + " M " + x + " " + (locY + height / 2) + " L " + (locX + width / 2) + " " + (locY + -height / 2);
      merge(options, { "d": path, stroke: options.fill });
      break;
    case "HorizontalLine":
      path = "M " + x + " " + locY + " L " + (locX + width / 2) + " " + locY;
      merge(options, { "d": path, stroke: options.fill });
      break;
    case "VerticalLine":
      path = "M " + locX + " " + (locY + height / 2) + " L " + locX + " " + (locY + -height / 2);
      merge(options, { "d": path, stroke: options.fill });
      break;
    case "Diamond":
      path = "M " + x + " " + locY + " L " + locX + " " + (locY + -height / 2) + " L " + (locX + width / 2) + " " + locY + " L " + locX + " " + (locY + height / 2) + " L " + x + " " + locY + " z";
      merge(options, { "d": path });
      break;
    case "Rectangle":
      path = "M " + x + " " + (locY + -height / 2) + " L " + (locX + width / 2) + " " + (locY + -height / 2) + " L " + (locX + width / 2) + " " + (locY + height / 2) + " L " + x + " " + (locY + height / 2) + " L " + x + " " + (locY + -height / 2) + " z";
      merge(options, { "d": path });
      break;
    case "Triangle":
      path = "M " + x + " " + (locY + height / 2) + " L " + locX + " " + (locY + -height / 2) + " L " + (locX + width / 2) + " " + (locY + height / 2) + " L " + x + " " + (locY + height / 2) + " z";
      merge(options, { "d": path });
      break;
    case "InvertedTriangle":
      path = "M " + (locX + width / 2) + " " + (locY - height / 2) + " L " + locX + " " + (locY + height / 2) + " L " + (locX - width / 2) + " " + (locY - height / 2) + " L " + (locX + width / 2) + " " + (locY - height / 2) + " z";
      merge(options, { "d": path });
      break;
    case "Pentagon":
      var eq = 72;
      var xValue = void 0;
      var yValue = void 0;
      for (var i = 0; i <= 5; i++) {
        xValue = width / 2 * Math.cos(Math.PI / 180 * (i * eq));
        yValue = height / 2 * Math.sin(Math.PI / 180 * (i * eq));
        if (i === 0) {
          path = "M " + (locX + xValue) + " " + (locY + yValue) + " ";
        } else {
          path = path.concat("L " + (locX + xValue) + " " + (locY + yValue) + " ");
        }
      }
      path = path.concat("Z");
      merge(options, { "d": path });
      break;
    case "Image":
      functionName = "Image";
      merge(options, { "href": url, "height": height, "width": width, x, y });
      break;
    case "Star": {
      var cornerPoints = 5;
      var outerRadius = Math.min(width, height) / 2;
      var innerRadius = outerRadius / 2;
      var angle = Math.PI / cornerPoints;
      var starPath = "";
      for (var i = 0; i < 2 * cornerPoints; i++) {
        var radius = i % 2 === 0 ? outerRadius : innerRadius;
        var currentX = locX + radius * Math.cos(i * angle - Math.PI / 2);
        var currentY = locY + radius * Math.sin(i * angle - Math.PI / 2);
        starPath += (i === 0 ? "M" : "L") + currentX + "," + currentY;
      }
      starPath += "Z";
      merge(options, { "d": starPath });
      break;
    }
  }
  return { renderOption: options, functionName };
}
var PathOption = (
  /** @class */
  (function(_super) {
    __extends17(PathOption3, _super);
    function PathOption3(id, fill, width, color, opacity, dashArray, d) {
      var _this = _super.call(this, id) || this;
      _this.opacity = opacity;
      _this.fill = fill;
      _this.stroke = color;
      _this["stroke-width"] = width;
      _this["stroke-dasharray"] = dashArray;
      _this.d = d;
      return _this;
    }
    return PathOption3;
  })(CustomizeOption)
);
function textElement(options, font, color, parent, themeStyle) {
  var renderOptions = {};
  var renderer = new SvgRenderer("");
  renderOptions = {
    "id": options.id,
    "x": options.x,
    "y": options.y,
    "fill": color,
    "font-size": font.size || themeStyle.size,
    "font-style": font.fontStyle || themeStyle.fontStyle,
    "font-family": font.fontFamily || themeStyle.fontFamily,
    "font-weight": font.fontWeight || themeStyle.fontWeight,
    "text-anchor": options.anchor,
    "transform": options.transform,
    "opacity": font.opacity,
    "dominant-baseline": options.baseLine
  };
  var text = typeof options.text === "string" ? options.text : options.text[0];
  var htmlObject = renderer.createText(renderOptions, text);
  if (parent) {
    parent.appendChild(htmlObject);
  }
  return htmlObject;
}
var TooltipLocation = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TooltipLocation2(x, y) {
      this.x = x;
      this.y = y;
    }
    return TooltipLocation2;
  })()
);

// node_modules/@syncfusion/ej2-svg-base/src/tooltip/tooltip.js
var __extends18 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var TextStyle = (
  /** @class */
  (function(_super) {
    __extends18(TextStyle2, _super);
    function TextStyle2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate7([
      Property(null)
    ], TextStyle2.prototype, "size", void 0);
    __decorate7([
      Property("")
    ], TextStyle2.prototype, "color", void 0);
    __decorate7([
      Property("Segoe UI")
    ], TextStyle2.prototype, "fontFamily", void 0);
    __decorate7([
      Property("Normal")
    ], TextStyle2.prototype, "fontWeight", void 0);
    __decorate7([
      Property("Normal")
    ], TextStyle2.prototype, "fontStyle", void 0);
    __decorate7([
      Property(1)
    ], TextStyle2.prototype, "opacity", void 0);
    __decorate7([
      Property(null)
    ], TextStyle2.prototype, "headerTextSize", void 0);
    __decorate7([
      Property(null)
    ], TextStyle2.prototype, "boldTextSize", void 0);
    return TextStyle2;
  })(ChildProperty)
);
var TooltipBorder = (
  /** @class */
  (function(_super) {
    __extends18(TooltipBorder2, _super);
    function TooltipBorder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate7([
      Property("")
    ], TooltipBorder2.prototype, "color", void 0);
    __decorate7([
      Property(1)
    ], TooltipBorder2.prototype, "width", void 0);
    __decorate7([
      Property("")
    ], TooltipBorder2.prototype, "dashArray", void 0);
    return TooltipBorder2;
  })(ChildProperty)
);
var AreaBounds = (
  /** @class */
  (function(_super) {
    __extends18(AreaBounds2, _super);
    function AreaBounds2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate7([
      Property(0)
    ], AreaBounds2.prototype, "x", void 0);
    __decorate7([
      Property(0)
    ], AreaBounds2.prototype, "y", void 0);
    __decorate7([
      Property(0)
    ], AreaBounds2.prototype, "width", void 0);
    __decorate7([
      Property(0)
    ], AreaBounds2.prototype, "height", void 0);
    return AreaBounds2;
  })(ChildProperty)
);
var ToolLocation = (
  /** @class */
  (function(_super) {
    __extends18(ToolLocation2, _super);
    function ToolLocation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate7([
      Property(0)
    ], ToolLocation2.prototype, "x", void 0);
    __decorate7([
      Property(0)
    ], ToolLocation2.prototype, "y", void 0);
    return ToolLocation2;
  })(ChildProperty)
);
var Tooltip = (
  /** @class */
  (function(_super) {
    __extends18(Tooltip2, _super);
    function Tooltip2(options, element) {
      return _super.call(this, options, element) || this;
    }
    Tooltip2.prototype.preRender = function() {
      this.allowServerDataBinding = false;
      this.initPrivateVariable();
      if (!this.isCanvas) {
        this.removeSVG();
      }
      this.createTooltipElement();
    };
    Tooltip2.prototype.initPrivateVariable = function() {
      this.renderer = new SvgRenderer(this.element.id);
      this.themeStyle = getTooltipThemeColor(this.theme);
      this.formattedText = [];
      this.padding = 5;
      this.highlightPadding = 3;
      this.areaMargin = 10;
      this.isFirst = true;
      this.markerPoint = [];
    };
    Tooltip2.prototype.removeSVG = function() {
      var svgObject = document.getElementById(this.element.id + "_svg");
      var templateObject = document.getElementById(this.element.id + "parent_template");
      if (this.blazorTemplate) {
        resetBlazorTemplate(this.element.id + "parent_template_blazorTemplate");
      }
      if (svgObject && svgObject.parentNode) {
        remove(svgObject);
      }
      if (templateObject && templateObject.parentNode) {
        remove(templateObject);
      }
    };
    Tooltip2.prototype.render = function() {
      this.fadeOuted = false;
      if (!this.template) {
        this.renderText(this.isFirst);
        var argsData = {
          cancel: false,
          name: "tooltipRender",
          tooltip: this
        };
        this.trigger("tooltipRender", argsData);
        var markerSide = this.renderTooltipElement(this.areaBounds, this.location);
        this.drawMarker(markerSide.isBottom, markerSide.isRight, this.markerSize);
      } else {
        this.updateTemplateFn();
        this.createTemplate(this.areaBounds, this.location);
      }
      this.trigger("loaded", { tooltip: this });
      var element = document.getElementById("chartmeasuretext");
      if (element) {
        remove(element);
      }
      this.allowServerDataBinding = true;
    };
    Tooltip2.prototype.createTooltipElement = function() {
      this.textElements = [];
      if (!this.template || this.shared) {
        if (this.enableRTL) {
          this.element.setAttribute("dir", "ltr");
        }
        var svgObject = this.renderer.createSvg({ id: this.element.id + "_svg" });
        this.element.appendChild(svgObject);
        var groupElement = document.getElementById(this.element.id + "_group");
        if (!groupElement) {
          groupElement = this.renderer.createGroup({ id: this.element.id + "_group" });
          groupElement.setAttribute("transform", "translate(0,0)");
        }
        svgObject.appendChild(groupElement);
        var pathElement = this.renderer.drawPath({
          "id": this.element.id + "_path",
          "stroke-width": (this.theme === "Fabric" || this.theme === "Fluent" || this.theme === "Fluent2" || this.theme === "Fluent2HighContrast") && !this.border.width ? 1 : this.border.width,
          "fill": this.fill || this.themeStyle.tooltipFill,
          "opacity": (this.theme === "TailwindDark" || this.theme === "Tailwind" || this.theme === "Tailwind3Dark" || this.theme === "Tailwind3" || this.theme === "Bootstrap5" || this.theme === "Bootstrap5Dark" || this.theme.indexOf("Fluent2") > -1) && this.opacity === 0.75 ? 1 : this.opacity,
          "stroke": this.border.color || (this.theme === "Fabric" || this.theme === "Fluent" || this.theme === "Fluent2" ? "#D2D0CE" : this.border.color)
        });
        groupElement.appendChild(pathElement);
      }
    };
    Tooltip2.prototype.drawMarker = function(isBottom, isRight, size) {
      if (this.shapes.length <= 0) {
        return null;
      }
      var shapeOption;
      var count = 0;
      var markerGroup = this.renderer.createGroup({ id: this.element.id + "_trackball_group" });
      var groupElement = getElement(this.element.id + "_group");
      if (!groupElement) {
        return null;
      }
      var x = (this.enableRTL ? this.elementSize.width - size / 2 : this.marginX * 2 + size / 2) + (isRight ? this.arrowPadding : 0);
      for (var _i = 0, _a = this.shapes; _i < _a.length; _i++) {
        var shape = _a[_i];
        if (shape !== "None") {
          shapeOption = new PathOption(this.element.id + "_Trackball_" + count, this.palette[count], 1, "#cccccc", 1, null);
          if (this.markerPoint[count]) {
            var padding = 0;
            if (this.header.indexOf("<br") > -1) {
              padding = this.header.split(/<br.*?>/g).length + count;
            }
            var tooltipContent = this.formattedText && this.formattedText.length >= 2 ? this.getTooltipTextContent(this.formattedText[1]) + ", " + this.getTooltipTextContent(this.formattedText[0]) : "";
            markerGroup.appendChild(drawSymbol(new TooltipLocation(x, this.markerPoint[count] - this.padding + (isBottom ? this.arrowPadding : padding)), shape, new Size(size, size), "", shapeOption, "img", tooltipContent));
          }
          count++;
        }
      }
      groupElement.appendChild(markerGroup);
    };
    Tooltip2.prototype.renderTooltipElement = function(areaBounds, location2) {
      var tooltipDiv = getElement(this.element.id);
      var arrowLocation = new TooltipLocation(0, 0);
      var tipLocation = new TooltipLocation(0, 0);
      var svgObject = getElement(this.element.id + "_svg");
      var groupElement = getElement(this.element.id + "_group");
      var pathElement = getElement(this.element.id + "_path");
      var rect;
      var isTop = false;
      var isLeft = false;
      var isBottom = false;
      var x = 0;
      var y = 0;
      if (!isNullOrUndefined(groupElement)) {
        if (this.header !== "" && this.showHeaderLine) {
          this.elementSize.height += this.marginY;
        }
        if (this.isFixed) {
          var width = this.elementSize.width + 2 * this.marginX;
          var height = this.elementSize.height + 2 * this.marginY;
          rect = new Rect(location2.x, location2.y, width, height);
        } else if (this.content.length > 1) {
          rect = this.sharedTooltipLocation(areaBounds, this.location.x, this.location.y);
          isTop = true;
        } else {
          rect = this.tooltipLocation(areaBounds, location2, arrowLocation, tipLocation);
          if (!this.inverted) {
            isTop = rect.y < location2.y + this.clipBounds.y;
            isBottom = !isTop;
            y = isTop ? 0 : this.arrowPadding;
          } else {
            isLeft = rect.x < location2.x + this.clipBounds.x;
            x = isLeft ? 0 : this.arrowPadding;
            if (this.allowHighlight) {
              rect.x += isLeft ? this.highlightPadding : -(2 * this.highlightPadding);
            }
          }
        }
        if (this.header !== "" && this.showHeaderLine) {
          var wrapPadding = 2;
          var padding = 0;
          var wrapHeader = this.isWrap ? this.wrappedText : this.header;
          if (this.isWrap && typeof wrapHeader === "string" && (wrapHeader.indexOf("<") > -1 || wrapHeader.indexOf(">") > -1)) {
            var textArray = wrapHeader.split("<br>");
            wrapPadding = textArray.length;
          }
          if (this.header.indexOf("<br") > -1) {
            padding = 5 * (this.header.split(/<br.*?>/g).length - 1);
          }
          var key = "properties";
          var font = extend({}, this.textStyle, null, true)[key];
          var headerSize = measureText(this.isWrap ? this.wrappedText : this.header, font, this.themeStyle.textStyle).height + this.marginY * wrapPadding + (isBottom ? this.arrowPadding : 0) + (this.isWrap ? 5 : padding);
          var xLength = this.marginX * 3 + (!isLeft && !isTop && !isBottom ? this.arrowPadding : 0);
          var direction = "M " + xLength + " " + headerSize + "L " + (rect.width + (!isLeft && !isTop && !isBottom ? this.arrowPadding : 0) - this.marginX * 2) + " " + headerSize;
          var pathElement_1 = this.renderer.drawPath({
            "id": this.element.id + "_header_path",
            "stroke-width": 1,
            "fill": null,
            "opacity": this.theme === "Material3" || this.theme === "Material3Dark" ? 0.2 : 0.8,
            "stroke": this.themeStyle.tooltipHeaderLine,
            "d": direction
          });
          groupElement.appendChild(pathElement_1);
        }
        var start = this.border.width / 2;
        var pointRect = new Rect(start + x, start + y, rect.width - start, rect.height - start);
        groupElement.setAttribute("opacity", "1");
        if (this.enableAnimation && !this.isFirst && !this.crosshair) {
          this.animateTooltipDiv(tooltipDiv, rect);
        } else {
          this.updateDiv(tooltipDiv, rect.x, rect.y);
        }
        svgObject.setAttribute("height", (rect.height + this.border.width + (!!this.inverted ? 0 : this.arrowPadding) + 5).toString());
        svgObject.setAttribute("width", (rect.width + this.border.width + (!this.inverted ? 0 : this.arrowPadding) + 5).toString());
        svgObject.setAttribute("opacity", "1");
        if (!isNullOrUndefined(this.tooltipPlacement)) {
          isTop = this.tooltipPlacement.indexOf("Top") > -1;
          isBottom = this.tooltipPlacement.indexOf("Bottom") > -1;
          isLeft = this.tooltipPlacement.indexOf("Left") > -1;
        }
        pathElement.setAttribute("d", findDirection(this.rx, this.ry, pointRect, arrowLocation, this.arrowPadding, isTop, isBottom, isLeft, tipLocation.x, tipLocation.y, this.controlName));
        if (this.enableShadow && this.theme !== "Bootstrap4" || this.theme.indexOf("Fluent2") > -1) {
          var shadowId = this.element.id + "_shadow";
          if (this.theme === "Tailwind" || this.theme === "TailwindDark" || this.theme === "Tailwind3" || this.theme === "Tailwind3Dark" || this.theme === "Bootstrap5" || this.theme === "Bootstrap5Dark") {
            pathElement.setAttribute("box-shadow", "0px 1px 2px rgba(0, 0, 0, 0.06), 0px 1px 3px rgba(0, 0, 0, 0.1)");
          } else {
            pathElement.setAttribute("filter", Browser.isIE ? "" : "url(#" + shadowId + ")");
          }
          var shadow = '<filter id="' + shadowId + '" height="130%"><feGaussianBlur in="SourceAlpha" stdDeviation="3"/>';
          if (this.theme.indexOf("Fluent2") > -1) {
            shadow += '<feOffset dx="-1" dy="3.6" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="0.2"/>';
          } else {
            shadow += '<feOffset dx="3" dy="3" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="0.5"/>';
          }
          shadow += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
          var defElement = this.renderer.createDefs();
          defElement.setAttribute("id", this.element.id + "SVG_tooltip_definition");
          groupElement.appendChild(defElement);
          defElement.innerHTML = shadow;
        }
        var borderColor = (this.theme === "Fabric" || this.theme === "Fluent" || this.theme === "Fluent2") && !this.border.color ? "#D2D0CE" : this.theme === "Fluent2HighContrast" ? "#FFFFFF" : this.border.color;
        pathElement.setAttribute("stroke", borderColor);
        if (!isNullOrUndefined(this.border.dashArray)) {
          pathElement.setAttribute("stroke-dasharray", this.border.dashArray);
        }
        this.changeText(new TooltipLocation(x, y), isBottom, !isLeft && !isTop && !isBottom);
        if (this.revert) {
          this.inverted = !this.inverted;
          this.revert = false;
        }
      }
      return new Side(isBottom, !isLeft && !isTop && !isBottom);
    };
    Tooltip2.prototype.changeText = function(point, isBottom, isRight) {
      var element = document.getElementById(this.element.id + "_text");
      if (isBottom) {
        element.setAttribute("transform", "translate(0," + this.arrowPadding + ")");
      }
      if (isRight) {
        element.setAttribute("transform", "translate(" + this.arrowPadding + " 0)");
      }
    };
    Tooltip2.prototype.findFormattedText = function() {
      this.formattedText = [];
      if (this.header.replace(/<b>/g, "").replace(/<\/b>/g, "").trim() !== "") {
        this.formattedText = this.formattedText.concat(this.header);
      }
      this.formattedText = this.formattedText.concat(this.content);
    };
    Tooltip2.prototype.renderText = function(isRender) {
      var height = 0;
      var width = 0;
      var subWidth = 0;
      var lines;
      var key = "properties";
      var font = extend({}, this.textStyle, null, true)[key];
      var groupElement = getElement(this.element.id + "_group");
      var tspanElement;
      var textCollection;
      var tspanStyle = "";
      var line;
      var tspanOption;
      this.findFormattedText();
      this.isWrap = false;
      var isRtlEnabled = document.body.getAttribute("dir") === "rtl";
      var anchor = isRtlEnabled && !this.enableRTL ? "end" : "start";
      this.leftSpace = this.areaBounds.x + this.location.x;
      this.rightSpace = this.areaBounds.x + this.areaBounds.width - this.leftSpace;
      var headerContent = this.header.replace(/<b>/g, "").replace(/<\/b>/g, "").trim();
      var isBoldTag = this.header.indexOf("<b>") > -1 && this.header.indexOf("</b>") > -1;
      var headerWidth = measureText(this.formattedText[0], font, this.themeStyle.textStyle).width + 2 * this.marginX + this.arrowPadding;
      var isLeftSpace = this.location.x - headerWidth < this.location.x;
      var isRightSpace = this.areaBounds.x + this.areaBounds.width < this.location.x + headerWidth;
      var header;
      var headerSpace = headerContent !== "" && this.showHeaderLine ? this.marginY : 0;
      var isRow = true;
      var isColumn = true;
      this.markerPoint = [];
      var markerSize = this.shapes.length > 0 ? 10 : 0;
      var markerPadding = this.shapes.length > 0 ? 5 : 0;
      var spaceWidth = 4;
      var subStringLength;
      var fontSize = "12px";
      var fontWeight = "400";
      var labelColor = this.themeStyle.tooltipLightLabel;
      var dy = 22 / parseFloat(fontSize) * parseFloat(font.size || this.themeStyle.textStyle.size);
      var contentWidth = [];
      var textHeight = 0;
      if (!isRender || this.isCanvas) {
        removeElement(this.element.id + "_text");
        removeElement(this.element.id + "_header_path");
        removeElement(this.element.id + "_trackball_group");
        removeElement(this.element.id + "SVG_tooltip_definition");
      }
      if (this.controlName === "Chart" && parseFloat(fontSize) < parseFloat(font.size || this.themeStyle.textStyle.headerTextSize)) {
        textHeight = parseFloat(font.size || this.themeStyle.textStyle.size) - parseFloat(fontSize);
      }
      var options = new TextOption(this.element.id + "_text", this.marginX * 2, textHeight + this.marginY * 2 + this.padding * 2 + (this.marginY === 2 ? this.controlName === "RangeNavigator" ? 5 : 3 : 0), anchor, "");
      var parentElement = textElement(options, font, font.color || this.themeStyle.tooltipBoldLabel, groupElement, this.themeStyle.textStyle);
      var withoutHeader = this.formattedText.length === 1 && this.formattedText[0].indexOf(" : <b>") > -1;
      var isHeader = this.header !== "";
      var size = isHeader && isBoldTag ? 16 : 13;
      for (var k = 0, pointsLength = this.formattedText.length; k < pointsLength; k++) {
        textCollection = this.formattedText[k].replace(/<(b|strong)>/g, "<b>").replace(/<\/(b|strong)>/g, "</b>").split(/<br.*?>/g);
        if (this.isTextWrap && this.header !== this.formattedText[k] && this.formattedText[k].indexOf("<br") === -1) {
          subStringLength = Math.round(this.leftSpace > this.rightSpace ? this.leftSpace / size : this.rightSpace / size);
          textCollection = this.formattedText[k].match(new RegExp(".{1," + subStringLength + "}", "g"));
        }
        if (k === 0 && !withoutHeader && this.isTextWrap && (this.leftSpace < headerWidth || isLeftSpace) && (this.rightSpace < headerWidth || isRightSpace)) {
          subStringLength = Math.round(this.leftSpace > this.rightSpace ? this.leftSpace / size : this.rightSpace / size);
          header = headerContent !== "" ? headerContent : this.formattedText[k];
          textCollection = header.match(new RegExp(".{1," + subStringLength + "}", "g"));
          this.wrappedText = isBoldTag ? "<b>" + textCollection.join("<br>") + "</b>" : textCollection.join("<br>");
          this.isWrap = textCollection.length > 1;
        }
        if (textCollection[0] === "") {
          continue;
        }
        if (k !== 0 || headerContent === "") {
          this.markerPoint.push((headerContent !== "" && this.showHeaderLine ? this.marginY : 0) + options.y + height - (textHeight !== 0 ? textHeight / this.markerSize * (parseFloat(font.size || this.themeStyle.textStyle.headerTextSize) / this.markerSize) : 0));
        }
        for (var i = 0, len = textCollection.length; i < len; i++) {
          lines = textCollection[i].replace(/<b>/g, "<br><b>").replace(/<\/b>/g, "</b><br>").replace(/:/g, this.enableRTL ? "<br>‎: <br>" : "<br>‎:<br>").split("<br>");
          if (this.enableRTL && lines.length > 0 && textCollection[i].match(/:/g)) {
            lines[0] = lines[0].trim();
            lines.reverse();
          }
          subWidth = 0;
          isColumn = true;
          height += dy;
          for (var j = 0, len_1 = lines.length; j < len_1; j++) {
            line = lines[j];
            if (this.enableRTL && line !== "" && this.isRTLText(line)) {
              line = line.concat("‎");
            }
            if (!/\S/.test(line) && line !== "") {
              line = " ";
            }
            if (!isColumn && line === " " || line.replace(/<b>/g, "").replace(/<\/b>/g, "").trim() !== "") {
              subWidth += line !== " " ? spaceWidth : 0;
              if (isColumn && !isRow) {
                if (this.header.indexOf("<br") > -1 && k !== 0) {
                  headerSpace += this.header.split(/<br.*?>/g).length;
                }
                tspanOption = {
                  x: this.marginX * 2 + (markerSize + markerPadding),
                  dy: dy + (isColumn ? headerSpace : 0),
                  fill: ""
                };
                headerSpace = null;
              } else {
                if (isRow && isColumn) {
                  tspanOption = {
                    x: headerContent === "" ? this.marginX * 2 + (markerSize + markerPadding) : this.marginX * 2 + (this.isWrap ? markerSize + markerPadding : 0)
                  };
                } else {
                  tspanOption = {};
                }
              }
              isColumn = false;
              tspanElement = this.renderer.createTSpan(tspanOption, "");
              parentElement.appendChild(tspanElement);
              if (line.indexOf("<b>") > -1 || isBoldTag && j === 0 && k === 0 && (isHeader || this.isWrap)) {
                fontWeight = "600";
                labelColor = this.themeStyle.tooltipBoldLabel;
                tspanStyle = "font-weight:" + fontWeight;
                font.fontWeight = fontWeight;
                tspanElement.setAttribute("fill", this.textStyle.color || labelColor);
              } else {
                tspanStyle = fontWeight === "600" ? "font-weight:" + fontWeight : "";
                font.fontWeight = fontWeight;
                tspanElement.setAttribute("fill", this.textStyle.color || labelColor);
              }
              if (line.indexOf("</b>") > -1 || isBoldTag && j === len_1 - 1 && k === 0 && (isHeader || this.isWrap)) {
                fontWeight = "Normal";
                labelColor = this.themeStyle.tooltipLightLabel;
              }
              if (tspanStyle !== "") {
                tspanElement.style.fontWeight = tspanStyle.split("font-weight:")[1];
                tspanElement.style.color = tspanElement.getAttribute("fill");
              }
              tspanElement.style.fontFamily = "inherit";
              tspanElement.style.fontStyle = "inherit";
              tspanElement.style.fontSize = this.header === this.formattedText[k] ? font.size || this.themeStyle.textStyle.headerTextSize : line.indexOf("<b>") > -1 || line.indexOf("</b>") > -1 ? font.size || this.themeStyle.textStyle.boldTextSize : font.size || this.themeStyle.textStyle.size;
              tspanElement.style.fontWeight = this.header === this.formattedText[k] && (this.header.indexOf("<b>") === -1 || this.header.indexOf("</b>") === -1) ? this.textStyle.fontWeight || (this.theme.indexOf("Tailwind3") > -1 ? "500" : "600") : line.indexOf("<b>") > -1 || line.indexOf("</b>") > -1 ? this.theme.indexOf("Bootstrap5") > -1 ? this.textStyle.fontWeight || "600" : "bold" : (line.indexOf("<b>") === -1 || line.indexOf("</b>") === -1) && (this.theme.indexOf("Bootstrap5") > -1 || this.theme.indexOf("Tailwind3") > -1) ? this.textStyle.fontWeight || (this.theme.indexOf("Tailwind3") > -1 ? "500" : "600") : this.textStyle.fontWeight || font.fontWeight;
              var textFont = extend({}, this.textStyle, null, true)[key];
              textFont.fontWeight = tspanElement.style.fontWeight;
              textFont.size = tspanElement.style.fontSize;
              isRow = false;
              tspanElement.textContent = line = this.getTooltipTextContent(line);
              subWidth += measureText(line, textFont, this.themeStyle.textStyle).width;
            }
          }
          subWidth -= spaceWidth;
          width = Math.max(width, subWidth);
          contentWidth.push(subWidth);
        }
      }
      this.elementSize = new Size(width + (width > 0 ? 2 * this.marginX : 0), height);
      this.elementSize.width += markerSize + markerPadding;
      var element = parentElement.childNodes[0];
      if (headerContent !== "" && element && !this.isWrap) {
        font.fontWeight = "600";
        var width_1 = (this.elementSize.width + 2 * this.padding) / 2 - measureText(headerContent, font, this.themeStyle.textStyle, true).width / 2;
        element.setAttribute("x", width_1.toString());
      }
      this.renderContentRTL(parentElement, isHeader, markerSize + markerPadding, contentWidth);
    };
    Tooltip2.prototype.renderContentRTL = function(textElement2, isHeader, markerSize, contentWidth) {
      if (this.enableRTL) {
        var tspanElement = void 0;
        var contentWidthIndex = isHeader ? 1 : 0;
        for (var i = 0; i < textElement2.childNodes.length; i++) {
          tspanElement = textElement2.childNodes[i];
          if ((!isHeader || i > 0) && !isNullOrUndefined(tspanElement.getAttribute("x"))) {
            tspanElement.setAttribute("x", (this.elementSize.width - (markerSize + contentWidth[contentWidthIndex])).toString());
            contentWidthIndex++;
          }
        }
      }
    };
    Tooltip2.prototype.getTooltipTextContent = function(tooltipText) {
      var characterCollection = tooltipText.match(/<[a-zA-Z\/](.|\n)*?>/g);
      if (isNullOrUndefined(characterCollection)) {
        return tooltipText;
      }
      var isRtlText = this.isRTLText(tooltipText);
      for (var i = 0; i < characterCollection.length; i++) {
        if (this.isValidHTMLElement(characterCollection[i].replace("<", "").replace("/", "").replace(">", "").trim())) {
          tooltipText = tooltipText.replace(characterCollection[i], isRtlText ? "‎" : "");
        }
      }
      return tooltipText;
    };
    Tooltip2.prototype.isValidHTMLElement = function(element) {
      return document.createElement(element).toString() !== "[object HTMLUnknownElement]";
    };
    Tooltip2.prototype.isRTLText = function(tooltipContent) {
      return /[\u0590-\u07FF\u200F\u202B\u202E\uFB1D-\uFDFD\uFE70-\uFEFC]/.test(tooltipContent);
    };
    Tooltip2.prototype.createTemplate = function(areaBounds, location2) {
      var argsData = { cancel: false, name: "tooltipRender", tooltip: this };
      this.trigger("tooltipRender", argsData);
      var parent = document.getElementById(this.element.id);
      if (this.isCanvas) {
        this.removeSVG();
      }
      var firstElement = !isNullOrUndefined(parent) ? parent.firstElementChild : null;
      if (firstElement) {
        remove(firstElement);
      }
      if (!argsData.cancel) {
        var elem = createElement("div", { id: this.element.id + "parent_template" });
        var templateElement = void 0;
        if (this.controlName === "Chart" && this.shared) {
          for (var i = 0; i < this.data.length; i++) {
            var sharedTemplateElement = this.templateFn(this.data[i], this.controlInstance, elem.id, elem.id + "_blazorTemplate", "");
            if (i === 0) {
              templateElement = sharedTemplateElement;
            } else {
              if (sharedTemplateElement.length > 1) {
                templateElement[i].outerHTML = sharedTemplateElement[i].outerHTML || sharedTemplateElement[i].textContent;
              } else {
                templateElement[templateElement.length - 1].outerHTML += sharedTemplateElement[0].outerHTML;
              }
            }
          }
        } else {
          templateElement = this.templateFn(this.data, this.controlInstance, elem.id, elem.id + "_blazorTemplate", "");
        }
        while (templateElement && templateElement.length > 0) {
          if (isBlazor() || templateElement.length === 1) {
            elem.appendChild(templateElement[0]);
            templateElement = null;
          } else {
            elem.appendChild(templateElement[0]);
          }
        }
        if (!isNullOrUndefined(parent)) {
          parent.appendChild(elem);
        }
        var element = this.isCanvas ? elem : this.element;
        var rect = element.getBoundingClientRect();
        this.padding = 0;
        this.elementSize = new Size(rect.width, rect.height);
        var tooltipRect = this.shared ? this.sharedTooltipLocation(areaBounds, this.location.x, this.location.y) : this.tooltipLocation(areaBounds, location2, new TooltipLocation(0, 0), new TooltipLocation(0, 0));
        if (this.enableAnimation && !this.isFirst && !this.crosshair) {
          this.animateTooltipDiv(this.element, tooltipRect);
        } else {
          this.updateDiv(element, tooltipRect.x, tooltipRect.y);
        }
        if (this.blazorTemplate) {
          var tooltipRendered = function() {
            var rect1 = getElement(thisObject_1.element.id).getBoundingClientRect();
            thisObject_1.elementSize = new Size(rect1.width, rect1.height);
            var tooltipRect1 = thisObject_1.tooltipLocation(areaBounds, location2, new TooltipLocation(0, 0), new TooltipLocation(0, 0));
            thisObject_1.updateDiv(getElement(thisObject_1.element.id), tooltipRect1.x, tooltipRect1.y);
          };
          var thisObject_1 = this;
          tooltipRendered.bind(thisObject_1, areaBounds, location2);
          updateBlazorTemplate(this.element.id + "parent_template_blazorTemplate", this.blazorTemplate.name, this.blazorTemplate.parent, void 0, tooltipRendered);
        }
      } else {
        remove(getElement(this.element.id + "_tooltip"));
      }
    };
    Tooltip2.prototype.sharedTooltipLocation = function(bounds, x, y) {
      var width = this.elementSize.width + 2 * this.marginX;
      var height = this.elementSize.height + 2 * this.marginY;
      var tooltipRect = new Rect(x + 2 * this.padding, y - height - this.padding, width, height);
      if (tooltipRect.y < bounds.y) {
        tooltipRect.y += tooltipRect.height + 2 * this.padding;
      }
      if (tooltipRect.y + tooltipRect.height > bounds.y + bounds.height) {
        tooltipRect.y = Math.max(bounds.y + bounds.height - (tooltipRect.height + 2 * this.padding), bounds.y);
      }
      if (tooltipRect.x + tooltipRect.width > bounds.x + bounds.width) {
        tooltipRect.x = bounds.x + this.location.x - (tooltipRect.width + 4 * this.padding);
      }
      if (tooltipRect.x < bounds.x) {
        tooltipRect.x = bounds.x;
      }
      return tooltipRect;
    };
    Tooltip2.prototype.getCurrentPosition = function(bounds, symbolLocation, arrowLocation, tipLocation) {
      var position = this.tooltipPlacement;
      var clipX = this.clipBounds.x;
      var clipY = this.clipBounds.y;
      var markerHeight = this.offset;
      var width = this.elementSize.width + 2 * this.marginX;
      var height = this.elementSize.height + 2 * this.marginY;
      var location2 = new TooltipLocation(symbolLocation.x, symbolLocation.y);
      if (position === "Top" || position === "Bottom") {
        location2 = new TooltipLocation(location2.x + clipX - this.elementSize.width / 2 - this.padding, location2.y + clipY - this.elementSize.height - 2 * this.padding - this.arrowPadding - markerHeight);
        arrowLocation.x = tipLocation.x = width / 2;
        if (position === "Bottom") {
          location2.y = symbolLocation.y + clipY + markerHeight;
        }
        if (bounds.x + bounds.width < location2.x + width) {
          location2.x = bounds.width > width ? bounds.x + bounds.width - width + 6 : bounds.x;
          arrowLocation.x = tipLocation.x = bounds.width > width ? bounds.x + symbolLocation.x - location2.x : symbolLocation.x;
        } else if (bounds.x > location2.x) {
          location2.x = bounds.x;
          arrowLocation.x = tipLocation.x = symbolLocation.x;
        }
      } else {
        location2 = new TooltipLocation(location2.x + clipX + markerHeight, location2.y + clipY - this.elementSize.height / 2 - this.padding);
        arrowLocation.y = tipLocation.y = height / 2;
        if (position === "Left") {
          location2.x = symbolLocation.x + clipX - markerHeight - (width + this.arrowPadding);
        }
        if (bounds.y + bounds.height < location2.y + height) {
          location2.y = bounds.height > height ? bounds.y + bounds.height - height + 6 : bounds.y;
          arrowLocation.y = tipLocation.y = bounds.height > height ? bounds.y + symbolLocation.y - location2.y : symbolLocation.y;
        } else if (bounds.y > location2.y) {
          location2.y = bounds.y;
          arrowLocation.y = tipLocation.y = symbolLocation.y;
        }
      }
      return new Rect(location2.x, location2.y, width, height);
    };
    Tooltip2.prototype.tooltipLocation = function(bounds, symbolLocation, arrowLocation, tipLocation) {
      if (!isNullOrUndefined(this.tooltipPlacement)) {
        var tooltipRect = this.getCurrentPosition(bounds, symbolLocation, arrowLocation, tipLocation);
        return tooltipRect;
      }
      var location2 = new TooltipLocation(symbolLocation.x, symbolLocation.y);
      var width = this.elementSize.width + 2 * this.marginX;
      var height = this.elementSize.height + 2 * this.marginY;
      var markerHeight = this.offset;
      var clipX = this.clipBounds.x;
      var clipY = this.clipBounds.y;
      var boundsX = bounds.x;
      var boundsY = bounds.y;
      this.outOfBounds = false;
      if (!this.inverted) {
        location2 = new TooltipLocation(location2.x + clipX - this.elementSize.width / 2 - this.padding, location2.y + clipY - this.elementSize.height - 2 * (this.allowHighlight ? this.highlightPadding : this.padding) - this.arrowPadding - markerHeight);
        arrowLocation.x = tipLocation.x = width / 2;
        if ((location2.y < boundsY || this.isNegative) && !(this.controlName === "Progressbar")) {
          location2.y = (symbolLocation.y < 0 ? 0 : symbolLocation.y) + clipY + markerHeight;
        }
        if (location2.y + height + this.arrowPadding > boundsY + bounds.height) {
          location2.y = Math.min(symbolLocation.y, boundsY + bounds.height) + clipY - this.elementSize.height - 2 * this.padding - this.arrowPadding - markerHeight;
        }
        if ((location2.x + width > boundsX + bounds.width && location2.y < boundsY || this.isNegative) && !(this.controlName === "Progressbar")) {
          location2.y = (symbolLocation.y < 0 ? 0 : symbolLocation.y) + clipY + markerHeight;
        }
        tipLocation.x = width / 2;
        if (location2.x < boundsX && !(this.controlName === "Progressbar")) {
          arrowLocation.x -= boundsX - location2.x;
          tipLocation.x -= boundsX - location2.x;
          location2.x = boundsX;
        }
        if (location2.x + width > boundsX + bounds.width && !(this.controlName === "Progressbar")) {
          arrowLocation.x += location2.x + width - (boundsX + bounds.width);
          tipLocation.x += location2.x + width - (boundsX + bounds.width);
          location2.x -= location2.x + width - (boundsX + bounds.width);
        }
        if (location2.x < boundsX && !(this.controlName === "Progressbar")) {
          arrowLocation.x -= boundsX - location2.x;
          tipLocation.x -= boundsX - location2.x;
          location2.x = boundsX;
        }
        if (arrowLocation.x + this.arrowPadding > width - this.rx) {
          arrowLocation.x = width - this.rx - this.arrowPadding;
          tipLocation.x = width - this.rx - this.arrowPadding;
        }
        if (arrowLocation.x - this.arrowPadding < this.rx) {
          arrowLocation.x = tipLocation.x = this.rx + this.arrowPadding;
        }
        if (this.controlName === "Chart") {
          if (bounds.x + bounds.width - (location2.x + arrowLocation.x) < this.areaMargin + this.arrowPadding || location2.x + arrowLocation.x < this.areaMargin + this.arrowPadding) {
            this.outOfBounds = true;
          }
          if (this.template && location2.y < 0) {
            location2.y = symbolLocation.y + clipY + markerHeight;
          }
          if (!withInAreaBounds(location2.x, location2.y, bounds) || this.outOfBounds) {
            this.inverted = !this.inverted;
            this.revert = true;
            location2 = new TooltipLocation(symbolLocation.x + markerHeight + clipX, symbolLocation.y + clipY - this.elementSize.height / 2 - this.padding);
            tipLocation.x = arrowLocation.x = 0;
            tipLocation.y = arrowLocation.y = height / 2;
            if (location2.x + this.arrowPadding + width > boundsX + bounds.width || this.isNegative) {
              location2.x = (symbolLocation.x > boundsX + bounds.width ? bounds.width : symbolLocation.x) + clipX - markerHeight - (this.arrowPadding + width);
            }
            if (location2.x < boundsX) {
              location2.x = (symbolLocation.x < 0 ? 0 : symbolLocation.x) + markerHeight + clipX;
            }
            if (location2.y <= boundsY) {
              tipLocation.y -= boundsY - location2.y;
              arrowLocation.y -= boundsY - location2.y;
              location2.y = boundsY;
            }
            if (location2.y + height >= bounds.height + boundsY) {
              arrowLocation.y += location2.y + height - (bounds.height + boundsY);
              tipLocation.y += location2.y + height - (bounds.height + boundsY);
              location2.y -= location2.y + height - (bounds.height + boundsY);
            }
            if (this.arrowPadding + arrowLocation.y > height - this.ry) {
              arrowLocation.y = height - this.arrowPadding - this.ry;
              tipLocation.y = height;
            }
            if (arrowLocation.y - this.arrowPadding < this.ry) {
              arrowLocation.y = this.arrowPadding + this.ry;
              tipLocation.y = 0;
            }
          }
        }
      } else {
        location2 = new TooltipLocation(location2.x + clipX + markerHeight, location2.y + clipY - this.elementSize.height / 2 - this.padding);
        arrowLocation.y = tipLocation.y = height / 2;
        if (location2.x + width + this.arrowPadding > boundsX + bounds.width || this.isNegative) {
          location2.x = (symbolLocation.x > bounds.width + bounds.x ? bounds.width : symbolLocation.x) + clipX - markerHeight - (width + this.arrowPadding);
        }
        if (location2.x < boundsX) {
          location2.x = (symbolLocation.x < 0 ? 0 : symbolLocation.x) + clipX + markerHeight;
        }
        if (location2.x + width + this.arrowPadding > boundsX + bounds.width) {
          location2.x = (symbolLocation.x > bounds.width + bounds.x ? bounds.width : symbolLocation.x) + clipX - markerHeight - (width + this.arrowPadding);
        }
        if (location2.y <= boundsY) {
          arrowLocation.y -= boundsY - location2.y;
          tipLocation.y -= boundsY - location2.y;
          location2.y = boundsY;
        }
        if (location2.y + height >= boundsY + bounds.height) {
          arrowLocation.y += location2.y + height - (boundsY + bounds.height);
          tipLocation.y += location2.y + height - (boundsY + bounds.height);
          location2.y -= location2.y + height - (boundsY + bounds.height);
        }
        if (arrowLocation.y + this.arrowPadding > height - this.ry) {
          arrowLocation.y = height - this.ry - this.arrowPadding;
          tipLocation.y = height;
        }
        if (arrowLocation.y - this.arrowPadding < this.ry) {
          arrowLocation.y = tipLocation.y = this.ry + this.arrowPadding;
        }
        if (this.controlName === "Chart") {
          if (location2.y + arrowLocation.y < this.areaMargin + this.arrowPadding || bounds.y + bounds.height - (location2.y + arrowLocation.y) < this.areaMargin + this.arrowPadding) {
            this.outOfBounds = true;
          }
          if (!withInAreaBounds(location2.x, location2.y, bounds) || this.outOfBounds) {
            this.inverted = !this.inverted;
            location2 = new TooltipLocation(symbolLocation.x + clipX - this.padding - this.elementSize.width / 2, symbolLocation.y + clipY - this.elementSize.height - 2 * this.padding - markerHeight - this.arrowPadding);
            this.revert = true;
            tipLocation.x = arrowLocation.x = width / 2;
            tipLocation.y = arrowLocation.y = 0;
            if (location2.y < boundsY || this.isNegative) {
              location2.y = (symbolLocation.y < 0 ? 0 : symbolLocation.y) + markerHeight + clipY;
            }
            if (location2.y + this.arrowPadding + height > boundsY + bounds.height) {
              location2.y = Math.min(symbolLocation.y, boundsY + bounds.height) + clipY - this.elementSize.height - 2 * this.padding - markerHeight - this.arrowPadding;
            }
            tipLocation.x = width / 2;
            if (location2.x < boundsX) {
              tipLocation.x -= boundsX - location2.x;
              arrowLocation.x -= boundsX - location2.x;
              location2.x = boundsX;
            }
            if (location2.x + width > bounds.width + boundsX) {
              arrowLocation.x += location2.x + width - (bounds.width + boundsX);
              tipLocation.x += location2.x + width - (bounds.width + boundsX);
              location2.x -= location2.x + width - (bounds.width + boundsX);
            }
            if (this.arrowPadding + arrowLocation.x > width - this.rx) {
              tipLocation.x = width - this.rx - this.arrowPadding;
              arrowLocation.x = width - this.rx - this.arrowPadding;
            }
            if (arrowLocation.x - this.arrowPadding < this.rx) {
              arrowLocation.x = tipLocation.x = this.rx + this.arrowPadding;
            }
          }
        }
      }
      return new Rect(location2.x, location2.y, width, height);
    };
    Tooltip2.prototype.animateTooltipDiv = function(tooltipDiv, rect) {
      var _this = this;
      var x = parseFloat(tooltipDiv.style.left);
      var y = parseFloat(tooltipDiv.style.top);
      var duration = this.duration === 0 && animationMode === "Enable" ? 300 : this.duration;
      if (this.controlName === "Chart" && this.shared && !this.enableRTL) {
        var transformValues = this.element.style.transform.split(/[(),\s]+/);
        x = parseFloat(transformValues[1]);
        y = parseFloat(transformValues[2]);
        tooltipDiv.style.transition = "transform " + duration + "ms ease";
      }
      var currenDiff;
      new Animation({}).animate(tooltipDiv, {
        duration,
        progress: function(args) {
          currenDiff = args.timeStamp / args.duration;
          tooltipDiv.style.animation = null;
          if (_this.controlName === "Chart" && _this.shared && !_this.enableRTL) {
            tooltipDiv.style.transform = "translate(" + (x + (rect.x - x)) + "px," + (y + rect.y - y) + "px)";
            tooltipDiv.style.left = "";
            tooltipDiv.style.top = "";
          } else if (_this.controlName === "Chart" && _this.showNearestTooltip) {
            tooltipDiv.style.transition = "left " + args.duration + "ms ease-out, top " + args.duration + "ms ease-out";
            tooltipDiv.style.left = rect.x + "px";
            tooltipDiv.style.top = rect.y + "px";
          } else {
            tooltipDiv.style.left = x + currenDiff * (rect.x - x) + "px";
            tooltipDiv.style.top = y + currenDiff * (rect.y - y) + "px";
            tooltipDiv.style.transform = _this.controlName === "RangeNavigator" ? tooltipDiv.style.transform : "";
          }
        },
        end: function(model) {
          _this.updateDiv(tooltipDiv, rect.x, rect.y);
          _this.trigger("animationComplete", { tooltip: _this });
        }
      });
    };
    Tooltip2.prototype.updateDiv = function(tooltipDiv, x, y) {
      if (this.controlName === "Chart" && this.shared && !this.crosshair && !this.enableRTL) {
        tooltipDiv.style.transform = "translate(" + x + "px," + y + "px)";
        tooltipDiv.style.left = "";
        tooltipDiv.style.top = "";
      } else {
        tooltipDiv.style.left = x + "px";
        tooltipDiv.style.top = y + "px";
        tooltipDiv.style.transform = this.controlName === "RangeNavigator" ? tooltipDiv.style.transform : "";
      }
    };
    Tooltip2.prototype.updateTemplateFn = function() {
      if (this.template) {
        try {
          if (typeof this.template !== "function" && document.querySelectorAll(this.template).length) {
            this.templateFn = compile2(document.querySelector(this.template).innerHTML.trim());
          } else {
            this.templateFn = compile2(this.template);
          }
        } catch (e) {
          this.templateFn = compile2(this.template);
        }
      }
    };
    Tooltip2.prototype.fadeOut = function() {
      var _this = this;
      var tooltipElement = this.isCanvas && !this.template ? getElement(this.element.id + "_svg") : getElement(this.element.id);
      var tooltipDiv = getElement(this.element.id);
      if (tooltipElement) {
        var tooltipGroup_1 = tooltipElement.firstChild;
        if (tooltipGroup_1.nodeType !== Node.ELEMENT_NODE) {
          tooltipGroup_1 = tooltipElement.firstElementChild;
        }
        if (this.isCanvas && !this.template) {
          tooltipGroup_1 = document.getElementById(this.element.id + "_group") ? document.getElementById(this.element.id + "_group") : tooltipGroup_1;
        }
        if (!tooltipGroup_1) {
          return null;
        }
        var opacity_1 = parseFloat(tooltipGroup_1.getAttribute("opacity"));
        opacity_1 = !isNullOrUndefined(opacity_1) ? opacity_1 : 1;
        new Animation({}).animate(tooltipGroup_1, {
          duration: 200,
          progress: function(args) {
            _this.progressAnimation(tooltipGroup_1, opacity_1, args.timeStamp / args.duration);
          },
          end: function() {
            _this.fadeOuted = true;
            _this.endAnimation(tooltipGroup_1);
            tooltipDiv.style.transition = "";
          }
        });
      }
    };
    Tooltip2.prototype.progressAnimation = function(tooltipGroup, opacity, timeStamp) {
      tooltipGroup.style.animation = "";
      tooltipGroup.setAttribute("opacity", (opacity - timeStamp).toString());
    };
    Tooltip2.prototype.endAnimation = function(tooltipGroup) {
      tooltipGroup.setAttribute("opacity", "0");
      if (this.template) {
        tooltipGroup.style.display = "none";
      }
      this.trigger("animationComplete", { tooltip: this });
    };
    Tooltip2.prototype.getPersistData = function() {
      var keyEntity = [];
      return this.addOnPersist(keyEntity);
    };
    Tooltip2.prototype.getModuleName = function() {
      return "tooltip";
    };
    Tooltip2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.element.classList.remove("e-tooltip");
    };
    Tooltip2.prototype.onPropertyChanged = function(newProp, oldProp) {
      if (this.blazorTemplate) {
        resetBlazorTemplate(this.element.id + "parent_template_blazorTemplate");
      }
      this.isFirst = false;
      this.render();
    };
    __decorate7([
      Property(false)
    ], Tooltip2.prototype, "enable", void 0);
    __decorate7([
      Property(false)
    ], Tooltip2.prototype, "shared", void 0);
    __decorate7([
      Property(false)
    ], Tooltip2.prototype, "crosshair", void 0);
    __decorate7([
      Property(false)
    ], Tooltip2.prototype, "enableShadow", void 0);
    __decorate7([
      Property(null)
    ], Tooltip2.prototype, "fill", void 0);
    __decorate7([
      Property("")
    ], Tooltip2.prototype, "header", void 0);
    __decorate7([
      Property(0.75)
    ], Tooltip2.prototype, "opacity", void 0);
    __decorate7([
      Complex({ size: "12px", fontWeight: null, color: null, fontStyle: "Normal", fontFamily: null }, TextStyle)
    ], Tooltip2.prototype, "textStyle", void 0);
    __decorate7([
      Property(null)
    ], Tooltip2.prototype, "template", void 0);
    __decorate7([
      Property(true)
    ], Tooltip2.prototype, "enableAnimation", void 0);
    __decorate7([
      Property(300)
    ], Tooltip2.prototype, "duration", void 0);
    __decorate7([
      Property(false)
    ], Tooltip2.prototype, "inverted", void 0);
    __decorate7([
      Property(false)
    ], Tooltip2.prototype, "isNegative", void 0);
    __decorate7([
      Complex({ color: null, width: null }, TooltipBorder)
    ], Tooltip2.prototype, "border", void 0);
    __decorate7([
      Property([])
    ], Tooltip2.prototype, "content", void 0);
    __decorate7([
      Property(10)
    ], Tooltip2.prototype, "markerSize", void 0);
    __decorate7([
      Complex({ x: 0, y: 0 }, ToolLocation)
    ], Tooltip2.prototype, "clipBounds", void 0);
    __decorate7([
      Property([])
    ], Tooltip2.prototype, "palette", void 0);
    __decorate7([
      Property([])
    ], Tooltip2.prototype, "shapes", void 0);
    __decorate7([
      Complex({ x: 0, y: 0 }, ToolLocation)
    ], Tooltip2.prototype, "location", void 0);
    __decorate7([
      Property(0)
    ], Tooltip2.prototype, "offset", void 0);
    __decorate7([
      Property(4)
    ], Tooltip2.prototype, "rx", void 0);
    __decorate7([
      Property(4)
    ], Tooltip2.prototype, "ry", void 0);
    __decorate7([
      Property(5)
    ], Tooltip2.prototype, "marginX", void 0);
    __decorate7([
      Property(5)
    ], Tooltip2.prototype, "marginY", void 0);
    __decorate7([
      Property(7)
    ], Tooltip2.prototype, "arrowPadding", void 0);
    __decorate7([
      Property(null)
    ], Tooltip2.prototype, "data", void 0);
    __decorate7([
      Property("Material")
    ], Tooltip2.prototype, "theme", void 0);
    __decorate7([
      Complex({ x: 0, y: 0, width: 0, height: 0 }, AreaBounds)
    ], Tooltip2.prototype, "areaBounds", void 0);
    __decorate7([
      Property(null)
    ], Tooltip2.prototype, "availableSize", void 0);
    __decorate7([
      Property()
    ], Tooltip2.prototype, "blazorTemplate", void 0);
    __decorate7([
      Property(false)
    ], Tooltip2.prototype, "isCanvas", void 0);
    __decorate7([
      Property(false)
    ], Tooltip2.prototype, "isTextWrap", void 0);
    __decorate7([
      Property(false)
    ], Tooltip2.prototype, "isFixed", void 0);
    __decorate7([
      Property(null)
    ], Tooltip2.prototype, "tooltipPlacement", void 0);
    __decorate7([
      Property(null)
    ], Tooltip2.prototype, "controlInstance", void 0);
    __decorate7([
      Property("")
    ], Tooltip2.prototype, "controlName", void 0);
    __decorate7([
      Property(false)
    ], Tooltip2.prototype, "showNearestTooltip", void 0);
    __decorate7([
      Event2()
    ], Tooltip2.prototype, "tooltipRender", void 0);
    __decorate7([
      Event2()
    ], Tooltip2.prototype, "loaded", void 0);
    __decorate7([
      Event2()
    ], Tooltip2.prototype, "animationComplete", void 0);
    __decorate7([
      Property(false)
    ], Tooltip2.prototype, "enableRTL", void 0);
    __decorate7([
      Property(false)
    ], Tooltip2.prototype, "allowHighlight", void 0);
    __decorate7([
      Property(true)
    ], Tooltip2.prototype, "showHeaderLine", void 0);
    Tooltip2 = __decorate7([
      NotifyPropertyChanges
    ], Tooltip2);
    return Tooltip2;
  })(Component)
);

// node_modules/@syncfusion/ej2-maps/src/maps/utils/helper.js
var __extends19 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var Size2 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Size3(width, height) {
      this.width = width;
      this.height = height;
    }
    return Size3;
  })()
);
function stringToNumber(value, containerSize) {
  if (typeof value !== "string") {
    return value;
  }
  if (!isNullOrUndefined(value)) {
    return value.indexOf("%") !== -1 ? containerSize / 100 * parseInt(value, 10) : parseInt(value, 10);
  }
  return null;
}
function calculateSize(maps) {
  maps.element.style.height = !isNullOrUndefined(maps.height) ? maps.height : "auto";
  maps.element.style.width = !isNullOrUndefined(maps.width) ? maps.width : "auto";
  maps.element.style.setProperty("display", "block");
  var containerWidth = maps.element.clientWidth;
  var containerHeight = maps.element.clientHeight;
  var containerElementWidth = typeof maps.element.style.width === "string" ? stringToNumber(maps.element.style.width, containerWidth) : maps.element.style.width;
  var containerElementHeight = typeof maps.element.style.height === "string" ? stringToNumber(maps.element.style.height, containerHeight) : maps.element.style.height;
  var availableSize = new Size2(0, 0);
  if (maps.width === "0px" || maps.width === "0%" || maps.height === "0%" || maps.height === "0px") {
    availableSize = new Size2(0, 0);
  } else {
    availableSize = new Size2(stringToNumber(maps.width, containerWidth) || containerWidth || containerElementWidth || 600, stringToNumber(maps.height, containerHeight) || containerHeight || containerElementHeight || (maps.isDevice ? Math.min(window.innerWidth, window.innerHeight) : 450));
  }
  return availableSize;
}
function createSvg(maps) {
  maps.renderer = new SvgRenderer(maps.element.id);
  maps.availableSize = calculateSize(maps);
  maps.svgObject = maps.renderer.createSvg({
    id: maps.element.id + "_svg",
    width: maps.availableSize.width,
    height: maps.availableSize.height
  });
  if (maps.width === "0px" || maps.width === "0%" || maps.height === "0%" || maps.height === "0px") {
    maps.svgObject.setAttribute("height", "0");
    maps.svgObject.setAttribute("width", "0");
  }
}
function getMousePosition(pageX, pageY, element) {
  var elementRect = element.getBoundingClientRect();
  var pageXOffset = element.ownerDocument.defaultView.pageXOffset;
  var pageYOffset = element.ownerDocument.defaultView.pageYOffset;
  var clientTop = element.ownerDocument.documentElement.clientTop;
  var clientLeft = element.ownerDocument.documentElement.clientLeft;
  var positionX = elementRect.left + pageXOffset - clientLeft;
  var positionY = elementRect.top + pageYOffset - clientTop;
  return new MapLocation(pageX - positionX, pageY - positionY);
}
function degreesToRadians(deg) {
  return deg * (Math.PI / 180);
}
function radiansToDegrees(radian) {
  return radian * (180 / Math.PI);
}
function convertGeoToPoint(latitude, longitude, factor, layer, mapModel) {
  var mapSize = new Size2(mapModel.mapAreaRect.width, mapModel.mapAreaRect.height);
  var x;
  var y;
  var value;
  var lat;
  var lng;
  var temp;
  var longitudeMinMax = mapModel.baseMapBounds.longitude;
  var latitudeMinMax = mapModel.baseMapBounds.latitude;
  var latRadian = degreesToRadians(latitude);
  var lngRadian = degreesToRadians(longitude);
  var type = !isNullOrUndefined(mapModel.projectionType) ? mapModel.projectionType : "Mercator";
  var size = mapModel.isTileMap ? Math.pow(2, 1) * 256 : isNullOrUndefined(factor) ? Math.min(mapSize.width, mapSize.height) : Math.min(mapSize.width, mapSize.height) * factor;
  if (layer.geometryType === "Normal") {
    x = isNullOrUndefined(factor) ? longitude : Math.abs((longitude - longitudeMinMax.min) * factor);
    y = isNullOrUndefined(factor) ? latitude : Math.abs((latitudeMinMax.max - latitude) * factor);
  } else if (layer.geometryType === "Geographic") {
    switch (type) {
      case "Mercator": {
        var pixelOrigin = new Point(size / 2, size / 2);
        x = pixelOrigin.x + longitude * (size / 360);
        var sinY = calculateBound(Math.sin(degreesToRadians(latitude)), -0.9999, 0.9999);
        y = pixelOrigin.y + 0.5 * Math.log((1 + sinY) / (1 - sinY)) * -(size / (2 * Math.PI));
        break;
      }
      case "Winkel3":
        value = aitoff(lngRadian, latRadian);
        lng = (value.x + lngRadian / (Math.PI / 2)) / 2;
        lat = (value.y + latRadian) / 2;
        break;
      case "Miller":
        lng = lngRadian;
        lat = 1.25 * Math.log(Math.tan(Math.PI / 4 + 0.4 * latRadian));
        break;
      case "Eckert3":
        temp = Math.sqrt(Math.PI * (4 + Math.PI));
        lng = 2 / temp * lngRadian * (1 + Math.sqrt(1 - 4 * latRadian * latRadian / (Math.PI * Math.PI)));
        lat = 4 / temp * latRadian;
        break;
      case "AitOff":
        value = aitoff(lngRadian, latRadian);
        lng = value.x;
        lat = value.y;
        break;
      case "Eckert5":
        lng = lngRadian * (1 + Math.cos(latRadian)) / Math.sqrt(2 + Math.PI);
        lat = 2 * latRadian / Math.sqrt(2 + Math.PI);
        break;
      case "Equirectangular":
        lng = lngRadian;
        lat = latRadian;
        break;
      case "Eckert6": {
        var epsilon = 1e-6;
        temp = (1 + Math.PI / 2) * Math.sin(latRadian);
        var delta = Infinity;
        for (var i = 0; i < 10 && Math.abs(delta) > epsilon; i++) {
          delta = (latRadian + Math.sin(latRadian) - temp) / (1 + Math.cos(latRadian));
          latRadian = latRadian - delta;
        }
        temp = Math.sqrt(2 + Math.PI);
        lng = lngRadian * (1 + Math.cos(latRadian)) / temp;
        lat = 2 * latRadian / temp;
        break;
      }
    }
    x = type === "Mercator" ? x : roundTo(xToCoordinate(mapModel, radiansToDegrees(lng)), 3);
    y = type === "Mercator" ? y : -roundTo(yToCoordinate(mapModel, radiansToDegrees(lat)), 3);
  }
  return new Point(x, y);
}
function calculatePolygonPath(maps, factor, currentLayer, markerData) {
  var path = "";
  if (!isNullOrUndefined(markerData) && markerData.length > 1) {
    Array.prototype.forEach.call(markerData, function(data, dataIndex) {
      var lat = data.latitude;
      var lng = data.longitude;
      var location2 = maps.isTileMap ? convertTileLatLongToPoint(new MapLocation(lng, lat), factor, maps.tileTranslatePoint, true) : convertGeoToPoint(lat, lng, factor, currentLayer, maps);
      if (dataIndex === 0) {
        path += "M " + location2.x + " " + location2.y;
      } else {
        path += " L " + location2.x + " " + location2.y;
      }
    });
    path += " z ";
  }
  return path;
}
function convertTileLatLongToPoint(center, zoomLevel, tileTranslatePoint, isMapCoordinates) {
  var size = Math.pow(2, zoomLevel) * 256;
  var x = (center.x + 180) / 360;
  var sinLatitude = Math.sin(center.y * Math.PI / 180);
  var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
  var pixelX = center.x;
  var pixelY = center.y;
  if (isMapCoordinates) {
    pixelX = x * size + 0.5 + tileTranslatePoint.x;
    pixelY = y * size + 0.5 + tileTranslatePoint.y;
  }
  return { x: pixelX, y: pixelY };
}
function xToCoordinate(mapObject, val) {
  var longitudeMinMax = mapObject.baseMapBounds.longitude;
  var totalSize = isNullOrUndefined(mapObject.baseSize) ? mapObject.mapAreaRect.width : mapObject.mapAreaRect.width + Math.abs(mapObject.baseSize.width - mapObject.mapAreaRect.width) / 2;
  return Math.round(totalSize * (val - longitudeMinMax.min) / (longitudeMinMax.max - longitudeMinMax.min) * 100) / 100;
}
function yToCoordinate(mapObject, val) {
  var latitudeMinMax = mapObject.baseMapBounds.latitude;
  return Math.round(mapObject.mapAreaRect.height * (val - latitudeMinMax.min) / (latitudeMinMax.max - latitudeMinMax.min) * 100) / 100;
}
function aitoff(x, y) {
  var cosy = Math.cos(y);
  var sincia = sinci(acos(cosy * Math.cos(x /= 2)));
  return new Point(2 * cosy * Math.sin(x) * sincia, Math.sin(y) * sincia);
}
function roundTo(a, b) {
  var c = Math.pow(10, b);
  return Math.round(a * c) / c;
}
function sinci(x) {
  return x / Math.sin(x);
}
function acos(a) {
  return Math.acos(a);
}
function calculateBound(value, min, max) {
  if (!isNullOrUndefined(min)) {
    value = Math.max(value, min);
  }
  if (!isNullOrUndefined(max)) {
    value = Math.min(value, max);
  }
  return value;
}
function triggerDownload(fileName, type, url, isDownload) {
  createElement("a", {
    attrs: {
      "download": fileName + "." + type.toLocaleLowerCase(),
      "href": url
    }
  }).dispatchEvent(new MouseEvent(isDownload ? "click" : "move", {
    view: window,
    bubbles: false,
    cancelable: true
  }));
}
var Point = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Point2(x, y) {
      this.x = x;
      this.y = y;
    }
    return Point2;
  })()
);
var RelativePoint = (
  /** @class */
  /* @__PURE__ */ (function() {
    function RelativePoint2(x, y) {
      this.x = x;
      this.y = y;
    }
    return RelativePoint2;
  })()
);
var Coordinate = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Coordinate2(latitude, longitude) {
      this.latitude = latitude;
      this.longitude = longitude;
    }
    return Coordinate2;
  })()
);
var MinMax = (
  /** @class */
  /* @__PURE__ */ (function() {
    function MinMax2(min, max) {
      this.min = min;
      this.max = max;
    }
    return MinMax2;
  })()
);
var GeoLocation = (
  /** @class */
  /* @__PURE__ */ (function() {
    function GeoLocation2(latitude, longitude) {
      this.latitude = new MinMax(latitude.min, latitude.max);
      this.longitude = new MinMax(longitude.min, longitude.max);
    }
    return GeoLocation2;
  })()
);
function measureText2(text, font) {
  var measureObject = document.getElementById("mapsmeasuretext");
  if (measureObject === null) {
    measureObject = document.createElement("text");
    measureObject.id = "mapsmeasuretext";
    document.body.appendChild(measureObject);
  }
  measureObject.innerText = text;
  measureObject.style.cssText = "position: absolute; font-size: " + (typeof font.size === "number" ? font.size + "px" : font.size) + "; font-weight: " + font.fontWeight + "; font-style: " + font.fontStyle + "; font-family: " + font.fontFamily + "; visibility: hidden; top: -100; left: 0; whiteSpace: nowrap; lineHeight: normal";
  return new Size2(measureObject.clientWidth, measureObject.clientHeight);
}
function measureTextElement(text, font) {
  var canvas = document.createElement("canvas");
  var context = canvas.getContext("2d");
  context.font = font.fontStyle + " " + font.fontWeight + " " + (typeof font.size === "number" ? font.size + "px" : font.size) + " " + font.fontFamily;
  var metrics = context.measureText(text);
  var width = metrics.width;
  var height = parseFloat(font.size) || 16;
  canvas = null;
  return new Size2(width, height);
}
var TextOption2 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TextOption3(id, x, y, anchor, text, transform, baseLine) {
      if (transform === void 0) {
        transform = "";
      }
      this.transform = "";
      this.baseLine = "auto";
      this.id = id;
      this.text = text;
      this.transform = transform;
      this.anchor = anchor;
      this.x = x;
      this.y = y;
      this.baseLine = baseLine;
    }
    return TextOption3;
  })()
);
var PathOption2 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function PathOption3(id, fill, width, color, fillOpacity, strokeOpacity, dashArray, d) {
      this.id = id;
      this["fill-opacity"] = fillOpacity;
      this["stroke-opacity"] = strokeOpacity;
      this.fill = fill;
      this.stroke = color;
      this["stroke-width"] = width;
      this["stroke-dasharray"] = dashArray;
      this.d = d;
    }
    return PathOption3;
  })()
);
var ColorValue = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ColorValue2(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
    }
    return ColorValue2;
  })()
);
var RectOption = (
  /** @class */
  (function(_super) {
    __extends19(RectOption2, _super);
    function RectOption2(id, fill, border, fillOpacity, rect, rx, ry, transform, dashArray) {
      var _this = _super.call(this, id, fill, border.width, border.color, fillOpacity, border.opacity) || this;
      _this.y = rect.y;
      _this.x = rect.x;
      _this.height = rect.height;
      _this.width = rect.width;
      _this.rx = rx ? rx : 0;
      _this.ry = ry ? ry : 0;
      _this.transform = transform ? transform : "";
      _this["stroke-dasharray"] = dashArray;
      _this["fill-opacity"] = fillOpacity;
      _this["stroke-opacity"] = border.opacity;
      return _this;
    }
    return RectOption2;
  })(PathOption2)
);
var CircleOption = (
  /** @class */
  (function(_super) {
    __extends19(CircleOption2, _super);
    function CircleOption2(id, fill, border, fillOpacity, cx, cy, r, dashArray) {
      var _this = _super.call(this, id, fill, border.width, border.color, fillOpacity, border.opacity, dashArray) || this;
      _this.cy = cy;
      _this.cx = cx;
      _this.r = r;
      _this["stroke-dasharray"] = dashArray;
      _this["fill-opacity"] = fillOpacity;
      _this["stroke-opacity"] = border.opacity;
      return _this;
    }
    return CircleOption2;
  })(PathOption2)
);
var PolygonOption = (
  /** @class */
  (function(_super) {
    __extends19(PolygonOption2, _super);
    function PolygonOption2(id, points, fill, width, color, fillOpacity, strokeOpacity, dashArray) {
      if (fillOpacity === void 0) {
        fillOpacity = 1;
      }
      if (strokeOpacity === void 0) {
        strokeOpacity = 1;
      }
      if (dashArray === void 0) {
        dashArray = "";
      }
      var _this = _super.call(this, id, fill, width, color, fillOpacity, strokeOpacity, dashArray) || this;
      _this.points = points;
      return _this;
    }
    return PolygonOption2;
  })(PathOption2)
);
var PolylineOption = (
  /** @class */
  (function(_super) {
    __extends19(PolylineOption2, _super);
    function PolylineOption2(id, points, fill, width, color, fillOpacity, strokeOpacity, dashArray) {
      if (fillOpacity === void 0) {
        fillOpacity = 1;
      }
      if (strokeOpacity === void 0) {
        strokeOpacity = 1;
      }
      if (dashArray === void 0) {
        dashArray = "";
      }
      return _super.call(this, id, points, fill, width, color, fillOpacity, strokeOpacity, dashArray) || this;
    }
    return PolylineOption2;
  })(PolygonOption)
);
var LineOption = (
  /** @class */
  (function(_super) {
    __extends19(LineOption2, _super);
    function LineOption2(id, line, fill, width, color, fillOpacity, strokeOpacity, dashArray) {
      if (fillOpacity === void 0) {
        fillOpacity = 1;
      }
      if (strokeOpacity === void 0) {
        strokeOpacity = 1;
      }
      if (dashArray === void 0) {
        dashArray = "";
      }
      var _this = _super.call(this, id, fill, width, color, fillOpacity, strokeOpacity, dashArray) || this;
      _this.x1 = line.x1;
      _this.y1 = line.y1;
      _this.x2 = line.x2;
      _this.y2 = line.y2;
      return _this;
    }
    return LineOption2;
  })(PathOption2)
);
var Line = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Line2(x1, y1, x2, y2) {
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
    }
    return Line2;
  })()
);
var MapLocation = (
  /** @class */
  /* @__PURE__ */ (function() {
    function MapLocation2(x, y) {
      this.x = x;
      this.y = y;
    }
    return MapLocation2;
  })()
);
var Rect2 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Rect3(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    return Rect3;
  })()
);
var PatternOptions = (
  /** @class */
  /* @__PURE__ */ (function() {
    function PatternOptions2(id, x, y, width, height, patternUnits, patternContentUnits, patternTransform, href) {
      if (patternUnits === void 0) {
        patternUnits = "userSpaceOnUse";
      }
      if (patternContentUnits === void 0) {
        patternContentUnits = "userSpaceOnUse";
      }
      if (patternTransform === void 0) {
        patternTransform = "";
      }
      if (href === void 0) {
        href = "";
      }
      this.id = id;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.patternUnits = patternUnits;
      this.patternContentUnits = patternContentUnits;
      this.patternTransform = patternTransform;
      this.href = href;
    }
    return PatternOptions2;
  })()
);
function renderTextElement(option, style, color, parent, isMinus) {
  if (isMinus === void 0) {
    isMinus = false;
  }
  var renderOptions = {
    "id": option.id,
    "x": option.x,
    "y": option.y,
    "fill": color,
    "font-size": style.size,
    "font-style": style.fontStyle,
    "font-family": style.fontFamily,
    "font-weight": style.fontWeight,
    "text-anchor": option.anchor,
    "transform": option.transform,
    "opacity": style.opacity,
    "dominant-baseline": option.baseLine
  };
  var text = typeof option.text === "string" || typeof option.text === "number" ? option.text : isMinus ? option.text[option.text.length - 1] : option.text[0];
  var tspanElement;
  var renderer = new SvgRenderer("");
  var height;
  var htmlObject = renderer.createText(renderOptions, text);
  htmlObject.style["user-select"] = "none";
  htmlObject.style["font-family"] = style.fontFamily;
  htmlObject.style["font-size"] = style.size;
  htmlObject.style["font-weight"] = style.fontWeight;
  htmlObject.style["font-color"] = style.color;
  htmlObject.style["-moz-user-select"] = "none";
  htmlObject.style["-webkit-touch-callout"] = "none";
  htmlObject.style["-webkit-user-select"] = "none";
  htmlObject.style["-khtml-user-select"] = "none";
  htmlObject.style["-ms-user-select"] = "none";
  htmlObject.style["-o-user-select"] = "none";
  if (typeof option.text !== "string" && option.text.length > 1) {
    for (var i = 1, len = option.text.length; i < len; i++) {
      height = measureText2(option.text[i], style).height;
      tspanElement = renderer.createTSpan({
        "x": option.x,
        "id": option.id,
        "y": option.y + (isMinus ? -(i * height) : i * height)
      }, isMinus ? option.text[option.text.length - (i + 1)] : option.text[i]);
      htmlObject.appendChild(tspanElement);
    }
  }
  parent.appendChild(htmlObject);
  return htmlObject;
}
function convertElement(element, markerId, data, index, mapObj, templateType) {
  var childElement = createElement("div", {
    id: markerId,
    className: mapObj.element.id + "_marker_template_element"
  });
  childElement.style.cssText = "position: absolute;pointer-events: auto;";
  var elementLength = element.length;
  while (elementLength > 0) {
    childElement.appendChild(element[0]);
    elementLength--;
  }
  if (!mapObj.isReact || templateType !== "function") {
    var templateHtml = childElement.innerHTML;
    var properties = Object.keys(data);
    var regExp3 = RegExp;
    for (var i = 0; i < properties.length; i++) {
      if (typeof data[properties[i]] === "object") {
        templateHtml = convertStringToValue(templateHtml, "", data, mapObj);
      } else if (properties[i].toLowerCase() !== "latitude" && properties[i].toLowerCase() !== "longitude") {
        templateHtml = templateHtml.replace(new regExp3("{{:" + properties[i] + "}}", "g"), data[properties[i].toString()]);
      }
    }
    childElement.innerHTML = templateHtml;
  }
  return childElement;
}
function formatValue(value, maps) {
  var formatValue2;
  var formatFunction;
  if (maps.format && !isNaN(Number(value))) {
    formatFunction = maps.intl.getNumberFormat({ format: maps.format, useGrouping: maps.useGroupingSeparator });
    formatValue2 = formatFunction(Number(value));
  } else {
    formatValue2 = value;
  }
  return formatValue2;
}
function convertStringToValue(stringTemplate, format, data, maps) {
  var templateHtml = stringTemplate === "" ? format : stringTemplate;
  var templateValue = stringTemplate === "" ? templateHtml.split("${") : templateHtml.split("{{:");
  var regExp3 = RegExp;
  for (var i = 0; i < templateValue.length; i++) {
    if (templateValue[i].indexOf("}}") > -1 && templateValue[i].indexOf(".") > -1 || templateValue[i].indexOf("}") > -1 && templateValue[i].search(".") > -1) {
      var split = stringTemplate === "" ? templateValue[i].split("}") : templateValue[i].split("}}");
      for (var j = 0; j < split.length; j++) {
        if (split[j].indexOf(".") > -1) {
          var templateSplitValue = getValueFromObject(data, split[j]).toString();
          templateHtml = stringTemplate === "" ? templateHtml.split("${" + split[j] + "}").join(formatValue(templateSplitValue, maps)) : templateHtml.replace(new regExp3("{{:" + split[j] + "}}", "g"), templateSplitValue);
        }
      }
    }
  }
  return templateHtml;
}
function convertElementFromLabel(element, labelId, data) {
  var labelEle = isNullOrUndefined(element.childElementCount) ? element[0] : element;
  var templateHtml = labelEle.outerHTML;
  var properties = Object.keys(data);
  var regExp3 = RegExp;
  for (var i = 0; i < properties.length; i++) {
    templateHtml = templateHtml.replace(new regExp3("{{:" + properties[i] + "}}", "g"), data[properties[i].toString()]);
  }
  var templateEle = createElement("div", {
    id: labelId,
    innerHTML: templateHtml
  });
  templateEle.style.position = "absolute";
  return templateEle;
}
function drawSymbols(shape, imageUrl, location2, markerID, shapeCustom, markerCollection, maps) {
  var markerEle;
  var x;
  var y;
  var size = shapeCustom["size"];
  var borderColor = shapeCustom["borderColor"];
  var borderWidth = parseFloat(shapeCustom["borderWidth"]);
  var borderOpacity = parseFloat(shapeCustom["borderOpacity"]);
  var fill = shapeCustom["fill"];
  var dashArray = shapeCustom["dashArray"];
  var border = { color: borderColor, width: borderWidth, opacity: borderOpacity };
  var opacity = shapeCustom["opacity"];
  var rectOptions;
  var pathOptions = new PathOption2(markerID, fill, borderWidth, borderColor, opacity, borderOpacity, dashArray, "");
  size.width = typeof size.width === "string" ? parseInt(size.width, 10) : size.width;
  size.height = typeof size.height === "string" ? parseInt(size.height, 10) : size.height;
  if (shape === "Circle") {
    var radius = (size.width + size.height) / 4;
    var circleOptions = new CircleOption(markerID, fill, border, opacity, location2.x, location2.y, radius, dashArray);
    markerEle = maps.renderer.drawCircle(circleOptions);
  } else if (shape === "Rectangle") {
    x = location2.x - size.width / 2;
    y = location2.y - size.height / 2;
    rectOptions = new RectOption(markerID, fill, border, opacity, new Rect2(x, y, size.width, size.height), null, null, "", dashArray);
    markerEle = maps.renderer.drawRectangle(rectOptions);
  } else if (shape === "Image") {
    x = location2.x - size.width / 2;
    y = location2.y - (markerID.indexOf("cluster") > -1 ? size.height / 2 : size.height);
    merge(pathOptions, { "href": imageUrl, "height": size.height, "width": size.width, x, y });
    markerEle = maps.renderer.drawImage(pathOptions);
  } else {
    markerEle = calculateShapes2(maps, shape, pathOptions, size, location2, markerCollection);
  }
  return markerEle;
}
function getValueFromObject(data, value) {
  if (!isNullOrUndefined(data) && !isNullOrUndefined(value)) {
    var splits = value.replace(/\[/g, ".").replace(/\]/g, "").split(".");
    if (splits.length === 1) {
      data = data[splits[0]];
    } else {
      for (var i = 0; i < splits.length && !isNullOrUndefined(data); i++) {
        data = data[splits[i]];
      }
    }
  }
  return data;
}
function markerColorChoose(eventArgs, data) {
  var color = !isNullOrUndefined(eventArgs.colorValuePath) ? eventArgs.colorValuePath.indexOf(".") > -1 ? getValueFromObject(data, eventArgs.colorValuePath).toString() : data[eventArgs.colorValuePath] : data[eventArgs.colorValuePath];
  eventArgs.fill = !isNullOrUndefined(eventArgs.colorValuePath) && !isNullOrUndefined(color) ? eventArgs.colorValuePath.indexOf(".") > -1 ? getValueFromObject(data, eventArgs.colorValuePath).toString() : data[eventArgs.colorValuePath] : eventArgs.fill;
  return eventArgs;
}
function markerShapeChoose(eventArgs, data) {
  if (!isNullOrUndefined(eventArgs.shapeValuePath) && !isNullOrUndefined(data[eventArgs.shapeValuePath])) {
    updateShape(eventArgs, data);
    if (data[eventArgs.shapeValuePath] === "Image") {
      updateImageUrl(eventArgs, data);
    }
  } else {
    updateShape(eventArgs, data);
    updateImageUrl(eventArgs, data);
  }
  return eventArgs;
}
function getValue2(path, data) {
  return path.indexOf(".") > -1 ? getValueFromObject(data, path).toString() : data[path];
}
function updateShape(eventArgs, data) {
  if (!isNullOrUndefined(eventArgs.shapeValuePath)) {
    var shape = getValue2(eventArgs.shapeValuePath, data);
    eventArgs.shape = !isNullOrUndefined(shape) && shape.toString() !== "" ? shape : eventArgs.shape;
  }
}
function updateImageUrl(eventArgs, data) {
  if (!isNullOrUndefined(eventArgs.imageUrlValuePath)) {
    var imageUrl = getValue2(eventArgs.imageUrlValuePath, data);
    eventArgs.imageUrl = !isNullOrUndefined(imageUrl) ? imageUrl : eventArgs.imageUrl;
  }
}
function clusterTemplate(currentLayer, markerTemplate2, maps, layerIndex, markerIndex, markerCollection, layerElement, check, zoomCheck, translatePoint, allowInnerClusterSetting) {
  var bounds1;
  var bounds2;
  var colloideBounds = [];
  var clusterColloideBounds = [];
  var tempX = 0;
  var tempY = 0;
  var data;
  var markerSetting = currentLayer.markerSettings[markerIndex];
  var options;
  var textElement2;
  var tempElement1;
  var shapeCustom;
  var tempElement;
  var postionY = 15 / 4;
  var m = 0;
  var indexCollection = [];
  var clusters = !allowInnerClusterSetting && currentLayer.markerClusterSettings.allowClustering ? currentLayer.markerClusterSettings : markerSetting.clusterSettings;
  var style = clusters.labelStyle;
  var clusterGroup = maps.renderer.createGroup({ id: maps.element.id + "_LayerIndex_" + layerIndex + "_markerCluster" });
  var eventArg = {
    cancel: false,
    name: markerClusterRendering,
    fill: clusters.fill,
    height: clusters.height,
    width: clusters.width,
    imageUrl: clusters.imageUrl,
    shape: clusters.shape,
    data,
    maps,
    cluster: clusters,
    border: clusters.border
  };
  var containerRect = maps.element.getBoundingClientRect();
  maps.isTileMap ? new Object() : getTranslate(maps, currentLayer, false);
  var factor;
  if (!maps.isTileMap) {
    factor = maps.mapLayerPanel.calculateFactor(currentLayer);
  }
  var isClusteringCompleted = false;
  var currentZoomFactor = !maps.isTileMap ? maps.mapScaleValue : maps.tileZoomLevel;
  var markerGroup = markerSetting.clusterSettings.allowClustering || currentLayer.markerClusterSettings.allowClustering && currentLayer.markerSettings.length > 1 ? markerTemplate2.querySelectorAll("[id*='LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex + "']:not([id*='_Group'])") : markerTemplate2.childNodes;
  maps.trigger("markerClusterRendering", eventArg, function(clusterargs) {
    Array.prototype.forEach.call(markerGroup, function(markerElement, o) {
      indexCollection = [];
      if (markerElement["style"]["visibility"] !== "hidden") {
        tempElement = markerElement;
        bounds1 = tempElement.getBoundingClientRect();
        indexCollection.push(o);
        if (!isNullOrUndefined(bounds1)) {
          var list = maps.markerModule.zoomedMarkerCluster.length > 0 && maps.markerModule.zoomedMarkerCluster[layerIndex] && maps.markerModule.zoomedMarkerCluster[layerIndex][o] && maps.markerModule.zoomedMarkerCluster[layerIndex][o].length > 0 || maps.markerModule.initialMarkerCluster.length > 0 && maps.markerModule.initialMarkerCluster[layerIndex] && maps.markerModule.initialMarkerCluster[layerIndex][o] && maps.markerModule.initialMarkerCluster[layerIndex][o].length > 0 ? maps.previousScale < currentZoomFactor ? maps.markerModule.zoomedMarkerCluster[layerIndex][o] : maps.markerModule.initialMarkerCluster[layerIndex][o] : null;
          if (!isNullOrUndefined(list) && list.length !== 0 && !markerSetting.clusterSettings.allowClustering) {
            Array.prototype.forEach.call(list, function(currentIndex) {
              if (o !== currentIndex) {
                var otherMarkerElement = document.getElementById(maps.element.id + "_LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex + "_dataIndex_" + currentIndex);
                if (otherMarkerElement && otherMarkerElement["style"]["visibility"] !== "hidden") {
                  markerBoundsComparer(otherMarkerElement, bounds1, colloideBounds, indexCollection, currentIndex);
                }
              }
            });
          } else {
            Array.prototype.forEach.call(markerGroup, function(otherMarkerElement, p) {
              if (p >= o + 1 && otherMarkerElement["style"]["visibility"] !== "hidden") {
                markerBoundsComparer(otherMarkerElement, bounds1, colloideBounds, indexCollection, p);
              }
            });
          }
          markerClusterListHandler(maps, currentZoomFactor, layerIndex, o, indexCollection);
          tempX = bounds1.left + bounds1.width / 2;
          tempY = bounds1.top + bounds1.height;
          if (colloideBounds.length > 0) {
            indexCollection = indexCollection.filter(function(item, index, value) {
              return value.indexOf(item) === index;
            });
            tempX = tempX - containerRect["left"];
            tempY = tempY - (maps.availableSize.height <= containerRect["height"] ? containerRect["top"] : containerRect["bottom"] - containerRect["top"]);
            var dataIndex = parseInt(markerElement["id"].split("_dataIndex_")[1].split("_")[0], 10);
            var markerIndex_1 = parseInt(markerElement["id"].split("_MarkerIndex_")[1].split("_")[0], 10);
            var markerSetting_1 = currentLayer.markerSettings[markerIndex_1];
            var markerData = markerSetting_1.dataSource[dataIndex];
            var location_1;
            var longitude = !isNullOrUndefined(markerSetting_1.longitudeValuePath) ? Number(getValueFromObject(markerData, markerSetting_1.longitudeValuePath)) : !isNullOrUndefined(markerData["longitude"]) ? parseFloat(markerData["longitude"]) : !isNullOrUndefined(markerData["Longitude"]) ? parseFloat(markerData["Longitude"]) : 0;
            var latitude = !isNullOrUndefined(markerSetting_1.latitudeValuePath) ? Number(getValueFromObject(markerData, markerSetting_1.latitudeValuePath)) : !isNullOrUndefined(markerData["latitude"]) ? parseFloat(markerData["latitude"]) : !isNullOrUndefined(markerData["Latitude"]) ? parseFloat(markerData["Latitude"]) : 0;
            if (!maps.isTileMap) {
              location_1 = convertGeoToPoint(latitude, longitude, factor, currentLayer, maps);
            } else if (maps.isTileMap) {
              location_1 = convertTileLatLongToPoint(new Point(longitude, latitude), maps.tileZoomLevel, maps.tileTranslatePoint, true);
            }
            markerElement["style"]["visibility"] = "hidden";
            if (eventArg.cancel) {
              shapeCustom = {
                size: new Size2(clusters.width, clusters.height),
                fill: clusters.fill,
                borderColor: clusters.border.color,
                borderWidth: clusters.border.width,
                opacity: clusters.opacity,
                dashArray: clusters.dashArray,
                imageUrl: clusters.imageUrl,
                shape: clusters.shape
              };
              shapeCustom["borderOpacity"] = isNullOrUndefined(clusters.border.opacity) ? clusters.opacity : clusters.border.opacity;
            } else {
              shapeCustom = {
                size: new Size2(eventArg.width, eventArg.height),
                fill: eventArg.fill,
                borderColor: eventArg.border.color,
                borderWidth: eventArg.border.width,
                opacity: clusters.opacity,
                dashArray: clusters.dashArray,
                imageUrl: eventArg.imageUrl,
                shape: eventArg.shape
              };
              shapeCustom["borderOpacity"] = isNullOrUndefined(eventArg.border.opacity) ? clusters.opacity : eventArg.border.opacity;
            }
            tempX = maps.isTileMap ? tempX : markerTemplate2.id.indexOf("_Markers_Group") > -1 ? tempX : tempX + postionY - eventArg.width / 2;
            tempY = maps.isTileMap ? tempY : markerTemplate2.id.indexOf("_Markers_Group") > -1 ? tempY : tempY - eventArg.height / 2;
            if (maps.isTileMap) {
              tempX = location_1.x;
              tempY = location_1.y;
            } else {
              tempX = (location_1.x + (!isNullOrUndefined(maps.translatePoint) && maps.translatePoint.x !== 0 && !maps.isResize ? maps.translatePoint.x : translatePoint.location.x)) * (isNullOrUndefined(maps.scale) ? translatePoint.scale : maps.scale) + markerSetting_1.offset.x;
              tempY = (location_1.y + (!isNullOrUndefined(maps.translatePoint) && maps.translatePoint.y !== 0 && !maps.isResize ? maps.translatePoint.y : translatePoint.location.y)) * (isNullOrUndefined(maps.scale) ? translatePoint.scale : maps.scale) + markerSetting_1.offset.y;
            }
            var clusterID = maps.element.id + "_LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex_1 + "_dataIndex_" + dataIndex + "_cluster_" + m;
            var labelID = maps.element.id + "_LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex_1 + "_dataIndex_" + dataIndex + "_cluster_" + m + "_datalabel_" + m;
            m++;
            var ele = drawSymbols(shapeCustom["shape"], shapeCustom["imageUrl"], { x: 0, y: 0 }, clusterID, shapeCustom, markerCollection, maps);
            ele.setAttribute("transform", "translate( " + tempX + " " + tempY + " )");
            if (eventArg.shape === "Balloon") {
              ele.children[0].textContent = indexCollection.toString();
            } else {
              ele.textContent = indexCollection.toString();
            }
            options = new TextOption2(labelID, 0, postionY, "middle", (colloideBounds.length + 1).toString(), "", "");
            textElement2 = renderTextElement(options, style, style.color, markerCollection);
            textElement2.setAttribute("transform", "translate( " + tempX + " " + tempY + " )");
            var eleMarkerIndex2 = parseFloat(ele.id.split("_MarkerIndex_")[1]);
            if (markerSetting_1.clusterSettings.allowClustering && eleMarkerIndex2 === markerIndex_1 || currentLayer.markerClusterSettings.allowClustering && currentLayer.markerSettings.length > 1 && eleMarkerIndex2 === markerIndex_1) {
              clusterGroup.appendChild(ele);
              clusterGroup.appendChild(textElement2);
            } else {
              clusterGroup.appendChild(textElement2);
              clusterGroup.appendChild(ele);
            }
          }
        }
        colloideBounds = [];
      } else {
        markerClusterListHandler(maps, currentZoomFactor, layerIndex, o, indexCollection);
      }
      isClusteringCompleted = true;
    });
    layerElement.appendChild(clusterGroup);
    maps.svgObject.appendChild(layerElement);
    maps.element.appendChild(maps.svgObject);
    if (clusters.allowDeepClustering && !allowInnerClusterSetting) {
      Array.prototype.forEach.call(clusterGroup.childNodes, function(clusterElement, o) {
        if (clusterElement["style"]["visibility"] !== "hidden") {
          tempElement = clusterElement;
          bounds1 = tempElement.getBoundingClientRect();
          if (!isNullOrUndefined(bounds1) && !(tempElement.id.indexOf("_datalabel_") > -1)) {
            for (var p = o + 1; p < clusterGroup.childElementCount; p++) {
              if (clusterGroup.childNodes[p]["style"]["visibility"] !== "hidden") {
                tempElement1 = clusterGroup.childNodes[p];
                bounds2 = tempElement1.getBoundingClientRect();
                if (!isNullOrUndefined(bounds2) && !(tempElement1.id.indexOf("_datalabel_") > -1)) {
                  if (!(bounds1.left > bounds2.right || bounds1.right < bounds2.left || bounds1.top > bounds2.bottom || bounds1.bottom < bounds2.top)) {
                    clusterColloideBounds.push(tempElement1);
                    clusterColloideBounds.push(clusterGroup.childNodes[p - 1]);
                    clusterGroup.childNodes[p]["style"]["visibility"] = "hidden";
                    var eleMarkerIndex2 = !isNullOrUndefined(clusterGroup.childNodes[p + 1]) ? parseFloat(clusterGroup.childNodes[p + 1].id.split("_MarkerIndex_")[1]) : null;
                    if (markerSetting.clusterSettings.allowClustering && eleMarkerIndex2 === markerIndex || currentLayer.markerClusterSettings.allowClustering && currentLayer.markerSettings.length > 1 && eleMarkerIndex2 === markerIndex) {
                      clusterGroup.childNodes[p + 1]["style"]["visibility"] = "hidden";
                    } else {
                      eleMarkerIndex2 = parseFloat(clusterGroup.childNodes[p - 1].id.split("_MarkerIndex_")[1]);
                      clusterGroup.childNodes[p - 1]["style"]["visibility"] = eleMarkerIndex2 === markerIndex ? "hidden" : clusterGroup.childNodes[p - 1]["style"]["visibility"];
                    }
                    indexCollection.push(p);
                  }
                }
              }
            }
            if (clusterColloideBounds.length > 0) {
              tempElement = clusterElement;
              for (var i = 0; i < clusterColloideBounds.length; i++) {
                if (tempElement.tagName === "g") {
                  tempElement.childNodes[0].textContent = tempElement.childNodes[0].textContent + "," + clusterColloideBounds[i].textContent;
                } else {
                  tempElement.textContent = tempElement.textContent + "," + clusterColloideBounds[i].textContent;
                }
                var eleMarkerIndex2 = parseFloat(clusterGroup.childNodes[o + 1].id.split("_MarkerIndex_")[1]);
                if (markerSetting.clusterSettings.allowClustering && eleMarkerIndex2 === markerIndex || currentLayer.markerClusterSettings.allowClustering && currentLayer.markerSettings.length > 1 && eleMarkerIndex2 === markerIndex) {
                  clusterGroup.childNodes[o + 1].textContent = (+clusterGroup.childNodes[o + 1].textContent + +clusterColloideBounds[i + 1].textContent).toString();
                } else {
                  eleMarkerIndex2 = parseFloat(clusterGroup.childNodes[o - 1].id.split("_MarkerIndex_")[1]);
                  clusterGroup.childNodes[o - 1].textContent = eleMarkerIndex2 === markerIndex ? (+clusterGroup.childNodes[o - 1].textContent + +clusterColloideBounds[i + 1].textContent).toString() : clusterGroup.childNodes[o - 1].textContent;
                }
                i++;
              }
            }
            clusterColloideBounds = [];
          }
        }
      });
    }
    while (0 < clusterGroup.childNodes.length) {
      var eleMarkerIndex = parseFloat(clusterGroup.childNodes[0].id.split("_MarkerIndex_")[1]);
      if (markerSetting.clusterSettings.allowClustering && eleMarkerIndex === markerIndex || currentLayer.markerClusterSettings.allowClustering && currentLayer.markerSettings.length > 1 && eleMarkerIndex === markerIndex) {
        markerCollection.insertBefore(clusterGroup.childNodes[0], null);
      } else {
        if (eleMarkerIndex === markerIndex) {
          markerCollection.insertBefore(clusterGroup.childNodes[0], markerCollection.firstChild);
        }
      }
    }
    if (!check) {
      getElementByID(maps.element.id + "_Secondary_Element").appendChild(markerCollection);
    }
    var element = document.getElementById(maps.element.id + "_LayerIndex_" + layerIndex + "_Polygon_Group");
    var polygonElement = document.getElementById(maps.element.id + "_LayerIndex_" + layerIndex + "_Polygons_Group");
    if (isNullOrUndefined(element) && !maps.isTileMap) {
      layerElement.insertBefore(markerCollection, layerElement.firstChild);
    } else if (!maps.isTileMap) {
      layerElement.appendChild(markerCollection);
    } else {
      if (!isNullOrUndefined(polygonElement)) {
        polygonElement.insertAdjacentElement("afterend", markerCollection);
      } else if (!isNullOrUndefined(element)) {
        element.insertAdjacentElement("afterend", markerCollection);
      } else {
        layerElement.insertBefore(markerCollection, layerElement.firstChild);
      }
    }
    var markerCluster = document.getElementById(maps.element.id + "_LayerIndex_" + layerIndex + "_markerCluster");
    if (!isNullOrUndefined(markerCluster)) {
      markerCluster.remove();
    }
    if (zoomCheck) {
      var layerGroupElement = document.getElementById(maps.element.id + "_Layer_Collections");
      var element_1 = document.getElementById(maps.element.id + "_LayerIndex_" + (layerIndex + 1));
      if (!isNullOrUndefined(layerGroupElement) && !isNullOrUndefined(element_1)) {
        layerGroupElement.insertBefore(layerElement, element_1);
      } else if (!isNullOrUndefined(layerGroupElement)) {
        layerGroupElement.appendChild(layerElement);
      }
    }
  });
  return isClusteringCompleted;
}
function markerClusterListHandler(maps, currentZoomFactor, layerIndex, index, indexCollection) {
  if (currentZoomFactor === 1) {
    var initialMarkerClusterList = isNullOrUndefined(maps.markerModule.initialMarkerCluster[layerIndex][index]) ? [] : indexCollection.length > 1 ? indexCollection : [];
    maps.markerModule.initialMarkerCluster[layerIndex][index] = initialMarkerClusterList;
    var zoomedMarkerClusterList = isNullOrUndefined(maps.markerModule.zoomedMarkerCluster[layerIndex][index]) ? [] : indexCollection.length > 1 ? indexCollection : [];
    maps.markerModule.zoomedMarkerCluster[layerIndex][index] = zoomedMarkerClusterList;
  } else if (currentZoomFactor > 1) {
    maps.markerModule.zoomedMarkerCluster[layerIndex][index] = indexCollection.length > 1 ? indexCollection : [];
  }
}
function markerBoundsComparer(tempElement, markerBounds, colloideBounds, indexCollection, p) {
  var currentMarkerBound = tempElement.getBoundingClientRect();
  if (!isNullOrUndefined(currentMarkerBound)) {
    if (!(markerBounds.left > currentMarkerBound.right || markerBounds.right < currentMarkerBound.left || markerBounds.top > currentMarkerBound.bottom || markerBounds.bottom < currentMarkerBound.top)) {
      colloideBounds.push(currentMarkerBound);
      tempElement["style"]["visibility"] = "hidden";
      indexCollection.push(p);
    }
  }
}
function mergeSeparateCluster(sameMarkerData, maps) {
  var layerIndex = sameMarkerData[0].layerIndex;
  var clusterIndex = sameMarkerData[0].targetClusterIndex;
  var markerIndex = sameMarkerData[0].markerIndex;
  var dataIndex = sameMarkerData[0].dataIndex;
  var markerId = maps.element.id + "_LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex;
  var clusterId = markerId + "_dataIndex_" + dataIndex + "_cluster_" + clusterIndex;
  var clusterEle = maps.layers[layerIndex].markerClusterSettings.shape === "Balloon" ? getElement2(clusterId + "_Group") : getElement2(clusterId);
  var clusterEleLabel = getElement2(clusterId + "_datalabel_" + clusterIndex);
  clusterEle.setAttribute("visibility", "visible");
  clusterEleLabel.setAttribute("visibility", "visible");
  var markerEle;
  var markerDataLength = sameMarkerData[0].data.length;
  for (var i = 0; i < markerDataLength; i++) {
    markerEle = getElement2(markerId + "_dataIndex_" + sameMarkerData[0].data[i]["index"] + "_Group") ? getElement2(markerId + "_dataIndex_" + sameMarkerData[0].data[i]["index"] + "_Group") : getElement2(markerId + "_dataIndex_" + sameMarkerData[0].data[i]["index"]);
    markerEle["style"]["visibility"] = "hidden";
    if (markerEle.id.indexOf("Group") > -1) {
      var marker_1 = getElement2(markerId + "_dataIndex_" + sameMarkerData[0].data[i]["index"]);
      marker_1["style"]["visibility"] = "hidden";
    }
  }
  removeElement2(maps.element.id + "_LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex + "_markerClusterConnectorLine");
}
function clusterSeparate(sameMarkerData, maps, markerElement, isDom) {
  var layerIndex = sameMarkerData[0].layerIndex;
  var markerIndex = sameMarkerData[0].markerIndex;
  var clusterIndex = sameMarkerData[0].targetClusterIndex;
  var dataIndex = sameMarkerData[0].dataIndex;
  var getElementFunction = isDom ? getElement2 : markerElement.querySelector.bind(markerElement);
  var getQueryConnect = isDom ? "" : "#";
  var markerId = maps.element.id + "_LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex;
  var layer = maps.layers[layerIndex];
  var allowInnerClusterSetting = maps.markerModule.allowInnerClusterSetting(layer);
  var cluster = !allowInnerClusterSetting && layer.markerClusterSettings.allowClustering ? layer.markerClusterSettings : layer.markerSettings[markerIndex].clusterSettings;
  var marker2 = layer.markerSettings[markerIndex];
  var clusterId = markerId + "_dataIndex_" + dataIndex + "_cluster_" + clusterIndex;
  var clusterEle = cluster.shape === "Balloon" ? getElementFunction(getQueryConnect + "" + clusterId + "_Group") : getElementFunction(getQueryConnect + "" + clusterId);
  var clusterEleLabel = getElementFunction(getQueryConnect + "" + clusterId + "_datalabel_" + clusterIndex);
  clusterEle.setAttribute("visibility", "hidden");
  clusterEleLabel.setAttribute("visibility", "hidden");
  var markerEle = getElementFunction(getQueryConnect + "" + markerId + "_dataIndex_" + dataIndex + "_Group") ? getElementFunction(getQueryConnect + "" + markerId + "_dataIndex_" + dataIndex + "_Group") : getElementFunction(getQueryConnect + "" + markerId + "_dataIndex_" + dataIndex);
  var height = markerEle.parentElement.id.indexOf("Template_Group") > -1 ? markerEle.getBoundingClientRect().height : marker2.height;
  var width = markerEle.parentElement.id.indexOf("Template_Group") > -1 ? markerEle.getBoundingClientRect().width : marker2.width;
  var centerX = +clusterEle.getAttribute("transform").split("translate(")[1].trim().split(" ")[0];
  var centerY = +clusterEle.getAttribute("transform").split("translate(")[1].trim().split(" ")[1].split(")")[0].trim();
  width = typeof width === "string" ? parseFloat(width) : width;
  var radius = width + 5;
  var area = 2 * 3.14 * radius;
  var totalMarker = 0;
  var numberOfMarker = Math.round(area / width);
  totalMarker += numberOfMarker;
  var markerDataLength = sameMarkerData[0].data.length;
  var percent = Math.round(height / area * 100);
  percent = markerDataLength < numberOfMarker ? 100 / markerDataLength : percent;
  var angle = percent / 100 * 360;
  var newAngle = markerDataLength < numberOfMarker ? 45 : 0;
  var count = 1;
  var start = "M " + centerX + " " + centerY + " ";
  var path = "";
  for (var i = 0; i < markerDataLength; i++) {
    if (totalMarker === i || Math.round(newAngle) >= 360) {
      count++;
      radius = (width + 5) * count;
      newAngle = 0;
      area = 2 * 3.14 * radius;
      numberOfMarker = Math.round(area / height);
      percent = Math.round(height / area * 100);
      while (percent * numberOfMarker < 100) {
        numberOfMarker++;
      }
      angle = percent / 100 * 360;
      totalMarker += numberOfMarker;
    }
    var x1 = centerX + radius * Math.sin(Math.PI * 2 * newAngle / 360);
    var y1 = centerY + radius * Math.cos(Math.PI * 2 * newAngle / 360);
    path += start + "L " + x1 + " " + y1 + " ";
    markerEle = getElementFunction(getQueryConnect + "" + markerId + "_dataIndex_" + sameMarkerData[0].data[i]["index"] + "_Group") ? getElementFunction(getQueryConnect + "" + markerId + "_dataIndex_" + sameMarkerData[0].data[i]["index"] + "_Group") : getElementFunction(getQueryConnect + "" + markerId + "_dataIndex_" + sameMarkerData[0].data[i]["index"]);
    if (markerEle.parentElement.id.indexOf("Template_Group") > -1) {
      markerEle["style"]["transform"] = "";
      markerEle["style"]["left"] = maps.isTileMap ? x1 - width / 2 + "px" : x1 - width / 2 - 10 + "px";
      markerEle["style"]["top"] = maps.isTileMap ? y1 - height / 2 + "px" : y1 - height / 2 - 10 + "px";
      markerEle.setAttribute("transform", "translate( " + x1 + " " + y1 + ")");
    } else {
      markerEle.setAttribute("transform", "translate( " + x1 + " " + y1 + ")");
    }
    markerEle["style"]["visibility"] = "visible";
    if (markerEle.id.indexOf("Group") > -1) {
      var marker_2 = getElementFunction(getQueryConnect + "" + markerId + "_dataIndex_" + sameMarkerData[0].data[i]["index"]);
      marker_2["style"]["visibility"] = "visible";
    }
    newAngle += angle;
  }
  var connectorLine = cluster.connectorLineSettings;
  var options = {
    d: path,
    id: maps.element.id + "_LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex + "_dataIndex_" + dataIndex + "_markerClusterConnectorLine",
    stroke: connectorLine.color,
    "fill-opacity": connectorLine.opacity,
    "stroke-opacity": connectorLine.opacity,
    "stroke-width": connectorLine.width
  };
  markerElement = isDom ? getElementFunction(maps.element.id + "_Markers_Group") : markerElement;
  var layerElement = getElementFunction(maps.element.id + "_LayerIndex_" + layerIndex);
  markerElement = layerElement.querySelector("#" + markerElement.id);
  var groupEle = maps.renderer.createGroup({ id: maps.element.id + "_LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex + "_markerClusterConnectorLine" });
  groupEle.appendChild(maps.renderer.drawPath(options));
  if (marker2.shape === "Balloon") {
    markerElement.insertBefore(groupEle, markerElement.querySelector("#" + markerId + "_dataIndex_0_Group"));
  } else {
    markerElement.insertBefore(groupEle, markerElement.querySelector("#" + markerId + "_dataIndex_0"));
  }
}
function marker(eventArgs, markerSettings, markerData, dataIndex, location2, transPoint, markerID, offset, scale, maps, markerCollection) {
  var shapeCustom = {
    size: new Size2(eventArgs.width, eventArgs.height),
    fill: eventArgs.fill,
    borderColor: eventArgs.border.color,
    borderWidth: eventArgs.border.width,
    opacity: markerSettings.opacity,
    dashArray: markerSettings.dashArray,
    borderOpacity: isNullOrUndefined(eventArgs.border.opacity) ? markerSettings.opacity : eventArgs.border.opacity
  };
  removeElement2(markerID);
  var ele = drawSymbols(eventArgs.shape, eventArgs.imageUrl, { x: 0, y: 0 }, markerID, shapeCustom, markerCollection, maps);
  var x = (maps.isTileMap ? location2.x : (location2.x + transPoint.x) * scale) + (!isNullOrUndefined(offset) && !isNullOrUndefined(offset.x) ? offset.x : 0);
  var y = (maps.isTileMap ? location2.y : (location2.y + transPoint.y) * scale) + (!isNullOrUndefined(offset) && !isNullOrUndefined(offset.y) ? offset.y : 0);
  ele.setAttribute("transform", "translate( " + x + " " + y + " )");
  maintainSelection(maps.selectedMarkerElementId, maps.markerSelectionClass, ele, "MarkerselectionMapStyle");
  if (maps.legendSettings.toggleLegendSettings.enable && maps.legendSettings.type === "Markers") {
    var layerIndex = parseInt(ele.id.split("_LayerIndex_")[1], 10);
    maintainToggleSelection(maps.toggledElementId, ele.tagName === "g" ? ele.children[0] : ele, maps.legendSettings.toggleLegendSettings.applyShapeSettings ? maps.layers[layerIndex].shapeSettings : maps.legendSettings.toggleLegendSettings);
  }
  markerCollection.appendChild(ele);
  var element = markerData.length - 1 === dataIndex ? "marker" : null;
  var markerPoint = new Point(x, y);
  if (markerSettings.animationDuration > 0 || animationMode === "Enable") {
    elementAnimate(ele, markerSettings.animationDelay, markerSettings.animationDuration, markerPoint, maps, element);
  }
  return markerCollection;
}
function markerTemplate(eventArgs, templateFn, markerID, data, markerIndex, markerTemplate2, location2, transPoint, scale, offset, maps) {
  templateFn = getTemplateFunction(eventArgs.template, maps);
  if (templateFn && templateFn(data, maps, eventArgs.template, maps.element.id + "_MarkerTemplate" + markerIndex, false).length) {
    var templateElement = templateFn(data, maps, eventArgs.template, maps.element.id + "_MarkerTemplate" + markerIndex, false);
    var markerElement = convertElement(templateElement, markerID, data, markerIndex, maps, typeof eventArgs.template);
    for (var i = 0; i < markerElement.children.length; i++) {
      markerElement.children[i].style.pointerEvents = "auto";
    }
    markerElement.style.left = (maps.isTileMap ? location2.x : (location2.x + transPoint.x) * scale) + offset.x - (maps.isTileMap ? 0 : maps.mapAreaRect.x) + "px";
    markerElement.style.top = (maps.isTileMap ? location2.y : (location2.y + transPoint.y) * scale) + offset.y - (maps.isTileMap ? 0 : maps.mapAreaRect.y) + "px";
    markerElement.style.transform = "translate(-50%, -50%)";
    markerTemplate2.appendChild(markerElement);
  }
  return markerTemplate2;
}
function maintainSelection(elementId, elementClass, element, className) {
  if (elementId) {
    for (var index = 0; index < elementId.length; index++) {
      if (element.getAttribute("id") === elementId[index]) {
        if (index === 0 || element.tagName === "g") {
          if (!isNullOrUndefined(elementClass) && !isNullOrUndefined(elementClass.id)) {
            document.body.appendChild(elementClass);
          }
          if (element.id.indexOf("_MarkerIndex_") > -1 && element.childElementCount > 0) {
            element.children[0].setAttribute("class", className);
          }
        }
        element.setAttribute("class", className);
      }
    }
  }
}
function maintainToggleSelection(toggledElements, element, styleProperty) {
  if (!isNullOrUndefined(toggledElements) && toggledElements.length > 0) {
    for (var j = 0; j < toggledElements.length; j++) {
      if (toggledElements[j] === element.id) {
        element.setAttribute("fill", styleProperty.fill);
        element.setAttribute("stroke", styleProperty.border.color);
        element.setAttribute("fill-opacity", styleProperty.opacity.toString());
        element.setAttribute("stroke-opacity", (isNullOrUndefined(styleProperty.border.opacity) ? styleProperty.opacity : styleProperty.border.opacity).toString());
        element.setAttribute("stroke-width", (isNullOrUndefined(styleProperty.border.width) ? 0 : styleProperty.border.width).toString());
      }
    }
  }
}
function maintainStyleClass(id, idClass, fill, opacity, borderColor, borderWidth, maps) {
  if (!getElement2(id)) {
    var styleClass = createElement("style", {
      id
    });
    styleClass.innerText = "." + idClass + "{fill:" + fill + ";opacity:" + opacity + ";stroke-width:" + borderWidth + ";stroke:" + borderColor + ";}";
    maps.shapeSelectionClass = styleClass;
    document.body.appendChild(styleClass);
  }
}
function appendShape(shape, element) {
  if (element) {
    element.appendChild(shape);
  }
  return shape;
}
function drawCircle(maps, options, element) {
  return appendShape(maps.renderer.drawCircle(options), element);
}
function drawRectangle(maps, options, element) {
  return appendShape(maps.renderer.drawRectangle(options), element);
}
function drawPath(maps, options, element) {
  return appendShape(maps.renderer.drawPath(options), element);
}
function drawPolygon(maps, options, element) {
  return appendShape(maps.renderer.drawPolygon(options), element);
}
function drawPolyline(maps, options, element) {
  return appendShape(maps.renderer.drawPolyline(options), element);
}
function drawLine(maps, options, element) {
  return appendShape(maps.renderer.drawLine(options), element);
}
function calculateShapes2(maps, shape, options, size, location2, markerEle) {
  var tempGroup;
  switch (shape) {
    case "Balloon":
      tempGroup = drawBalloon(maps, options, size, location2, "Marker", markerEle);
      break;
    case "Cross":
      options.d = "M " + location2.x + " " + (location2.y - size.height / 2) + " L " + location2.x + " " + (location2.y + size.height / 2) + " M " + (location2.x - size.width / 2) + " " + location2.y + " L " + (location2.x + size.width / 2) + " " + location2.y;
      break;
    case "Diamond":
      options.d = "M " + location2.x + " " + (location2.y - size.height / 2) + " L " + (location2.x + size.width / 2) + " " + location2.y + " L " + location2.x + " " + (location2.y + size.height / 2) + " L " + (location2.x - size.width / 2) + " " + location2.y + " Z";
      break;
    case "Star":
      options.d = "M " + (location2.x + size.width / 3) + " " + (location2.y + size.height / 2) + " L " + (location2.x - size.width / 2) + " " + (location2.y - size.height / 6) + " L " + (location2.x + size.width / 2) + " " + (location2.y - size.height / 6) + " L " + (location2.x - size.width / 3) + " " + (location2.y + size.height / 2) + " L " + location2.x + " " + (location2.y - size.height / 2) + " L " + (location2.x + size.width / 3) + " " + (location2.y + size.height / 2) + " Z";
      break;
    case "Triangle":
      options.d = "M " + location2.x + " " + (location2.y - size.height / 2) + " L " + (location2.x + size.width / 2) + " " + (location2.y + size.height / 2) + " L " + (location2.x - size.width / 2) + " " + (location2.y + size.height / 2) + " Z";
      break;
    case "HorizontalLine":
      options.d = " M " + (location2.x - size.width / 2) + " " + location2.y + " L " + (location2.x + size.width / 2) + " " + location2.y;
      break;
    case "VerticalLine":
      options.d = "M " + location2.x + " " + (location2.y - size.height / 2) + " L " + location2.x + " " + (location2.y + size.height / 2);
      break;
    case "InvertedTriangle":
      options.d = "M " + (location2.x - size.width / 2) + " " + (location2.y - size.height / 2) + " L " + (location2.x + size.width / 2) + " " + (location2.y - size.height / 2) + " L " + location2.x + " " + (location2.y + size.height / 2) + " Z";
      break;
    case "Pentagon":
      var eq = 72;
      var xValue = void 0;
      var yValue = void 0;
      for (var i = 0; i < 5; i++) {
        xValue = size.width / 2 * Math.cos(Math.PI / 180 * (i * eq));
        yValue = size.height / 2 * Math.sin(Math.PI / 180 * (i * eq));
        options.d += (i === 0 ? "M " : "L ") + (location2.x + xValue) + " " + (location2.y + yValue);
      }
      options.d += " Z";
      break;
  }
  if (shape === "Cross" || shape === "HorizontalLine" || shape === "VerticalLine") {
    options["stroke"] = options["stroke"] === "transparent" ? options["fill"] : options["stroke"];
  }
  return shape === "Balloon" ? tempGroup : maps.renderer.drawPath(options);
}
function drawDiamond(maps, options, size, location2, element) {
  options.d = "M " + location2.x + " " + (location2.y - size.height / 2) + " L " + (location2.x + size.width / 2) + " " + location2.y + " L " + location2.x + " " + (location2.y + size.height / 2) + " L " + (location2.x - size.width / 2) + " " + location2.y + " Z";
  return appendShape(maps.renderer.drawPath(options), element);
}
function drawTriangle(maps, options, size, location2, element) {
  options.d = "M " + location2.x + " " + (location2.y - size.height / 2) + " L " + (location2.x + size.width / 2) + " " + (location2.y + size.height / 2) + " L " + (location2.x - size.width / 2) + " " + (location2.y + size.height / 2) + " Z";
  return appendShape(maps.renderer.drawPath(options), element);
}
function drawCross(maps, options, size, location2, element) {
  options.d = "M " + location2.x + " " + (location2.y - size.height / 2) + " L " + location2.x + " " + (location2.y + size.height / 2) + " M " + (location2.x - size.width / 2) + " " + location2.y + " L " + (location2.x + size.width / 2) + " " + location2.y;
  return appendShape(maps.renderer.drawPath(options), element);
}
function drawHorizontalLine(maps, options, size, location2, element) {
  options.d = " M " + (location2.x - size.width / 2) + " " + location2.y + " L " + (location2.x + size.width / 2) + " " + location2.y;
  return appendShape(maps.renderer.drawPath(options), element);
}
function drawVerticalLine(maps, options, size, location2, element) {
  options.d = "M " + location2.x + " " + (location2.y - size.height / 2) + " L " + location2.x + " " + (location2.y + size.height / 2);
  return appendShape(maps.renderer.drawPath(options), element);
}
function drawStar(maps, options, size, location2, element) {
  options.d = "M " + (location2.x + size.width / 3) + " " + (location2.y + size.height / 2) + " L " + (location2.x - size.width / 2) + " " + (location2.y - size.height / 6) + " L " + (location2.x + size.width / 2) + " " + (location2.y - size.height / 6) + " L " + (location2.x - size.width / 3) + " " + (location2.y + size.height / 2) + " L " + location2.x + " " + (location2.y - size.height / 2) + " L " + (location2.x + size.width / 3) + " " + (location2.y + size.height / 2) + " Z";
  return appendShape(maps.renderer.drawPath(options), element);
}
function drawBalloon(maps, options, size, location2, type, element) {
  var width = size.width;
  var height = size.height;
  var pathElement;
  location2.x -= width / 2;
  location2.y -= options.id.indexOf("cluster") > -1 ? height / 2 : options.id.indexOf("Legend") > -1 ? height / 1.25 : height;
  options.d = "M15,0C8.8,0,3.8,5,3.8,11.2C3.8,17.5,9.4,24.4,15,30c5.6-5.6,11.2-12.5,11.2-18.8C26.2,5,21.2,0,15,0z M15,16c-2.8,0-5-2.2-5-5s2.2-5,5-5s5,2.2,5,5S17.8,16,15,16z";
  var balloon = maps.renderer.drawPath(options);
  var x = size.width / 30;
  var y = size.height / 30;
  balloon.setAttribute("transform", "translate(" + location2.x + ", " + location2.y + ") scale(" + x + ", " + y + ")");
  if (type === "Marker") {
    var g = maps.renderer.createGroup({ id: options.id + "_Group" });
    appendShape(balloon, g);
    pathElement = appendShape(g, element);
  } else {
    pathElement = balloon;
  }
  return pathElement;
}
function drawPattern(maps, options, elements, element) {
  var pattern = maps.renderer.createPattern(options, "pattern");
  for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
    var ele = elements_1[_i];
    appendShape(ele, pattern);
  }
  return appendShape(pattern, element);
}
function getFieldData(dataSource, fields) {
  var newData = [];
  var data;
  for (var _i = 0, dataSource_1 = dataSource; _i < dataSource_1.length; _i++) {
    var temp = dataSource_1[_i];
    data = {};
    for (var _a = 0, fields_1 = fields; _a < fields_1.length; _a++) {
      var field = fields_1[_a];
      if (temp[field]) {
        data[field] = temp[field];
      }
    }
    newData.push(data);
  }
  return newData;
}
function checkShapeDataFields(dataSource, properties, dataPath, propertyPath, layer) {
  if (!isNullOrUndefined(properties) && !isNullOrUndefined(dataSource) && !isNullOrUndefined(dataPath)) {
    for (var i = 0; i < dataSource.length; i++) {
      var shapeDataPath = dataPath.indexOf(".") > -1 ? getValueFromObject(dataSource[i], dataPath) : dataSource[i][dataPath];
      var shapePath = checkPropertyPath(shapeDataPath, propertyPath, properties);
      var shapeDataPathValue = !isNullOrUndefined(shapeDataPath) && isNaN(properties[shapePath]) ? typeof shapeDataPath === "string" ? shapeDataPath.toLowerCase() : shapeDataPath : shapeDataPath;
      var propertiesShapePathValue = !isNullOrUndefined(properties[shapePath]) && isNaN(properties[shapePath]) ? properties[shapePath].toLowerCase() : properties[shapePath];
      if (shapeDataPathValue === propertiesShapePathValue) {
        return i;
      }
    }
  }
  return null;
}
function checkPropertyPath(shapeData, shapePropertyPath, shape) {
  if (!isNullOrUndefined(shapeData) && !isNullOrUndefined(shape)) {
    if (!isNullOrUndefined(shapePropertyPath)) {
      var properties = Object.prototype.toString.call(shapePropertyPath) === "[object Array]" ? shapePropertyPath : [shapePropertyPath];
      for (var i = 0; i < properties.length; i++) {
        var shapeDataValue = !isNullOrUndefined(shapeData) && typeof shapeData === "string" ? shapeData.toLowerCase() : shapeData;
        var shapePropertiesValue = !isNullOrUndefined(shape[properties[i]]) && isNaN(shape[properties[i]]) ? shape[properties[i]].toLowerCase() : shape[properties[i]];
        if (shapeDataValue === shapePropertiesValue) {
          return properties[i];
        }
      }
    }
  }
  return null;
}
function filter(points, start, end) {
  var pointObject = [];
  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    if (start <= point.y && end >= point.y) {
      pointObject.push(point);
    }
  }
  return pointObject;
}
function getRatioOfBubble(min, max, value, minValue, maxValue) {
  var percent = 100 / (maxValue - minValue) * (value - minValue);
  var bubbleRadius = (max - min) / 100 * percent + min;
  if (maxValue === minValue) {
    bubbleRadius = (max - min) / 100 + min;
  }
  return bubbleRadius;
}
function findMidPointOfPolygon(points, type, geometryType) {
  if (!points.length) {
    return null;
  }
  var min = 0;
  var max = points.length;
  var startX;
  var startY;
  var startX1;
  var startY1;
  var sum2 = 0;
  var xSum = 0;
  var ySum = 0;
  for (var i = min; i <= max - 1; i++) {
    startX = points[i].x;
    startY = type === "Mercator" || geometryType === "Normal" ? points[i].y : -points[i].y;
    if (i === max - 1) {
      startX1 = points[0].x;
      startY1 = type === "Mercator" || geometryType === "Normal" ? points[0].y : -points[0].y;
    } else {
      startX1 = points[i + 1].x;
      startY1 = type === "Mercator" || geometryType === "Normal" ? points[i + 1].y : -points[i + 1].y;
    }
    sum2 = sum2 + Math.abs(startX * startY1 - startX1 * startY);
    xSum = xSum + Math.abs((startX + startX1) * (startX * startY1 - startX1 * startY));
    ySum = ySum + Math.abs((startY + startY1) * (startX * startY1 - startX1 * startY));
  }
  sum2 = 0.5 * sum2;
  var pointValue = points.some(function(point2) {
    return point2.x < 5 && point2.y < 5;
  }) && geometryType === "Normal" ? 6 : 4;
  xSum = sum2 !== 0 ? 1 / (pointValue * sum2) * xSum : 0;
  ySum = sum2 !== 0 ? 1 / (pointValue * sum2) * ySum : 0;
  var rightMinPoint = { x: 0, y: 0 };
  var rightMaxPoint = { x: 0, y: 0 };
  var leftMinPoint = { x: 0, y: 0 };
  var leftMaxPoint = { x: 0, y: 0 };
  var bottomMinPoint = { x: 0, y: 0 };
  var bottomMaxPoint = { x: 0, y: 0 };
  var topMinPoint = { x: 0, y: 0 };
  var topMaxPoint = { x: 0, y: 0 };
  var height = 0;
  for (var i = min; i <= max - 1; i++) {
    var point = points[i];
    point.y = type === "Mercator" || geometryType === "Normal" ? point.y : -point.y;
    if (point.y > ySum) {
      if (point.x < xSum && xSum - point.x < xSum - bottomMinPoint.x) {
        bottomMinPoint = { x: point.x, y: point.y };
      } else if (point.x > xSum && (bottomMaxPoint.x === 0 || point.x - xSum < bottomMaxPoint.x - xSum)) {
        bottomMaxPoint = { x: point.x, y: point.y };
      }
    } else {
      if (point.x < xSum && xSum - point.x < xSum - topMinPoint.x) {
        topMinPoint = { x: point.x, y: point.y };
      } else if (point.x > xSum && (topMaxPoint.x === 0 || point.x - xSum < topMaxPoint.x - xSum)) {
        topMaxPoint = { x: point.x, y: point.y };
      }
    }
    height = bottomMaxPoint.y - topMaxPoint.y + (bottomMaxPoint.y - topMaxPoint.y) / 4;
    if (point.x > xSum) {
      if (point.y < ySum && ySum - point.y < ySum - rightMinPoint.y) {
        rightMinPoint = { x: point.x, y: point.y };
      } else if (point.y > ySum && (rightMaxPoint.y === 0 || point.y - ySum < rightMaxPoint.y - ySum)) {
        rightMaxPoint = { x: point.x, y: point.y };
      }
    } else {
      if (point.y < ySum && ySum - point.y < ySum - leftMinPoint.y) {
        leftMinPoint = { x: point.x, y: point.y };
      } else if (point.y > ySum && (leftMaxPoint.y === 0 || point.y - ySum < leftMaxPoint.y - ySum)) {
        leftMaxPoint = { x: point.x, y: point.y };
      }
    }
  }
  return {
    x: xSum,
    y: ySum,
    rightMin: rightMinPoint,
    rightMax: rightMaxPoint,
    leftMin: leftMinPoint,
    leftMax: leftMaxPoint,
    points,
    topMax: topMaxPoint,
    topMin: topMinPoint,
    bottomMax: bottomMaxPoint,
    bottomMin: bottomMinPoint,
    height
  };
}
function isCustomPath(layerData) {
  var customPath = false;
  if (Object.prototype.toString.call(layerData) === "[object Array]") {
    Array.prototype.forEach.call(layerData, function(layer) {
      if (!isNullOrUndefined(layer["geometry"]) && layer["geometry"]["type"] === "Path") {
        customPath = true;
      }
    });
  }
  return customPath;
}
function textTrim(maxWidth, text, font, width, isCanvasMeasure, widthList) {
  var label = text;
  if (isNullOrUndefined(width)) {
    if (!isCanvasMeasure) {
      width = measureText2(text, font).width;
    } else {
      width = measureTextElement(text, font).width;
    }
  }
  if (width > maxWidth) {
    var textLength = text.length;
    for (var i = textLength - 1; i >= 0; --i) {
      label = text.substring(0, i) + "...";
      if (!isCanvasMeasure) {
        width = measureText2(label, font).width;
      } else {
        width = measureTextElement(label, font).width;
      }
      if (width <= maxWidth || label.length < 4) {
        if (label.length < 4) {
          label = " ";
        }
        if (!isNullOrUndefined(widthList)) {
          widthList.push(width);
        }
        return label;
      }
    }
  }
  if (!isNullOrUndefined(widthList)) {
    widthList.push(width);
  }
  return label;
}
function findPosition(location2, alignment, textSize, type) {
  var x;
  switch (alignment) {
    case "Near":
      x = location2.x;
      break;
    case "Center":
      x = type === "title" ? location2.width / 2 - textSize.width / 2 : location2.x + location2.width / 2 - textSize.width / 2;
      break;
    case "Far":
      x = type === "title" ? location2.width - location2.y - textSize.width : location2.x + location2.width - textSize.width;
      break;
  }
  var y = type === "title" ? location2.y + textSize.height / 2 : location2.y + location2.height / 2 + textSize.height / 2;
  return new Point(x, y);
}
function removeElement2(id) {
  var element = document.getElementById(id);
  return element ? remove(element) : null;
}
function calculateCenterFromPixel(mapObject, layer) {
  var point1 = convertGeoToPoint(mapObject.minLatOfGivenLocation, mapObject.minLongOfGivenLocation, mapObject.mapLayerPanel.calculateFactor(layer), layer, mapObject);
  var point2 = convertGeoToPoint(mapObject.maxLatOfGivenLocation, mapObject.maxLongOfGivenLocation, mapObject.mapLayerPanel.calculateFactor(layer), layer, mapObject);
  var x = (point1.x + point2.x) / 2;
  var y = (point1.y + point2.y) / 2;
  return new Point(x, y);
}
function getTranslate(mapObject, layer, animate2) {
  var zoomFactorValue = mapObject.zoomSettings.zoomFactor;
  var scaleFactor;
  var center = mapObject.centerPosition;
  var centerLatitude = center.latitude;
  var centerLongitude = center.longitude;
  var checkMethodeZoom = !isNullOrUndefined(mapObject.centerLatOfGivenLocation) && !isNullOrUndefined(mapObject.centerLongOfGivenLocation) && mapObject.zoomNotApplied;
  if (isNullOrUndefined(mapObject.mapScaleValue)) {
    mapObject.mapScaleValue = zoomFactorValue;
  }
  if (mapObject.zoomSettings.shouldZoomInitially && mapObject.zoomSettings.enable) {
    mapObject.mapScaleValue = scaleFactor = zoomFactorValue = (mapObject.zoomSettings.shouldZoomInitially || mapObject.enablePersistence) && mapObject.scale === 1 ? mapObject.scale : isNullOrUndefined(mapObject.markerZoomFactor) ? 1 : mapObject.markerZoomedState ? mapObject.markerZoomFactor : parseInt(mapObject.scale.toString());
    if (mapObject.markerZoomedState && mapObject.mapScaleValue !== mapObject.markerZoomFactor && !mapObject.enablePersistence) {
      mapObject.mapScaleValue = zoomFactorValue = mapObject.markerZoomFactor;
    }
    if (mapObject.markerZoomedState && !isNullOrUndefined(mapObject.markerCenterLatitude) && !isNullOrUndefined(mapObject.markerCenterLongitude)) {
      centerLatitude = mapObject.markerCenterLatitude;
      centerLongitude = mapObject.markerCenterLongitude;
    }
  }
  if (checkMethodeZoom) {
    mapObject.mapScaleValue = scaleFactor = zoomFactorValue = mapObject.scaleOfGivenLocation;
  }
  var min = !isNullOrUndefined(mapObject.baseMapRectBounds) ? mapObject.baseMapRectBounds["min"] : null;
  var max = !isNullOrUndefined(mapObject.baseMapRectBounds) ? mapObject.baseMapRectBounds["max"] : null;
  var zoomFactor = animate2 ? 1 : mapObject.mapScaleValue;
  if (isNullOrUndefined(mapObject.currentShapeDataLength) && !isNullOrUndefined(layer.shapeData)) {
    mapObject.currentShapeDataLength = !isNullOrUndefined(layer.shapeData["features"]) ? layer.shapeData["features"].length : !isNullOrUndefined(layer.shapeData["geometries"]) ? layer.shapeData["geometries"].length : 0;
  }
  var size = mapObject.totalRect && mapObject.legendSettings.visible ? mapObject.totalRect : mapObject.mapAreaRect;
  var availSize = mapObject.availableSize;
  var x;
  var y;
  if (!isNullOrUndefined(min) && !isNullOrUndefined(max)) {
    var mapWidth = Math.abs(max["x"] - min["x"]);
    var mapHeight = Math.abs(min["y"] - max["y"]);
    var factor = animate2 ? 1 : mapObject.markerZoomFactor === 1 ? mapObject.mapScaleValue : zoomFactorValue;
    center = mapObject.zoomSettings.shouldZoomInitially && mapObject.markerZoomedState && !mapObject.zoomPersistence ? mapObject.markerZoomCenterPoint : mapObject.centerPosition;
    if (!isNullOrUndefined(centerLongitude) && centerLongitude !== 0 && (!isNullOrUndefined(centerLatitude) && centerLatitude !== 0) || checkMethodeZoom) {
      var leftPosition = ((mapWidth + Math.abs(mapObject.mapAreaRect.width - mapWidth)) / 2 + mapObject.mapAreaRect.x) / factor;
      var topPosition = ((mapHeight + Math.abs(mapObject.mapAreaRect.height - mapHeight)) / 2 + mapObject.mapAreaRect.y) / factor;
      var point = checkMethodeZoom ? calculateCenterFromPixel(mapObject, layer) : convertGeoToPoint(centerLatitude, centerLongitude, mapObject.mapLayerPanel.calculateFactor(layer), layer, mapObject);
      if (isNullOrUndefined(mapObject.previousProjection) || mapObject.previousProjection !== mapObject.projectionType || mapObject.isMarkerZoomCompleted) {
        x = -point.x + leftPosition;
        y = -point.y + topPosition;
        scaleFactor = zoomFactor;
      } else {
        if (Math.floor(mapObject.scale) !== 1 && mapObject.zoomSettings.shouldZoomInitially || mapObject.zoomNotApplied) {
          x = -point.x + leftPosition;
          y = -point.y + topPosition;
        } else {
          if (mapObject.zoomSettings.shouldZoomInitially || mapObject.zoomNotApplied) {
            x = -point.x + leftPosition;
            y = -point.y + topPosition;
            scaleFactor = zoomFactor;
          } else {
            x = mapObject.zoomTranslatePoint.x;
            y = mapObject.zoomTranslatePoint.y;
          }
        }
        scaleFactor = mapObject.mapScaleValue;
      }
    } else {
      if (isNullOrUndefined(mapObject.previousProjection) || mapObject.previousProjection !== mapObject.projectionType) {
        if (mapHeight === 0 || mapWidth === 0 || mapHeight === mapWidth) {
          mapWidth = size.width / 2;
          mapHeight = size.height;
        }
        scaleFactor = parseFloat(Math.min(size.width / mapWidth, size.height / mapHeight).toFixed(2));
        scaleFactor = scaleFactor > 1.05 ? 1 : scaleFactor;
        mapWidth *= scaleFactor;
        mapHeight *= scaleFactor;
        var widthDiff = min["x"] !== 0 && mapObject.translateType === "layers" ? availSize.width - size.width : 0;
        x = size.x + (-min["x"] + (size.width / 2 - mapWidth / 2)) - widthDiff;
        y = size.y + (-min["y"] + (size.height / 2 - mapHeight / 2));
        mapObject.previousTranslate = new Point(x, y);
      } else {
        if (!mapObject.zoomSettings.shouldZoomInitially && mapObject.markerZoomFactor === 1 && mapObject.mapScaleValue === 1) {
          scaleFactor = parseFloat(Math.min(size.width / mapWidth, size.height / mapHeight).toFixed(2));
          mapHeight *= scaleFactor;
          mapWidth *= scaleFactor;
          y = size.y + (-min["y"] + (size.height / 2 - mapHeight / 2));
          x = size.x + (-min["x"] + (size.width / 2 - mapWidth / 2));
        } else {
          scaleFactor = mapObject.mapScaleValue < 1 ? mapObject.mapScaleValue + 1 : mapObject.mapScaleValue;
          mapObject.mapScaleValue = mapObject.zoomSettings.enable && mapObject.mapScaleValue !== 1 ? mapObject.mapScaleValue : 1;
          if (mapObject.currentShapeDataLength !== (!isNullOrUndefined(layer.shapeData["features"]) ? layer.shapeData["features"].length : layer.shapeData["geometries"].length) && layer.type !== "SubLayer") {
            var scale = parseFloat(Math.min(size.height / mapHeight, size.width / mapWidth).toFixed(2));
            mapHeight *= scale;
            mapWidth *= scale;
            y = size.y + (-min["y"] + (size.height / 2 - mapHeight / 2));
            scaleFactor = scale;
            x = size.x + (-min["x"] + (size.width / 2 - mapWidth / 2));
          } else if ((mapObject.availableSize.height !== mapObject.heightBeforeRefresh || mapObject.widthBeforeRefresh !== mapObject.availableSize.width) && !isNullOrUndefined(mapObject.translatePoint) && !isNullOrUndefined(mapObject.previousTranslate)) {
            var cscaleFactor = parseFloat(Math.min(size.width / mapWidth, size.height / mapHeight).toFixed(2));
            var cmapWidth = mapWidth;
            cmapWidth *= cscaleFactor;
            var cmapHeight = mapHeight;
            cmapHeight *= cscaleFactor;
            var x1 = size.x + (-min["x"] + (size.width / 2 - cmapWidth / 2));
            var y1 = size.y + (-min["y"] + (size.height / 2 - cmapHeight / 2));
            var xdiff = (mapObject.translatePoint.x - mapObject.previousTranslate.x) / mapObject.widthBeforeRefresh;
            var ydiff = (mapObject.translatePoint.y - mapObject.previousTranslate.y) / mapObject.heightBeforeRefresh;
            var actxdiff = xdiff * mapObject.availableSize.width;
            var actydiff = ydiff * mapObject.availableSize.height;
            x = x1 + actxdiff;
            y = y1 + actydiff;
            mapObject.previousTranslate = new Point(x1, y1);
            mapObject.zoomTranslatePoint.x = x;
            mapObject.zoomTranslatePoint.y = y;
          } else {
            if (!isNullOrUndefined(mapObject.previousProjection) && (mapObject.mapScaleValue === 1 || mapObject.mapScaleValue <= 1.05) && !mapObject.zoomModule.isDragZoom) {
              scaleFactor = parseFloat(Math.min(size.width / mapWidth, size.height / mapHeight).toFixed(2));
              scaleFactor = scaleFactor > 1.05 ? 1 : scaleFactor;
              mapWidth *= scaleFactor;
              x = size.x + (-min["x"] + (size.width / 2 - mapWidth / 2));
              mapHeight *= scaleFactor;
              y = size.y + (-min["y"] + (size.height / 2 - mapHeight / 2));
            } else {
              x = mapObject.zoomTranslatePoint.x;
              y = mapObject.zoomTranslatePoint.y;
              scaleFactor = mapObject.scale;
            }
          }
        }
      }
    }
    if (!isNullOrUndefined(mapObject.translatePoint)) {
      x = mapObject.enablePersistence && mapObject.translatePoint.x !== 0 && !mapObject.zoomNotApplied ? mapObject.translatePoint.x : x;
      y = mapObject.enablePersistence && mapObject.translatePoint.y !== 0 && !mapObject.zoomNotApplied ? mapObject.translatePoint.y : y;
    }
  }
  scaleFactor = mapObject.enablePersistence ? mapObject.mapScaleValue >= 1 ? mapObject.mapScaleValue : 1 : scaleFactor;
  mapObject.widthBeforeRefresh = mapObject.availableSize.width;
  mapObject.heightBeforeRefresh = mapObject.availableSize.height;
  return { scale: scaleFactor, location: new Point(x, y) };
}
function getZoomTranslate(mapObject, layer, animate2) {
  var zoomFactorValue = mapObject.zoomSettings.zoomFactor;
  var scaleFactor;
  var center = mapObject.centerPosition;
  var latitude = center.latitude;
  var longitude = center.longitude;
  var checkZoomMethod = !isNullOrUndefined(mapObject.centerLongOfGivenLocation) && !isNullOrUndefined(mapObject.centerLatOfGivenLocation) && mapObject.zoomNotApplied;
  if (isNullOrUndefined(mapObject.previousCenterLatitude) && isNullOrUndefined(mapObject.previousCenterLongitude)) {
    mapObject.previousCenterLatitude = mapObject.centerPosition.latitude;
    mapObject.previousCenterLongitude = mapObject.centerPosition.longitude;
  } else if (mapObject.previousCenterLatitude !== mapObject.centerPosition.latitude && mapObject.previousCenterLongitude !== mapObject.centerPosition.longitude) {
    mapObject.centerPositionChanged = true;
    mapObject.previousCenterLatitude = mapObject.centerPosition.latitude;
    mapObject.previousCenterLongitude = mapObject.centerPosition.longitude;
  } else {
    mapObject.centerPositionChanged = false;
  }
  if (isNullOrUndefined(mapObject.mapScaleValue) || zoomFactorValue > mapObject.mapScaleValue) {
    if (mapObject.isReset && mapObject.mapScaleValue === 1) {
      mapObject.mapScaleValue = mapObject.mapScaleValue;
    } else if (!isNullOrUndefined(mapObject.mapScaleValue) && mapObject.mapScaleValue <= mapObject.scale) {
      mapObject.mapScaleValue = mapObject.scale;
    } else {
      mapObject.mapScaleValue = zoomFactorValue;
    }
  }
  mapObject.mapScaleValue = mapObject.zoomSettings.zoomFactor !== 1 && mapObject.zoomSettings.zoomFactor === mapObject.mapScaleValue ? mapObject.zoomSettings.zoomFactor : mapObject.zoomSettings.zoomFactor !== mapObject.mapScaleValue && !mapObject.centerPositionChanged ? mapObject.mapScaleValue : mapObject.zoomSettings.zoomFactor;
  if (mapObject.zoomSettings.shouldZoomInitially && !mapObject.isZoomByPosition) {
    mapObject.mapScaleValue = zoomFactorValue = scaleFactor = (mapObject.enablePersistence || mapObject.zoomSettings.shouldZoomInitially) && mapObject.scale === 1 ? mapObject.scale : isNullOrUndefined(mapObject.markerZoomFactor) ? mapObject.mapScaleValue : mapObject.markerZoomFactor;
    zoomFactorValue = mapObject.mapScaleValue;
    if (!isNullOrUndefined(mapObject.markerCenterLatitude) && !isNullOrUndefined(mapObject.markerCenterLongitude)) {
      latitude = mapObject.markerCenterLatitude;
      longitude = mapObject.markerCenterLongitude;
    }
  }
  if (checkZoomMethod) {
    mapObject.mapScaleValue = scaleFactor = zoomFactorValue = mapObject.scaleOfGivenLocation;
  }
  var zoomFactor = animate2 ? 1 : mapObject.mapScaleValue;
  var size = mapObject.mapAreaRect;
  var x;
  var y;
  var min = mapObject.baseMapRectBounds["min"];
  var max = mapObject.baseMapRectBounds["max"];
  var factor = animate2 ? 1 : mapObject.mapScaleValue;
  var mapWidth = Math.abs(max["x"] - min["x"]);
  var mapHeight = Math.abs(min["y"] - max["y"]);
  if (!isNullOrUndefined(longitude) && longitude !== 0 && (!isNullOrUndefined(latitude) && latitude !== 0) || checkZoomMethod) {
    var topPosition = (mapHeight + Math.abs(mapObject.mapAreaRect.height - mapHeight)) / 2 / factor;
    var leftPosition = (mapWidth + Math.abs(mapObject.mapAreaRect.width - mapWidth)) / 2 / factor;
    var point = checkZoomMethod ? calculateCenterFromPixel(mapObject, layer) : convertGeoToPoint(latitude, longitude, mapObject.mapLayerPanel.calculateFactor(layer), layer, mapObject);
    if ((!isNullOrUndefined(mapObject.zoomTranslatePoint) || !isNullOrUndefined(mapObject.previousProjection)) && !mapObject.zoomNotApplied) {
      if (mapObject.previousProjection !== mapObject.projectionType) {
        x = -point.x + leftPosition;
        y = -point.y + topPosition;
      } else {
        if (mapObject.isZoomByPosition) {
          mapObject.zoomTranslatePoint.x = -point.x + leftPosition;
          mapObject.zoomTranslatePoint.y = -point.y + topPosition;
        }
        x = mapObject.zoomTranslatePoint.x;
        y = mapObject.zoomTranslatePoint.y;
        zoomFactorValue = zoomFactor;
      }
    } else {
      x = -point.x + leftPosition + mapObject.mapAreaRect.x / zoomFactor;
      y = -point.y + topPosition + mapObject.mapAreaRect.y / zoomFactor;
    }
    if (!isNullOrUndefined(mapObject.translatePoint)) {
      y = mapObject.enablePersistence && mapObject.translatePoint.y !== 0 && !mapObject.zoomNotApplied ? mapObject.translatePoint.y : y;
      x = mapObject.enablePersistence && mapObject.translatePoint.x !== 0 && !mapObject.zoomNotApplied ? mapObject.translatePoint.x : x;
    }
    scaleFactor = zoomFactorValue !== 0 ? zoomFactorValue : 1;
  } else {
    var zoomFact = mapObject.zoomSettings.zoomFactor === 0 ? 1 : mapObject.zoomSettings.zoomFactor;
    var maxZoomFact = mapObject.zoomSettings.maxZoom;
    zoomFact = zoomFact > maxZoomFact ? maxZoomFact : zoomFact;
    scaleFactor = zoomFact;
    var mapScale = mapObject.mapScaleValue === 0 ? 1 : mapObject.mapScaleValue > maxZoomFact ? maxZoomFact : mapObject.mapScaleValue;
    var leftPosition = size.x + (-min["x"] + (size.width / 2 - mapWidth / 2));
    var topPosition = size.y + (-min["y"] + (size.height / 2 - mapHeight / 2));
    if (!isNullOrUndefined(mapObject.zoomTranslatePoint) || !isNullOrUndefined(mapObject.previousProjection)) {
      if (mapObject.previousProjection !== mapObject.projectionType) {
        var previousPositions = [];
        var previousPoints = { x: leftPosition, y: topPosition };
        previousPositions.push(previousPoints);
        for (var i = 1; i < maxZoomFact; i++) {
          var translatePointX = previousPositions[i - 1]["x"] - (size.width / i - size.width / (i + 1)) / 2;
          var translatePointY = previousPositions[i - 1]["y"] - (size.height / i - size.height / (i + 1)) / 2;
          previousPoints = { x: translatePointX, y: translatePointY };
          previousPositions.push(previousPoints);
        }
        leftPosition = previousPositions[zoomFact - 1]["x"];
        topPosition = previousPositions[zoomFact - 1]["y"];
      } else {
        leftPosition = mapObject.zoomTranslatePoint.x;
        topPosition = mapObject.zoomTranslatePoint.y;
        if (zoomFact !== mapScale) {
          scaleFactor = mapScale;
        }
      }
    }
    if (!isNullOrUndefined(mapObject.translatePoint)) {
      x = mapObject.enablePersistence && mapObject.translatePoint.x !== 0 && !mapObject.zoomNotApplied ? mapObject.translatePoint.x : leftPosition;
      y = mapObject.enablePersistence && mapObject.translatePoint.y !== 0 && !mapObject.zoomNotApplied ? mapObject.translatePoint.y : topPosition;
    }
  }
  scaleFactor = mapObject.enablePersistence ? mapObject.mapScaleValue === 0 ? 1 : mapObject.mapScaleValue : scaleFactor;
  mapObject.widthBeforeRefresh = mapObject.availableSize.width;
  mapObject.heightBeforeRefresh = mapObject.availableSize.height;
  return { scale: animate2 ? 1 : scaleFactor, location: new Point(x, y) };
}
function fixInitialScaleForTile(map) {
  map.tileZoomScale = map.tileZoomLevel = Math.floor(map.availableSize.height / 512) + 1;
  var padding = 20;
  var totalSize = Math.pow(2, map.tileZoomLevel) * 256;
  map.tileTranslatePoint.x = map.availableSize.width / 2 - totalSize / 2;
  map.tileTranslatePoint.y = map.availableSize.height / 2 - totalSize / 2 + padding;
  map.previousTileWidth = map.availableSize.width;
  map.previousTileHeight = map.availableSize.height;
}
function getElementByID(id) {
  return document.getElementById(id);
}
function getProcessedMarginValue(marginValue) {
  return typeof marginValue === "string" ? parseFloat(marginValue) : marginValue;
}
function Internalize(maps, value) {
  maps.formatFunction = maps.intl.getNumberFormat({ format: maps.format, useGrouping: maps.useGroupingSeparator });
  return maps.formatFunction(value);
}
function getTemplateFunction(template, maps) {
  var templateFn = null;
  try {
    if (typeof template !== "function" && document.querySelectorAll(template).length) {
      templateFn = compile2(document.querySelector(template).innerHTML.trim());
    } else if (maps.isVue || maps.isVue3) {
      templateFn = compile2(template);
    } else if (typeof template === "function") {
      templateFn = compile2(template);
    }
  } catch (e) {
    templateFn = compile2(template);
  }
  return templateFn;
}
function getElement2(id) {
  return document.getElementById(id);
}
function getShapeData(targetId, map) {
  var layerIndex = parseInt(targetId.split("_LayerIndex_")[1].split("_")[0], 10);
  var shapeIndex = parseInt(targetId.split("_shapeIndex_")[1].split("_")[0], 10);
  var layer = map.layersCollection[layerIndex];
  var shapeData = layer.layerData[shapeIndex]["property"];
  var data;
  if (layer.dataSource) {
    data = layer.dataSource[checkShapeDataFields(layer.dataSource, shapeData, layer.shapeDataPath, layer.shapePropertyPath, layer)];
  }
  return { shapeData, data };
}
function triggerShapeEvent(targetId, selection, maps, eventName) {
  var shape = getShapeData(targetId, maps);
  var border = {
    color: selection.border.color,
    opacity: selection.border.opacity,
    width: selection.border.width
  };
  var eventArgs = selection.enableMultiSelect ? {
    cancel: false,
    name: eventName,
    fill: selection.fill,
    opacity: selection.opacity,
    border,
    shapeData: shape.shapeData,
    data: shape.data,
    target: targetId,
    maps,
    shapeDataCollection: maps.shapeSelectionItem
  } : {
    cancel: false,
    name: eventName,
    fill: selection.fill,
    opacity: selection.opacity,
    border,
    shapeData: shape.shapeData,
    data: shape.data,
    target: targetId,
    maps
  };
  maps.trigger(eventName, eventArgs, function() {
    eventArgs.border.opacity = isNullOrUndefined(eventArgs.border.opacity) ? eventArgs.opacity : eventArgs.border.opacity;
  });
  return eventArgs;
}
function getElementsByClassName(className) {
  return document.getElementsByClassName(className);
}
function querySelector(args, elementSelector) {
  var targetEle = null;
  targetEle = document.querySelector("#" + args);
  return targetEle;
}
function getTargetElement(layerIndex, name, enable, map) {
  var targetId;
  var shapeData = map.layers[layerIndex].shapeData["features"];
  for (var i = 0; i < shapeData.length; i++) {
    if (shapeData[i]["properties"].name === name) {
      targetId = map.element.id + "_LayerIndex_" + layerIndex + "_shapeIndex_" + i + "_dataIndex_undefined";
      break;
    }
  }
  var targetEle = getElement2(targetId);
  return targetEle;
}
function createStyle(id, className, eventArgs) {
  var styleEle = createElement("style", {
    id
  });
  styleEle.innerText = "." + className + "{fill:" + eventArgs["fill"] + ";fill-opacity:" + (!isNullOrUndefined(eventArgs["opacity"]) ? eventArgs["opacity"].toString() : "1") + ";stroke-opacity:" + (!isNullOrUndefined(eventArgs["border"]["opacity"]) ? eventArgs["border"]["opacity"].toString() : "1") + ";stroke-width:" + eventArgs["border"]["width"].toString() + ";stroke:" + eventArgs["border"]["color"] + ";}";
  return styleEle;
}
function customizeStyle(id, className, eventArgs) {
  var styleEle = getElement2(id);
  if (!isNullOrUndefined(styleEle)) {
    styleEle.innerText = "." + className + "{fill:" + eventArgs["fill"] + ";fill-opacity:" + (!isNullOrUndefined(eventArgs["opacity"]) ? eventArgs["opacity"].toString() : "1") + ";stroke-width:" + eventArgs["border"]["width"].toString() + ";stroke-opacity:" + (!isNullOrUndefined(eventArgs["border"]["opacity"]) ? eventArgs["border"]["opacity"].toString() : "1") + ";stroke:" + eventArgs["border"]["color"] + "}";
  }
}
function triggerItemSelectionEvent(selectionSettings, map, targetElement, shapeData, data) {
  var border = {
    color: selectionSettings.border.color,
    width: selectionSettings.border.width / map.scale,
    opacity: selectionSettings.border.opacity
  };
  var eventArgs = {
    opacity: selectionSettings.opacity,
    fill: selectionSettings.fill,
    border,
    name: itemSelection,
    target: targetElement.id,
    cancel: false,
    shapeData,
    data,
    maps: map
  };
  map.trigger("itemSelection", eventArgs, function(observedArgs) {
    eventArgs.border.opacity = isNullOrUndefined(selectionSettings.border.opacity) ? selectionSettings.opacity : selectionSettings.border.opacity;
    map.shapeSelectionItem.push(eventArgs.shapeData);
    if (!getElement2("ShapeselectionMap")) {
      document.body.appendChild(createStyle("ShapeselectionMap", "ShapeselectionMapStyle", eventArgs));
    } else {
      customizeStyle("ShapeselectionMap", "ShapeselectionMapStyle", eventArgs);
    }
  });
}
function removeClass2(element) {
  element.removeAttribute("class");
}
function elementAnimate(element, delay, duration, point, maps, ele, radius) {
  if (radius === void 0) {
    radius = 0;
  }
  var centerX = point.x;
  var centerY = point.y;
  var height = 0;
  var transform = element.getAttribute("transform") || "";
  new Animation({}).animate(element, {
    duration: duration === 0 && animationMode === "Enable" ? 1e3 : duration,
    delay,
    progress: function(args) {
      if (args.timeStamp > args.delay && !maps.zoomModule.isPanningInProgress) {
        if (maps.isTileMap && height === 0) {
          var layerGroupElement = document.querySelector(".GroupElement");
          if (!isNullOrUndefined(layerGroupElement)) {
            layerGroupElement.style.display = "block";
          }
        }
        height = (args.timeStamp - args.delay) / args.duration;
        element.setAttribute("transform", "translate( " + (centerX - radius * height) + " " + (centerY - radius * height) + " ) scale(" + height + ")");
      } else {
        if (maps.zoomModule.isPanningInProgress) {
          transform = element.getAttribute("transform");
        }
      }
    },
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    end: function(model) {
      if (!maps.zoomModule.isPanningInProgress) {
        element.setAttribute("transform", transform);
      }
      maps.zoomModule.isPanningInProgress = false;
      if (!ele) {
        return;
      }
      var event = {
        cancel: false,
        name: animationComplete,
        element: ele,
        maps
      };
      maps.trigger(animationComplete, event);
    }
  });
}
function timeout(id) {
  removeElement2(id);
}
function showTooltip(text, size, x, y, areaWidth, areaHeight, id, element, isTouch) {
  var location2 = getMousePosition(x, y, element);
  if (!isNullOrUndefined(location2)) {
    x = location2.x;
    y = location2.y;
  }
  var tooltip = document.getElementById(id);
  var width = measureText2(text, {
    fontFamily: "Segoe UI",
    size: "8px",
    fontStyle: "Normal",
    fontWeight: "Regular"
  }).width;
  var str = text.split(" ");
  var demo = str[0].length;
  for (var i = 1; i < str.length; i++) {
    if (demo < str[i].length) {
      demo = str[i].length;
    }
  }
  if (!tooltip) {
    tooltip = createElement("div", {
      id
    });
    tooltip.style.cssText = 'background-color: rgb(255, 255, 255) !important; color:black !important; position:absolute;border:1px solid rgb(0, 0, 0); padding-left:5px;font-size:12px; font-family: "Segoe UI"; text-align:center';
  }
  if (x < areaWidth - width) {
    x = x;
  } else if (x > areaWidth - width && x < areaWidth - demo * 8) {
    width = areaWidth - x;
  } else if (x >= areaWidth - demo * 8) {
    if (x > width) {
      x = x - width;
    } else {
      width = x;
      x = 0;
    }
  }
  var size1 = size.split("px");
  wordWrap(tooltip, text, x, y, size1, width, areaWidth, element);
  var height = tooltip.clientHeight;
  if (height + parseInt(size1[0], 10) * 2 > areaHeight) {
    width = x;
    x = 0;
  }
  wordWrap(tooltip, text, x, y, size1, width, areaWidth, element);
  if (isTouch) {
    setTimeout(timeout, 5e3, id);
  }
}
function wordWrap(tooltip, text, x, y, size1, width, areaWidth, element) {
  tooltip.innerText = text;
  tooltip.style.top = tooltip.id.indexOf("_Legend") !== -1 ? (parseInt(size1[0], 10) + y).toString() + "px" : (parseInt(size1[0], 10) * 2).toString() + "px";
  tooltip.style.left = x.toString() + "px";
  tooltip.style.width = width.toString() + "px";
  tooltip.style.maxWidth = areaWidth.toString() + "px";
  tooltip.style.wordWrap = "break-word";
  element.appendChild(tooltip);
}
function createTooltip(id, text, top, left, settings) {
  var tooltip = getElement2(id);
  var borderColor = getHexColor(settings.borderColor);
  var fontColor = getHexColor(settings.fontColor);
  var style = "top:" + top.toString() + "px;left:" + left.toString() + "px;color:" + (fontColor ? "rgba(" + fontColor.r + "," + fontColor.g + "," + fontColor.b + "," + settings.fontOpacity + ")" : settings.fontColor) + ";background:" + settings.fill + ";z-index: 2;position:absolute;border:" + settings.borderWidth + "px solid " + (borderColor ? "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + settings.borderOpacity + ")" : settings.borderColor) + ";font-family:" + settings.fontFamily + ";font-style:" + settings.fontStyle + ";font-weight:" + settings.fontWeight + ";font-size:" + settings.fontSize + ";border-radius:" + settings.borderWidth + "px;";
  if (!tooltip && settings.visible) {
    tooltip = createElement("div", {
      id
    });
    tooltip.innerHTML = SanitizeHtmlHelper.sanitize("&nbsp;" + text + "&nbsp;");
    tooltip.style.cssText = style;
    document.body.appendChild(tooltip);
  } else if (settings.visible) {
    tooltip.innerHTML = SanitizeHtmlHelper.sanitize("&nbsp;" + text + "&nbsp;");
    tooltip.style.cssText = style;
  }
}
function getHexColor(color) {
  if (color.indexOf("#") !== -1 && color.toLowerCase().indexOf("rgb") === -1) {
    var colorArray = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
    return colorArray ? { r: parseInt(colorArray[1], 16), g: parseInt(colorArray[2], 16), b: parseInt(colorArray[3], 16) } : null;
  } else if (color.toLowerCase().indexOf("rgb") !== -1) {
    var colorArray = color.match(/\d+/g).map(function(a) {
      return parseInt(a, 10);
    });
    return colorArray ? { r: colorArray[0], g: colorArray[1], b: colorArray[2] } : null;
  } else {
    var divElment = document.createElement("div");
    divElment.style.color = color;
    var colorArray = window.getComputedStyle(document.body.appendChild(divElment)).color.match(/\d+/g).map(function(a) {
      return parseInt(a, 10);
    });
    document.body.removeChild(divElment);
    return colorArray ? { r: colorArray[0], g: colorArray[1], b: colorArray[2] } : null;
  }
}
function drawSymbol2(location2, shape, size, url, options) {
  var renderer = new SvgRenderer("");
  var temp = renderLegendShape(location2, size, shape, options, url);
  var htmlObject = renderer["draw" + temp.functionName](temp.renderOption);
  return htmlObject;
}
function renderLegendShape(location2, size, shape, options, url) {
  var renderPath;
  var functionName = "Path";
  var shapeWidth = size.width;
  var shapeHeight = size.height;
  var shapeX = location2.x;
  var shapeY = location2.y;
  var x = location2.x + -shapeWidth / 2;
  var y = location2.y + -shapeHeight / 2;
  options["stroke"] = shape === "HorizontalLine" || shape === "VerticalLine" || shape === "Cross" ? options["fill"] : options["stroke"];
  options["stroke-width"] = options["stroke-width"] === 0 && (shape === "HorizontalLine" || shape === "VerticalLine" || shape === "Cross") ? 1 : options["stroke-width"];
  switch (shape) {
    case "Circle":
    case "Bubble":
      functionName = "Ellipse";
      merge(options, { "rx": shapeWidth / 2, "ry": shapeHeight / 2, "cx": shapeX, "cy": shapeY });
      break;
    case "VerticalLine":
      renderPath = "M " + shapeX + " " + (shapeY + shapeHeight / 2) + " L " + shapeX + " " + (shapeY + -shapeHeight / 2);
      merge(options, { "d": renderPath });
      break;
    case "HorizontalLine":
      renderPath = "M " + shapeX + " " + shapeY + " L " + (shapeX + shapeWidth / 2) + " " + shapeY;
      merge(options, { "d": renderPath });
      break;
    case "Diamond":
      renderPath = "M " + x + " " + shapeY + " L " + shapeX + " " + (shapeY + -shapeHeight / 2) + " L " + (shapeX + shapeWidth / 2) + " " + shapeY + " L " + shapeX + " " + (shapeY + shapeHeight / 2) + " L " + x + " " + shapeY + " z";
      merge(options, { "d": renderPath });
      break;
    case "Rectangle":
      renderPath = "M " + x + " " + (shapeY + -shapeHeight / 2) + " L " + (shapeX + shapeWidth / 2) + " " + (shapeY + -shapeHeight / 2) + " L " + (shapeX + shapeWidth / 2) + " " + (shapeY + shapeHeight / 2) + " L " + x + " " + (shapeY + shapeHeight / 2) + " L " + x + " " + (shapeY + -shapeHeight / 2) + " z";
      merge(options, { "d": renderPath });
      break;
    case "Triangle":
      renderPath = "M " + x + " " + (shapeY + shapeHeight / 2) + " L " + shapeX + " " + (shapeY + -shapeHeight / 2) + " L " + (shapeX + shapeWidth / 2) + " " + (shapeY + shapeHeight / 2) + " L " + x + " " + (shapeY + shapeHeight / 2) + " z";
      merge(options, { "d": renderPath });
      break;
    case "InvertedTriangle":
      renderPath = "M " + (shapeX + shapeWidth / 2) + " " + (shapeY - shapeHeight / 2) + " L " + shapeX + " " + (shapeY + shapeHeight / 2) + " L " + (shapeX - shapeWidth / 2) + " " + (shapeY - shapeHeight / 2) + " L " + (shapeX + shapeWidth / 2) + " " + (shapeY - shapeHeight / 2) + " z";
      merge(options, { "d": renderPath });
      break;
    case "Pentagon":
      var eq = 72;
      var xValue = void 0;
      var yValue = void 0;
      for (var i = 0; i <= 5; i++) {
        xValue = shapeWidth / 2 * Math.cos(Math.PI / 180 * (i * eq));
        yValue = shapeWidth / 2 * Math.sin(Math.PI / 180 * (i * eq));
        if (i === 0) {
          renderPath = "M " + (shapeX + xValue) + " " + (shapeY + yValue) + " ";
        } else {
          renderPath = renderPath.concat("L " + (shapeX + xValue) + " " + (shapeY + yValue) + " ");
        }
      }
      renderPath = renderPath.concat("Z");
      merge(options, { "d": renderPath });
      break;
    case "Star":
      renderPath = "M " + (location2.x + size.width / 3) + " " + (location2.y + size.height / 2) + " L " + (location2.x - size.width / 2) + " " + (location2.y - size.height / 6) + " L " + (location2.x + size.width / 2) + " " + (location2.y - size.height / 6) + " L " + (location2.x - size.width / 3) + " " + (location2.y + size.height / 2) + " L " + location2.x + " " + (location2.y - size.height / 2) + " L " + (location2.x + size.width / 3) + " " + (location2.y + size.height / 2) + " Z";
      merge(options, { "d": renderPath });
      break;
    case "Cross":
      renderPath = "M " + x + " " + shapeY + " L " + (shapeX + shapeWidth / 2) + " " + shapeY + " M " + shapeX + " " + (shapeY + shapeHeight / 2) + " L " + shapeX + " " + (shapeY + -shapeHeight / 2);
      merge(options, { "d": renderPath });
      break;
    case "Image":
      functionName = "Image";
      merge(options, { "href": url, "height": shapeHeight, "width": shapeWidth, x, y });
      break;
  }
  return { renderOption: options, functionName };
}
function getElementOffset(childElement, parentElement) {
  parentElement.appendChild(childElement);
  var width = childElement.offsetWidth;
  var height = childElement.offsetHeight;
  parentElement.removeChild(childElement);
  return new Size2(width, height);
}
function changeBorderWidth(element, index, scale, maps) {
  var childNode;
  for (var l = 0; l < element.childElementCount; l++) {
    childNode = element.childNodes[l];
    if (childNode.id.indexOf("_NavigationGroup") > -1) {
      changeNavaigationLineWidth(childNode, index, scale, maps);
    } else if (childNode.id.indexOf("_Polygons_Group") > -1) {
      for (var i = 0; i < childNode.childElementCount; i++) {
        var width = maps.layersCollection[index].polygonSettings.polygons[parseInt(childNode.children[i].id.split("_PolygonIndex_")[1])].borderWidth;
        childNode.children[i].setAttribute("stroke-width", (width / scale).toString());
      }
    } else {
      var currentStroke = void 0;
      var value = 0;
      var borderWidthValue = maps.layersCollection[index].shapeSettings.borderWidthValuePath;
      var borderWidth = maps.layersCollection[index].shapeSettings.border.width;
      var circleRadius = maps.layersCollection[index].shapeSettings.circleRadius;
      if (maps.layersCollection[index].shapeSettings.borderWidthValuePath) {
        value = checkShapeDataFields(
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          maps.layersCollection[index].dataSource,
          maps.layersCollection[index].layerData[l]["property"],
          maps.layersCollection[index].shapeDataPath,
          maps.layersCollection[index].shapePropertyPath,
          maps.layersCollection[index]
        );
        if (value !== null) {
          if (maps.layersCollection[index].dataSource[value][borderWidthValue]) {
            currentStroke = maps.layersCollection[index].dataSource[value][borderWidthValue];
          } else {
            currentStroke = isNullOrUndefined(borderWidth) ? 0 : borderWidth;
          }
        } else {
          currentStroke = isNullOrUndefined(borderWidth) ? 0 : borderWidth;
        }
      } else {
        currentStroke = isNullOrUndefined(borderWidth) ? 0 : borderWidth;
      }
      childNode.setAttribute("stroke-width", (currentStroke / scale).toString());
      if (element.id.indexOf("_Point") > -1 || element.id.indexOf("_MultiPoint") > -1) {
        childNode.setAttribute("r", (circleRadius / scale).toString());
      }
    }
  }
}
function changeNavaigationLineWidth(element, index, scale, maps) {
  var node;
  for (var m = 0; m < element.childElementCount; m++) {
    node = element.childNodes[m];
    if (node.tagName === "path") {
      var currentStroke = maps.layersCollection[index].navigationLineSettings[parseFloat(node.id.split("_NavigationIndex_")[1].split("_")[0])].width;
      node.setAttribute("stroke-width", (currentStroke / scale).toString());
    }
  }
}
function targetTouches(event) {
  var targetTouches2 = [];
  var touches = event.touches;
  for (var i = 0; i < touches.length; i++) {
    targetTouches2.push({ pageX: touches[i].pageX, pageY: touches[i].pageY });
  }
  return targetTouches2;
}
function calculateScale(startTouches, endTouches) {
  var startDistance = getDistance(startTouches[0], startTouches[1]);
  var endDistance = getDistance(endTouches[0], endTouches[1]);
  return endDistance / startDistance;
}
function getDistance(a, b) {
  var x = a.pageX - b.pageX;
  var y = a.pageY - b.pageY;
  return Math.sqrt(x * x + y * y);
}
function getTouches(touches, maps) {
  var rect = maps.element.getBoundingClientRect();
  var posTop = rect.top + document.defaultView.pageXOffset;
  var posLeft = rect.left + document.defaultView.pageYOffset;
  return Array.prototype.slice.call(touches).map(function(touch) {
    return {
      x: touch.pageX - posLeft,
      y: touch.pageY - posTop
    };
  });
}
function getTouchCenter(touches) {
  return {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    x: touches.map(function(e) {
      return e["x"];
    }).reduce(sum) / touches.length,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    y: touches.map(function(e) {
      return e["y"];
    }).reduce(sum) / touches.length
  };
}
function sum(a, b) {
  return a + b;
}
function zoomAnimate(element, delay, duration, point, scale, size, maps) {
  var delta = 0;
  var previousLocation = maps.previousPoint;
  var preScale = maps.previousScale;
  var diffScale = scale - preScale;
  var currentLocation = new MapLocation(0, 0);
  var currentScale = 1;
  if (scale === preScale) {
    element.setAttribute("transform", "scale( " + scale + " ) translate( " + point.x + " " + point.y + " )");
    return;
  }
  var slope = function(previousLocation2, point2) {
    if (previousLocation2.x === point2.x) {
      return null;
    }
    return (point2.y - previousLocation2.y) / (point2.x - previousLocation2.x);
  };
  var intercept = function(point2, slopeValue) {
    if (slopeValue === null) {
      return point2.x;
    }
    return point2.y - slopeValue * point2.x;
  };
  var slopeFactor = slope(previousLocation, point);
  var slopeIntersection = intercept(previousLocation, slopeFactor);
  var horizontalDifference = point.x - previousLocation.x;
  var verticalDifference = point.y - previousLocation.y;
  animate(element, delay, duration, function(args) {
    if (args.timeStamp > args.delay) {
      delta = (args.timeStamp - args.delay) / args.duration;
      currentScale = preScale + delta * diffScale;
      currentLocation.x = previousLocation.x + delta * horizontalDifference / (currentScale / scale);
      if (slopeFactor == null) {
        currentLocation.y = previousLocation.y + delta * verticalDifference;
      } else {
        currentLocation.y = slopeFactor * currentLocation.x + slopeIntersection;
      }
      args.element.setAttribute("transform", "scale( " + currentScale + " ) translate( " + currentLocation.x + " " + currentLocation.y + " )");
      maps.translatePoint = currentLocation;
      maps.scale = currentScale;
      maps.zoomModule.processTemplate(point.x, point.y, currentScale, maps);
    }
  }, function() {
    maps.translatePoint = point;
    maps.scale = scale;
    element.setAttribute("transform", "scale( " + scale + " ) translate( " + point.x + " " + point.y + " )");
    maps.zoomModule.processTemplate(point.x, point.y, scale, maps);
  });
}
function animate(element, delay, duration, process, end) {
  var _this = this;
  var start = null;
  var clearAnimation;
  var markerStyle = "visibility:visible";
  duration = animationMode === "Disable" ? 0 : duration;
  var startAnimation = function(timestamp) {
    if (!start) {
      start = timestamp;
    }
    var progress = timestamp - start;
    if (progress < duration) {
      process.call(_this, { element, delay: 0, timeStamp: progress, duration });
      window.requestAnimationFrame(startAnimation);
    } else {
      window.cancelAnimationFrame(clearAnimation);
      end.call(_this, { element });
      if (element.id.indexOf("Marker") > -1) {
        var markerElement = getElementByID(element.id.split("_Layer")[0] + "_Markers_Group");
        markerElement.style.cssText = markerStyle;
      }
    }
  };
  clearAnimation = window.requestAnimationFrame(startAnimation);
}
var MapAjax = (
  /** @class */
  /* @__PURE__ */ (function() {
    function MapAjax2(options, type, async, contentType, sendData) {
      this.dataOptions = options;
      this.type = type || "GET";
      this.async = async || true;
      this.contentType = contentType;
      this.sendData = sendData;
    }
    return MapAjax2;
  })()
);
function smoothTranslate(element, delay, duration, point) {
  var delta = 0;
  var transform = element.getAttribute("transform").split(" ");
  if (transform.length === 2) {
    transform[2] = transform[1].split(")")[0];
    transform[1] = transform[0].split("(")[1];
  }
  var previousLocation = new MapLocation(parseInt(transform[1], 10), parseInt(transform[2], 10));
  var diffx = point.x - previousLocation.x;
  var diffy = point.y - previousLocation.y;
  var currentLocation = new MapLocation(0, 0);
  animate(element, delay, duration, function(args) {
    if (args.timeStamp > args.delay) {
      delta = (args.timeStamp - args.delay) / args.duration;
      currentLocation.x = previousLocation.x + delta * diffx;
      currentLocation.y = previousLocation.y + delta * diffy;
      args.element.setAttribute("transform", "translate( " + currentLocation.x + " " + currentLocation.y + " )");
    }
  }, function() {
    element.setAttribute("transform", "translate( " + point.x + " " + point.y + " )");
  });
}
function compareZoomFactor(scaleFactor, maps) {
  var previous = isNullOrUndefined(maps.shouldZoomPreviousFactor) ? null : maps.shouldZoomPreviousFactor;
  var current = isNullOrUndefined(maps.shouldZoomCurrentFactor) ? null : maps.shouldZoomCurrentFactor;
  if (!isNullOrUndefined(current)) {
    maps.shouldZoomCurrentFactor = null;
    maps.shouldZoomPreviousFactor = null;
  } else if (!isNullOrUndefined(previous) && isNullOrUndefined(current) && maps.shouldZoomPreviousFactor !== scaleFactor) {
    maps.shouldZoomCurrentFactor = scaleFactor;
  } else {
    maps.shouldZoomPreviousFactor = scaleFactor;
  }
}
function calculateZoomLevel(minLat, maxLat, minLong, maxLong, mapWidth, mapHeight, maps, isZoomToCoordinates) {
  var scaleFactor;
  var maxZoomFact = maps.zoomSettings.maxZoom;
  var applyMethodeZoom;
  var maxLatSin = Math.sin(maxLat * Math.PI / 180);
  var maxLatRad = Math.log((1 + maxLatSin) / (1 - maxLatSin)) / 2;
  var maxLatValue = Math.max(Math.min(maxLatRad, Math.PI), -Math.PI) / 2;
  var minLatSin = Math.sin(minLat * Math.PI / 180);
  var minLatRad = Math.log((1 + minLatSin) / (1 - minLatSin)) / 2;
  var minLatValue = Math.max(Math.min(minLatRad, Math.PI), -Math.PI) / 2;
  if (maps.zoomNotApplied && !maps.isTileMap) {
    var latiRatio = Math.abs((maps.baseMapBounds.latitude.max - maps.baseMapBounds.latitude.min) / (maxLat - minLat));
    var longiRatio = Math.abs((maps.baseMapBounds.longitude.max - maps.baseMapBounds.longitude.min) / (maxLong - minLong));
    applyMethodeZoom = isZoomToCoordinates ? (latiRatio + longiRatio) / 2 : Math.min(latiRatio, longiRatio);
  }
  var latRatio = (maxLatValue - minLatValue) / Math.PI;
  var lngDiff = maxLong - minLong;
  var lngRatio = (lngDiff < 0 ? lngDiff + 360 : lngDiff) / 360;
  var WORLD_PX_HEIGHT = 256;
  var WORLD_PX_WIDTH = 256;
  var latZoom = Math.log(mapHeight / WORLD_PX_HEIGHT / latRatio) / Math.LN2;
  var lngZoom = Math.log(mapWidth / WORLD_PX_WIDTH / lngRatio) / Math.LN2;
  var result = maps.zoomNotApplied && !maps.isTileMap ? applyMethodeZoom : isZoomToCoordinates && !maps.isTileMap ? (latZoom + lngZoom) / 2 : Math.min(latZoom, lngZoom);
  scaleFactor = Math.min(result, maxZoomFact);
  scaleFactor = maps.isTileMap || !maps.zoomNotApplied ? Math.floor(scaleFactor) : scaleFactor;
  if (!maps.isTileMap) {
    compareZoomFactor(scaleFactor, maps);
  }
  return scaleFactor;
}
function processResult(e) {
  var dataValue;
  var resultValue = !isNullOrUndefined(e["result"]) ? e["result"] : e["actual"];
  if (isNullOrUndefined(resultValue.length)) {
    if (!isNullOrUndefined(resultValue["Items"])) {
      dataValue = resultValue["Items"];
    }
  } else {
    dataValue = resultValue;
  }
  return dataValue;
}

// node_modules/@syncfusion/ej2-maps/src/maps/model/theme.js
var Theme;
(function(Theme2) {
  Theme2.mapsTitleFont = {
    size: "14px",
    fontWeight: null,
    color: "#424242",
    fontStyle: "Medium",
    fontFamily: "Roboto, Noto, Sans-serif"
  };
  Theme2.mapsSubTitleFont = {
    size: "13px",
    fontWeight: null,
    color: "#424242",
    fontStyle: "Medium",
    fontFamily: "Roboto, Noto, Sans-serif"
  };
  Theme2.tooltipLabelFont = {
    size: "12px",
    fontWeight: "Regular",
    color: null,
    fontStyle: "Regular",
    fontFamily: null
  };
  Theme2.legendTitleFont = {
    size: "12px",
    fontWeight: "Medium",
    color: null,
    fontStyle: "Medium",
    fontFamily: null
  };
  Theme2.legendLabelFont = {
    size: "13px",
    fontWeight: "Medium",
    color: null,
    fontStyle: "Medium",
    fontFamily: "Roboto, Noto, Sans-serif"
  };
  Theme2.dataLabelFont = {
    size: null,
    fontWeight: "Medium",
    color: "#000000",
    fontStyle: "Medium",
    fontFamily: "Roboto, Noto, Sans-serif"
  };
})(Theme || (Theme = {}));
var FabricTheme;
(function(FabricTheme2) {
  FabricTheme2.mapsTitleFont = {
    size: "14px",
    fontWeight: "Semibold",
    color: "#424242",
    fontStyle: "Semibold",
    fontFamily: "SegoeUI, Helvetica Neue, Helvetica, Arial, sans-serif"
  };
  FabricTheme2.mapsSubTitleFont = {
    size: "13px",
    fontWeight: "Regular",
    color: "#424242",
    fontStyle: "Regular",
    fontFamily: "SegoeUI, Helvetica Neue, Helvetica, Arial, sans-serif"
  };
  FabricTheme2.tooltipLabelFont = {
    size: "12px",
    fontWeight: "Regular",
    color: "#FFFFFF",
    fontStyle: "Regular",
    fontFamily: "Roboto"
  };
  FabricTheme2.legendTitleFont = {
    size: "14px",
    fontWeight: "Regular",
    color: "#757575",
    fontStyle: "Regular",
    fontFamily: "SegoeUI, Helvetica Neue, Helvetica, Arial, sans-serif"
  };
  FabricTheme2.legendLabelFont = {
    size: "13px",
    fontWeight: "Medium",
    color: "#757575",
    fontStyle: "Medium",
    fontFamily: "SegoeUI, Helvetica Neue, Helvetica, Arial, sans-serif"
  };
  FabricTheme2.dataLabelFont = {
    size: "12px",
    fontWeight: "Medium",
    color: "#000000",
    fontStyle: "Medium",
    fontFamily: "SegoeUI, Helvetica Neue, Helvetica, Arial, sans-serif"
  };
})(FabricTheme || (FabricTheme = {}));
var BootstrapTheme;
(function(BootstrapTheme2) {
  BootstrapTheme2.mapsTitleFont = {
    size: "14px",
    fontWeight: "Semibold",
    color: "#424242",
    fontStyle: "Semibold",
    fontFamily: "Helvetica Neue, Helvetica, Arial, sans-serif"
  };
  BootstrapTheme2.mapsSubTitleFont = {
    size: "13px",
    fontWeight: "Regular",
    color: "#424242",
    fontStyle: "Regular",
    fontFamily: "Helvetica Neue, Helvetica, Arial, sans-serif"
  };
  BootstrapTheme2.tooltipLabelFont = {
    size: "12px",
    fontWeight: "Regular",
    color: "#FFFFFF",
    fontStyle: "Regular",
    fontFamily: "Roboto"
  };
  BootstrapTheme2.legendTitleFont = {
    size: "14px",
    fontWeight: "Regular",
    color: "#757575",
    fontStyle: "Regular",
    fontFamily: "Helvetica Neue, Helvetica, Arial, sans-serif"
  };
  BootstrapTheme2.legendLabelFont = {
    size: "13px",
    fontWeight: "Medium",
    color: "#757575",
    fontStyle: "Medium",
    fontFamily: "Helvetica Neue, Helvetica, Arial, sans-serif"
  };
  BootstrapTheme2.dataLabelFont = {
    size: "12px",
    fontWeight: "Medium",
    color: "#000000",
    fontStyle: "Medium",
    fontFamily: "Helvetica Neue, Helvetica, Arial, sans-serif"
  };
})(BootstrapTheme || (BootstrapTheme = {}));
function getShapeColor(theme) {
  var themePalette;
  switch (theme.toLowerCase()) {
    case "tailwind":
      themePalette = [
        "#0369A1",
        "#14B8A6",
        "#15803D",
        "#334155",
        "#5A61F6",
        "#65A30D",
        "#8B5CF6",
        "#9333EA",
        "#F59E0B",
        "#F97316"
      ];
      break;
    case "tailwinddark":
      themePalette = [
        "#10B981",
        "#22D3EE",
        "#2DD4BF",
        "#4ADE80",
        "#8B5CF6",
        "#E879F9",
        "#F472B6",
        "#F87171",
        "#F97316",
        "#FCD34D"
      ];
      break;
    case "tailwind3":
      themePalette = ["#2F4074", "#03B4B4", "#0D72DE", "#FF5733", "#D63384", "#F39C12", "#EF291F", "#91C822"];
      break;
    case "tailwind3dark":
      themePalette = ["#8029F1", "#1ABC9C", "#0D72DE", "#FF5733", "#D63384", "#F39C12", "#EF291F", "#91C822"];
      break;
    case "fluent":
      themePalette = [
        "#614570",
        "#4C6FB1",
        "#CC6952",
        "#3F579A",
        "#4EA09B",
        "#6E7A89",
        "#D4515C",
        "#E6AF5D",
        "#639751",
        "#9D4D69"
      ];
      break;
    case "fluentdark":
      themePalette = [
        "#8AB113",
        "#2A72D5",
        "#43B786",
        "#584EC6",
        "#E85F9C",
        "#6E7A89",
        "#EA6266",
        "#EBA844",
        "#26BC7A",
        "#BC4870"
      ];
      break;
    case "material3":
      themePalette = [
        "#6200EE",
        "#E77A16",
        "#82C100",
        "#7107DC",
        "#05BB3D",
        "#D21020",
        "#FAD200",
        "#0085FF",
        "#9204EA",
        "#08EE9B"
      ];
      break;
    case "material3dark":
      themePalette = [
        "#4EAAFF",
        "#FA4EAB",
        "#FFF500",
        "#17EA58",
        "#38FFE7",
        "#FF9E45",
        "#B3F32F",
        "#B93CE4",
        "#FC5664",
        "#9B55FF"
      ];
      break;
    case "fluent2":
      themePalette = [
        "#6200EE",
        "#09AF74",
        "#0076E5",
        "#CB3587",
        "#E7910F",
        "#0364DE",
        "#66CD15",
        "#F3A93C",
        "#107C10",
        "#C19C00"
      ];
      break;
    case "fluent2dark":
    case "fluent2highcontrast":
      themePalette = [
        "#9BB449",
        "#2A72D5",
        "#43B786",
        "#3F579A",
        "#584EC6",
        "#E85F9C",
        "#6E7A89",
        "#EA6266",
        "#0B6A0B",
        "#C19C00"
      ];
      break;
    case "bootstrap5":
    case "bootstrap5dark":
      themePalette = [
        "#6610F2",
        "#6f42C1",
        "#D63384",
        "#DC3545",
        "#FD7E14",
        "#FFC107",
        "#198754",
        "#0DCAF0"
      ];
      break;
    default:
      themePalette = [
        "#B5E485",
        "#7BC1E8",
        "#DF819C",
        "#EC9B79",
        "#78D0D3",
        "#D6D572",
        "#9178E3",
        "#A1E5B4",
        "#87A4B4",
        "#E4C16C"
      ];
      break;
  }
  return themePalette;
}
var HighContrastTheme;
(function(HighContrastTheme2) {
  HighContrastTheme2.mapsTitleFont = {
    size: "14px",
    fontWeight: "Medium",
    color: "#FFFFFF",
    fontStyle: "Medium",
    fontFamily: "Roboto, Noto, Sans-serif"
  };
  HighContrastTheme2.mapsSubTitleFont = {
    size: "13px",
    fontWeight: "Medium",
    color: "#FFFFFF",
    fontStyle: "Medium",
    fontFamily: "Roboto, Noto, Sans-serif"
  };
  HighContrastTheme2.tooltipLabelFont = {
    size: "12px",
    fontWeight: "Regular",
    color: "#000000",
    fontStyle: "Regular",
    fontFamily: "Roboto"
  };
  HighContrastTheme2.legendTitleFont = {
    size: "14px",
    fontWeight: "Regular",
    color: "#FFFFFF",
    fontStyle: "Regular",
    fontFamily: "Roboto, Noto, Sans-serif"
  };
  HighContrastTheme2.legendLabelFont = {
    size: "13px",
    fontWeight: "Medium",
    color: "#FFFFFF",
    fontStyle: "Medium",
    fontFamily: "Roboto, Noto, Sans-serif"
  };
  HighContrastTheme2.dataLabelFont = {
    size: null,
    fontWeight: "Medium",
    color: "#000000",
    fontStyle: "Medium",
    fontFamily: "Roboto, Noto, Sans-serif"
  };
})(HighContrastTheme || (HighContrastTheme = {}));
var DarkTheme;
(function(DarkTheme2) {
  DarkTheme2.mapsTitleFont = {
    fontFamily: "Roboto, Noto, Sans-serif",
    fontWeight: "Medium",
    size: "14px",
    fontStyle: "Medium",
    color: "#FFFFFF"
  };
  DarkTheme2.mapsSubTitleFont = {
    size: "13px",
    color: "#FFFFFF",
    fontWeight: "Medium",
    fontFamily: "Roboto, Noto, Sans-serif",
    fontStyle: "Medium"
  };
  DarkTheme2.tooltipLabelFont = {
    size: "12px",
    color: "#282727",
    fontWeight: "Regular",
    fontFamily: "Roboto",
    fontStyle: "Regular"
  };
  DarkTheme2.legendTitleFont = {
    size: "14px",
    fontWeight: "Regular",
    color: "#FFFFFF",
    fontStyle: "Regular",
    fontFamily: "Roboto, Noto, Sans-serif"
  };
  DarkTheme2.legendLabelFont = {
    size: "13px",
    fontFamily: "Roboto, Noto, Sans-serif",
    fontWeight: "Medium",
    color: "#DADADA",
    fontStyle: "Medium"
  };
})(DarkTheme || (DarkTheme = {}));
function getThemeStyle(theme) {
  var style;
  var color;
  switch (theme.toLowerCase()) {
    case "materialdark":
      color = "#303030";
      break;
    case "fabricdark":
      color = "#201F1F";
      break;
    case "bootstrapdark":
      color = "#1A1A1A";
      break;
  }
  switch (theme.toLowerCase()) {
    case "materialdark":
    case "fabricdark":
    case "bootstrapdark":
      style = {
        backgroundColor: color,
        areaBackgroundColor: color,
        titleFontColor: "#FFFFFF",
        titleFontSize: "14px",
        subTitleFontColor: "#FFFFFF",
        legendTitleFontColor: "#DADADA",
        legendTextColor: "#DADADA",
        dataLabelFontColor: "#DADADA",
        tooltipFontColor: "#FFFFFF",
        tooltipFillColor: "#363F4C",
        zoomFillColor: "#FFFFFF",
        labelFontFamily: "Roboto, Noto, Sans-serif",
        fontFamily: "Roboto, Noto, Sans-serif",
        fontSize: "12px",
        legendFontSize: "12px",
        fontWeight: "Medium",
        titleFontWeight: "Medium",
        zoomSelectionColor: "#e61576",
        shapeFill: "#A6A6A6",
        shapeBorderColor: "#000000",
        rectangleZoomFillColor: "#d3d3d3",
        rectangleZoomFillOpacity: 0.5,
        rectangleZoomBorderColor: "#009900",
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent",
        zoomButtonRadius: 30
      };
      break;
    case "highcontrast":
      style = {
        backgroundColor: "#000000",
        areaBackgroundColor: "#000000",
        titleFontColor: "#FFFFFF",
        titleFontSize: "14px",
        subTitleFontColor: "#FFFFFF",
        legendTitleFontColor: "#FFFFFF",
        legendTextColor: "#FFFFFF",
        dataLabelFontColor: "#000000",
        tooltipFontColor: "#000000",
        tooltipFillColor: "#ffffff",
        zoomFillColor: "#FFFFFF",
        fontFamily: "Roboto, Noto, Sans-serif",
        fontSize: "12px",
        legendFontSize: "12px",
        fontWeight: "Medium",
        labelFontFamily: "Roboto, Noto, Sans-serif",
        titleFontWeight: "Medium",
        zoomSelectionColor: "#e61576",
        shapeFill: "#A6A6A6",
        shapeBorderColor: "#000000",
        rectangleZoomFillColor: "#d3d3d3",
        rectangleZoomFillOpacity: 0.5,
        rectangleZoomBorderColor: "#009900",
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent",
        zoomButtonRadius: 30
      };
      break;
    case "bootstrap4":
      style = {
        backgroundColor: "#FFFFFF",
        areaBackgroundColor: "#FFFFFF",
        titleFontColor: "#212529",
        subTitleFontColor: "#212529",
        legendTitleFontColor: "#212529",
        legendTextColor: "#212529",
        dataLabelFontColor: "#212529",
        tooltipFontColor: "#FFFFFF",
        tooltipFillColor: "#000000",
        zoomFillColor: "#5B6269",
        fontFamily: "HelveticaNeue-Medium",
        fontSize: "12px",
        fontWeight: "Medium",
        titleFontSize: "16px",
        legendFontSize: "14px",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 0.9,
        labelFontFamily: "HelveticaNeue-Medium",
        titleFontWeight: "Medium",
        zoomSelectionColor: "#e61576",
        shapeFill: "#A6A6A6",
        shapeBorderColor: "#000000",
        rectangleZoomFillColor: "#d3d3d3",
        rectangleZoomFillOpacity: 0.5,
        rectangleZoomBorderColor: "#009900",
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent",
        zoomButtonRadius: 30
      };
      break;
    case "tailwind":
      style = {
        backgroundColor: "rgba(255,255,255, 0.0)",
        areaBackgroundColor: "rgba(255,255,255, 0.0)",
        titleFontColor: "#374151",
        subTitleFontColor: "#374151",
        legendTitleFontColor: "#374151",
        legendTextColor: "#6B7280",
        dataLabelFontColor: "#505967",
        tooltipFontColor: "#F9FAFB",
        tooltipFillColor: "#111827",
        zoomFillColor: "#6b7280",
        fontFamily: "Inter",
        fontSize: "12px",
        fontWeight: "Medium",
        titleFontSize: "14px",
        legendFontSize: "12px",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 0.9,
        labelFontFamily: "Inter",
        titleFontWeight: "500",
        zoomSelectionColor: "#374151",
        shapeFill: "#E5E7EB",
        shapeBorderColor: "#000000",
        rectangleZoomFillColor: "#d3d3d3",
        rectangleZoomFillOpacity: 0.5,
        rectangleZoomBorderColor: "#009900",
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent",
        zoomButtonRadius: 30
      };
      break;
    case "tailwinddark":
      style = {
        backgroundColor: "rgba(255,255,255, 0.0)",
        areaBackgroundColor: "rgba(255,255,255, 0.0)",
        titleFontColor: "#D1D5DB",
        subTitleFontColor: "#D1D5DB",
        legendTitleFontColor: "#D1D5DB",
        legendTextColor: "#D1D5DB",
        dataLabelFontColor: "#D1D5DB",
        tooltipFontColor: "#1F2937",
        tooltipFillColor: "#F9FAFB",
        zoomFillColor: "#D1D5DB",
        fontFamily: "Inter",
        fontSize: "12px",
        fontWeight: "Medium",
        titleFontSize: "14px",
        legendFontSize: "12px",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 0.9,
        labelFontFamily: "Inter",
        titleFontWeight: "500",
        zoomSelectionColor: "#F3F4F6",
        shapeFill: "#374151",
        shapeBorderColor: "#000000",
        rectangleZoomFillColor: "#d3d3d3",
        rectangleZoomFillOpacity: 0.5,
        rectangleZoomBorderColor: "#009900",
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent",
        zoomButtonRadius: 30
      };
      break;
    case "tailwind3":
      style = {
        backgroundColor: "rgba(255,255,255, 0.0)",
        areaBackgroundColor: "rgba(255,255,255, 0.0)",
        titleFontColor: "#111827",
        subTitleFontColor: "#111827",
        legendTitleFontColor: "#111827",
        legendTextColor: "#6B7280",
        dataLabelFontColor: "#111827",
        tooltipFontColor: "#F9FAFB",
        tooltipFillColor: "#111827",
        zoomFillColor: "#374151",
        fontFamily: "Inter",
        fontSize: "12px",
        fontWeight: "400",
        titleFontSize: "14px",
        legendFontSize: "12px",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Inter",
        titleFontWeight: "500",
        zoomSelectionColor: "#6B7280",
        shapeFill: "#F3F4F6",
        shapeBorderColor: "#E5E7EB",
        rectangleZoomFillColor: "#818CF8",
        rectangleZoomFillOpacity: 0.3,
        rectangleZoomBorderColor: "#4F46E5",
        legendBorderColor: "#E5E7EB",
        legendBorderWidth: 0,
        tooltipBorderColor: "#111827",
        zoomButtonRadius: 32
      };
      break;
    case "tailwind3dark":
      style = {
        backgroundColor: "rgba(255,255,255, 0.0)",
        areaBackgroundColor: "rgba(255,255,255, 0.0)",
        titleFontColor: "#FFFFFF",
        subTitleFontColor: "#FFFFFF",
        legendTitleFontColor: "#FFFFFF",
        legendTextColor: "#9CA3AF",
        dataLabelFontColor: "#FFFFFF",
        tooltipFontColor: "#1F2937",
        tooltipFillColor: "#F9FAFB",
        zoomFillColor: "#D1D5DB",
        fontFamily: "Inter",
        fontSize: "12px",
        fontWeight: "400",
        titleFontSize: "14px",
        legendFontSize: "12px",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Inter",
        titleFontWeight: "600",
        zoomSelectionColor: "#9CA3AF",
        shapeFill: "#282F3C",
        shapeBorderColor: "#282F3C",
        rectangleZoomFillColor: "#3730A3",
        rectangleZoomFillOpacity: 0.3,
        rectangleZoomBorderColor: "#6366F1",
        legendBorderColor: "#282F3C",
        legendBorderWidth: 0,
        tooltipBorderColor: "#F9FAFB",
        zoomButtonRadius: 30
      };
      break;
    case "bootstrap5":
      style = {
        backgroundColor: "transparent",
        areaBackgroundColor: "transparent",
        titleFontColor: "#212529",
        subTitleFontColor: "#212529",
        legendTitleFontColor: "#212529",
        legendTextColor: "#212529",
        dataLabelFontColor: "#212529",
        tooltipFontColor: "#FFFFFF",
        tooltipFillColor: "#000000",
        zoomFillColor: "#6E757D",
        fontFamily: "Segoe UI",
        fontSize: "10px",
        fontWeight: "400",
        titleFontSize: "14px",
        subTitleFontSize: "12px",
        legendFontSize: "10px",
        tooltipFillOpacity: 0.9,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        titleFontWeight: "400",
        zoomSelectionColor: "#212529",
        zoomBorderColor: "#DEE2E6",
        shapeFill: "#E9ECEF",
        shapeBorderColor: "#DEE2E6",
        zoomButtonRadius: 32,
        rectangleZoomBorderColor: "#0D6EFD",
        rectangleZoomFillColor: "#86B7FE",
        rectangleZoomFillOpacity: 0.3,
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent"
      };
      break;
    case "bootstrap5dark":
      style = {
        backgroundColor: "transparent",
        areaBackgroundColor: "transparent",
        titleFontColor: "#DEE2E6",
        subTitleFontColor: "#DEE2E6",
        legendTitleFontColor: "#DEE2E6",
        legendTextColor: "#DEE2E6",
        dataLabelFontColor: "#DEE2E6",
        tooltipFontColor: "#212529",
        tooltipFillColor: "#FFFFFF",
        zoomFillColor: "#ADB5BD",
        fontFamily: "Segoe UI",
        fontSize: "10px",
        fontWeight: "400",
        titleFontSize: "14px",
        subTitleFontSize: "12px",
        legendFontSize: "10px",
        tooltipFillOpacity: 0.9,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        titleFontWeight: "400",
        zoomSelectionColor: "#F8F9FA",
        zoomBorderColor: "#495057",
        shapeFill: "#343A40",
        shapeBorderColor: "#495057",
        zoomButtonRadius: 32,
        rectangleZoomFillColor: "#86B7FE",
        rectangleZoomBorderColor: "#0D6EFD",
        rectangleZoomFillOpacity: 0.3,
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent"
      };
      break;
    case "fluent":
      style = {
        backgroundColor: "rgba(255,255,255, 0.0)",
        areaBackgroundColor: "rgba(255,255,255, 0.0)",
        titleFontColor: "#201F1E",
        subTitleFontColor: "#201F1E",
        legendTitleFontColor: "#201F1E",
        legendTextColor: "#201F1E",
        dataLabelFontColor: "#201F1E",
        tooltipFontColor: "#323130",
        tooltipFillColor: "#FFFFFF",
        zoomFillColor: "#A19F9D",
        fontFamily: "Segoe UI",
        fontSize: "12px",
        fontWeight: "Medium",
        titleFontSize: "14px",
        legendFontSize: "12px",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        titleFontWeight: "600",
        zoomSelectionColor: "#323130",
        shapeFill: "#F3F2F1",
        shapeBorderColor: "#000000",
        rectangleZoomFillColor: "#d3d3d3",
        rectangleZoomFillOpacity: 0.5,
        rectangleZoomBorderColor: "#009900",
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent",
        zoomButtonRadius: 30
      };
      break;
    case "fluentdark":
      style = {
        backgroundColor: "rgba(255,255,255, 0.0)",
        areaBackgroundColor: "rgba(255,255,255, 0.0)",
        titleFontColor: "#F3F2F1",
        subTitleFontColor: "#F3F2F1",
        legendTitleFontColor: "#F3F2F1",
        legendTextColor: "#F3F2F1",
        dataLabelFontColor: "#F3F2F1",
        tooltipFontColor: "#F3F2F1",
        tooltipFillColor: "#252423",
        zoomFillColor: "#484644",
        fontFamily: "Segoe UI",
        fontSize: "12px",
        fontWeight: "Medium",
        titleFontSize: "14px",
        legendFontSize: "12px",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        titleFontWeight: "600",
        zoomSelectionColor: "#F3F2F1",
        shapeFill: "#252423",
        shapeBorderColor: "#000000",
        rectangleZoomFillColor: "#d3d3d3",
        rectangleZoomFillOpacity: 0.5,
        rectangleZoomBorderColor: "#009900",
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent",
        zoomButtonRadius: 30
      };
      break;
    case "material3":
      style = {
        backgroundColor: "transparent",
        areaBackgroundColor: "transparent",
        titleFontColor: "#1C1B1F",
        subTitleFontColor: "#1C1B1F",
        legendTitleFontColor: "#1C1B1F",
        legendTextColor: "#49454E",
        dataLabelFontColor: "#1C1B1F",
        tooltipFontColor: "#F4EFF4",
        tooltipFillColor: "#313033",
        zoomFillColor: "#49454E",
        fontFamily: "Roboto",
        fontSize: "14px",
        titleFontSize: "16px",
        subTitleFontSize: "14px",
        legendFontSize: "12px",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Roboto",
        titleFontWeight: "500",
        fontWeight: "400",
        zoomSelectionColor: "#49454E",
        shapeFill: "#E7E0EC",
        shapeBorderColor: "#000000",
        rectangleZoomFillColor: "#6750A4",
        rectangleZoomFillOpacity: 0.24,
        rectangleZoomBorderColor: "#6750A4",
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent",
        zoomButtonRadius: 30
      };
      break;
    case "material3dark":
      style = {
        backgroundColor: "transparent",
        areaBackgroundColor: "transparent",
        titleFontColor: "#E6E1E5",
        subTitleFontColor: "#E6E1E5",
        legendTitleFontColor: "#E6E1E5",
        legendTextColor: "#CAC4D0",
        dataLabelFontColor: "#E6E1E5",
        tooltipFontColor: "#313033",
        tooltipFillColor: "#E6E1E5",
        zoomFillColor: "#E6E1E5",
        fontFamily: "Roboto",
        fontSize: "14px",
        titleFontSize: "16px",
        subTitleFontSize: "14px",
        legendFontSize: "12px",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Roboto",
        titleFontWeight: "500",
        fontWeight: "400",
        zoomSelectionColor: "#E6E1E5",
        shapeFill: "#49454F",
        shapeBorderColor: "#000000",
        rectangleZoomFillColor: "#D0BCFF",
        rectangleZoomFillOpacity: 0.24,
        rectangleZoomBorderColor: "#D0BCFF",
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent",
        zoomButtonRadius: 30
      };
      break;
    case "fluent2":
      style = {
        backgroundColor: "transparent",
        areaBackgroundColor: "transparent",
        titleFontColor: "#242424",
        subTitleFontColor: "#242424",
        legendTitleFontColor: "#242424",
        legendTextColor: "#242424",
        dataLabelFontColor: "#242424",
        tooltipFontColor: "#242424",
        tooltipFillColor: "#FFFFFF",
        zoomFillColor: "#D1D1D1",
        fontFamily: "Segoe UI",
        fontSize: "10px",
        fontWeight: "400",
        titleFontSize: "14px",
        subTitleFontSize: "12px",
        legendFontSize: "12px",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        titleFontWeight: "600",
        zoomSelectionColor: "#242424",
        shapeFill: "#E6E6E6",
        shapeBorderColor: "#EBEBEB",
        rectangleZoomFillColor: "#B4D6FA",
        rectangleZoomFillOpacity: 0.25,
        rectangleZoomBorderColor: "#0F6CBD",
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent",
        zoomButtonRadius: 32
      };
      break;
    case "fluent2dark":
      style = {
        backgroundColor: "transparent",
        areaBackgroundColor: "transparent",
        titleFontColor: "#FFFFFF",
        subTitleFontColor: "#FFFFFF",
        legendTitleFontColor: "#FFFFFF",
        legendTextColor: "#FFFFFF",
        dataLabelFontColor: "#FFFFFF",
        tooltipFontColor: "#FFFFFF",
        tooltipFillColor: "#292929",
        zoomFillColor: "#666",
        fontFamily: "Segoe UI",
        fontSize: "10px",
        fontWeight: "400",
        titleFontSize: "14px",
        subTitleFontSize: "12px",
        legendFontSize: "12px",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        titleFontWeight: "600",
        zoomSelectionColor: "#FFFFFF",
        shapeFill: "#333333",
        shapeBorderColor: "#000000",
        rectangleZoomFillColor: "#0E4775",
        rectangleZoomFillOpacity: 0.25,
        rectangleZoomBorderColor: "#0E4775",
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent",
        zoomButtonRadius: 32
      };
      break;
    case "fluent2highcontrast":
      style = {
        backgroundColor: "transparent",
        areaBackgroundColor: "transparent",
        titleFontColor: "#FFFFFF",
        subTitleFontColor: "#FFFFFF",
        legendTitleFontColor: "#FFFFFF",
        legendTextColor: "#FFFFFF",
        dataLabelFontColor: "#FFFFFF",
        tooltipFontColor: "#FFFFFF",
        tooltipFillColor: "#000000",
        zoomFillColor: "#3FF23F",
        fontFamily: "Segoe UI",
        fontSize: "10px",
        fontWeight: "400",
        titleFontSize: "14px",
        subTitleFontSize: "12px",
        legendFontSize: "12px",
        tooltipFillOpacity: 1,
        tooltipTextOpacity: 1,
        labelFontFamily: "Segoe UI",
        titleFontWeight: "600",
        zoomSelectionColor: "#FFFFFF",
        zoomBorderColor: "#FFFFFF",
        shapeFill: "#FFFFFF",
        shapeBorderColor: "#FFFFFF",
        rectangleZoomFillColor: "#1AEBFF",
        rectangleZoomFillOpacity: 0.25,
        rectangleZoomBorderColor: "#1AEBFF",
        legendBorderColor: "#FFFFFF",
        legendBorderWidth: 1,
        tooltipBorderColor: "#FFF",
        zoomButtonRadius: 32
      };
      break;
    default:
      style = {
        backgroundColor: "#FFFFFF",
        areaBackgroundColor: "#FFFFFF",
        titleFontColor: "#424242",
        titleFontSize: "14px",
        subTitleFontColor: "#424242",
        legendTitleFontColor: "#757575",
        legendTextColor: "#757575",
        dataLabelFontColor: "#000000",
        tooltipFontColor: "#FFFFFF",
        tooltipFillColor: "#000000",
        zoomFillColor: "#737373",
        labelFontFamily: "Roboto, Noto, Sans-serif",
        fontFamily: "Roboto, Noto, Sans-serif",
        fontSize: "12px",
        legendFontSize: "12px",
        fontWeight: "Medium",
        titleFontWeight: "Medium",
        zoomSelectionColor: "#e61576",
        shapeFill: "#A6A6A6",
        shapeBorderColor: "#000000",
        rectangleZoomFillColor: "#d3d3d3",
        rectangleZoomFillOpacity: 0.5,
        rectangleZoomBorderColor: "#009900",
        legendBorderColor: "#000000",
        legendBorderWidth: 0,
        tooltipBorderColor: "transparent",
        zoomButtonRadius: 30
      };
      break;
  }
  return style;
}

// node_modules/@syncfusion/ej2-maps/src/maps/model/base.js
var __extends20 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Annotation = (
  /** @class */
  (function(_super) {
    __extends20(Annotation2, _super);
    function Annotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property("")
    ], Annotation2.prototype, "content", void 0);
    __decorate8([
      Property("0px")
    ], Annotation2.prototype, "x", void 0);
    __decorate8([
      Property("0px")
    ], Annotation2.prototype, "y", void 0);
    __decorate8([
      Property("None")
    ], Annotation2.prototype, "verticalAlignment", void 0);
    __decorate8([
      Property("None")
    ], Annotation2.prototype, "horizontalAlignment", void 0);
    __decorate8([
      Property("-1")
    ], Annotation2.prototype, "zIndex", void 0);
    return Annotation2;
  })(ChildProperty)
);
var Arrow = (
  /** @class */
  (function(_super) {
    __extends20(Arrow2, _super);
    function Arrow2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property("Start")
    ], Arrow2.prototype, "position", void 0);
    __decorate8([
      Property("false")
    ], Arrow2.prototype, "showArrow", void 0);
    __decorate8([
      Property(2)
    ], Arrow2.prototype, "size", void 0);
    __decorate8([
      Property("black")
    ], Arrow2.prototype, "color", void 0);
    __decorate8([
      Property(0)
    ], Arrow2.prototype, "offSet", void 0);
    return Arrow2;
  })(ChildProperty)
);
var Font = (
  /** @class */
  (function(_super) {
    __extends20(Font2, _super);
    function Font2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(null)
    ], Font2.prototype, "size", void 0);
    __decorate8([
      Property(null)
    ], Font2.prototype, "color", void 0);
    __decorate8([
      Property("Roboto, Noto, Sans-serif")
    ], Font2.prototype, "fontFamily", void 0);
    __decorate8([
      Property("Medium")
    ], Font2.prototype, "fontWeight", void 0);
    __decorate8([
      Property("Medium")
    ], Font2.prototype, "fontStyle", void 0);
    __decorate8([
      Property(1)
    ], Font2.prototype, "opacity", void 0);
    return Font2;
  })(ChildProperty)
);
var ZoomToolbarButtonSettings = (
  /** @class */
  (function(_super) {
    __extends20(ZoomToolbarButtonSettings2, _super);
    function ZoomToolbarButtonSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property("transparent")
    ], ZoomToolbarButtonSettings2.prototype, "fill", void 0);
    __decorate8([
      Property(null)
    ], ZoomToolbarButtonSettings2.prototype, "color", void 0);
    __decorate8([
      Property(1)
    ], ZoomToolbarButtonSettings2.prototype, "borderOpacity", void 0);
    __decorate8([
      Property(1)
    ], ZoomToolbarButtonSettings2.prototype, "borderWidth", void 0);
    __decorate8([
      Property(null)
    ], ZoomToolbarButtonSettings2.prototype, "borderColor", void 0);
    __decorate8([
      Property(null)
    ], ZoomToolbarButtonSettings2.prototype, "radius", void 0);
    __decorate8([
      Property(null)
    ], ZoomToolbarButtonSettings2.prototype, "selectionColor", void 0);
    __decorate8([
      Property(null)
    ], ZoomToolbarButtonSettings2.prototype, "highlightColor", void 0);
    __decorate8([
      Property(5)
    ], ZoomToolbarButtonSettings2.prototype, "padding", void 0);
    __decorate8([
      Property(1)
    ], ZoomToolbarButtonSettings2.prototype, "opacity", void 0);
    __decorate8([
      Property(["ZoomIn", "ZoomOut", "Reset"])
    ], ZoomToolbarButtonSettings2.prototype, "toolbarItems", void 0);
    return ZoomToolbarButtonSettings2;
  })(ChildProperty)
);
var ZoomToolbarTooltipSettings = (
  /** @class */
  (function(_super) {
    __extends20(ZoomToolbarTooltipSettings2, _super);
    function ZoomToolbarTooltipSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(true)
    ], ZoomToolbarTooltipSettings2.prototype, "visible", void 0);
    __decorate8([
      Property("white")
    ], ZoomToolbarTooltipSettings2.prototype, "fill", void 0);
    __decorate8([
      Property(1)
    ], ZoomToolbarTooltipSettings2.prototype, "borderOpacity", void 0);
    __decorate8([
      Property(1)
    ], ZoomToolbarTooltipSettings2.prototype, "borderWidth", void 0);
    __decorate8([
      Property("#707070")
    ], ZoomToolbarTooltipSettings2.prototype, "borderColor", void 0);
    __decorate8([
      Property("black")
    ], ZoomToolbarTooltipSettings2.prototype, "fontColor", void 0);
    __decorate8([
      Property("")
    ], ZoomToolbarTooltipSettings2.prototype, "fontFamily", void 0);
    __decorate8([
      Property("")
    ], ZoomToolbarTooltipSettings2.prototype, "fontStyle", void 0);
    __decorate8([
      Property("")
    ], ZoomToolbarTooltipSettings2.prototype, "fontWeight", void 0);
    __decorate8([
      Property("")
    ], ZoomToolbarTooltipSettings2.prototype, "fontSize", void 0);
    __decorate8([
      Property(1)
    ], ZoomToolbarTooltipSettings2.prototype, "fontOpacity", void 0);
    return ZoomToolbarTooltipSettings2;
  })(ChildProperty)
);
var ZoomToolbarSettings = (
  /** @class */
  (function(_super) {
    __extends20(ZoomToolbarSettings2, _super);
    function ZoomToolbarSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property("transparent")
    ], ZoomToolbarSettings2.prototype, "backgroundColor", void 0);
    __decorate8([
      Property(1)
    ], ZoomToolbarSettings2.prototype, "borderOpacity", void 0);
    __decorate8([
      Property(1)
    ], ZoomToolbarSettings2.prototype, "borderWidth", void 0);
    __decorate8([
      Property("transparent")
    ], ZoomToolbarSettings2.prototype, "borderColor", void 0);
    __decorate8([
      Property("Far")
    ], ZoomToolbarSettings2.prototype, "horizontalAlignment", void 0);
    __decorate8([
      Property("Near")
    ], ZoomToolbarSettings2.prototype, "verticalAlignment", void 0);
    __decorate8([
      Property("Horizontal")
    ], ZoomToolbarSettings2.prototype, "orientation", void 0);
    __decorate8([
      Complex({}, ZoomToolbarButtonSettings)
    ], ZoomToolbarSettings2.prototype, "buttonSettings", void 0);
    __decorate8([
      Complex({}, ZoomToolbarTooltipSettings)
    ], ZoomToolbarSettings2.prototype, "tooltipSettings", void 0);
    return ZoomToolbarSettings2;
  })(ChildProperty)
);
var Border = (
  /** @class */
  (function(_super) {
    __extends20(Border2, _super);
    function Border2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property("")
    ], Border2.prototype, "color", void 0);
    __decorate8([
      Property(0)
    ], Border2.prototype, "width", void 0);
    __decorate8([
      Property(null)
    ], Border2.prototype, "opacity", void 0);
    return Border2;
  })(ChildProperty)
);
var CenterPosition = (
  /** @class */
  (function(_super) {
    __extends20(CenterPosition2, _super);
    function CenterPosition2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(null)
    ], CenterPosition2.prototype, "latitude", void 0);
    __decorate8([
      Property(null)
    ], CenterPosition2.prototype, "longitude", void 0);
    return CenterPosition2;
  })(ChildProperty)
);
var TooltipSettings = (
  /** @class */
  (function(_super) {
    __extends20(TooltipSettings2, _super);
    function TooltipSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(false)
    ], TooltipSettings2.prototype, "visible", void 0);
    __decorate8([
      Property("")
    ], TooltipSettings2.prototype, "template", void 0);
    __decorate8([
      Property("")
    ], TooltipSettings2.prototype, "fill", void 0);
    __decorate8([
      Complex({ color: null, width: 1 }, Border)
    ], TooltipSettings2.prototype, "border", void 0);
    __decorate8([
      Complex({ fontFamily: null, size: null, fontWeight: null }, Font)
    ], TooltipSettings2.prototype, "textStyle", void 0);
    __decorate8([
      Property(null)
    ], TooltipSettings2.prototype, "format", void 0);
    __decorate8([
      Property(null)
    ], TooltipSettings2.prototype, "valuePath", void 0);
    __decorate8([
      Property(2e3)
    ], TooltipSettings2.prototype, "duration", void 0);
    return TooltipSettings2;
  })(ChildProperty)
);
var PolygonTooltipSettings = (
  /** @class */
  (function(_super) {
    __extends20(PolygonTooltipSettings2, _super);
    function PolygonTooltipSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(false)
    ], PolygonTooltipSettings2.prototype, "visible", void 0);
    __decorate8([
      Property("")
    ], PolygonTooltipSettings2.prototype, "fill", void 0);
    __decorate8([
      Complex({ color: null, width: 1 }, Border)
    ], PolygonTooltipSettings2.prototype, "border", void 0);
    __decorate8([
      Complex({ fontFamily: null, size: null, fontWeight: null }, Font)
    ], PolygonTooltipSettings2.prototype, "textStyle", void 0);
    __decorate8([
      Property(2e3)
    ], PolygonTooltipSettings2.prototype, "duration", void 0);
    return PolygonTooltipSettings2;
  })(ChildProperty)
);
var Margin = (
  /** @class */
  (function(_super) {
    __extends20(Margin2, _super);
    function Margin2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(10)
    ], Margin2.prototype, "left", void 0);
    __decorate8([
      Property(10)
    ], Margin2.prototype, "right", void 0);
    __decorate8([
      Property(10)
    ], Margin2.prototype, "top", void 0);
    __decorate8([
      Property(10)
    ], Margin2.prototype, "bottom", void 0);
    return Margin2;
  })(ChildProperty)
);
var ConnectorLineSettings = (
  /** @class */
  (function(_super) {
    __extends20(ConnectorLineSettings2, _super);
    function ConnectorLineSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property("#000000")
    ], ConnectorLineSettings2.prototype, "color", void 0);
    __decorate8([
      Property(1)
    ], ConnectorLineSettings2.prototype, "width", void 0);
    __decorate8([
      Property(1)
    ], ConnectorLineSettings2.prototype, "opacity", void 0);
    return ConnectorLineSettings2;
  })(ChildProperty)
);
var MarkerClusterSettings = (
  /** @class */
  (function(_super) {
    __extends20(MarkerClusterSettings2, _super);
    function MarkerClusterSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(false)
    ], MarkerClusterSettings2.prototype, "allowClustering", void 0);
    __decorate8([
      Property(true)
    ], MarkerClusterSettings2.prototype, "allowDeepClustering", void 0);
    __decorate8([
      Complex({ color: "transparent", width: 1 }, Border)
    ], MarkerClusterSettings2.prototype, "border", void 0);
    __decorate8([
      Property("#D2691E")
    ], MarkerClusterSettings2.prototype, "fill", void 0);
    __decorate8([
      Property(1)
    ], MarkerClusterSettings2.prototype, "opacity", void 0);
    __decorate8([
      Property("Rectangle")
    ], MarkerClusterSettings2.prototype, "shape", void 0);
    __decorate8([
      Property(12)
    ], MarkerClusterSettings2.prototype, "width", void 0);
    __decorate8([
      Property(12)
    ], MarkerClusterSettings2.prototype, "height", void 0);
    __decorate8([
      Property(new Point(0, 0))
    ], MarkerClusterSettings2.prototype, "offset", void 0);
    __decorate8([
      Property("")
    ], MarkerClusterSettings2.prototype, "imageUrl", void 0);
    __decorate8([
      Property("")
    ], MarkerClusterSettings2.prototype, "dashArray", void 0);
    __decorate8([
      Complex({}, Font)
    ], MarkerClusterSettings2.prototype, "labelStyle", void 0);
    __decorate8([
      Property(false)
    ], MarkerClusterSettings2.prototype, "allowClusterExpand", void 0);
    __decorate8([
      Complex({}, ConnectorLineSettings)
    ], MarkerClusterSettings2.prototype, "connectorLineSettings", void 0);
    return MarkerClusterSettings2;
  })(ChildProperty)
);
var MarkerClusterData = (
  /** @class */
  (function(_super) {
    __extends20(MarkerClusterData2, _super);
    function MarkerClusterData2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return MarkerClusterData2;
  })(ChildProperty)
);
var ColorMappingSettings = (
  /** @class */
  (function(_super) {
    __extends20(ColorMappingSettings2, _super);
    function ColorMappingSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(null)
    ], ColorMappingSettings2.prototype, "from", void 0);
    __decorate8([
      Property(null)
    ], ColorMappingSettings2.prototype, "to", void 0);
    __decorate8([
      Property(null)
    ], ColorMappingSettings2.prototype, "value", void 0);
    __decorate8([
      Property(null)
    ], ColorMappingSettings2.prototype, "color", void 0);
    __decorate8([
      Property(null)
    ], ColorMappingSettings2.prototype, "minOpacity", void 0);
    __decorate8([
      Property(null)
    ], ColorMappingSettings2.prototype, "maxOpacity", void 0);
    __decorate8([
      Property(null)
    ], ColorMappingSettings2.prototype, "label", void 0);
    __decorate8([
      Property(true)
    ], ColorMappingSettings2.prototype, "showLegend", void 0);
    return ColorMappingSettings2;
  })(ChildProperty)
);
var InitialMarkerSelectionSettings = (
  /** @class */
  (function(_super) {
    __extends20(InitialMarkerSelectionSettings2, _super);
    function InitialMarkerSelectionSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(null)
    ], InitialMarkerSelectionSettings2.prototype, "latitude", void 0);
    __decorate8([
      Property(null)
    ], InitialMarkerSelectionSettings2.prototype, "longitude", void 0);
    return InitialMarkerSelectionSettings2;
  })(ChildProperty)
);
var InitialShapeSelectionSettings = (
  /** @class */
  (function(_super) {
    __extends20(InitialShapeSelectionSettings2, _super);
    function InitialShapeSelectionSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(null)
    ], InitialShapeSelectionSettings2.prototype, "shapePath", void 0);
    __decorate8([
      Property(null)
    ], InitialShapeSelectionSettings2.prototype, "shapeValue", void 0);
    return InitialShapeSelectionSettings2;
  })(ChildProperty)
);
var SelectionSettings = (
  /** @class */
  (function(_super) {
    __extends20(SelectionSettings2, _super);
    function SelectionSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(false)
    ], SelectionSettings2.prototype, "enable", void 0);
    __decorate8([
      Property(null)
    ], SelectionSettings2.prototype, "fill", void 0);
    __decorate8([
      Property(1)
    ], SelectionSettings2.prototype, "opacity", void 0);
    __decorate8([
      Property(false)
    ], SelectionSettings2.prototype, "enableMultiSelect", void 0);
    __decorate8([
      Complex({ color: "transparent", width: 0 }, Border)
    ], SelectionSettings2.prototype, "border", void 0);
    return SelectionSettings2;
  })(ChildProperty)
);
var HighlightSettings = (
  /** @class */
  (function(_super) {
    __extends20(HighlightSettings2, _super);
    function HighlightSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(null)
    ], HighlightSettings2.prototype, "fill", void 0);
    __decorate8([
      Property(false)
    ], HighlightSettings2.prototype, "enable", void 0);
    __decorate8([
      Property(1)
    ], HighlightSettings2.prototype, "opacity", void 0);
    __decorate8([
      Complex({ color: "transparent", width: 0 }, Border)
    ], HighlightSettings2.prototype, "border", void 0);
    return HighlightSettings2;
  })(ChildProperty)
);
var PolygonSetting = (
  /** @class */
  (function(_super) {
    __extends20(PolygonSetting2, _super);
    function PolygonSetting2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(1)
    ], PolygonSetting2.prototype, "borderWidth", void 0);
    __decorate8([
      Property(1)
    ], PolygonSetting2.prototype, "borderOpacity", void 0);
    __decorate8([
      Property(1)
    ], PolygonSetting2.prototype, "opacity", void 0);
    __decorate8([
      Property("#FF471A")
    ], PolygonSetting2.prototype, "borderColor", void 0);
    __decorate8([
      Property("#FF471A")
    ], PolygonSetting2.prototype, "fill", void 0);
    __decorate8([
      Property([])
    ], PolygonSetting2.prototype, "points", void 0);
    __decorate8([
      Property("")
    ], PolygonSetting2.prototype, "tooltipText", void 0);
    __decorate8([
      Property("")
    ], PolygonSetting2.prototype, "tooltipTemplate", void 0);
    return PolygonSetting2;
  })(ChildProperty)
);
var PolygonSettings = (
  /** @class */
  (function(_super) {
    __extends20(PolygonSettings2, _super);
    function PolygonSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Collection([], PolygonSetting)
    ], PolygonSettings2.prototype, "polygons", void 0);
    __decorate8([
      Complex({}, SelectionSettings)
    ], PolygonSettings2.prototype, "selectionSettings", void 0);
    __decorate8([
      Complex({}, HighlightSettings)
    ], PolygonSettings2.prototype, "highlightSettings", void 0);
    __decorate8([
      Complex({}, PolygonTooltipSettings)
    ], PolygonSettings2.prototype, "tooltipSettings", void 0);
    return PolygonSettings2;
  })(ChildProperty)
);
var NavigationLineSettings = (
  /** @class */
  (function(_super) {
    __extends20(NavigationLineSettings2, _super);
    function NavigationLineSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(false)
    ], NavigationLineSettings2.prototype, "visible", void 0);
    __decorate8([
      Property(1)
    ], NavigationLineSettings2.prototype, "width", void 0);
    __decorate8([
      Property(null)
    ], NavigationLineSettings2.prototype, "longitude", void 0);
    __decorate8([
      Property(null)
    ], NavigationLineSettings2.prototype, "latitude", void 0);
    __decorate8([
      Property("")
    ], NavigationLineSettings2.prototype, "dashArray", void 0);
    __decorate8([
      Property("black")
    ], NavigationLineSettings2.prototype, "color", void 0);
    __decorate8([
      Property(0)
    ], NavigationLineSettings2.prototype, "angle", void 0);
    __decorate8([
      Complex({ showArrow: false, position: "Start", size: 5, color: "black" }, Arrow)
    ], NavigationLineSettings2.prototype, "arrowSettings", void 0);
    __decorate8([
      Complex({}, SelectionSettings)
    ], NavigationLineSettings2.prototype, "selectionSettings", void 0);
    __decorate8([
      Complex({}, HighlightSettings)
    ], NavigationLineSettings2.prototype, "highlightSettings", void 0);
    return NavigationLineSettings2;
  })(ChildProperty)
);
var BubbleSettings = (
  /** @class */
  (function(_super) {
    __extends20(BubbleSettings2, _super);
    function BubbleSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Complex({}, Border)
    ], BubbleSettings2.prototype, "border", void 0);
    __decorate8([
      Property(false)
    ], BubbleSettings2.prototype, "visible", void 0);
    __decorate8([
      Property([])
    ], BubbleSettings2.prototype, "dataSource", void 0);
    __decorate8([
      Property()
    ], BubbleSettings2.prototype, "query", void 0);
    __decorate8([
      Property(1e3)
    ], BubbleSettings2.prototype, "animationDuration", void 0);
    __decorate8([
      Property(0)
    ], BubbleSettings2.prototype, "animationDelay", void 0);
    __decorate8([
      Property("")
    ], BubbleSettings2.prototype, "fill", void 0);
    __decorate8([
      Property(10)
    ], BubbleSettings2.prototype, "minRadius", void 0);
    __decorate8([
      Property(20)
    ], BubbleSettings2.prototype, "maxRadius", void 0);
    __decorate8([
      Property(1)
    ], BubbleSettings2.prototype, "opacity", void 0);
    __decorate8([
      Property(null)
    ], BubbleSettings2.prototype, "valuePath", void 0);
    __decorate8([
      Property("Circle")
    ], BubbleSettings2.prototype, "bubbleType", void 0);
    __decorate8([
      Property(null)
    ], BubbleSettings2.prototype, "colorValuePath", void 0);
    __decorate8([
      Collection([], ColorMappingSettings)
    ], BubbleSettings2.prototype, "colorMapping", void 0);
    __decorate8([
      Complex({}, TooltipSettings)
    ], BubbleSettings2.prototype, "tooltipSettings", void 0);
    __decorate8([
      Complex({}, SelectionSettings)
    ], BubbleSettings2.prototype, "selectionSettings", void 0);
    __decorate8([
      Complex({}, HighlightSettings)
    ], BubbleSettings2.prototype, "highlightSettings", void 0);
    return BubbleSettings2;
  })(ChildProperty)
);
var CommonTitleSettings = (
  /** @class */
  (function(_super) {
    __extends20(CommonTitleSettings2, _super);
    function CommonTitleSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property("")
    ], CommonTitleSettings2.prototype, "text", void 0);
    __decorate8([
      Property("")
    ], CommonTitleSettings2.prototype, "description", void 0);
    return CommonTitleSettings2;
  })(ChildProperty)
);
var SubTitleSettings = (
  /** @class */
  (function(_super) {
    __extends20(SubTitleSettings2, _super);
    function SubTitleSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Complex({ size: null, fontWeight: null, fontFamily: null }, Font)
    ], SubTitleSettings2.prototype, "textStyle", void 0);
    __decorate8([
      Property("Center")
    ], SubTitleSettings2.prototype, "alignment", void 0);
    return SubTitleSettings2;
  })(CommonTitleSettings)
);
var TitleSettings = (
  /** @class */
  (function(_super) {
    __extends20(TitleSettings2, _super);
    function TitleSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Complex({ size: null, fontWeight: null, fontFamily: null }, Font)
    ], TitleSettings2.prototype, "textStyle", void 0);
    __decorate8([
      Property("Center")
    ], TitleSettings2.prototype, "alignment", void 0);
    __decorate8([
      Complex({}, SubTitleSettings)
    ], TitleSettings2.prototype, "subtitleSettings", void 0);
    return TitleSettings2;
  })(CommonTitleSettings)
);
var ZoomSettings = (
  /** @class */
  (function(_super) {
    __extends20(ZoomSettings2, _super);
    function ZoomSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(false)
    ], ZoomSettings2.prototype, "enable", void 0);
    __decorate8([
      Property(true)
    ], ZoomSettings2.prototype, "enablePanning", void 0);
    __decorate8([
      Property(true)
    ], ZoomSettings2.prototype, "enableSelectionZooming", void 0);
    __decorate8([
      Property(true)
    ], ZoomSettings2.prototype, "mouseWheelZoom", void 0);
    __decorate8([
      Property(false)
    ], ZoomSettings2.prototype, "doubleClickZoom", void 0);
    __decorate8([
      Property(true)
    ], ZoomSettings2.prototype, "pinchZooming", void 0);
    __decorate8([
      Property(false)
    ], ZoomSettings2.prototype, "zoomOnClick", void 0);
    __decorate8([
      Property(1)
    ], ZoomSettings2.prototype, "zoomFactor", void 0);
    __decorate8([
      Property(10)
    ], ZoomSettings2.prototype, "maxZoom", void 0);
    __decorate8([
      Property(1)
    ], ZoomSettings2.prototype, "minZoom", void 0);
    __decorate8([
      Property(false)
    ], ZoomSettings2.prototype, "shouldZoomInitially", void 0);
    __decorate8([
      Property(true)
    ], ZoomSettings2.prototype, "resetToInitial", void 0);
    __decorate8([
      Complex({}, ZoomToolbarSettings)
    ], ZoomSettings2.prototype, "toolbarSettings", void 0);
    return ZoomSettings2;
  })(ChildProperty)
);
var ToggleLegendSettings = (
  /** @class */
  (function(_super) {
    __extends20(ToggleLegendSettings2, _super);
    function ToggleLegendSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(false)
    ], ToggleLegendSettings2.prototype, "enable", void 0);
    __decorate8([
      Property(true)
    ], ToggleLegendSettings2.prototype, "applyShapeSettings", void 0);
    __decorate8([
      Property(1)
    ], ToggleLegendSettings2.prototype, "opacity", void 0);
    __decorate8([
      Property("")
    ], ToggleLegendSettings2.prototype, "fill", void 0);
    __decorate8([
      Complex({ color: "", width: 0 }, Border)
    ], ToggleLegendSettings2.prototype, "border", void 0);
    return ToggleLegendSettings2;
  })(ChildProperty)
);
var LegendSettings = (
  /** @class */
  (function(_super) {
    __extends20(LegendSettings2, _super);
    function LegendSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(false)
    ], LegendSettings2.prototype, "useMarkerShape", void 0);
    __decorate8([
      Property(false)
    ], LegendSettings2.prototype, "toggleVisibility", void 0);
    __decorate8([
      Property(false)
    ], LegendSettings2.prototype, "visible", void 0);
    __decorate8([
      Property("transparent")
    ], LegendSettings2.prototype, "background", void 0);
    __decorate8([
      Property("Layers")
    ], LegendSettings2.prototype, "type", void 0);
    __decorate8([
      Property(false)
    ], LegendSettings2.prototype, "invertedPointer", void 0);
    __decorate8([
      Property("After")
    ], LegendSettings2.prototype, "labelPosition", void 0);
    __decorate8([
      Property("None")
    ], LegendSettings2.prototype, "labelDisplayMode", void 0);
    __decorate8([
      Property("Circle")
    ], LegendSettings2.prototype, "shape", void 0);
    __decorate8([
      Property("")
    ], LegendSettings2.prototype, "width", void 0);
    __decorate8([
      Property("")
    ], LegendSettings2.prototype, "height", void 0);
    __decorate8([
      Complex({ fontFamily: null, fontWeight: null }, Font)
    ], LegendSettings2.prototype, "textStyle", void 0);
    __decorate8([
      Property(15)
    ], LegendSettings2.prototype, "shapeWidth", void 0);
    __decorate8([
      Property(15)
    ], LegendSettings2.prototype, "shapeHeight", void 0);
    __decorate8([
      Property(10)
    ], LegendSettings2.prototype, "shapePadding", void 0);
    __decorate8([
      Complex({ color: null, width: 0 }, Border)
    ], LegendSettings2.prototype, "border", void 0);
    __decorate8([
      Complex({ color: "#000000", width: 0 }, Border)
    ], LegendSettings2.prototype, "shapeBorder", void 0);
    __decorate8([
      Complex({}, CommonTitleSettings)
    ], LegendSettings2.prototype, "title", void 0);
    __decorate8([
      Complex({ size: null, color: Theme.legendTitleFont.color, fontStyle: Theme.legendTitleFont.fontStyle, fontWeight: null, fontFamily: null }, Font)
    ], LegendSettings2.prototype, "titleStyle", void 0);
    __decorate8([
      Property("Bottom")
    ], LegendSettings2.prototype, "position", void 0);
    __decorate8([
      Property("Center")
    ], LegendSettings2.prototype, "alignment", void 0);
    __decorate8([
      Property("None")
    ], LegendSettings2.prototype, "orientation", void 0);
    __decorate8([
      Property({ x: 0, y: 0 })
    ], LegendSettings2.prototype, "location", void 0);
    __decorate8([
      Property(null)
    ], LegendSettings2.prototype, "fill", void 0);
    __decorate8([
      Property(1)
    ], LegendSettings2.prototype, "opacity", void 0);
    __decorate8([
      Property("Default")
    ], LegendSettings2.prototype, "mode", void 0);
    __decorate8([
      Property(null)
    ], LegendSettings2.prototype, "showLegendPath", void 0);
    __decorate8([
      Property(null)
    ], LegendSettings2.prototype, "valuePath", void 0);
    __decorate8([
      Property(false)
    ], LegendSettings2.prototype, "removeDuplicateLegend", void 0);
    __decorate8([
      Complex({}, ToggleLegendSettings)
    ], LegendSettings2.prototype, "toggleLegendSettings", void 0);
    return LegendSettings2;
  })(ChildProperty)
);
var DataLabelSettings = (
  /** @class */
  (function(_super) {
    __extends20(DataLabelSettings2, _super);
    function DataLabelSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(false)
    ], DataLabelSettings2.prototype, "visible", void 0);
    __decorate8([
      Complex({ width: 0, color: "transparent" }, Border)
    ], DataLabelSettings2.prototype, "border", void 0);
    __decorate8([
      Property("black")
    ], DataLabelSettings2.prototype, "fill", void 0);
    __decorate8([
      Property(1)
    ], DataLabelSettings2.prototype, "opacity", void 0);
    __decorate8([
      Property(5)
    ], DataLabelSettings2.prototype, "rx", void 0);
    __decorate8([
      Property(5)
    ], DataLabelSettings2.prototype, "ry", void 0);
    __decorate8([
      Complex({ fontWeight: null }, Font)
    ], DataLabelSettings2.prototype, "textStyle", void 0);
    __decorate8([
      Property("")
    ], DataLabelSettings2.prototype, "labelPath", void 0);
    __decorate8([
      Property("None")
    ], DataLabelSettings2.prototype, "smartLabelMode", void 0);
    __decorate8([
      Property("None")
    ], DataLabelSettings2.prototype, "intersectionAction", void 0);
    __decorate8([
      Property("")
    ], DataLabelSettings2.prototype, "template", void 0);
    __decorate8([
      Property(0)
    ], DataLabelSettings2.prototype, "animationDuration", void 0);
    return DataLabelSettings2;
  })(ChildProperty)
);
var ShapeSettings = (
  /** @class */
  (function(_super) {
    __extends20(ShapeSettings2, _super);
    function ShapeSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(null)
    ], ShapeSettings2.prototype, "fill", void 0);
    __decorate8([
      Property([])
    ], ShapeSettings2.prototype, "palette", void 0);
    __decorate8([
      Property(5)
    ], ShapeSettings2.prototype, "circleRadius", void 0);
    __decorate8([
      Complex({ width: null, color: null }, Border)
    ], ShapeSettings2.prototype, "border", void 0);
    __decorate8([
      Property("")
    ], ShapeSettings2.prototype, "dashArray", void 0);
    __decorate8([
      Property(1)
    ], ShapeSettings2.prototype, "opacity", void 0);
    __decorate8([
      Property(null)
    ], ShapeSettings2.prototype, "colorValuePath", void 0);
    __decorate8([
      Property(null)
    ], ShapeSettings2.prototype, "borderColorValuePath", void 0);
    __decorate8([
      Property(null)
    ], ShapeSettings2.prototype, "borderWidthValuePath", void 0);
    __decorate8([
      Property(null)
    ], ShapeSettings2.prototype, "valuePath", void 0);
    __decorate8([
      Collection([], ColorMappingSettings)
    ], ShapeSettings2.prototype, "colorMapping", void 0);
    __decorate8([
      Property(false)
    ], ShapeSettings2.prototype, "autofill", void 0);
    return ShapeSettings2;
  })(ChildProperty)
);
var MarkerBase = (
  /** @class */
  (function(_super) {
    __extends20(MarkerBase2, _super);
    function MarkerBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Complex({ color: "transparent", width: 1 }, Border)
    ], MarkerBase2.prototype, "border", void 0);
    __decorate8([
      Property(null)
    ], MarkerBase2.prototype, "dashArray", void 0);
    __decorate8([
      Property(false)
    ], MarkerBase2.prototype, "visible", void 0);
    __decorate8([
      Property(false)
    ], MarkerBase2.prototype, "enableDrag", void 0);
    __decorate8([
      Property("#FF471A")
    ], MarkerBase2.prototype, "fill", void 0);
    __decorate8([
      Property(null)
    ], MarkerBase2.prototype, "heightValuePath", void 0);
    __decorate8([
      Property(null)
    ], MarkerBase2.prototype, "widthValuePath", void 0);
    __decorate8([
      Property(10)
    ], MarkerBase2.prototype, "height", void 0);
    __decorate8([
      Property(10)
    ], MarkerBase2.prototype, "width", void 0);
    __decorate8([
      Property(1)
    ], MarkerBase2.prototype, "opacity", void 0);
    __decorate8([
      Property(null)
    ], MarkerBase2.prototype, "colorValuePath", void 0);
    __decorate8([
      Property(null)
    ], MarkerBase2.prototype, "shapeValuePath", void 0);
    __decorate8([
      Property(null)
    ], MarkerBase2.prototype, "imageUrlValuePath", void 0);
    __decorate8([
      Property("Balloon")
    ], MarkerBase2.prototype, "shape", void 0);
    __decorate8([
      Property("")
    ], MarkerBase2.prototype, "legendText", void 0);
    __decorate8([
      Property(new Point(0, 0))
    ], MarkerBase2.prototype, "offset", void 0);
    __decorate8([
      Property("")
    ], MarkerBase2.prototype, "imageUrl", void 0);
    __decorate8([
      Property(null)
    ], MarkerBase2.prototype, "template", void 0);
    __decorate8([
      Property([])
    ], MarkerBase2.prototype, "dataSource", void 0);
    __decorate8([
      Property()
    ], MarkerBase2.prototype, "query", void 0);
    __decorate8([
      Complex({}, TooltipSettings)
    ], MarkerBase2.prototype, "tooltipSettings", void 0);
    __decorate8([
      Property(1e3)
    ], MarkerBase2.prototype, "animationDuration", void 0);
    __decorate8([
      Property(0)
    ], MarkerBase2.prototype, "animationDelay", void 0);
    __decorate8([
      Complex({}, SelectionSettings)
    ], MarkerBase2.prototype, "selectionSettings", void 0);
    __decorate8([
      Complex({}, HighlightSettings)
    ], MarkerBase2.prototype, "highlightSettings", void 0);
    __decorate8([
      Property(null)
    ], MarkerBase2.prototype, "latitudeValuePath", void 0);
    __decorate8([
      Property(null)
    ], MarkerBase2.prototype, "longitudeValuePath", void 0);
    __decorate8([
      Collection([], InitialMarkerSelectionSettings)
    ], MarkerBase2.prototype, "initialMarkerSelection", void 0);
    __decorate8([
      Complex({}, MarkerClusterSettings)
    ], MarkerBase2.prototype, "clusterSettings", void 0);
    return MarkerBase2;
  })(ChildProperty)
);
var MarkerSettings = (
  /** @class */
  (function(_super) {
    __extends20(MarkerSettings2, _super);
    function MarkerSettings2(parent, propName, defaultValue, isArray) {
      return _super.call(this, parent, propName, defaultValue, isArray) || this;
    }
    return MarkerSettings2;
  })(MarkerBase)
);
var LayerSettings = (
  /** @class */
  (function(_super) {
    __extends20(LayerSettings2, _super);
    function LayerSettings2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isBaseLayer = false;
      return _this;
    }
    __decorate8([
      Property(null)
    ], LayerSettings2.prototype, "shapeData", void 0);
    __decorate8([
      Property()
    ], LayerSettings2.prototype, "query", void 0);
    __decorate8([
      Complex({}, ShapeSettings)
    ], LayerSettings2.prototype, "shapeSettings", void 0);
    __decorate8([
      Property([])
    ], LayerSettings2.prototype, "dataSource", void 0);
    __decorate8([
      Property("Layer")
    ], LayerSettings2.prototype, "type", void 0);
    __decorate8([
      Property("Geographic")
    ], LayerSettings2.prototype, "geometryType", void 0);
    __decorate8([
      Property("")
    ], LayerSettings2.prototype, "urlTemplate", void 0);
    __decorate8([
      Property(true)
    ], LayerSettings2.prototype, "visible", void 0);
    __decorate8([
      Property("name")
    ], LayerSettings2.prototype, "shapeDataPath", void 0);
    __decorate8([
      Property("name")
    ], LayerSettings2.prototype, "shapePropertyPath", void 0);
    __decorate8([
      Property(0)
    ], LayerSettings2.prototype, "animationDuration", void 0);
    __decorate8([
      Collection([], MarkerSettings)
    ], LayerSettings2.prototype, "markerSettings", void 0);
    __decorate8([
      Complex({}, MarkerClusterSettings)
    ], LayerSettings2.prototype, "markerClusterSettings", void 0);
    __decorate8([
      Complex({}, DataLabelSettings)
    ], LayerSettings2.prototype, "dataLabelSettings", void 0);
    __decorate8([
      Collection([], BubbleSettings)
    ], LayerSettings2.prototype, "bubbleSettings", void 0);
    __decorate8([
      Collection([], NavigationLineSettings)
    ], LayerSettings2.prototype, "navigationLineSettings", void 0);
    __decorate8([
      Complex({}, PolygonSettings)
    ], LayerSettings2.prototype, "polygonSettings", void 0);
    __decorate8([
      Complex({}, TooltipSettings)
    ], LayerSettings2.prototype, "tooltipSettings", void 0);
    __decorate8([
      Complex({}, SelectionSettings)
    ], LayerSettings2.prototype, "selectionSettings", void 0);
    __decorate8([
      Complex({}, HighlightSettings)
    ], LayerSettings2.prototype, "highlightSettings", void 0);
    __decorate8([
      Complex({}, ToggleLegendSettings)
    ], LayerSettings2.prototype, "toggleLegendSettings", void 0);
    __decorate8([
      Collection([], InitialShapeSelectionSettings)
    ], LayerSettings2.prototype, "initialShapeSelection", void 0);
    return LayerSettings2;
  })(ChildProperty)
);
var Tile = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Tile2(x, y, height, width, top, left, src) {
      if (height === void 0) {
        height = 256;
      }
      if (width === void 0) {
        width = 256;
      }
      if (top === void 0) {
        top = 0;
      }
      if (left === void 0) {
        left = 0;
      }
      if (src === void 0) {
        src = null;
      }
      this.x = x;
      this.y = y;
      this.top = top;
      this.left = left;
      this.height = height;
      this.width = width;
      this.src = src;
    }
    return Tile2;
  })()
);
var MapsAreaSettings = (
  /** @class */
  (function(_super) {
    __extends20(MapsAreaSettings2, _super);
    function MapsAreaSettings2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate8([
      Property(null)
    ], MapsAreaSettings2.prototype, "background", void 0);
    __decorate8([
      Complex({ color: "transparent", width: 1 }, Border)
    ], MapsAreaSettings2.prototype, "border", void 0);
    return MapsAreaSettings2;
  })(ChildProperty)
);

// node_modules/@syncfusion/ej2-maps/src/maps/model/constants.js
var load = "load";
var loaded = "loaded";
var click = "click";
var onclick = "onclick";
var rightClick = "rightClick";
var doubleClick = "doubleClick";
var resize = "resize";
var tooltipRender = "tooltipRender";
var shapeSelected = "shapeSelected";
var shapeHighlight = "shapeHighlight";
var mousemove = "mousemove";
var mouseup = "mouseup";
var mousedown = "mousedown";
var layerRendering = "layerRendering";
var shapeRendering = "shapeRendering";
var markerRendering = "markerRendering";
var markerClusterRendering = "markerClusterRendering";
var markerClick = "markerClick";
var markerDragStart = "markerDragStart";
var markerDragEnd = "markerDragEnd";
var markerClusterClick = "markerClusterClick";
var markerMouseMove = "markerMouseMove";
var mouseMove = "mouseMove";
var markerClusterMouseMove = "markerClusterMouseMove";
var dataLabelRendering = "dataLabelRendering";
var bubbleRendering = "bubbleRendering";
var bubbleClick = "bubbleClick";
var bubbleMouseMove = "bubbleMouseMove";
var animationComplete = "animationComplete";
var legendRendering = "legendRendering";
var annotationRendering = "annotationRendering";
var itemSelection = "itemSelection";
var panComplete = "panComplete";
var zoomComplete = "zoomComplete";
var itemHighlight = "itemHighlight";
var beforePrint = "beforePrint";
var zoomIn = "zoomIn";
var zoomOut = "zoomOut";
var pan = "pan";

// node_modules/@syncfusion/ej2-maps/src/maps/layers/bing-map.js
var BingMap = (
  /** @class */
  (function() {
    function BingMap2(maps) {
      this.maps = maps;
    }
    BingMap2.prototype.getBingMap = function(tile, key, type, language, imageUrl, subDomains) {
      var quadKey = "";
      var maxZoom = Math.min(this.maps.tileZoomLevel, parseInt(this.maxZoom, 10));
      for (var i = maxZoom; i > 0; i--) {
        var digit = 0;
        var mask = 1 << i - 1;
        if ((tile.x & mask) !== 0) {
          digit++;
        }
        if ((tile.y & mask) !== 0) {
          digit += 2;
        }
        quadKey = quadKey + "" + digit;
      }
      if (!isNullOrUndefined(subDomains)) {
        var subDomain = subDomains[Math.min(parseInt(quadKey.substr(quadKey.length - 1, 1), 10), subDomains.length)];
        imageUrl = imageUrl.replace("{quadkey}", quadKey).replace("{subdomain}", subDomain);
        return imageUrl += "&mkt=" + language + "&ur=IN&Key=" + key;
      } else {
        return "";
      }
    };
    BingMap2.prototype.destroy = function() {
      this.maps = null;
      this.subDomains = [];
    };
    return BingMap2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/layers/color-mapping.js
var ColorMapping = (
  /** @class */
  (function() {
    function ColorMapping2(maps) {
    }
    ColorMapping2.prototype.getShapeColorMapping = function(shapeSettings, layerData, color) {
      var colorValuePath = shapeSettings.colorValuePath ? shapeSettings.colorValuePath : shapeSettings.valuePath;
      var equalValue = !isNullOrUndefined(colorValuePath) ? colorValuePath.indexOf(".") > -1 ? getValueFromObject(layerData, colorValuePath) : layerData[colorValuePath] : layerData[colorValuePath];
      var colorValue = Number(equalValue);
      var shapeColor = this.getColorByValue(shapeSettings.colorMapping, colorValue, equalValue);
      return !isNullOrUndefined(shapeColor) ? shapeColor : color;
    };
    ColorMapping2.prototype.getColorByValue = function(colorMapping, colorValue, equalValue) {
      if (isNaN(colorValue) && isNullOrUndefined(equalValue)) {
        return null;
      }
      var fill = "";
      var opacity;
      var gradientFill;
      for (var _i = 0, colorMapping_1 = colorMapping; _i < colorMapping_1.length; _i++) {
        var colorMap = colorMapping_1[_i];
        if (!isNullOrUndefined(colorMap.from) && !isNullOrUndefined(colorMap.to) && (colorValue >= colorMap.from && colorValue <= colorMap.to) || colorMap.value === equalValue) {
          if (Object.prototype.toString.call(colorMap.color) === "[object Array]") {
            if (!isNullOrUndefined(colorMap.value)) {
              fill = colorMap.color[0];
            } else {
              gradientFill = this.getColor(colorMap, colorValue);
              fill = gradientFill;
            }
          } else {
            fill = colorMap.color;
          }
        }
        if ((colorValue >= colorMap.from && colorValue <= colorMap.to || colorMap.value === equalValue) && (!isNullOrUndefined(colorMap.minOpacity) && !isNullOrUndefined(colorMap.maxOpacity) && fill)) {
          opacity = this.deSaturationColor(colorMap, fill, colorValue, equalValue);
        }
        if ((fill === "" || isNullOrUndefined(fill)) && isNullOrUndefined(colorMap.from) && isNullOrUndefined(colorMap.to) && isNullOrUndefined(colorMap.minOpacity) && isNullOrUndefined(colorMap.maxOpacity) && isNullOrUndefined(colorMap.value)) {
          fill = Object.prototype.toString.call(colorMap.color) === "[object Array]" ? colorMap.color[0] : colorMap.color;
        }
      }
      return { fill: fill || (!colorMapping.length ? equalValue : null), opacity };
    };
    ColorMapping2.prototype.deSaturationColor = function(colorMapping, color, rangeValue, equalValue) {
      var opacity = 1;
      if (rangeValue >= colorMapping.from && rangeValue <= colorMapping.to || colorMapping.value === equalValue) {
        var ratio = !isNaN(rangeValue) ? (rangeValue - colorMapping.from) / (colorMapping.to - colorMapping.from) : colorMapping.from / (colorMapping.to - colorMapping.from);
        opacity = ratio * (colorMapping.maxOpacity - colorMapping.minOpacity) + colorMapping.minOpacity;
      }
      return opacity;
    };
    ColorMapping2.prototype.rgbToHex = function(r, g, b) {
      return "#" + this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);
    };
    ColorMapping2.prototype.componentToHex = function(value) {
      var hex = value.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    };
    ColorMapping2.prototype.getColor = function(colorMap, value) {
      var color = "";
      var rbg;
      if (Number(value) === colorMap.from) {
        color = colorMap.color[0];
      } else if (Number(value) === colorMap.to) {
        color = colorMap.color[colorMap.color.length - 1];
      } else {
        rbg = this.getGradientColor(Number(value), colorMap);
        color = this.rgbToHex(rbg.r, rbg.g, rbg.b);
      }
      return color;
    };
    ColorMapping2.prototype.getGradientColor = function(value, colorMap) {
      var previousOffset = colorMap.from;
      var nextOffset = colorMap.to;
      var percent = 0;
      var full = nextOffset - previousOffset;
      var midColor;
      percent = (value - previousOffset) / full;
      var previousColor;
      var nextColor;
      if (colorMap.color.length <= 2) {
        previousColor = colorMap.color[0].charAt(0) === "#" ? colorMap.color[0] : this._colorNameToHex(colorMap.color[0]);
        nextColor = colorMap.color[colorMap.color.length - 1].charAt(0) === "#" ? colorMap.color[colorMap.color.length - 1] : this._colorNameToHex(colorMap.color[colorMap.color.length - 1]);
      } else {
        previousColor = colorMap.color[0].charAt(0) === "#" ? colorMap.color[0] : this._colorNameToHex(colorMap.color[0]);
        nextColor = colorMap.color[colorMap.color.length - 1].charAt(0) === "#" ? colorMap.color[colorMap.color.length - 1] : this._colorNameToHex(colorMap.color[colorMap.color.length - 1]);
        var a = full / (colorMap.color.length - 1);
        var b = void 0;
        var c = void 0;
        var length_1 = colorMap.color.length - 1;
        var splitColorValueOffset = [];
        var splitColor = {};
        for (var j = 1; j < length_1; j++) {
          c = j * a;
          b = previousOffset + c;
          splitColor = { b, color: colorMap.color[j] };
          splitColorValueOffset.push(splitColor);
        }
        for (var i = 0; i < splitColorValueOffset.length; i++) {
          if (previousOffset <= value && value <= splitColorValueOffset[i]["b"] && i === 0) {
            midColor = splitColorValueOffset[i]["color"].charAt(0) === "#" ? splitColorValueOffset[i]["color"] : this._colorNameToHex(splitColorValueOffset[i]["color"]);
            nextColor = midColor;
            percent = value < splitColorValueOffset[i]["b"] ? 1 - Math.abs((value - splitColorValueOffset[i]["b"]) / a) : (value - splitColorValueOffset[i]["b"]) / a;
          } else if (splitColorValueOffset[i]["b"] <= value && value <= nextOffset && i === splitColorValueOffset.length - 1) {
            midColor = splitColorValueOffset[i]["color"].charAt(0) === "#" ? splitColorValueOffset[i]["color"] : this._colorNameToHex(splitColorValueOffset[i]["color"]);
            previousColor = midColor;
            percent = value < splitColorValueOffset[i]["b"] ? 1 - Math.abs((value - splitColorValueOffset[i]["b"]) / a) : (value - splitColorValueOffset[i]["b"]) / a;
          }
          if (i !== splitColorValueOffset.length - 1 && i < splitColorValueOffset.length) {
            if (splitColorValueOffset[i]["b"] <= value && value <= splitColorValueOffset[i + 1]["b"]) {
              midColor = splitColorValueOffset[i]["color"].charAt(0) === "#" ? splitColorValueOffset[i]["color"] : this._colorNameToHex(splitColorValueOffset[i]["color"]);
              previousColor = midColor;
              nextColor = splitColorValueOffset[i + 1]["color"].charAt(0) === "#" ? splitColorValueOffset[i + 1]["color"] : this._colorNameToHex(splitColorValueOffset[i + 1]["color"]);
              percent = Math.abs(value - splitColorValueOffset[i + 1]["b"]) / a;
            }
          }
        }
      }
      return this.getPercentageColor(percent, previousColor, nextColor);
    };
    ColorMapping2.prototype.getPercentageColor = function(percent, previous, next) {
      var nextColor = next.split("#")[1];
      var prevColor = previous.split("#")[1];
      var r = this.getPercentage(percent, parseInt(prevColor.substr(0, 2), 16), parseInt(nextColor.substr(0, 2), 16));
      var g = this.getPercentage(percent, parseInt(prevColor.substr(2, 2), 16), parseInt(nextColor.substr(2, 2), 16));
      var b = this.getPercentage(percent, parseInt(prevColor.substr(4, 2), 16), parseInt(nextColor.substr(4, 2), 16));
      return new ColorValue(r, g, b);
    };
    ColorMapping2.prototype.getPercentage = function(percent, previous, next) {
      var full = next - previous;
      return Math.round(previous + full * percent);
    };
    ColorMapping2.prototype._colorNameToHex = function(color) {
      var colors = {
        "aliceblue": "#f0f8ff",
        "antiquewhite": "#faebd7",
        "aqua": "#00ffff",
        "aquamarine": "#7fffd4",
        "azure": "#f0ffff",
        "beige": "#f5f5dc",
        "bisque": "#ffe4c4",
        "black": "#000000",
        "blanchedalmond": "#ffebcd",
        "blue": "#0000ff",
        "blueviolet": "#8a2be2",
        "brown": "#a52a2a",
        "burlywood": "#deb887",
        "cadetblue": "#5f9ea0",
        "chartreuse": "#7fff00",
        "chocolate": "#d2691e",
        "coral": "#ff7f50",
        "cornflowerblue": "#6495ed",
        "cornsilk": "#fff8dc",
        "crimson": "#dc143c",
        "cyan": "#00ffff",
        "darkblue": "#00008b",
        "darkcyan": "#008b8b",
        "darkgoldenrod": "#b8860b",
        "darkgray": "#a9a9a9",
        "darkgreen": "#006400",
        "darkkhaki": "#bdb76b",
        "darkmagenta": "#8b008b",
        "darkolivegreen": "#556b2f",
        "darkorange": "#ff8c00",
        "darkorchid": "#9932cc",
        "darkred": "#8b0000",
        "darksalmon": "#e9967a",
        "darkseagreen": "#8fbc8f",
        "darkslateblue": "#483d8b",
        "darkslategray": "#2f4f4f",
        "darkturquoise": "#00ced1",
        "darkviolet": "#9400d3",
        "deeppink": "#ff1493",
        "deepskyblue": "#00bfff",
        "dimgray": "#696969",
        "dodgerblue": "#1e90ff",
        "firebrick": "#b22222",
        "floralwhite": "#fffaf0",
        "forestgreen": "#228b22",
        "fuchsia": "#ff00ff",
        "gainsboro": "#dcdcdc",
        "ghostwhite": "#f8f8ff",
        "gold": "#ffd700",
        "goldenrod": "#daa520",
        "gray": "#808080",
        "green": "#008000",
        "greenyellow": "#adff2f",
        "honeydew": "#f0fff0",
        "hotpink": "#ff69b4",
        "indianred ": "#cd5c5c",
        "indigo ": "#4b0082",
        "ivory": "#fffff0",
        "khaki": "#f0e68c",
        "lavender": "#e6e6fa",
        "lavenderblush": "#fff0f5",
        "lawngreen": "#7cfc00",
        "lemonchiffon": "#fffacd",
        "lightblue": "#add8e6",
        "lightcoral": "#f08080",
        "lightcyan": "#e0ffff",
        "lightgoldenrodyellow": "#fafad2",
        "lightgrey": "#d3d3d3",
        "lightgreen": "#90ee90",
        "lightpink": "#ffb6c1",
        "lightsalmon": "#ffa07a",
        "lightseagreen": "#20b2aa",
        "lightskyblue": "#87cefa",
        "lightslategray": "#778899",
        "lightsteelblue": "#b0c4de",
        "lightyellow": "#ffffe0",
        "lime": "#00ff00",
        "limegreen": "#32cd32",
        "linen": "#faf0e6",
        "magenta": "#ff00ff",
        "maroon": "#800000",
        "mediumaquamarine": "#66cdaa",
        "mediumblue": "#0000cd",
        "mediumorchid": "#ba55d3",
        "mediumpurple": "#9370d8",
        "mediumseagreen": "#3cb371",
        "mediumslateblue": "#7b68ee",
        "mediumspringgreen": "#00fa9a",
        "mediumturquoise": "#48d1cc",
        "mediumvioletred": "#c71585",
        "midnightblue": "#191970",
        "mintcream": "#f5fffa",
        "mistyrose": "#ffe4e1",
        "moccasin": "#ffe4b5",
        "navajowhite": "#ffdead",
        "navy": "#000080",
        "orchid": "#da70d6",
        "papayawhip": "#ffefd5",
        "oldlace": "#fdf5e6",
        "olive": "#808000",
        "olivedrab": "#6b8e23",
        "orange": "#ffa500",
        "orangered": "#ff4500",
        "palegoldenrod": "#eee8aa",
        "palegreen": "#98fb98",
        "paleturquoise": "#afeeee",
        "palevioletred": "#d87093",
        "peachpuff": "#ffdab9",
        "peru": "#cd853f",
        "pink": "#ffc0cb",
        "plum": "#dda0dd",
        "powderblue": "#b0e0e6",
        "purple": "#800080",
        "red": "#ff0000",
        "rosybrown": "#bc8f8f",
        "royalblue": "#4169e1",
        "saddlebrown": "#8b4513",
        "salmon": "#fa8072",
        "sandybrown": "#f4a460",
        "seagreen": "#2e8b57",
        "seashell": "#fff5ee",
        "sienna": "#a0522d",
        "silver": "#c0c0c0",
        "skyblue": "#87ceeb",
        "slateblue": "#6a5acd",
        "slategray": "#708090",
        "snow": "#fffafa",
        "springgreen": "#00ff7f",
        "steelblue": "#4682b4",
        "tan": "#d2b48c",
        "teal": "#008080",
        "thistle": "#d8bfd8",
        "tomato": "#ff6347",
        "turquoise": "#40e0d0",
        "violet": "#ee82ee",
        "wheat": "#f5deb3",
        "white": "#ffffff",
        "whitesmoke": "#f5f5f5",
        "yellow": "#ffff00",
        "yellowgreen": "#9acd32"
      };
      if (Object.prototype.toString.call(color) === "[object Array]") {
        return color;
      }
      if (typeof colors[color.toLowerCase()] !== "undefined") {
        return colors[color.toLowerCase()];
      }
      return color;
    };
    return ColorMapping2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/layers/layer-panel.js
var LayerPanel = (
  /** @class */
  (function() {
    function LayerPanel2(map) {
      this.isMapCoordinates = true;
      this.horizontalPan = false;
      this.horizontalPanXCount = 0;
      this.mapObject = map;
      this.ajaxModule = new Fetch();
      this.ajaxResponse = [];
    }
    LayerPanel2.prototype.measureLayerPanel = function() {
      var _this = this;
      var layerCollection = this.mapObject.layersCollection;
      var areaRect = this.mapObject.mapAreaRect;
      var secondaryEle = getElementByID(this.mapObject.element.id + "_Secondary_Element");
      if (this.mapObject.isTileMap && secondaryEle) {
        this.tileSvgObject = this.mapObject.renderer.createSvg({
          id: this.mapObject.element.id + "_Tile_SVG",
          width: areaRect.width,
          height: areaRect.height
        });
        var parentElement = createElement("div", {
          id: this.mapObject.element.id + "_Tile_SVG_Parent"
        });
        parentElement.style.cssText = "position: absolute; height: " + areaRect.height + "px; width: " + areaRect.width + "px;";
        parentElement.appendChild(this.tileSvgObject);
        secondaryEle.appendChild(parentElement);
      }
      this.layerGroup = this.mapObject.renderer.createGroup({
        id: this.mapObject.element.id + "_Layer_Collections",
        "clip-path": "url(#" + this.mapObject.element.id + "_MapArea_ClipRect)"
      });
      this.clipRectElement = this.mapObject.renderer.drawClipPath(new RectOption(this.mapObject.element.id + "_MapArea_ClipRect", "transparent", { width: 1, color: "Gray" }, 1, {
        x: this.mapObject.isTileMap ? 0 : areaRect.x,
        y: this.mapObject.isTileMap ? 0 : areaRect.y,
        width: areaRect.width,
        height: areaRect.height
      }));
      this.layerGroup.appendChild(this.clipRectElement);
      this.mapObject.baseMapBounds = null;
      this.mapObject.baseMapRectBounds = null;
      this.mapObject.baseSize = null;
      Array.prototype.forEach.call(layerCollection, function(layer, index) {
        _this.currentLayer = layer;
        _this.processLayers(layer, index);
      });
      if (!isNullOrUndefined(this.mapObject.legendModule) && this.mapObject.legendSettings.position === "Float") {
        if (this.mapObject.isTileMap) {
          this.layerGroup.appendChild(this.mapObject.legendModule.legendGroup);
        } else {
          this.mapObject.svgObject.appendChild(this.mapObject.legendModule.legendGroup);
        }
      }
    };
    LayerPanel2.prototype.renderTileLayer = function(panel, layer, layerIndex, bing) {
      panel.currentFactor = panel.calculateFactor(layer);
      panel.mapObject.defaultState = panel.mapObject.zoomSettings.zoomFactor !== 1 && (!isNullOrUndefined(panel.mapObject.tileZoomLevel) && panel.mapObject.tileZoomLevel !== 1) ? false : true;
      if (isNullOrUndefined(panel.mapObject.previousCenterLatitude) && isNullOrUndefined(panel.mapObject.previousCenterLongitude) && !panel.mapObject.isZoomByPosition) {
        panel.mapObject.previousCenterLatitude = panel.mapObject.centerPosition.latitude;
        panel.mapObject.previousCenterLongitude = panel.mapObject.centerPosition.longitude;
      } else if (panel.mapObject.previousCenterLatitude !== panel.mapObject.centerPosition.latitude && panel.mapObject.previousCenterLongitude !== panel.mapObject.centerPosition.longitude || panel.mapObject.isZoomByPosition) {
        panel.mapObject.centerPositionChanged = true;
        panel.mapObject.previousCenterLatitude = panel.mapObject.centerPosition.latitude;
        panel.mapObject.previousCenterLongitude = panel.mapObject.centerPosition.longitude;
      } else {
        panel.mapObject.centerPositionChanged = false;
      }
      var center = new Point(panel.mapObject.centerPosition.longitude, panel.mapObject.centerPosition.latitude);
      var centerTileMap = center;
      if (this.mapObject.isTileMap && panel.mapObject.markerModule && panel.mapObject.zoomSettings.enable) {
        panel.mapObject.markerModule.calculateZoomCenterPositionAndFactor(this.mapObject.layersCollection);
        if (!isNullOrUndefined(this.mapObject.markerCenterLatitude) && !isNullOrUndefined(this.mapObject.markerCenterLongitude) && !panel.mapObject.isZoomByPosition) {
          centerTileMap = new Point(panel.mapObject.markerCenterLongitude, panel.mapObject.markerCenterLatitude);
        }
      }
      if (!panel.mapObject.zoomSettings.shouldZoomInitially && panel.mapObject.centerPosition.longitude && panel.mapObject.centerPosition.latitude && !panel.mapObject.zoomPersistence && panel.mapObject.defaultState) {
        center = new Point(panel.mapObject.centerPosition.longitude, panel.mapObject.centerPosition.latitude);
      } else if (panel.mapObject.zoomSettings.shouldZoomInitially && panel.mapObject.markerZoomedState && !panel.mapObject.zoomPersistence && !isNullOrUndefined(panel.mapObject.markerZoomCenterPoint)) {
        center = new Point(panel.mapObject.markerZoomCenterPoint.longitude, panel.mapObject.markerZoomCenterPoint.latitude);
      } else {
        center = { x: null, y: null };
      }
      var zoomFactorValue = panel.mapObject.zoomSettings.shouldZoomInitially && !panel.mapObject.isZoomByPosition ? isNullOrUndefined(panel.mapObject.markerZoomFactor) ? 1 : panel.mapObject.markerZoomFactor : panel.mapObject.zoomSettings.zoomFactor;
      zoomFactorValue = panel.mapObject.enablePersistence ? isNullOrUndefined(panel.mapObject.mapScaleValue) ? isNullOrUndefined(panel.mapObject.markerZoomFactor) ? panel.mapObject.zoomSettings.zoomFactor : panel.mapObject.markerZoomFactor : panel.mapObject.mapScaleValue : zoomFactorValue;
      zoomFactorValue = panel.mapObject.zoomSettings.enable ? zoomFactorValue : panel.mapObject.zoomSettings.zoomFactor;
      zoomFactorValue = zoomFactorValue > 0 ? zoomFactorValue : 1;
      panel.mapObject.defaultState = zoomFactorValue !== 1 ? false : true;
      if (!panel.mapObject.markerZoomedState && panel.mapObject.zoomSettings.shouldZoomInitially && panel.mapObject.zoomSettings.zoomFactor === 1) {
        panel.mapObject.defaultState = true;
      }
      if (isNullOrUndefined(panel.mapObject.tileZoomLevel)) {
        panel.mapObject.tileZoomLevel = zoomFactorValue;
        panel.mapObject.previousZoomFactor = zoomFactorValue;
      } else if (this.mapObject.isReset && panel.mapObject.tileZoomLevel === 1 && !panel.mapObject.zoomSettings.shouldZoomInitially) {
        var zoomLevel = panel.mapObject.tileZoomLevel;
        panel.mapObject.tileZoomLevel = zoomLevel;
      } else if (panel.mapObject.zoomSettings.zoomFactor !== 1 || panel.mapObject.zoomSettings.shouldZoomInitially) {
        panel.mapObject.previousZoomFactor = panel.mapObject.tileZoomLevel;
        panel.mapObject.tileZoomLevel = panel.mapObject.defaultState && panel.mapObject.zoomSettings.enable ? panel.mapObject.tileZoomLevel : !panel.mapObject.zoomSettings.shouldZoomInitially && !panel.mapObject.centerPositionChanged ? panel.mapObject.previousZoomFactor !== panel.mapObject.zoomSettings.zoomFactor ? panel.mapObject.zoomSettings.zoomFactor : panel.mapObject.tileZoomLevel : zoomFactorValue;
        panel.mapObject.tileZoomLevel = zoomFactorValue === 1 && panel.mapObject.zoomSettings.zoomFactor === 0 ? zoomFactorValue : panel.mapObject.tileZoomLevel;
        if (!isNullOrUndefined(panel.mapObject.tileTranslatePoint) && (panel.mapObject.markerZoomFactor !== panel.mapObject.mapScaleValue || isNullOrUndefined(panel.mapObject.markerZoomFactor) && isNullOrUndefined(panel.mapObject.mapScaleValue)) && (panel.mapObject.zoomSettings.zoomFactor <= 1 || panel.mapObject.previousZoomFactor !== panel.mapObject.zoomSettings.zoomFactor)) {
          panel.mapObject.tileTranslatePoint.x = 0;
          panel.mapObject.tileTranslatePoint.y = 0;
        }
      } else if (panel.mapObject.defaultState) {
        panel.mapObject.previousZoomFactor = panel.mapObject.tileZoomLevel;
        panel.mapObject.tileZoomLevel = zoomFactorValue;
        if (!isNullOrUndefined(panel.mapObject.tileTranslatePoint)) {
          panel.mapObject.tileTranslatePoint.x = 0;
          panel.mapObject.tileTranslatePoint.y = 0;
        }
      }
      if (zoomFactorValue <= 1 && !isNullOrUndefined(panel.mapObject.height) && !panel.mapObject.zoomSettings.shouldZoomInitially && panel.mapObject.tileZoomLevel === panel.mapObject.tileZoomScale && this.mapObject.initialCheck) {
        fixInitialScaleForTile(this.mapObject);
      }
      if (!isNullOrUndefined(panel.mapObject.centerLatOfGivenLocation) && !isNullOrUndefined(panel.mapObject.centerLongOfGivenLocation) && panel.mapObject.zoomNotApplied) {
        if (!isNullOrUndefined(centerTileMap)) {
          centerTileMap.y = panel.mapObject.centerLatOfGivenLocation;
          centerTileMap.x = panel.mapObject.centerLongOfGivenLocation;
        }
        panel.mapObject.tileZoomLevel = panel.mapObject.mapScaleValue = panel.mapObject.scaleOfGivenLocation;
      }
      panel.mapObject.tileTranslatePoint = panel.panTileMap(panel.mapObject.availableSize.width, panel.mapObject.availableSize.height, centerTileMap);
      if (this.mapObject.zoomSettings.resetToInitial && this.mapObject.initialCheck && !isNullOrUndefined(panel.mapObject.height) && this.mapObject.availableSize.height > 512) {
        this.mapObject.applyZoomReset = true;
        this.mapObject.initialZoomLevel = Math.floor(this.mapObject.availableSize.height / 512);
        var padding = 20;
        var totalSize = Math.pow(2, this.mapObject.initialZoomLevel) * 256;
        if (!isNullOrUndefined(this.mapObject.initialTileTranslate)) {
          this.mapObject.initialTileTranslate.x = this.mapObject.availableSize.width / 2 - totalSize / 2;
          this.mapObject.initialTileTranslate.y = this.mapObject.availableSize.height / 2 - totalSize / 2 + padding;
        }
      }
      panel.generateTiles(panel.mapObject.tileZoomLevel, panel.mapObject.tileTranslatePoint, null, bing);
      if (!isNullOrUndefined(panel.mapObject.previousZoomFactor) && panel.mapObject.previousZoomFactor !== panel.mapObject.zoomSettings.zoomFactor) {
        panel.mapObject.previousZoomFactor = panel.mapObject.zoomSettings.zoomFactor;
      }
      if (panel.mapObject.polygonModule) {
        var polygonElement = panel.mapObject.polygonModule.polygonRender(this.mapObject, layerIndex, panel.mapObject.tileZoomLevel);
        if (!isNullOrUndefined(polygonElement)) {
          panel.layerObject.appendChild(polygonElement);
        }
      }
      if (panel.mapObject.navigationLineModule) {
        var navigationLineElement = panel.mapObject.navigationLineModule.renderNavigation(panel.currentLayer, panel.mapObject.tileZoomLevel, layerIndex);
        if (!isNullOrUndefined(navigationLineElement)) {
          panel.layerObject.appendChild(navigationLineElement);
        }
      }
      if (panel.mapObject.markerModule) {
        panel.mapObject.markerModule.markerRender(this.mapObject, panel.layerObject, layerIndex, panel.mapObject.tileZoomLevel, null);
      }
      panel.translateLayerElements(panel.layerObject);
      panel.layerGroup.appendChild(panel.layerObject);
    };
    LayerPanel2.prototype.processLayers = function(layer, layerIndex) {
      var _this = this;
      this.layerObject = this.mapObject.renderer.createGroup({
        id: this.mapObject.element.id + "_LayerIndex_" + layerIndex
      });
      if (!this.mapObject.enablePersistence) {
        var itemName = this.mapObject.getModuleName() + this.mapObject.element.id;
        if (navigator.userAgent.indexOf("Edge") === -1) {
          var data = void 0;
          try {
            data = window.localStorage;
          } catch (e) {
            data = null;
          }
          if (!isNullOrUndefined(data) && window.localStorage.getItem(itemName)) {
            window.localStorage.removeItem(itemName);
          }
        }
      }
      var eventArgs = {
        cancel: false,
        name: layerRendering,
        index: layerIndex,
        layer,
        maps: this.mapObject,
        visible: layer.visible
      };
      this.mapObject.trigger("layerRendering", eventArgs, function(observedArgs) {
        if (!eventArgs.cancel && eventArgs.visible) {
          if (isNullOrUndefined(layer.shapeData) && !isNullOrUndefined(layer.urlTemplate) && layer.urlTemplate !== "") {
            if (!isNullOrUndefined(layer.urlTemplate) && layer.urlTemplate.indexOf("quadkey") > -1) {
              var bing = new BingMap(_this.mapObject);
              _this.bingMapCalculation(layer, layerIndex, _this, bing);
            } else {
              _this.renderTileLayer(_this, layer, layerIndex);
            }
          } else {
            if (!isNullOrUndefined(layer.shapeData) && (!isNullOrUndefined(layer.shapeData["geometries"]) || !isNullOrUndefined(layer.shapeData["features"]))) {
              var featureData = !isNullOrUndefined(layer.shapeData["geometries"]) && // eslint-disable-next-line @typescript-eslint/no-explicit-any
              layer.shapeData["geometries"].length > 0 ? layer.shapeData["geometries"] : layer.shapeData["features"];
              layer.layerData = [];
              var bbox = layer.shapeData["bbox"];
              if (!isNullOrUndefined(bbox) && layer.isBaseLayer) {
                _this.mapObject.baseMapBounds = new GeoLocation({ min: bbox[0][1], max: bbox[1][1] }, { min: bbox[0][0], max: bbox[1][0] });
              } else if (isNullOrUndefined(_this.mapObject.baseMapBounds) && !isCustomPath(featureData)) {
                _this.calculateRectBounds(featureData);
              }
              _this.calculatePathCollection(layerIndex, featureData);
            }
          }
        }
      });
      if (!this.mapObject.isTileMap) {
        this.mapObject.svgObject.appendChild(this.layerGroup);
      } else if (this.tileSvgObject) {
        this.tileSvgObject.appendChild(this.layerGroup);
        this.mapObject.baseMapBounds = null;
      }
    };
    LayerPanel2.prototype.bingMapCalculation = function(layer, layerIndex, proxy, bing) {
      bing.imageUrl = layer.urlTemplate;
      bing.subDomains = ["t0", "t1", "t2", "t3"];
      bing.maxZoom = "21";
      proxy.mapObject.bingMap = bing;
      proxy.renderTileLayer(proxy, layer, layerIndex, bing);
      this.mapObject.arrangeTemplate();
      if (this.mapObject.zoomModule && this.mapObject.previousScale !== this.mapObject.scale) {
        this.mapObject.zoomModule.applyTransform(this.mapObject, false, true);
      }
    };
    LayerPanel2.prototype.bubbleCalculation = function(bubbleSettings, range) {
      if (bubbleSettings.dataSource != null && bubbleSettings != null) {
        var bubbleDataSource = bubbleSettings.dataSource;
        for (var i = 0; i < bubbleDataSource.length; i++) {
          var bubbledata = !isNullOrUndefined(bubbleSettings.valuePath) ? bubbleSettings.valuePath.indexOf(".") > -1 ? Number(getValueFromObject(bubbleSettings.dataSource[i], bubbleSettings.valuePath)) : parseFloat(bubbleSettings.dataSource[i][bubbleSettings.valuePath]) : parseFloat(bubbleSettings.dataSource[i][bubbleSettings.valuePath]);
          if (!isNaN(bubbledata)) {
            if (i !== 0) {
              if (bubbledata > range.max) {
                range.max = bubbledata;
              } else if (bubbledata < range.min) {
                range.min = bubbledata;
              }
            } else {
              range.max = range.min = bubbledata;
            }
          }
        }
      }
    };
    LayerPanel2.prototype.calculatePathCollection = function(layerIndex, renderData) {
      var _this = this;
      this.groupElements = [];
      if (!isCustomPath(renderData)) {
        this.currentFactor = this.calculateFactor(this.currentLayer);
      }
      this.rectBounds = null;
      var shapeSettings = this.currentLayer.shapeSettings;
      Array.prototype.forEach.call(renderData, function(geometryData) {
        if (!isNullOrUndefined(geometryData["geometry"]) || !isNullOrUndefined(geometryData["coordinates"])) {
          var type = !isNullOrUndefined(geometryData["geometry"]) ? geometryData["geometry"]["type"] : geometryData["type"];
          var coords = !isNullOrUndefined(geometryData["geometry"]) ? geometryData["geometry"]["coordinates"] : geometryData["coordinates"];
          var data = geometryData["geometry"];
          var properties = geometryData["properties"];
          _this.generatePoints(type, coords, data, properties);
        }
      });
      this.currentLayer.rectBounds = this.rectBounds;
      if (isNullOrUndefined(this.mapObject.baseMapRectBounds) && this.currentLayer.isBaseLayer) {
        this.mapObject.baseMapRectBounds = this.rectBounds;
      }
      var colors = !isNullOrUndefined(shapeSettings.palette) && shapeSettings.palette.length > 1 ? shapeSettings.palette : getShapeColor(this.mapObject.theme);
      var labelTemplateEle = createElement("div", {
        id: this.mapObject.element.id + "_LayerIndex_" + layerIndex + "_Label_Template_Group",
        className: this.mapObject.element.id + "_template"
      });
      labelTemplateEle.style.cssText = "pointer-events: none; overflow: hidden; position: absolute;top:" + this.mapObject.mapAreaRect.y + "px;left:" + this.mapObject.mapAreaRect.x + "px;height:" + this.mapObject.mapAreaRect.height + "px;width:" + this.mapObject.mapAreaRect.width + "px;";
      if (this.currentLayer.layerData.length !== 0) {
        var _loop_1 = function(i2) {
          var k = void 0;
          var borderValue = {
            color: shapeSettings.border.color || this_1.mapObject.themeStyle.shapeBorderColor,
            width: shapeSettings.border.width,
            opacity: shapeSettings.border.opacity
          };
          var currentShapeData = this_1.currentLayer.layerData[i2];
          var pathOptions;
          var circleOptions;
          var groupElement;
          var path = "";
          var fill = shapeSettings.autofill ? colors[i2 % colors.length] : shapeSettings.fill || this_1.mapObject.themeStyle.shapeFill;
          if (shapeSettings.colorValuePath !== null && !isNullOrUndefined(currentShapeData["property"])) {
            k = checkShapeDataFields(
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              this_1.currentLayer.dataSource,
              currentShapeData["property"],
              this_1.currentLayer.shapeDataPath,
              this_1.currentLayer.shapePropertyPath,
              this_1.currentLayer
            );
            if (k !== null && shapeSettings.colorMapping.length === 0) {
              fill = this_1.currentLayer.shapeSettings.colorValuePath.indexOf(".") > -1 ? getValueFromObject(this_1.currentLayer.dataSource[k], shapeSettings.colorValuePath) : this_1.currentLayer.dataSource[k][shapeSettings.colorValuePath];
            } else if (currentShapeData["property"][shapeSettings.colorValuePath] && // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this_1.currentLayer.dataSource.length === 0 && shapeSettings.colorMapping.length === 0) {
              fill = this_1.currentLayer.shapeSettings.colorValuePath.indexOf(".") > -1 ? getValueFromObject(currentShapeData["property"], shapeSettings.colorValuePath) : currentShapeData["property"][shapeSettings.colorValuePath];
            }
            fill = !isNullOrUndefined(fill) ? fill : shapeSettings.fill || this_1.mapObject.themeStyle.shapeFill;
          }
          var shapeID = this_1.mapObject.element.id + "_LayerIndex_" + layerIndex + "_shapeIndex_" + i2 + "_dataIndex_" + k;
          var getShapeColor_1 = this_1.getShapeColorMapping(this_1.currentLayer, currentShapeData["property"], fill);
          fill = Object.prototype.toString.call(getShapeColor_1) === "[object Object]" && !isNullOrUndefined(getShapeColor_1["fill"]) ? getShapeColor_1["fill"] : fill;
          if (this_1.currentLayer.shapeSettings.borderColorValuePath || this_1.currentLayer.shapeSettings.borderWidthValuePath) {
            k = checkShapeDataFields(
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              this_1.currentLayer.dataSource,
              currentShapeData["property"],
              this_1.currentLayer.shapeDataPath,
              this_1.currentLayer.shapePropertyPath,
              this_1.currentLayer
            );
            if (k !== null) {
              if (this_1.currentLayer.dataSource[k][shapeSettings.borderColorValuePath]) {
                borderValue.color = this_1.currentLayer.dataSource[k][shapeSettings.borderColorValuePath];
              }
              if (this_1.currentLayer.dataSource[k][shapeSettings.borderWidthValuePath]) {
                borderValue.width = this_1.currentLayer.dataSource[k][shapeSettings.borderWidthValuePath];
              }
            }
          }
          var opacity = Object.prototype.toString.call(getShapeColor_1) === "[object Object]" && !isNullOrUndefined(getShapeColor_1["opacity"]) ? getShapeColor_1["opacity"] : shapeSettings.opacity;
          var eventArgs = {
            cancel: false,
            name: shapeRendering,
            index: i2,
            data: this_1.currentLayer.dataSource ? this_1.currentLayer.dataSource[k] : null,
            maps: this_1.mapObject,
            shape: shapeSettings,
            fill,
            border: { width: borderValue.width, color: borderValue.color, opacity: borderValue.opacity }
          };
          var shapeRenderingSuccess = function(eventArgs2) {
            var drawingType = !isNullOrUndefined(currentShapeData["_isMultiPolygon"]) ? "MultiPolygon" : isNullOrUndefined(currentShapeData["type"]) ? currentShapeData[0]["type"] : currentShapeData["type"];
            drawingType = drawingType === "Polygon" || drawingType === "MultiPolygon" ? "Polygon" : drawingType;
            if (!eventArgs2.cancel) {
              eventArgs2.fill = eventArgs2.fill === "#A6A6A6" ? eventArgs2.shape.fill || _this.mapObject.themeStyle.shapeFill : eventArgs2.fill;
              eventArgs2.border.color = eventArgs2.border.color === "transparent" ? eventArgs2.shape.border.color : eventArgs2.border.color;
              eventArgs2.border.width = eventArgs2.border.width === 0 ? eventArgs2.shape.border.width : eventArgs2.border.width;
              if (isNullOrUndefined(shapeSettings.borderColorValuePath)) {
                borderValue.color = eventArgs2.border.color;
              }
              if (isNullOrUndefined(shapeSettings.borderWidthValuePath)) {
                borderValue.width = eventArgs2.border.width;
              }
            } else {
              eventArgs2.fill = fill;
              eventArgs2.border.color = shapeSettings.border.color || _this.mapObject.themeStyle.shapeBorderColor;
              eventArgs2.border.width = shapeSettings.border.width;
            }
            eventArgs2.border.opacity = isNullOrUndefined(eventArgs2.border.opacity) ? opacity : eventArgs2.border.opacity;
            if (_this.groupElements.length < 1) {
              groupElement = _this.mapObject.renderer.createGroup({
                id: _this.mapObject.element.id + "_LayerIndex_" + layerIndex + "_" + drawingType + "_Group",
                transform: ""
              });
              _this.groupElements.push(groupElement);
            } else {
              for (var i_1 = 0; i_1 < _this.groupElements.length; i_1++) {
                var ele = _this.groupElements[i_1];
                if (ele.id.indexOf(drawingType) > -1) {
                  groupElement = ele;
                  break;
                } else if (i_1 >= _this.groupElements.length - 1) {
                  groupElement = _this.mapObject.renderer.createGroup({
                    id: _this.mapObject.element.id + "_LayerIndex_" + layerIndex + "_" + drawingType + "_Group"
                  });
                  _this.groupElements.push(groupElement);
                  break;
                }
              }
            }
            var pathEle;
            switch (drawingType) {
              case "Polygon":
                if (!currentShapeData["_isMultiPolygon"]) {
                  path += "M" + currentShapeData[0]["point"]["x"] + " " + currentShapeData[0]["point"]["y"];
                  currentShapeData.map(function(shapeData) {
                    path += " L " + shapeData["point"]["x"] + " " + shapeData["point"]["y"];
                  });
                } else {
                  path = _this.generateMultiPolygonPath(currentShapeData);
                }
                path += " z ";
                if (path.length > 3) {
                  pathOptions = new PathOption2(shapeID, eventArgs2.fill, eventArgs2.border.width, eventArgs2.border.color, opacity, eventArgs2.border.opacity, shapeSettings.dashArray, path);
                  pathEle = _this.mapObject.renderer.drawPath(pathOptions);
                }
                break;
              case "LineString":
                currentShapeData.map(function(lineData, index) {
                  if (index === 0) {
                    path += "M " + lineData["point"]["x"] + " " + lineData["point"]["y"];
                  } else {
                    path += "L" + lineData["point"]["x"] + " , " + lineData["point"]["y"] + " ";
                  }
                });
                if (path.length > 3) {
                  pathOptions = new PathOption2(shapeID, "transparent", !isNullOrUndefined(eventArgs2.border.width) ? eventArgs2.border.width : 1, !isNullOrUndefined(eventArgs2.fill) ? eventArgs2.fill : eventArgs2.border.color, opacity, eventArgs2.border.opacity, shapeSettings.dashArray, path);
                  pathEle = _this.mapObject.renderer.drawPath(pathOptions);
                }
                break;
              case "MultiLineString":
                currentShapeData.map(function(multilineData) {
                  multilineData.map(function(lineData, index) {
                    if (index === 0) {
                      path += "M " + lineData["point"]["x"] + " " + lineData["point"]["y"];
                    } else {
                      path += "L" + lineData["point"]["x"] + " , " + lineData["point"]["y"] + " ";
                    }
                  });
                });
                if (path.length > 3) {
                  pathOptions = new PathOption2(shapeID, "transparent", !isNullOrUndefined(eventArgs2.border.width) ? eventArgs2.border.width : 1, !isNullOrUndefined(eventArgs2.fill) ? eventArgs2.fill : eventArgs2.border.color, opacity, eventArgs2.border.opacity, shapeSettings.dashArray, path);
                  pathEle = _this.mapObject.renderer.drawPath(pathOptions);
                }
                break;
              case "Point":
                var pointData = currentShapeData["point"];
                var circleRadius = _this.mapObject.layers[layerIndex].type !== "SubLayer" ? shapeSettings.circleRadius : shapeSettings.circleRadius / (_this.mapObject.isTileMap ? _this.mapObject.scale : _this.currentFactor);
                circleOptions = new CircleOption(shapeID, eventArgs2.fill, eventArgs2.border, opacity, pointData["x"], pointData["y"], circleRadius, shapeSettings.dashArray);
                pathEle = _this.mapObject.renderer.drawCircle(circleOptions);
                break;
              case "MultiPoint":
                currentShapeData.map(function(multiPointData, index) {
                  var pointData2 = multiPointData["point"];
                  var circleRadius2 = _this.mapObject.layers[layerIndex].type !== "SubLayer" ? shapeSettings.circleRadius : shapeSettings.circleRadius / (_this.mapObject.isTileMap ? _this.mapObject.scale : _this.currentFactor);
                  circleOptions = new CircleOption(shapeID + "_multiLine_" + index, eventArgs2.fill, eventArgs2.border, opacity, pointData2["x"], pointData2["y"], circleRadius2, shapeSettings.dashArray);
                  pathEle = _this.mapObject.renderer.drawCircle(circleOptions);
                  _this.pathAttributeCalculate(groupElement, pathEle, drawingType, currentShapeData);
                });
                break;
              case "Path":
                path = currentShapeData["point"];
                pathOptions = new PathOption2(shapeID, eventArgs2.fill, eventArgs2.border.width, eventArgs2.border.color, opacity, eventArgs2.border.opacity, shapeSettings.dashArray, path);
                pathEle = _this.mapObject.renderer.drawPath(pathOptions);
                break;
            }
            if (!isNullOrUndefined(pathEle) && drawingType !== "MultiPoint") {
              _this.pathAttributeCalculate(groupElement, pathEle, drawingType, currentShapeData);
            }
            if (i2 === _this.currentLayer.layerData.length - 1) {
              _this.layerFeatures(layerIndex, colors, renderData, labelTemplateEle);
            }
          };
          shapeRenderingSuccess.bind(this_1);
          this_1.mapObject.trigger("shapeRendering", eventArgs, shapeRenderingSuccess);
        };
        var this_1 = this;
        for (var i = 0; i < this.currentLayer.layerData.length; i++) {
          _loop_1(i);
        }
      } else {
        this.layerFeatures(layerIndex, colors, renderData, labelTemplateEle);
      }
    };
    LayerPanel2.prototype.pathAttributeCalculate = function(groupElement, pathEle, drawingType, currentShapeData) {
      var property = Object.prototype.toString.call(this.currentLayer.shapePropertyPath) === "[object Array]" ? this.currentLayer.shapePropertyPath : [this.currentLayer.shapePropertyPath];
      var properties;
      for (var j = 0; j < property.length; j++) {
        if (!isNullOrUndefined(currentShapeData["property"])) {
          properties = property[j];
          break;
        }
      }
      pathEle.setAttribute("aria-label", !isNullOrUndefined(currentShapeData["property"]) ? currentShapeData["property"][properties] : "");
      if (this.currentLayer.selectionSettings.enable || this.currentLayer.highlightSettings.enable) {
        pathEle.tabIndex = this.mapObject.tabIndex;
        pathEle.setAttribute("role", "button");
        pathEle.style.cursor = this.currentLayer.highlightSettings.enable && !this.currentLayer.selectionSettings.enable ? "default" : "pointer";
      } else {
        pathEle.setAttribute("role", "region");
      }
      if (drawingType === "LineString" || drawingType === "MultiLineString") {
        pathEle.style.cssText = "outline:none";
      }
      maintainSelection(this.mapObject.selectedElementId, this.mapObject.shapeSelectionClass, pathEle, "ShapeselectionMapStyle");
      if (this.mapObject.legendSettings.toggleLegendSettings.enable && this.mapObject.legendSettings.type === "Layers") {
        maintainToggleSelection(this.mapObject.toggledElementId, pathEle, this.mapObject.legendSettings.toggleLegendSettings.applyShapeSettings ? this.currentLayer.shapeSettings : this.mapObject.legendSettings.toggleLegendSettings);
      }
      groupElement.appendChild(pathEle);
    };
    LayerPanel2.prototype.layerFeatures = function(layerIndex, colors, renderData, labelTemplateEle) {
      var _this = this;
      var bubbleG;
      if (this.mapObject.polygonModule) {
        this.groupElements.push(this.mapObject.polygonModule.polygonRender(this.mapObject, layerIndex, this.mapObject.isTileMap ? Math.floor(this.currentFactor) : this.currentFactor));
      }
      if (this.currentLayer.bubbleSettings.length && this.mapObject.bubbleModule) {
        var length_1 = this.currentLayer.bubbleSettings.length;
        var bubble_1;
        var _loop_2 = function(j2) {
          bubble_1 = this_2.currentLayer.bubbleSettings[j2];
          bubbleG = this_2.mapObject.renderer.createGroup({
            id: this_2.mapObject.element.id + "_LayerIndex_" + layerIndex + "_bubble_Group_" + j2
          });
          var range = { min: 0, max: 0 };
          this_2.bubbleCalculation(bubble_1, range);
          var bubbleDataSource = bubble_1.dataSource;
          this_2.mapObject.bubbleModule.bubbleCollection = [];
          if (!isNullOrUndefined(bubbleDataSource) && bubbleDataSource.length > 0) {
            bubbleDataSource.map(function(bubbleData, i) {
              _this.renderBubble(_this.currentLayer, bubbleData, colors[i % colors.length], range, j2, i, bubbleG, layerIndex, bubble_1);
            });
            this_2.groupElements.push(bubbleG);
          }
        };
        var this_2 = this;
        for (var j = 0; j < length_1; j++) {
          _loop_2(j);
        }
      }
      if (this.mapObject.markerModule && !this.mapObject.isTileMap && this.mapObject.zoomSettings.enable) {
        this.mapObject.markerModule.calculateZoomCenterPositionAndFactor(this.mapObject.layersCollection);
      }
      var group = this.mapObject.renderer.createGroup({
        id: this.mapObject.element.id + "_LayerIndex_" + layerIndex + "_dataLableIndex_Group"
      });
      group.style.pointerEvents = "none";
      if (this.mapObject.dataLabelModule && this.currentLayer.dataLabelSettings.visible) {
        var intersect_1 = [];
        Array.prototype.forEach.call(renderData, function(currentShapeData, i) {
          _this.renderLabel(_this.currentLayer, layerIndex, currentShapeData, group, i, labelTemplateEle, intersect_1);
        });
        this.groupElements.push(group);
      }
      if (this.mapObject.navigationLineModule) {
        this.groupElements.push(this.mapObject.navigationLineModule.renderNavigation(this.currentLayer, this.currentFactor, layerIndex));
      }
      if (!isNullOrUndefined(this.groupElements) && !isNullOrUndefined(this.layerObject)) {
        this.groupElements.map(function(element) {
          if (!isNullOrUndefined(element)) {
            _this.layerObject.appendChild(element);
          }
        });
      }
      if (this.mapObject.markerModule) {
        this.mapObject.markerModule.markerRender(this.mapObject, this.layerObject, layerIndex, this.mapObject.isTileMap ? Math.floor(this.currentFactor) : this.currentFactor, null);
      }
      this.translateLayerElements(this.layerObject);
      this.layerGroup.appendChild(this.layerObject);
    };
    LayerPanel2.prototype.renderLabel = function(layer, layerIndex, shape, group, shapeIndex, labelTemplateEle, intersect) {
      this.mapObject.dataLabelModule.renderLabel(layer, layerIndex, shape, layer.layerData, group, labelTemplateEle, shapeIndex, intersect);
    };
    LayerPanel2.prototype.generateMultiPolygonPath = function(currentShapeData) {
      var path = "";
      var shape;
      for (var j = 0; j < currentShapeData.length; j++) {
        path += "M" + currentShapeData[j][0]["point"]["x"] + " " + currentShapeData[j][0]["point"]["y"];
        shape = currentShapeData[j];
        shape.map(function(shapeData) {
          path += " L " + shapeData["point"]["x"] + " " + shapeData["point"]["y"];
        });
      }
      return path;
    };
    LayerPanel2.prototype.renderBubble = function(layer, bubbleData, color, range, bubbleIndex, dataIndex, group, layerIndex, bubbleSettings) {
      if (isNullOrUndefined(this.mapObject.bubbleModule) || !bubbleSettings.visible) {
        return null;
      }
      color = bubbleSettings.fill ? bubbleSettings.fill : color;
      this.mapObject.bubbleModule.id = this.mapObject.element.id + "_LayerIndex_" + layerIndex + "_BubbleIndex_" + bubbleIndex + "_dataIndex_" + dataIndex;
      this.mapObject.bubbleModule.renderBubble(bubbleSettings, bubbleData, color, range, bubbleIndex, dataIndex, layerIndex, layer, group, this.mapObject.bubbleModule.id);
    };
    LayerPanel2.prototype.getShapeColorMapping = function(layer, shape, color) {
      color = color ? color : layer.shapeSettings.fill;
      if (layer.shapeSettings.colorMapping.length === 0 && isNullOrUndefined(layer.dataSource)) {
        return color;
      }
      var index = checkShapeDataFields(layer.dataSource, shape, layer.shapeDataPath, layer.shapePropertyPath, layer);
      var colorMapping = new ColorMapping(this.mapObject);
      if (isNullOrUndefined(layer.dataSource) || isNullOrUndefined(layer.dataSource[index])) {
        return color;
      }
      return colorMapping.getShapeColorMapping(layer.shapeSettings, layer.dataSource[index], color);
    };
    LayerPanel2.prototype.generatePoints = function(type, coordinates, data, properties) {
      var _this = this;
      var latitude;
      var longitude;
      var newData = [];
      switch (type.toLowerCase()) {
        case "polygon":
          newData = this.calculatePolygonBox(coordinates[0]);
          if (newData.length > 0) {
            newData["property"] = properties;
            newData["type"] = type;
            newData["_isMultiPolygon"] = false;
            this.currentLayer.layerData.push(newData);
          }
          break;
        case "multipolygon":
          var multiPolygonDatas = [];
          for (var i = 0; i < coordinates.length; i++) {
            for (var j = 0; j < coordinates[i].length; j++) {
              newData = this.calculatePolygonBox(coordinates[i][j]);
              if (newData.length > 0) {
                multiPolygonDatas.push(newData);
              }
            }
          }
          multiPolygonDatas["property"] = properties;
          multiPolygonDatas["type"] = type;
          multiPolygonDatas["_isMultiPolygon"] = true;
          this.currentLayer.layerData.push(multiPolygonDatas);
          break;
        case "linestring":
          var lineExtraSpace_1 = !isNullOrUndefined(this.currentLayer.shapeSettings.border.width) ? typeof this.currentLayer.shapeSettings.border.width === "string" ? parseInt(this.currentLayer.shapeSettings.border.width, 10) : this.currentLayer.shapeSettings.border.width : 1;
          coordinates.map(function(points) {
            latitude = points[1];
            longitude = points[0];
            var point2 = convertGeoToPoint(latitude, longitude, _this.currentFactor, _this.currentLayer, _this.mapObject);
            _this.calculateBox(point2, lineExtraSpace_1);
            newData.push({
              point: point2,
              lat: latitude,
              lng: longitude
            });
          });
          newData["property"] = properties;
          newData["type"] = type;
          this.currentLayer.layerData.push(newData);
          break;
        case "multilinestring":
          var extraSpaces_1 = !isNullOrUndefined(this.currentLayer.shapeSettings.border.width) ? typeof this.currentLayer.shapeSettings.border.width === "string" ? parseInt(this.currentLayer.shapeSettings.border.width, 10) : this.currentLayer.shapeSettings.border.width : 1;
          var multiLineData_1 = [];
          coordinates.map(function(multiPoints) {
            newData = [];
            multiPoints.map(function(points) {
              latitude = points[1];
              longitude = points[0];
              var point2 = convertGeoToPoint(latitude, longitude, _this.currentFactor, _this.currentLayer, _this.mapObject);
              _this.calculateBox(point2, extraSpaces_1);
              newData.push({
                point: point2,
                lat: latitude,
                lng: longitude
              });
            });
            multiLineData_1.push(newData);
          });
          multiLineData_1["property"] = properties;
          multiLineData_1["type"] = type;
          this.currentLayer.layerData.push(multiLineData_1);
          break;
        case "point":
          var pointExtraSpace = (!isNullOrUndefined(this.currentLayer.shapeSettings.border.width) ? typeof this.currentLayer.shapeSettings.border.width === "string" ? parseInt(this.currentLayer.shapeSettings.border.width, 10) : this.currentLayer.shapeSettings.border.width : 1) + this.currentLayer.shapeSettings.circleRadius * 2;
          latitude = coordinates[1];
          longitude = coordinates[0];
          var point = convertGeoToPoint(latitude, longitude, this.currentFactor, this.currentLayer, this.mapObject);
          this.calculateBox(point, pointExtraSpace);
          this.currentLayer.layerData.push({
            point,
            type,
            lat: latitude,
            lng: longitude,
            property: properties
          });
          break;
        case "multipoint":
          var extraSpace_1 = (!isNullOrUndefined(this.currentLayer.shapeSettings.border.width) ? typeof this.currentLayer.shapeSettings.border.width === "string" ? parseInt(this.currentLayer.shapeSettings.border.width, 10) : this.currentLayer.shapeSettings.border.width : 1) + this.currentLayer.shapeSettings.circleRadius * 2;
          newData = [];
          coordinates.map(function(points) {
            latitude = points[1];
            longitude = points[0];
            var point2 = convertGeoToPoint(latitude, longitude, _this.currentFactor, _this.currentLayer, _this.mapObject);
            _this.calculateBox(point2, extraSpace_1);
            newData.push({
              point: point2,
              lat: latitude,
              lng: longitude
            });
          });
          newData["property"] = properties;
          newData["type"] = type;
          this.currentLayer.layerData.push(newData);
          break;
        case "path":
          this.currentLayer.layerData.push({
            point: data["d"],
            type,
            property: properties
          });
          break;
      }
    };
    LayerPanel2.prototype.calculateBox = function(point, extraSpace) {
      if (isNullOrUndefined(this.rectBounds)) {
        this.rectBounds = { min: { x: point.x - extraSpace, y: point.y - extraSpace }, max: {
          x: point.x + extraSpace,
          y: point.y + extraSpace
        } };
      } else {
        this.rectBounds["min"]["x"] = Math.min(this.rectBounds["min"]["x"], point.x - extraSpace);
        this.rectBounds["min"]["y"] = Math.min(this.rectBounds["min"]["y"], point.y - extraSpace);
        this.rectBounds["max"]["x"] = Math.max(this.rectBounds["max"]["x"], point.x + extraSpace);
        this.rectBounds["max"]["y"] = Math.max(this.rectBounds["max"]["y"], point.y + extraSpace);
      }
    };
    LayerPanel2.prototype.calculateFactor = function(layer) {
      var horFactor;
      var verFactor = 1;
      var divide = 10;
      var exp2 = "e+1";
      var bounds = this.mapObject.baseMapBounds;
      var mapSize = new Size2(this.mapObject.mapAreaRect.width, this.mapObject.mapAreaRect.height - 5);
      var mapHeight;
      var mapWidth;
      if (bounds) {
        var start = convertGeoToPoint(bounds.latitude.min, bounds.longitude.min, null, layer, this.mapObject);
        var end = convertGeoToPoint(bounds.latitude.max, bounds.longitude.max, null, layer, this.mapObject);
        mapHeight = end.y - start.y;
        mapWidth = end.x - start.x;
        if (mapHeight === 0 || mapWidth === 0) {
          mapWidth = mapSize.width / 2;
          mapHeight = mapSize.height;
        }
      } else {
        mapHeight = mapWidth = 500;
      }
      if (mapHeight < mapSize.height) {
        horFactor = parseFloat(Math.abs(Number(mapSize.height / Number(mapHeight.toString() + exp2)) * 100).toString().split(".")[0]) / divide;
      } else {
        horFactor = mapSize.height / mapHeight;
      }
      if (mapWidth < mapSize.width) {
        verFactor = parseFloat(Math.abs(Number(mapSize.width / Number(mapWidth.toString() + exp2)) * 100).toString().split(".")[0]) / divide;
      } else {
        verFactor = mapSize.width / mapWidth;
      }
      return Math.min(verFactor, horFactor);
    };
    LayerPanel2.prototype.translateLayerElements = function(layerElement) {
      var childNode;
      this.mapObject.translateType = "layer";
      if (!isNullOrUndefined(this.mapObject.baseMapRectBounds)) {
        var duration = animationMode === "Disable" ? 0 : this.currentLayer.animationDuration === 0 && animationMode === "Enable" ? 1e3 : this.currentLayer.animationDuration;
        var animate2 = duration !== 0 || isNullOrUndefined(this.mapObject.zoomModule);
        this.mapObject.baseTranslatePoint = this.mapObject.zoomTranslatePoint;
        var translate = void 0;
        if (this.mapObject.zoomSettings.zoomFactor > 1 && !isNullOrUndefined(this.mapObject.zoomModule)) {
          translate = getZoomTranslate(this.mapObject, this.currentLayer, animate2);
        } else {
          translate = getTranslate(this.mapObject, this.currentLayer, animate2);
        }
        var scale = this.mapObject.previousScale = translate["scale"];
        var location_1 = this.mapObject.previousPoint = translate["location"];
        this.mapObject.baseTranslatePoint = this.mapObject.translatePoint = location_1;
        this.mapObject.baseScale = this.mapObject.scale = scale;
        for (var i = 0; i < layerElement.childElementCount; i++) {
          childNode = layerElement.childNodes[i];
          if (!(childNode.id.indexOf("_Markers_Group") > -1) && !(childNode.id.indexOf("_bubble_Group") > -1) && !(childNode.id.indexOf("_dataLableIndex_Group") > -1)) {
            var transform = "scale( " + scale + " ) translate( " + location_1.x + " " + location_1.y + " ) ";
            childNode.setAttribute("transform", transform);
            if (duration > 0 && !isNullOrUndefined(this.mapObject.zoomModule)) {
              if (this.mapObject.zoomSettings.zoomFactor > 1) {
                translate = getZoomTranslate(this.mapObject, this.currentLayer);
              } else {
                translate = getTranslate(this.mapObject, this.currentLayer);
              }
              this.mapObject.scale = translate["scale"];
              this.mapObject.zoomTranslatePoint = this.mapObject.translatePoint = translate["location"];
            }
          }
        }
      } else if (this.mapObject.isTileMap && !isNullOrUndefined(this.mapObject.scale)) {
        for (var j = 0; j < layerElement.childElementCount; j++) {
          childNode = layerElement.childNodes[j];
          if (!(childNode.id.indexOf("_Markers_Group") > -1) && !(childNode.id.indexOf("_bubble_Group") > -1) && !(childNode.id.indexOf("_dataLableIndex_Group") > -1) && !(childNode.id.indexOf("_line_Group") > -1)) {
            if (childNode.id.indexOf("_Polygons_Group") === -1) {
              var transform = "scale( " + this.mapObject.scale + " ) translate( " + this.mapObject.translatePoint.x + " " + this.mapObject.translatePoint.y + " ) ";
              childNode.setAttribute("transform", transform);
            }
          }
        }
      }
    };
    LayerPanel2.prototype.calculateRectBounds = function(layerData) {
      var _this = this;
      Array.prototype.forEach.call(layerData, function(obj) {
        if (!isNullOrUndefined(obj["geometry"]) || !isNullOrUndefined(obj["coordinates"])) {
          var type = !isNullOrUndefined(obj["geometry"]) ? obj["geometry"]["type"] : obj["type"];
          var coordinates = !isNullOrUndefined(obj["geometry"]) ? obj["geometry"]["coordinates"] : obj["coordinates"];
          switch (type.toLowerCase()) {
            case "polygon":
              _this.calculateRectBox(coordinates[0]);
              break;
            case "multipolygon":
              coordinates.map(function(point) {
                _this.calculateRectBox(point[0]);
              });
              break;
            case "multilinestring":
              coordinates.map(function(multiPoint) {
                multiPoint.map(function(point, index) {
                  _this.calculateRectBox(point, "multilinestring", index === 0 ? true : false);
                });
              });
              break;
            case "linestring":
              coordinates.map(function(point, index) {
                _this.calculateRectBox(point, "linestring", index === 0 ? true : false);
              });
              break;
            case "point":
              _this.calculateRectBox(coordinates, "point");
              break;
            case "multipoint":
              coordinates.map(function(point, index) {
                _this.calculateRectBox(point, "multipoint", index === 0 ? true : false);
              });
              break;
          }
        }
      });
    };
    LayerPanel2.prototype.calculatePolygonBox = function(coordinates) {
      var _this = this;
      var newData = [];
      var bounds = this.mapObject.baseMapBounds;
      coordinates.map(function(currentPoint) {
        var latitude = currentPoint[1];
        var longitude = currentPoint[0];
        if (longitude >= bounds.longitude.min && longitude <= bounds.longitude.max && (latitude >= bounds.latitude.min && latitude <= bounds.latitude.max)) {
          var point = convertGeoToPoint(latitude, longitude, _this.currentFactor, _this.currentLayer, _this.mapObject);
          if (isNullOrUndefined(_this.rectBounds)) {
            _this.rectBounds = { min: { x: point.x, y: point.y }, max: { x: point.x, y: point.y } };
          } else {
            _this.rectBounds["min"]["x"] = Math.min(_this.rectBounds["min"]["x"], point.x);
            _this.rectBounds["min"]["y"] = Math.min(_this.rectBounds["min"]["y"], point.y);
            _this.rectBounds["max"]["x"] = Math.max(_this.rectBounds["max"]["x"], point.x);
            _this.rectBounds["max"]["y"] = Math.max(_this.rectBounds["max"]["y"], point.y);
          }
          newData.push({
            point,
            lat: latitude,
            lng: longitude
          });
        }
      });
      return newData;
    };
    LayerPanel2.prototype.calculateRectBox = function(coordinates, type, isFirstItem) {
      var _this = this;
      if (type !== "linestring" && type !== "multilinestring" && (type !== "point" && type !== "multipoint")) {
        Array.prototype.forEach.call(coordinates, function(currentCoords) {
          if (isNullOrUndefined(_this.mapObject.baseMapBounds)) {
            _this.mapObject.baseMapBounds = new GeoLocation({ min: currentCoords[1], max: currentCoords[1] }, { min: currentCoords[0], max: currentCoords[0] });
          } else {
            _this.mapObject.baseMapBounds.latitude.min = Math.min(_this.mapObject.baseMapBounds.latitude.min, currentCoords[1]);
            _this.mapObject.baseMapBounds.latitude.max = Math.max(_this.mapObject.baseMapBounds.latitude.max, currentCoords[1]);
            _this.mapObject.baseMapBounds.longitude.min = Math.min(_this.mapObject.baseMapBounds.longitude.min, currentCoords[0]);
            _this.mapObject.baseMapBounds.longitude.max = Math.max(_this.mapObject.baseMapBounds.longitude.max, currentCoords[0]);
          }
        });
      } else {
        if ((isFirstItem || type === "point") && isNullOrUndefined(this.mapObject.baseMapBounds)) {
          this.mapObject.baseMapBounds = new GeoLocation({ min: coordinates[1], max: coordinates[1] }, { min: coordinates[0], max: coordinates[0] });
        } else {
          this.mapObject.baseMapBounds.latitude.min = Math.min(this.mapObject.baseMapBounds.latitude.min, coordinates[1]);
          this.mapObject.baseMapBounds.latitude.max = Math.max(this.mapObject.baseMapBounds.latitude.max, coordinates[1]);
          this.mapObject.baseMapBounds.longitude.min = Math.min(this.mapObject.baseMapBounds.longitude.min, coordinates[0]);
          this.mapObject.baseMapBounds.longitude.max = Math.max(this.mapObject.baseMapBounds.longitude.max, coordinates[0]);
        }
      }
    };
    LayerPanel2.prototype.generateTiles = function(zoomLevel, tileTranslatePoint, zoomType, bing, position, isPinch) {
      var userLang = this.mapObject.locale;
      var size = this.mapObject.availableSize;
      this.tiles = [];
      var xcount;
      var ycount;
      xcount = ycount = Math.pow(2, zoomLevel);
      var xLeft = 0;
      var xRight = 0;
      if (tileTranslatePoint.x + xcount * 256 < size.width) {
        xLeft = tileTranslatePoint.x > 0 ? Math.ceil(tileTranslatePoint.x / 256) : 0;
        xRight = tileTranslatePoint.x + xcount * 256 < size.width ? Math.ceil((size.width - (tileTranslatePoint.x + xcount * 256)) / 256) : 0;
      }
      xcount += xLeft + xRight;
      if (zoomType === "Pan") {
        xcount = this.horizontalPanXCount >= xcount ? this.horizontalPanXCount : xcount;
        this.horizontalPan = false;
      } else {
        this.horizontalPanXCount = xcount;
        this.horizontalPan = true;
      }
      var baseLayer = this.mapObject.layers[this.mapObject.baseLayerIndex];
      this.urlTemplate = baseLayer.urlTemplate;
      var endY = Math.min(ycount, (-tileTranslatePoint.y + size.height) / 256 + 1);
      var endX = Math.min(xcount, (-tileTranslatePoint.x + size.width + xRight * 256) / 256 + 1);
      var startX = -(tileTranslatePoint.x + xLeft * 256 + 256) / 256;
      var startY = -(tileTranslatePoint.y + 256) / 256;
      bing = bing || this.bing || this.mapObject.bingMap;
      for (var i = Math.round(startX); i < Math.round(endX); i++) {
        for (var j = Math.round(startY); j < Math.round(endY); j++) {
          var x = 256 * i + tileTranslatePoint.x;
          var y = 256 * j + tileTranslatePoint.y;
          if (x > -256 && x <= size.width && y > -256 && y < size.height) {
            if (j >= 0) {
              var tileI = i;
              if (i < 0) {
                tileI = tileI % ycount + ycount;
              }
              var tile = new Tile(tileI % ycount, j);
              tile.left = Math.round(x);
              tile.top = Math.round(y);
              if (bing && !isNullOrUndefined(baseLayer.urlTemplate) && baseLayer.urlTemplate !== "" && baseLayer.urlTemplate.indexOf("quadkey") > -1) {
                tile.src = bing.getBingMap(tile, "", "", userLang, bing.imageUrl, bing.subDomains);
              } else {
                bing = null;
                tile.src = this.urlTemplate.replace("level", zoomLevel.toString()).replace("tileX", tile.x.toString()).replace("tileY", tile.y.toString());
              }
              this.tiles.push(tile);
            }
          }
        }
      }
      if (!isNullOrUndefined(zoomType)) {
        if (zoomType.indexOf("wheel") > 1) {
          this.animateToZoomX = this.mapObject.availableSize.width / 2 - position.x - 10;
          this.animateToZoomY = -position.y;
        } else {
          this.animateToZoomX = -10;
          this.animateToZoomY = -(this.mapObject.availableSize.height / 2 + 11.5) + 10;
        }
      }
      var proxTiles = extend([], this.tiles, [], true);
      for (var _i = 0, _a = this.mapObject.layers; _i < _a.length; _i++) {
        var layer = _a[_i];
        if (!(layer.type === "SubLayer" && layer.visible)) {
          continue;
        }
        if (isNullOrUndefined(layer.shapeData) && !isNullOrUndefined(layer.urlTemplate) && layer.urlTemplate !== "") {
          for (var _b = 0, proxTiles_1 = proxTiles; _b < proxTiles_1.length; _b++) {
            var baseTile = proxTiles_1[_b];
            var subtile = extend({}, baseTile, {}, true);
            if (layer.urlTemplate.indexOf("quadkey")) {
              bing = new BingMap(this.mapObject);
              subtile.src = bing.getBingMap(subtile, "", "", userLang, bing.imageUrl, bing.subDomains);
            } else {
              subtile.src = layer.urlTemplate.replace("level", zoomLevel.toString()).replace("tileX", baseTile.x.toString()).replace("tileY", baseTile.y.toString());
            }
            this.tiles.push(subtile);
          }
        }
      }
      if (this.mapObject.previousScale !== this.mapObject.scale || this.mapObject.isReset || this.mapObject.isZoomByPosition || this.mapObject.zoomNotApplied) {
        this.arrangeTiles(zoomType, this.animateToZoomX, this.animateToZoomY, isPinch);
      }
    };
    LayerPanel2.prototype.arrangeTiles = function(type, x, y, isPinch) {
      var _this = this;
      if (isPinch === void 0) {
        isPinch = false;
      }
      var element = document.getElementById(this.mapObject.element.id + "_tile_parent");
      var element1 = document.getElementById(this.mapObject.element.id + "_tiles");
      if (!isPinch) {
        var timeOut = void 0;
        if (!isNullOrUndefined(type) && type !== "Pan") {
          this.tileAnimation(type, x, y);
          timeOut = animationMode === "Disable" ? 0 : this.mapObject.layersCollection[0].animationDuration === 0 && animationMode === "Enable" ? 1e3 : this.mapObject.layersCollection[0].animationDuration;
        } else {
          timeOut = 0;
        }
        setTimeout(function() {
          if (element) {
            element.style.zIndex = "1";
          }
          if (element1) {
            element1.style.zIndex = "0";
          }
          var animateElement2;
          if (!document.getElementById(_this.mapObject.element.id + "_animated_tiles") && element) {
            animateElement2 = createElement("div", { id: _this.mapObject.element.id + "_animated_tiles" });
            element.appendChild(animateElement2);
          } else {
            if (type !== "Pan" && element1 && element) {
              element1.appendChild(element.children[0]);
              if (!_this.mapObject.isAddLayer && !isNullOrUndefined(document.getElementById(_this.mapObject.element.id + "_animated_tiles"))) {
                document.getElementById(_this.mapObject.element.id + "_animated_tiles").id = _this.mapObject.element.id + "_animated_tiles_old";
              }
              animateElement2 = createElement("div", { id: _this.mapObject.element.id + "_animated_tiles" });
              element.appendChild(animateElement2);
            } else {
              animateElement2 = element ? element.children[0] : null;
            }
          }
          _this.tileProcess(type, animateElement2, isPinch);
          if (!isNullOrUndefined(_this.mapObject.currentTiles)) {
            for (var l = _this.tiles.length; l < animateElement2.childElementCount; l++) {
              var isExistingElement = false;
              for (var a = 0; a < _this.mapObject.currentTiles.childElementCount; a++) {
                if (!isExistingElement && _this.mapObject.currentTiles.children[a].id === animateElement2.children[l].id) {
                  isExistingElement = true;
                }
              }
              if (isExistingElement) {
                animateElement2.children[l].style.display = "none";
              } else {
                animateElement2.removeChild(animateElement2.children[l]);
              }
            }
          }
        }, timeOut);
      } else {
        var animateElement = document.getElementById(this.mapObject.element.id + "_animates_tiles");
        if (isNullOrUndefined(animateElement)) {
          animateElement = createElement("div", { id: this.mapObject.element.id + "_animates_tiles" });
        }
        this.tileProcess(type, animateElement, isPinch);
        element1.appendChild(animateElement);
      }
    };
    LayerPanel2.prototype.tileProcess = function(type, animateElement, isPinch) {
      for (var id = 0; id < this.tiles.length; id++) {
        var tile = this.tiles[id];
        var imgElement = null;
        var mapId = this.mapObject.element.id;
        if (type === "Pan") {
          var child = document.getElementById(mapId + "_tile_" + id);
          var isNewTile = false;
          if (isNullOrUndefined(child)) {
            isNewTile = true;
            child = createElement("div", { id: mapId + "_tile_" + id });
            imgElement = createElement("img");
          } else {
            child.style.removeProperty("display");
            imgElement = child.children[0];
          }
          if (!isNewTile && imgElement && imgElement.src !== tile.src) {
            imgElement.src = tile.src;
          }
          child.style.position = "absolute";
          child.style.left = tile.left + "px";
          child.style.top = tile.top + "px";
          child.style.height = tile.height + "px";
          child.style.width = tile.width + "px";
          if (isNewTile) {
            imgElement.setAttribute("height", "256px");
            imgElement.setAttribute("width", "256px");
            imgElement.setAttribute("src", tile.src);
            imgElement.setAttribute("alt", this.mapObject.getLocalizedLabel("ImageNotFound"));
            imgElement.style.setProperty("user-select", "none");
            child.appendChild(imgElement);
            animateElement.appendChild(child);
          }
        } else {
          imgElement = createElement("img");
          imgElement.setAttribute("height", "256px");
          imgElement.setAttribute("width", "256px");
          imgElement.setAttribute("src", tile.src);
          imgElement.style.setProperty("user-select", "none");
          imgElement.setAttribute("alt", this.mapObject.getLocalizedLabel("ImageNotFound"));
          var child = createElement("div", { id: mapId + "_tile_" + id });
          child.style.position = "absolute";
          child.style.left = tile.left + "px";
          child.style.top = tile.top + "px";
          child.style.height = tile.height + "px";
          child.style.width = tile.width + "px";
          child.appendChild(imgElement);
          if (animateElement) {
            animateElement.appendChild(child);
          }
        }
        if (!isPinch && id === this.tiles.length - 1 && document.getElementById(this.mapObject.element.id + "_animated_tiles_old")) {
          removeElement2(this.mapObject.element.id + "_animated_tiles_old");
        }
      }
    };
    LayerPanel2.prototype.tileAnimation = function(zoomType, translateX, translateY) {
      var tileParent = document.getElementById(this.mapObject.element.id + "_tile_parent");
      var animatedTiles = document.getElementById(this.mapObject.element.id + "_animated_tiles");
      var tileElement = document.getElementById(this.mapObject.element.id + "_tiles");
      var scaleValue = "2";
      if (zoomType.indexOf("ZoomOut") === 0 || zoomType === "Reset") {
        tileElement.style.zIndex = "1";
        tileParent.style.zIndex = "0";
        while (tileElement.childElementCount >= 1) {
          tileElement.removeChild(tileElement.children[0]);
        }
        translateX = 0;
        translateY = document.getElementById(this.mapObject.element.id + "_tile_parent").getClientRects()[0].height / 4;
        scaleValue = zoomType.indexOf("ZoomOut") === 0 ? "0.5" : "0.2";
      }
      if (!isNullOrUndefined(animatedTiles)) {
        animatedTiles.style.transition = animationMode === "Disable" ? "0ms" : this.mapObject.layersCollection[0].animationDuration === 0 && animationMode === "Enable" ? "1000ms" : this.mapObject.layersCollection[0].animationDuration + "ms";
        animatedTiles.style.transform = "translate(" + translateX + "px, " + translateY + "px) scale(" + scaleValue + ")";
      }
    };
    LayerPanel2.prototype.panTileMap = function(factorX, factorY, centerPosition) {
      if (this.mapObject.tileZoomLevel <= this.mapObject.tileZoomScale && this.mapObject.initialCheck) {
        this.mapObject.tileZoomLevel = this.mapObject.tileZoomScale;
      }
      var level = this.mapObject.tileZoomLevel;
      var padding = 20;
      var x;
      var y;
      var totalSize = Math.pow(2, level) * 256;
      x = factorX / 2 - totalSize / 2;
      y = factorY / 2 - totalSize / 2;
      var position = convertTileLatLongToPoint(centerPosition, level, { x, y }, this.isMapCoordinates);
      padding = this.mapObject.zoomNotApplied ? 0 : padding;
      x -= position.x - factorX / 2;
      y = y - (position.y - factorY / 2) + padding;
      this.mapObject.scale = Math.pow(2, level - 1);
      if (isNullOrUndefined(this.mapObject.tileTranslatePoint) || this.mapObject.tileTranslatePoint.y === 0 && this.mapObject.tileTranslatePoint.x === 0 || (isNullOrUndefined(this.mapObject.previousTileWidth) || isNullOrUndefined(this.mapObject.previousTileHeight))) {
        this.mapObject.previousTileWidth = factorX;
        this.mapObject.previousTileHeight = factorY;
      }
      if (!isNullOrUndefined(this.mapObject.tileTranslatePoint) && isNullOrUndefined(centerPosition.x) && (this.mapObject.zoomSettings.zoomFactor === 1 || this.mapObject.zoomSettings.zoomFactor !== level || !this.mapObject.defaultState)) {
        if (factorX !== this.mapObject.previousTileWidth || factorY !== this.mapObject.previousTileHeight) {
          var xdiff = x - (this.mapObject.previousTileWidth / 2 - totalSize / 2);
          var ydiff = y - (this.mapObject.previousTileHeight / 2 - totalSize / 2 + padding);
          this.mapObject.tileTranslatePoint.x = this.mapObject.tileTranslatePoint.x + xdiff;
          this.mapObject.tileTranslatePoint.y = this.mapObject.tileTranslatePoint.y + ydiff;
        }
      }
      if (!isNullOrUndefined(this.mapObject.tileTranslatePoint) && !this.mapObject.zoomNotApplied) {
        if (this.mapObject.tileTranslatePoint.x !== 0 && this.mapObject.tileTranslatePoint.x !== x && !this.mapObject.centerPositionChanged) {
          x = this.mapObject.tileTranslatePoint.x;
        }
        if (this.mapObject.tileTranslatePoint.y !== 0 && this.mapObject.tileTranslatePoint.y !== y && !this.mapObject.centerPositionChanged) {
          y = this.mapObject.tileTranslatePoint.y;
        }
      }
      this.mapObject.translatePoint = new Point((x - 0.01 * this.mapObject.zoomSettings.zoomFactor) / this.mapObject.scale, (y - 0.01 * this.mapObject.zoomSettings.zoomFactor) / this.mapObject.scale);
      this.mapObject.previousTileWidth = factorX;
      this.mapObject.previousTileHeight = factorY;
      return new Point(x, y);
    };
    LayerPanel2.prototype.destroy = function() {
      this.mapObject = null;
      this.groupElements = [];
      this.layerObject = null;
      this.currentLayer = null;
      this.rectBounds = null;
      this.tiles = [];
      this.clipRectElement = null;
      this.tileSvgObject = null;
      this.ajaxModule = null;
      this.ajaxResponse = [];
      this.layerGroup = null;
      if (!isNullOrUndefined(this.bing)) {
        this.bing.destroy();
      }
      this.bing = null;
    };
    return LayerPanel2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/user-interaction/annotation.js
var Annotations = (
  /** @class */
  (function() {
    function Annotations2(map) {
      this.map = map;
    }
    Annotations2.prototype.renderAnnotationElements = function() {
      var _this = this;
      var secondaryID = this.map.element.id + "_Secondary_Element";
      var annotationGroup = createElement("div", { id: this.map.element.id + "_Annotations_Group" });
      annotationGroup.style.position = "absolute";
      annotationGroup.style.top = "0px";
      annotationGroup.style.left = "0px";
      this.map.annotations.map(function(annotation, index) {
        if (annotation.content !== null) {
          _this.createAnnotationTemplate(annotationGroup, annotation, index);
        }
      });
      if (annotationGroup.childElementCount > 0 && !isNullOrUndefined(getElementByID(secondaryID))) {
        getElementByID(secondaryID).appendChild(annotationGroup);
      }
      this.map.renderReactTemplates();
    };
    Annotations2.prototype.createAnnotationTemplate = function(parentElement, annotation, annotationIndex) {
      var _this = this;
      var left;
      var top;
      var templateFn;
      var map = this.map;
      var templateElement;
      var availSize = map.availableSize;
      var childElement = createElement("div", {
        id: map.element.id + "_Annotation_" + annotationIndex
      });
      childElement.style.cssText = "position: absolute; z-index:" + annotation.zIndex + ";";
      var argsData = {
        cancel: false,
        name: annotationRendering,
        content: annotation.content,
        annotation
      };
      this.map.trigger(annotationRendering, argsData, function(annotationArgs) {
        if (argsData.cancel) {
          return;
        }
        templateFn = getTemplateFunction(argsData.content, _this.map);
        if (templateFn && templateFn(_this.map, _this.map, argsData.content, _this.map.element.id + "_ContentTemplate_" + annotationIndex).length) {
          templateElement = Array.prototype.slice.call(templateFn(_this.map, _this.map, argsData.content, _this.map.element.id + "_ContentTemplate_" + annotationIndex));
          var length_1 = templateElement.length;
          for (var i = 0; i < length_1; i++) {
            childElement.appendChild(templateElement[i]);
          }
        } else {
          childElement.appendChild(createElement("div", {
            innerHTML: argsData.content
          }));
        }
      });
      var offset = getElementOffset(childElement.cloneNode(true), map.element);
      var elementRect = map.element.getBoundingClientRect();
      var bounds = map.svgObject.getBoundingClientRect();
      left = Math.abs(bounds.left - elementRect.left);
      top = Math.abs(bounds.top - elementRect.top);
      var annotationX = !isNullOrUndefined(annotation.x) ? annotation.x : "0%";
      var annotationY = !isNullOrUndefined(annotation.y) ? annotation.y : "0%";
      var annotationXValue = annotationX.indexOf("%") > -1 ? availSize.width / 100 * parseFloat(annotationX) : parseFloat(annotationX);
      var annotationYValue = annotationY.indexOf("%") > -1 ? availSize.height / 100 * parseFloat(annotationY) : parseFloat(annotationY);
      left = annotation.horizontalAlignment === "None" ? left + annotationXValue : left;
      top = annotation.verticalAlignment === "None" ? top + annotationYValue : top;
      switch (annotation.verticalAlignment) {
        case "Near":
          top = top + annotationYValue;
          break;
        case "Center":
          top = top + annotationYValue + (bounds.height / 2 - offset.height / 2);
          break;
        case "Far":
          top = top + bounds.height + annotationYValue - offset.height;
          break;
      }
      switch (annotation.horizontalAlignment) {
        case "Near":
          left = left + annotationXValue;
          break;
        case "Center":
          left = left + annotationXValue + (bounds.width / 2 - offset.width / 2);
          break;
        case "Far":
          left = left + bounds.width + annotationXValue - offset.width;
          break;
      }
      childElement.style.left = left + "px";
      childElement.style.top = top + "px";
      parentElement.appendChild(childElement);
    };
    Annotations2.prototype.getModuleName = function() {
      return "Annotations";
    };
    Annotations2.prototype.destroy = function() {
      this.map = null;
    };
    return Annotations2;
  })()
);

// node_modules/@syncfusion/ej2-data/src/query.js
var Query = (
  /** @class */
  (function() {
    function Query2(from) {
      this.subQuery = null;
      this.isChild = false;
      this.distincts = [];
      this.queries = [];
      this.key = "";
      this.fKey = "";
      if (typeof from === "string") {
        this.fromTable = from;
      } else if (from && from instanceof Array) {
        this.lookups = from;
      }
      this.expands = [];
      this.sortedColumns = [];
      this.groupedColumns = [];
      this.subQuery = null;
      this.isChild = false;
      this.params = [];
      this.lazyLoad = [];
      return this;
    }
    Object.defineProperty(Query2.prototype, "moduleName", {
      /** @hidden */
      get: function() {
        return "query";
      },
      enumerable: true,
      configurable: true
    });
    ;
    Query2.prototype.setKey = function(field) {
      this.key = field;
      return this;
    };
    Query2.prototype.using = function(dataManager) {
      this.dataManager = dataManager;
      return this;
    };
    Query2.prototype.execute = function(dataManager, done, fail, always) {
      dataManager = dataManager || this.dataManager;
      if (dataManager) {
        return dataManager.executeQuery(this, done, fail, always);
      }
      return DataUtil.throwError('Query - execute() : dataManager needs to be is set using "using" function or should be passed as argument');
    };
    Query2.prototype.executeLocal = function(dataManager) {
      dataManager = dataManager || this.dataManager;
      if (dataManager) {
        return dataManager.executeLocal(this);
      }
      return DataUtil.throwError('Query - executeLocal() : dataManager needs to be is set using "using" function or should be passed as argument');
    };
    Query2.prototype.clone = function() {
      var cloned = new Query2();
      cloned.queries = this.queries.slice(0);
      cloned.key = this.key;
      cloned.isChild = this.isChild;
      cloned.dataManager = this.dataManager;
      cloned.fromTable = this.fromTable;
      cloned.params = this.params.slice(0);
      cloned.expands = this.expands.slice(0);
      cloned.sortedColumns = this.sortedColumns.slice(0);
      cloned.groupedColumns = this.groupedColumns.slice(0);
      cloned.subQuerySelector = this.subQuerySelector;
      cloned.subQuery = this.subQuery;
      cloned.fKey = this.fKey;
      cloned.isCountRequired = this.isCountRequired;
      cloned.distincts = this.distincts.slice(0);
      cloned.lazyLoad = this.lazyLoad.slice(0);
      return cloned;
    };
    Query2.prototype.from = function(tableName) {
      this.fromTable = tableName;
      return this;
    };
    Query2.prototype.addParams = function(key, value) {
      if (typeof value === "function") {
        this.params.push({ key, fn: value });
      } else {
        this.params.push({ key, value });
      }
      return this;
    };
    Query2.prototype.distinct = function(fields) {
      if (typeof fields === "string") {
        this.distincts = [].slice.call([fields], 0);
      } else {
        this.distincts = fields.slice(0);
      }
      return this;
    };
    Query2.prototype.expand = function(tables) {
      if (typeof tables === "string") {
        this.expands = [].slice.call([tables], 0);
      } else {
        this.expands = tables.slice(0);
      }
      return this;
    };
    Query2.prototype.where = function(fieldName, operator, value, ignoreCase, ignoreAccent, matchCase) {
      operator = operator ? operator.toLowerCase() : null;
      var predicate = null;
      if (typeof fieldName === "string") {
        predicate = new Predicate(fieldName, operator, value, ignoreCase, ignoreAccent, matchCase);
      } else if (fieldName instanceof Predicate) {
        predicate = fieldName;
      }
      this.queries.push({
        fn: "onWhere",
        e: predicate
      });
      return this;
    };
    Query2.prototype.search = function(searchKey, fieldNames, operator, ignoreCase, ignoreAccent) {
      if (typeof fieldNames === "string") {
        fieldNames = [fieldNames];
      }
      if (!operator || operator === "none") {
        operator = "contains";
      }
      var comparer = DataUtil.fnOperators[operator];
      this.queries.push({
        fn: "onSearch",
        e: {
          fieldNames,
          operator,
          searchKey,
          ignoreCase,
          ignoreAccent,
          comparer
        }
      });
      return this;
    };
    Query2.prototype.sortBy = function(fieldName, comparer, isFromGroup) {
      return this.sortByForeignKey(fieldName, comparer, isFromGroup);
    };
    Query2.prototype.sortByForeignKey = function(fieldName, comparer, isFromGroup, direction) {
      var order = !isNullOrUndefined(direction) ? direction : "ascending";
      var sorts;
      var temp;
      if (typeof fieldName === "string" && DataUtil.endsWith(fieldName.toLowerCase(), " desc")) {
        fieldName = fieldName.replace(/ desc$/i, "");
        comparer = "descending";
      }
      if (!comparer || typeof comparer === "string") {
        order = comparer ? comparer.toLowerCase() : "ascending";
        comparer = DataUtil.fnSort(comparer);
      }
      if (isFromGroup) {
        sorts = Query2.filterQueries(this.queries, "onSortBy");
        for (var i = 0; i < sorts.length; i++) {
          temp = sorts[i].e.fieldName;
          if (typeof temp === "string") {
            if (temp === fieldName) {
              return this;
            }
          } else if (temp instanceof Array) {
            for (var j = 0; j < temp.length; j++) {
              if (temp[j] === fieldName || fieldName.toLowerCase() === temp[j] + " desc") {
                return this;
              }
            }
          }
        }
      }
      this.queries.push({
        fn: "onSortBy",
        e: {
          fieldName,
          comparer,
          direction: order
        }
      });
      return this;
    };
    Query2.prototype.sortByDesc = function(fieldName) {
      return this.sortBy(fieldName, "descending");
    };
    Query2.prototype.group = function(fieldName, fn, format) {
      this.sortBy(fieldName, null, true);
      this.queries.push({
        fn: "onGroup",
        e: {
          fieldName,
          comparer: fn ? fn : null,
          format: format ? format : null
        }
      });
      return this;
    };
    Query2.prototype.page = function(pageIndex, pageSize) {
      this.queries.push({
        fn: "onPage",
        e: {
          pageIndex,
          pageSize
        }
      });
      return this;
    };
    Query2.prototype.range = function(start, end) {
      this.queries.push({
        fn: "onRange",
        e: {
          start,
          end
        }
      });
      return this;
    };
    Query2.prototype.take = function(nos) {
      this.queries.push({
        fn: "onTake",
        e: {
          nos
        }
      });
      return this;
    };
    Query2.prototype.skip = function(nos) {
      this.queries.push({
        fn: "onSkip",
        e: { nos }
      });
      return this;
    };
    Query2.prototype.select = function(fieldNames) {
      if (typeof fieldNames === "string") {
        fieldNames = [].slice.call([fieldNames], 0);
      }
      this.queries.push({
        fn: "onSelect",
        e: { fieldNames }
      });
      return this;
    };
    Query2.prototype.hierarchy = function(query, selectorFn) {
      this.subQuerySelector = selectorFn;
      this.subQuery = query;
      return this;
    };
    Query2.prototype.foreignKey = function(key) {
      this.fKey = key;
      return this;
    };
    Query2.prototype.requiresCount = function() {
      this.isCountRequired = true;
      return this;
    };
    Query2.prototype.aggregate = function(type, field) {
      this.queries.push({
        fn: "onAggregates",
        e: { field, type }
      });
      return this;
    };
    Query2.filterQueries = function(queries, name) {
      return queries.filter(function(q) {
        return q.fn === name;
      });
    };
    Query2.filterQueryLists = function(queries, singles) {
      var filtered = queries.filter(function(q) {
        return singles.indexOf(q.fn) !== -1;
      });
      var res = {};
      for (var i = 0; i < filtered.length; i++) {
        if (!res[filtered[i].fn]) {
          res[filtered[i].fn] = filtered[i].e;
        }
      }
      return res;
    };
    return Query2;
  })()
);
var Predicate = (
  /** @class */
  (function() {
    function Predicate2(field, operator, value, ignoreCase, ignoreAccent, matchCase) {
      if (ignoreCase === void 0) {
        ignoreCase = false;
      }
      this.ignoreAccent = false;
      this.isComplex = false;
      if (typeof field === "string") {
        this.field = field;
        this.operator = operator.toLowerCase();
        this.value = value;
        this.matchCase = matchCase;
        this.ignoreCase = ignoreCase;
        this.ignoreAccent = ignoreAccent;
        this.isComplex = false;
        this.comparer = DataUtil.fnOperators.processOperator(this.operator);
      } else if (field instanceof Predicate2 && value instanceof Predicate2 || value instanceof Array) {
        this.isComplex = true;
        this.condition = operator.toLowerCase();
        this.predicates = [field];
        this.matchCase = field.matchCase;
        this.ignoreCase = field.ignoreCase;
        this.ignoreAccent = field.ignoreAccent;
        if (value instanceof Array) {
          [].push.apply(this.predicates, value);
        } else {
          this.predicates.push(value);
        }
      }
      return this;
    }
    Predicate2.and = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return Predicate2.combinePredicates([].slice.call(args, 0), "and");
    };
    Predicate2.prototype.and = function(field, operator, value, ignoreCase, ignoreAccent) {
      return Predicate2.combine(this, field, operator, value, "and", ignoreCase, ignoreAccent);
    };
    Predicate2.or = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return Predicate2.combinePredicates([].slice.call(args, 0), "or");
    };
    Predicate2.prototype.or = function(field, operator, value, ignoreCase, ignoreAccent) {
      return Predicate2.combine(this, field, operator, value, "or", ignoreCase, ignoreAccent);
    };
    Predicate2.ornot = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return Predicate2.combinePredicates([].slice.call(args, 0), "or not");
    };
    Predicate2.prototype.ornot = function(field, operator, value, ignoreCase, ignoreAccent) {
      return Predicate2.combine(this, field, operator, value, "ornot", ignoreCase, ignoreAccent);
    };
    Predicate2.andnot = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return Predicate2.combinePredicates([].slice.call(args, 0), "and not");
    };
    Predicate2.prototype.andnot = function(field, operator, value, ignoreCase, ignoreAccent) {
      return Predicate2.combine(this, field, operator, value, "andnot", ignoreCase, ignoreAccent);
    };
    Predicate2.fromJson = function(json) {
      if (json instanceof Array) {
        var res = [];
        for (var i = 0, len = json.length; i < len; i++) {
          res.push(this.fromJSONData(json[i]));
        }
        return res;
      }
      var pred = json;
      return this.fromJSONData(pred);
    };
    Predicate2.prototype.validate = function(record) {
      var predicate = this.predicates ? this.predicates : [];
      var ret;
      var isAnd;
      if (!this.isComplex && this.comparer) {
        if (this.condition && this.condition.indexOf("not") !== -1) {
          this.condition = this.condition.split("not")[0] === "" ? void 0 : this.condition.split("not")[0];
          return !this.comparer.call(this, DataUtil.getObject(this.field, record), this.value, this.ignoreCase, this.ignoreAccent);
        } else {
          return this.comparer.call(this, DataUtil.getObject(this.field, record), this.value, this.ignoreCase, this.ignoreAccent);
        }
      }
      if (this.condition && this.condition.indexOf("not") !== -1) {
        isAnd = this.condition.indexOf("and") !== -1;
      } else {
        isAnd = this.condition === "and";
      }
      for (var i = 0; i < predicate.length; i++) {
        if (i > 0 && this.condition && this.condition.indexOf("not") !== -1) {
          predicate[i].condition = predicate[i].condition ? predicate[i].condition + "not" : "not";
        }
        ret = predicate[i].validate(record);
        if (isAnd) {
          if (!ret) {
            return false;
          }
        } else {
          if (ret) {
            return true;
          }
        }
      }
      return isAnd;
    };
    Predicate2.prototype.toJson = function() {
      var predicates;
      var p;
      if (this.isComplex) {
        predicates = [];
        p = this.predicates;
        for (var i = 0; i < p.length; i++) {
          predicates.push(p[i].toJson());
        }
      }
      return {
        isComplex: this.isComplex,
        field: this.field,
        operator: this.operator,
        value: this.value,
        ignoreCase: this.ignoreCase,
        ignoreAccent: this.ignoreAccent,
        condition: this.condition,
        predicates,
        matchCase: this.matchCase
      };
    };
    Predicate2.combinePredicates = function(predicates, operator) {
      if (predicates.length === 1) {
        if (!(predicates[0] instanceof Array)) {
          return predicates[0];
        }
        predicates = predicates[0];
      }
      return new Predicate2(predicates[0], operator, predicates.slice(1));
    };
    Predicate2.combine = function(pred, field, operator, value, condition, ignoreCase, ignoreAccent) {
      if (field instanceof Predicate2) {
        return Predicate2[condition](pred, field);
      }
      if (typeof field === "string") {
        return Predicate2[condition](pred, new Predicate2(field, operator, value, ignoreCase, ignoreAccent));
      }
      return DataUtil.throwError("Predicate - " + condition + " : invalid arguments");
    };
    Predicate2.fromJSONData = function(json) {
      var preds = json.predicates || [];
      var len = preds.length;
      var predicates = [];
      var result;
      for (var i = 0; i < len; i++) {
        predicates.push(this.fromJSONData(preds[i]));
      }
      if (!json.isComplex) {
        result = new Predicate2(json.field, json.operator, json.value, json.ignoreCase, json.ignoreAccent);
      } else {
        result = new Predicate2(predicates[0], json.condition, predicates.slice(1));
      }
      return result;
    };
    return Predicate2;
  })()
);

// node_modules/@syncfusion/ej2-data/src/util.js
var consts = { GroupGuid: "{271bbba0-1ee7}" };
var DataUtil = (
  /** @class */
  (function() {
    function DataUtil2() {
    }
    DataUtil2.getValue = function(value, inst) {
      if (typeof value === "function") {
        return value.call(inst || {});
      }
      return value;
    };
    DataUtil2.endsWith = function(input, substr) {
      return input.slice && input.slice(-substr.length) === substr;
    };
    DataUtil2.notEndsWith = function(input, substr) {
      return input.slice && input.slice(-substr.length) !== substr;
    };
    DataUtil2.startsWith = function(input, start) {
      return input.slice(0, start.length) === start;
    };
    DataUtil2.notStartsWith = function(input, start) {
      return input.slice(0, start.length) !== start;
    };
    DataUtil2.wildCard = function(input, pattern) {
      var asteriskSplit;
      var optionalSplit;
      if (pattern.indexOf("[") !== -1) {
        pattern = pattern.split("[").join("[[]");
      }
      if (pattern.indexOf("(") !== -1) {
        pattern = pattern.split("(").join("[(]");
      }
      if (pattern.indexOf(")") !== -1) {
        pattern = pattern.split(")").join("[)]");
      }
      if (pattern.indexOf("\\") !== -1) {
        pattern = pattern.split("\\").join("[\\\\]");
      }
      if (pattern.indexOf("*") !== -1) {
        if (pattern.charAt(0) !== "*") {
          pattern = "^" + pattern;
        }
        if (pattern.charAt(pattern.length - 1) !== "*") {
          pattern = pattern + "$";
        }
        asteriskSplit = pattern.split("*");
        for (var i = 0; i < asteriskSplit.length; i++) {
          if (asteriskSplit[i].indexOf(".") === -1) {
            asteriskSplit[i] = asteriskSplit[i] + ".*";
          } else {
            asteriskSplit[i] = asteriskSplit[i] + "*";
          }
        }
        pattern = asteriskSplit.join("");
      }
      if (pattern.indexOf("%3f") !== -1 || pattern.indexOf("?") !== -1) {
        optionalSplit = pattern.indexOf("%3f") !== -1 ? pattern.split("%3f") : pattern.split("?");
        pattern = optionalSplit.join(".");
      }
      var regexPattern = new RegExp(pattern, "g");
      return regexPattern.test(input);
    };
    DataUtil2.like = function(input, pattern) {
      if (pattern.indexOf("%") !== -1) {
        if (pattern.charAt(0) === "%" && pattern.lastIndexOf("%") < 2) {
          pattern = pattern.substring(1, pattern.length);
          return DataUtil2.startsWith(DataUtil2.toLowerCase(input), DataUtil2.toLowerCase(pattern));
        } else if (pattern.charAt(pattern.length - 1) === "%" && pattern.indexOf("%") > pattern.length - 3) {
          pattern = pattern.substring(0, pattern.length - 1);
          return DataUtil2.endsWith(DataUtil2.toLowerCase(input), DataUtil2.toLowerCase(pattern));
        } else if (pattern.lastIndexOf("%") !== pattern.indexOf("%") && pattern.lastIndexOf("%") > pattern.indexOf("%") + 1) {
          pattern = pattern.substring(pattern.indexOf("%") + 1, pattern.lastIndexOf("%"));
          return input.indexOf(pattern) !== -1;
        } else {
          return input.indexOf(pattern) !== -1;
        }
      } else {
        return false;
      }
    };
    DataUtil2.fnSort = function(order) {
      order = order ? DataUtil2.toLowerCase(order) : "ascending";
      if (order === "ascending") {
        return this.fnAscending;
      }
      return this.fnDescending;
    };
    DataUtil2.fnAscending = function(x, y) {
      if (isNullOrUndefined(x) && isNullOrUndefined(y)) {
        return 0;
      }
      if (y === null || y === void 0) {
        return -1;
      }
      if (typeof x === "string") {
        return x.localeCompare(y);
      }
      if (x === null || x === void 0) {
        return 1;
      }
      return x - y;
    };
    DataUtil2.fnDescending = function(x, y) {
      if (isNullOrUndefined(x) && isNullOrUndefined(y)) {
        return 0;
      }
      if (y === null || y === void 0) {
        return 1;
      }
      if (typeof x === "string") {
        return x.localeCompare(y) * -1;
      }
      if (x === null || x === void 0) {
        return -1;
      }
      return y - x;
    };
    DataUtil2.extractFields = function(obj, fields) {
      var newObj = {};
      for (var i = 0; i < fields.length; i++) {
        newObj = this.setValue(fields[i], this.getObject(fields[i], obj), newObj);
      }
      return newObj;
    };
    DataUtil2.select = function(jsonArray, fields) {
      var newData = [];
      for (var i = 0; i < jsonArray.length; i++) {
        newData.push(this.extractFields(jsonArray[i], fields));
      }
      return newData;
    };
    DataUtil2.group = function(jsonArray, field, aggregates, level, groupDs, format, isLazyLoad) {
      level = level || 1;
      var jsonData = jsonArray;
      var guid = "GroupGuid";
      if (jsonData.GroupGuid === consts[guid]) {
        var _loop_1 = function(j2) {
          if (!isNullOrUndefined(groupDs)) {
            var indx = -1;
            var temp = groupDs.filter(function(e) {
              return e.key === jsonData[j2].key;
            });
            indx = groupDs.indexOf(temp[0]);
            jsonData[j2].items = this_1.group(jsonData[j2].items, field, aggregates, jsonData.level + 1, groupDs[indx].items, format, isLazyLoad);
            jsonData[j2].count = groupDs[indx].count;
          } else {
            jsonData[j2].items = this_1.group(jsonData[j2].items, field, aggregates, jsonData.level + 1, null, format, isLazyLoad);
            jsonData[j2].count = jsonData[j2].items.length;
          }
        };
        var this_1 = this;
        for (var j = 0; j < jsonData.length; j++) {
          _loop_1(j);
        }
        jsonData.childLevels += 1;
        return jsonData;
      }
      var grouped = {};
      var groupedArray = [];
      groupedArray.GroupGuid = consts[guid];
      groupedArray.level = level;
      groupedArray.childLevels = 0;
      groupedArray.records = jsonData;
      var _loop_2 = function(i2) {
        var val = this_2.getVal(jsonData, i2, field);
        if (!isNullOrUndefined(format)) {
          val = format(val, field);
        }
        if (!grouped[val]) {
          grouped[val] = {
            key: val,
            count: 0,
            items: [],
            aggregates: {},
            field
          };
          groupedArray.push(grouped[val]);
          if (!isNullOrUndefined(groupDs)) {
            var tempObj = groupDs.filter(function(e) {
              return e.key === grouped[val].key;
            });
            grouped[val].count = tempObj[0].count;
          }
        }
        grouped[val].count = !isNullOrUndefined(groupDs) ? grouped[val].count : grouped[val].count += 1;
        if (!isLazyLoad || isLazyLoad && aggregates.length) {
          grouped[val].items.push(jsonData[i2]);
        }
      };
      var this_2 = this;
      for (var i = 0; i < jsonData.length; i++) {
        _loop_2(i);
      }
      if (aggregates && aggregates.length) {
        var _loop_3 = function(i2) {
          var res = {};
          var fn = void 0;
          var aggs = aggregates;
          for (var j2 = 0; j2 < aggregates.length; j2++) {
            fn = DataUtil2.aggregates[aggregates[j2].type];
            if (!isNullOrUndefined(groupDs)) {
              var temp = groupDs.filter(function(e) {
                return e.key === groupedArray[i2].key;
              });
              if (fn) {
                res[aggs[j2].field + " - " + aggs[j2].type] = fn(temp[0].items, aggs[j2].field);
              }
            } else {
              if (fn) {
                res[aggs[j2].field + " - " + aggs[j2].type] = fn(groupedArray[i2].items, aggs[j2].field);
              }
            }
          }
          groupedArray[i2].aggregates = res;
        };
        for (var i = 0; i < groupedArray.length; i++) {
          _loop_3(i);
        }
      }
      if (isLazyLoad && groupedArray.length && aggregates.length) {
        for (var i = 0; i < groupedArray.length; i++) {
          groupedArray[i].items = [];
        }
      }
      return jsonData.length && groupedArray || jsonData;
    };
    DataUtil2.buildHierarchy = function(fKey, from, source, lookup, pKey) {
      var i;
      var grp = {};
      var temp;
      if (lookup.result) {
        lookup = lookup.result;
      }
      if (lookup.GroupGuid) {
        this.throwError("DataManager: Do not have support Grouping in hierarchy");
      }
      for (i = 0; i < lookup.length; i++) {
        var fKeyData = this.getObject(fKey, lookup[i]);
        temp = grp[fKeyData] || (grp[fKeyData] = []);
        temp.push(lookup[i]);
      }
      for (i = 0; i < source.length; i++) {
        var fKeyData = this.getObject(pKey || fKey, source[i]);
        source[i][from] = grp[fKeyData];
      }
    };
    DataUtil2.getFieldList = function(obj, fields, prefix) {
      if (prefix === void 0) {
        prefix = "";
      }
      if (fields === void 0 || fields === null) {
        return this.getFieldList(obj, [], prefix);
      }
      var copyObj = obj;
      var keys2 = Object.keys(obj);
      for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
        var prop = keys_1[_i];
        if (typeof copyObj[prop] === "object" && !(copyObj[prop] instanceof Array)) {
          this.getFieldList(copyObj[prop], fields, prefix + prop + ".");
        } else {
          fields.push(prefix + prop);
        }
      }
      return fields;
    };
    DataUtil2.getObject = function(nameSpace, from) {
      if (!nameSpace) {
        return from;
      }
      if (!from) {
        return void 0;
      }
      if (nameSpace.indexOf(".") === -1) {
        if (!isNullOrUndefined(from[nameSpace])) {
          return from[nameSpace];
        } else {
          var lowerCaseNameSpace = nameSpace.charAt(0).toLowerCase() + nameSpace.slice(1);
          var upperCaseNameSpace = nameSpace.charAt(0).toUpperCase() + nameSpace.slice(1);
          if (!isNullOrUndefined(from[lowerCaseNameSpace])) {
            return from[lowerCaseNameSpace];
          } else if (!isNullOrUndefined(from[upperCaseNameSpace])) {
            return from[upperCaseNameSpace];
          } else {
            return null;
          }
        }
      }
      var value = from;
      var splits = nameSpace.split(".");
      for (var i = 0; i < splits.length; i++) {
        if (value == null) {
          break;
        }
        value = value[splits[i]];
        if (value === void 0) {
          var casing = splits[i].charAt(0).toUpperCase() + splits[i].slice(1);
          value = from[casing] || from[casing.charAt(0).toLowerCase() + casing.slice(1)] || null;
        }
        from = value;
      }
      return value;
    };
    DataUtil2.setValue = function(nameSpace, value, obj) {
      var keys2 = nameSpace.toString().split(".");
      var start = obj || {};
      var fromObj = start;
      var i;
      var length = keys2.length;
      var key;
      for (i = 0; i < length; i++) {
        key = keys2[i];
        if (i + 1 === length) {
          fromObj[key] = value === void 0 ? void 0 : value;
        } else if (isNullOrUndefined(fromObj[key])) {
          fromObj[key] = {};
        }
        fromObj = fromObj[key];
      }
      return start;
    };
    DataUtil2.sort = function(dataSource, field, comparer) {
      var _this = this;
      if (dataSource.length <= 1) {
        return dataSource;
      }
      return dataSource.slice().sort(function(a, b) {
        return comparer(_this.getVal([a], 0, field), _this.getVal([b], 0, field), a, b);
      });
    };
    DataUtil2.ignoreDiacritics = function(value) {
      if (typeof value !== "string") {
        return value;
      }
      var result = value.split("");
      var newValue = result.map(function(temp) {
        return temp in DataUtil2.diacritics ? DataUtil2.diacritics[temp] : temp;
      });
      return newValue.join("");
    };
    DataUtil2.ignoreDiacriticsForArrays = function(valueArray) {
      if (!Array.isArray(valueArray)) {
        return [];
      }
      return valueArray.map(function(item) {
        return DataUtil2.ignoreDiacritics(item);
      });
    };
    DataUtil2.merge = function(left, right, fieldName, comparer) {
      var result = [];
      var current;
      while (left.length > 0 || right.length > 0) {
        if (left.length > 0 && right.length > 0) {
          if (comparer) {
            current = comparer(this.getVal(left, 0, fieldName), this.getVal(right, 0, fieldName), left[0], right[0]) <= 0 ? left : right;
          } else {
            current = left[0][fieldName] < left[0][fieldName] ? left : right;
          }
        } else {
          current = left.length > 0 ? left : right;
        }
        result.push(current.shift());
      }
      return result;
    };
    DataUtil2.getVal = function(array, index, field) {
      return field ? this.getObject(field, array[index]) : array[index];
    };
    DataUtil2.toLowerCase = function(val) {
      if (isNullOrUndefined(val))
        return "";
      if (typeof val === "string")
        return val.toLowerCase();
      if (val instanceof Date)
        return val.toString().toLowerCase();
      return val.toString();
    };
    DataUtil2.callAdaptorFunction = function(adaptor, fnName, param1, param2) {
      if (fnName in adaptor) {
        var res = adaptor[fnName](param1, param2);
        if (!isNullOrUndefined(res)) {
          param1 = res;
        }
      }
      return param1;
    };
    DataUtil2.getAddParams = function(adp, dm, query) {
      var req = {};
      DataUtil2.callAdaptorFunction(adp, "addParams", {
        dm,
        query,
        params: query ? query.params : [],
        reqParams: req
      });
      return req;
    };
    DataUtil2.isPlainObject = function(obj) {
      return !!obj && obj.constructor === Object;
    };
    DataUtil2.isCors = function() {
      var xhr = null;
      var request = "XMLHttpRequest";
      try {
        xhr = new window[request]();
      } catch (e) {
      }
      return !!xhr && "withCredentials" in xhr;
    };
    DataUtil2.getGuid = function(prefix) {
      var hexs = "0123456789abcdef";
      var rand;
      return (prefix || "") + "00000000-0000-4000-0000-000000000000".replace(/0/g, function(val, i) {
        if ("crypto" in window && "getRandomValues" in crypto) {
          var arr = new Uint8Array(1);
          window.crypto.getRandomValues(arr);
          rand = arr[0] % 16 | 0;
        } else {
          rand = Math.random() * 16 | 0;
        }
        return hexs[i === 19 ? rand & 3 | 8 : rand];
      });
    };
    DataUtil2.isNull = function(val) {
      return val === void 0 || val === null;
    };
    DataUtil2.getItemFromComparer = function(array, field, comparer) {
      var keyVal;
      var current;
      var key;
      var i = 0;
      var castRequired = typeof DataUtil2.getVal(array, 0, field) === "string";
      if (array.length) {
        while (isNullOrUndefined(keyVal) && i < array.length) {
          keyVal = DataUtil2.getVal(array, i, field);
          key = array[i++];
        }
      }
      for (; i < array.length; i++) {
        current = DataUtil2.getVal(array, i, field);
        if (isNullOrUndefined(current)) {
          continue;
        }
        if (castRequired) {
          keyVal = +keyVal;
          current = +current;
        }
        if (comparer(keyVal, current) > 0) {
          keyVal = current;
          key = array[i];
        }
      }
      return key;
    };
    DataUtil2.distinct = function(json, fieldName, requiresCompleteRecord) {
      requiresCompleteRecord = isNullOrUndefined(requiresCompleteRecord) ? false : requiresCompleteRecord;
      var result = [];
      var val;
      var tmp = {};
      json.forEach(function(data, index) {
        val = typeof json[index] === "object" ? DataUtil2.getVal(json, index, fieldName) : json[index];
        if (!(val in tmp)) {
          result.push(!requiresCompleteRecord ? val : json[index]);
          tmp[val] = 1;
        }
      });
      return result;
    };
    DataUtil2.processData = function(dm, records) {
      var query = this.prepareQuery(dm);
      var sampledata = new DataManager(records);
      if (dm.requiresCounts) {
        query.requiresCount();
      }
      var result = sampledata.executeLocal(query);
      var returnValue = {
        result: dm.requiresCounts ? result.result : result,
        count: result.count,
        aggregates: JSON.stringify(result.aggregates)
      };
      return dm.requiresCounts ? returnValue : result;
    };
    DataUtil2.prepareQuery = function(dm) {
      var _this = this;
      var query = new Query();
      if (dm.select) {
        query.select(dm.select);
      }
      if (dm.where) {
        var where = DataUtil2.parse.parseJson(dm.where);
        where.filter(function(pred) {
          if (isNullOrUndefined(pred.condition)) {
            query.where(pred.field, pred.operator, pred.value, pred.ignoreCase, pred.ignoreAccent);
          } else {
            var predicateList = [];
            if (pred.field) {
              predicateList.push(new Predicate(pred.field, pred.operator, pred.value, pred.ignoreCase, pred.ignoreAccent));
            } else {
              predicateList = predicateList.concat(_this.getPredicate(pred.predicates));
            }
            if (pred.condition === "or") {
              query.where(Predicate.or(predicateList));
            } else if (pred.condition === "and") {
              query.where(Predicate.and(predicateList));
            }
          }
        });
      }
      if (dm.search) {
        var search = DataUtil2.parse.parseJson(dm.search);
        search.filter(function(e) {
          return query.search(
            e.key,
            e.fields,
            e["operator"],
            // tslint:disable-next-line:no-string-literal
            e["ignoreCase"],
            e["ignoreAccent"]
          );
        });
      }
      if (dm.aggregates) {
        dm.aggregates.filter(function(e) {
          return query.aggregate(e.type, e.field);
        });
      }
      if (dm.sorted) {
        dm.sorted.filter(function(e) {
          return query.sortBy(e.name, e.direction);
        });
      }
      if (dm.skip) {
        query.skip(dm.skip);
      }
      if (dm.take) {
        query.take(dm.take);
      }
      if (dm.group) {
        dm.group.filter(function(grp) {
          return query.group(grp);
        });
      }
      return query;
    };
    DataUtil2.getPredicate = function(pred) {
      var mainPred = [];
      for (var i = 0; i < pred.length; i++) {
        var e = pred[i];
        if (e.field) {
          mainPred.push(new Predicate(e.field, e.operator, e.value, e.ignoreCase, e.ignoreAccent));
        } else {
          var childPred = [];
          var cpre = this.getPredicate(e.predicates);
          for (var _i = 0, _a = Object.keys(cpre); _i < _a.length; _i++) {
            var prop = _a[_i];
            childPred.push(cpre[prop]);
          }
          mainPred.push(e.condition === "or" ? Predicate.or(childPred) : Predicate.and(childPred));
        }
      }
      return mainPred;
    };
    DataUtil2.serverTimezoneOffset = null;
    DataUtil2.timeZoneHandling = true;
    DataUtil2.throwError = function(error) {
      try {
        throw new Error(error);
      } catch (e) {
        throw e.message + "\n" + e.stack;
      }
    };
    DataUtil2.aggregates = {
      /**
       * Calculate sum of the given field in the data.
       *
       * @param  {Object[]} ds
       * @param  {string} field
       */
      sum: function(ds, field) {
        var result = 0;
        var val;
        var castRequired = typeof DataUtil2.getVal(ds, 0, field) !== "number";
        for (var i = 0; i < ds.length; i++) {
          val = DataUtil2.getVal(ds, i, field);
          if (!isNaN(val) && val !== null) {
            if (castRequired) {
              val = +val;
            }
            result += val;
          }
        }
        return result;
      },
      /**
       * Calculate average value of the given field in the data.
       *
       * @param  {Object[]} ds
       * @param  {string} field
       */
      average: function(ds, field) {
        return DataUtil2.aggregates.sum(ds, field) / ds.length;
      },
      /**
       * Returns the min value of the data based on the field.
       *
       * @param  {Object[]} ds
       * @param  {string|Function} field
       */
      min: function(ds, field) {
        var comparer;
        if (typeof field === "function") {
          comparer = field;
          field = null;
        }
        return DataUtil2.getObject(field, DataUtil2.getItemFromComparer(ds, field, comparer || DataUtil2.fnAscending));
      },
      /**
       * Returns the max value of the data based on the field.
       *
       * @param  {Object[]} ds
       * @param  {string} field
       * @returns number
       */
      max: function(ds, field) {
        var comparer;
        if (typeof field === "function") {
          comparer = field;
          field = null;
        }
        return DataUtil2.getObject(field, DataUtil2.getItemFromComparer(ds, field, comparer || DataUtil2.fnDescending));
      },
      /**
       * Returns the total number of true value present in the data based on the given boolean field name.
       *
       * @param  {Object[]} ds
       * @param  {string} field
       */
      truecount: function(ds, field) {
        return new DataManager(ds).executeLocal(new Query().where(field, "equal", true, true)).length;
      },
      /**
       * Returns the total number of false value present in the data based on the given boolean field name.
       *
       * @param  {Object[]} ds
       * @param  {string} field
       */
      falsecount: function(ds, field) {
        return new DataManager(ds).executeLocal(new Query().where(field, "equal", false, true)).length;
      },
      /**
       * Returns the length of the given data.
       *
       * @param {Object[]} ds
       * @param {string} field?
       * @param field
       * @returns number
       */
      count: function(ds, field) {
        return ds.length;
      }
    };
    DataUtil2.operatorSymbols = {
      "<": "lessthan",
      ">": "greaterthan",
      "<=": "lessthanorequal",
      ">=": "greaterthanorequal",
      "==": "equal",
      "!=": "notequal",
      "*=": "contains",
      "$=": "endswith",
      "^=": "startswith"
    };
    DataUtil2.odBiOperator = {
      "<": " lt ",
      ">": " gt ",
      "<=": " le ",
      ">=": " ge ",
      "==": " eq ",
      "!=": " ne ",
      "lessthan": " lt ",
      "lessthanorequal": " le ",
      "greaterthan": " gt ",
      "greaterthanorequal": " ge ",
      "equal": " eq ",
      "notequal": " ne "
    };
    DataUtil2.odUniOperator = {
      "$=": "endswith",
      "^=": "startswith",
      "*=": "substringof",
      "endswith": "endswith",
      "startswith": "startswith",
      "contains": "substringof",
      "doesnotendwith": "not endswith",
      "doesnotstartwith": "not startswith",
      "doesnotcontain": "not substringof",
      "wildcard": "wildcard",
      "like": "like"
    };
    DataUtil2.odv4UniOperator = {
      "$=": "endswith",
      "^=": "startswith",
      "*=": "contains",
      "endswith": "endswith",
      "startswith": "startswith",
      "contains": "contains",
      "doesnotendwith": "not endswith",
      "doesnotstartwith": "not startswith",
      "doesnotcontain": "not contains",
      "wildcard": "wildcard",
      "like": "like"
    };
    DataUtil2.diacritics = {
      "Ⓐ": "A",
      "Ａ": "A",
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ầ": "A",
      "Ấ": "A",
      "Ẫ": "A",
      "Ẩ": "A",
      "Ã": "A",
      "Ā": "A",
      "Ă": "A",
      "Ằ": "A",
      "Ắ": "A",
      "Ẵ": "A",
      "Ẳ": "A",
      "Ȧ": "A",
      "Ǡ": "A",
      "Ä": "A",
      "Ǟ": "A",
      "Ả": "A",
      "Å": "A",
      "Ǻ": "A",
      "Ǎ": "A",
      "Ȁ": "A",
      "Ȃ": "A",
      "Ạ": "A",
      "Ậ": "A",
      "Ặ": "A",
      "Ḁ": "A",
      "Ą": "A",
      "Ⱥ": "A",
      "Ɐ": "A",
      "Ꜳ": "AA",
      "Æ": "AE",
      "Ǽ": "AE",
      "Ǣ": "AE",
      "Ꜵ": "AO",
      "Ꜷ": "AU",
      "Ꜹ": "AV",
      "Ꜻ": "AV",
      "Ꜽ": "AY",
      "Ⓑ": "B",
      "Ｂ": "B",
      "Ḃ": "B",
      "Ḅ": "B",
      "Ḇ": "B",
      "Ƀ": "B",
      "Ƃ": "B",
      "Ɓ": "B",
      "Ⓒ": "C",
      "Ｃ": "C",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "Ç": "C",
      "Ḉ": "C",
      "Ƈ": "C",
      "Ȼ": "C",
      "Ꜿ": "C",
      "Ⓓ": "D",
      "Ｄ": "D",
      "Ḋ": "D",
      "Ď": "D",
      "Ḍ": "D",
      "Ḑ": "D",
      "Ḓ": "D",
      "Ḏ": "D",
      "Đ": "D",
      "Ƌ": "D",
      "Ɗ": "D",
      "Ɖ": "D",
      "Ꝺ": "D",
      "Ǳ": "DZ",
      "Ǆ": "DZ",
      "ǲ": "Dz",
      "ǅ": "Dz",
      "Ⓔ": "E",
      "Ｅ": "E",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ề": "E",
      "Ế": "E",
      "Ễ": "E",
      "Ể": "E",
      "Ẽ": "E",
      "Ē": "E",
      "Ḕ": "E",
      "Ḗ": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ë": "E",
      "Ẻ": "E",
      "Ě": "E",
      "Ȅ": "E",
      "Ȇ": "E",
      "Ẹ": "E",
      "Ệ": "E",
      "Ȩ": "E",
      "Ḝ": "E",
      "Ę": "E",
      "Ḙ": "E",
      "Ḛ": "E",
      "Ɛ": "E",
      "Ǝ": "E",
      "Ⓕ": "F",
      "Ｆ": "F",
      "Ḟ": "F",
      "Ƒ": "F",
      "Ꝼ": "F",
      "Ⓖ": "G",
      "Ｇ": "G",
      "Ǵ": "G",
      "Ĝ": "G",
      "Ḡ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ǧ": "G",
      "Ģ": "G",
      "Ǥ": "G",
      "Ɠ": "G",
      "Ꞡ": "G",
      "Ᵹ": "G",
      "Ꝿ": "G",
      "Ⓗ": "H",
      "Ｈ": "H",
      "Ĥ": "H",
      "Ḣ": "H",
      "Ḧ": "H",
      "Ȟ": "H",
      "Ḥ": "H",
      "Ḩ": "H",
      "Ḫ": "H",
      "Ħ": "H",
      "Ⱨ": "H",
      "Ⱶ": "H",
      "Ɥ": "H",
      "Ⓘ": "I",
      "Ｉ": "I",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "İ": "I",
      "Ï": "I",
      "Ḯ": "I",
      "Ỉ": "I",
      "Ǐ": "I",
      "Ȉ": "I",
      "Ȋ": "I",
      "Ị": "I",
      "Į": "I",
      "Ḭ": "I",
      "Ɨ": "I",
      "Ⓙ": "J",
      "Ｊ": "J",
      "Ĵ": "J",
      "Ɉ": "J",
      "Ⓚ": "K",
      "Ｋ": "K",
      "Ḱ": "K",
      "Ǩ": "K",
      "Ḳ": "K",
      "Ķ": "K",
      "Ḵ": "K",
      "Ƙ": "K",
      "Ⱪ": "K",
      "Ꝁ": "K",
      "Ꝃ": "K",
      "Ꝅ": "K",
      "Ꞣ": "K",
      "Ⓛ": "L",
      "Ｌ": "L",
      "Ŀ": "L",
      "Ĺ": "L",
      "Ľ": "L",
      "Ḷ": "L",
      "Ḹ": "L",
      "Ļ": "L",
      "Ḽ": "L",
      "Ḻ": "L",
      "Ł": "L",
      "Ƚ": "L",
      "Ɫ": "L",
      "Ⱡ": "L",
      "Ꝉ": "L",
      "Ꝇ": "L",
      "Ꞁ": "L",
      "Ǉ": "LJ",
      "ǈ": "Lj",
      "Ⓜ": "M",
      "Ｍ": "M",
      "Ḿ": "M",
      "Ṁ": "M",
      "Ṃ": "M",
      "Ɱ": "M",
      "Ɯ": "M",
      "Ⓝ": "N",
      "Ｎ": "N",
      "Ǹ": "N",
      "Ń": "N",
      "Ñ": "N",
      "Ṅ": "N",
      "Ň": "N",
      "Ṇ": "N",
      "Ņ": "N",
      "Ṋ": "N",
      "Ṉ": "N",
      "Ƞ": "N",
      "Ɲ": "N",
      "Ꞑ": "N",
      "Ꞥ": "N",
      "Ǌ": "NJ",
      "ǋ": "Nj",
      "Ⓞ": "O",
      "Ｏ": "O",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Ồ": "O",
      "Ố": "O",
      "Ỗ": "O",
      "Ổ": "O",
      "Õ": "O",
      "Ṍ": "O",
      "Ȭ": "O",
      "Ṏ": "O",
      "Ō": "O",
      "Ṑ": "O",
      "Ṓ": "O",
      "Ŏ": "O",
      "Ȯ": "O",
      "Ȱ": "O",
      "Ö": "O",
      "Ȫ": "O",
      "Ỏ": "O",
      "Ő": "O",
      "Ǒ": "O",
      "Ȍ": "O",
      "Ȏ": "O",
      "Ơ": "O",
      "Ờ": "O",
      "Ớ": "O",
      "Ỡ": "O",
      "Ở": "O",
      "Ợ": "O",
      "Ọ": "O",
      "Ộ": "O",
      "Ǫ": "O",
      "Ǭ": "O",
      "Ø": "O",
      "Ǿ": "O",
      "Ɔ": "O",
      "Ɵ": "O",
      "Ꝋ": "O",
      "Ꝍ": "O",
      "Ƣ": "OI",
      "Ꝏ": "OO",
      "Ȣ": "OU",
      "Ⓟ": "P",
      "Ｐ": "P",
      "Ṕ": "P",
      "Ṗ": "P",
      "Ƥ": "P",
      "Ᵽ": "P",
      "Ꝑ": "P",
      "Ꝓ": "P",
      "Ꝕ": "P",
      "Ⓠ": "Q",
      "Ｑ": "Q",
      "Ꝗ": "Q",
      "Ꝙ": "Q",
      "Ɋ": "Q",
      "Ⓡ": "R",
      "Ｒ": "R",
      "Ŕ": "R",
      "Ṙ": "R",
      "Ř": "R",
      "Ȑ": "R",
      "Ȓ": "R",
      "Ṛ": "R",
      "Ṝ": "R",
      "Ŗ": "R",
      "Ṟ": "R",
      "Ɍ": "R",
      "Ɽ": "R",
      "Ꝛ": "R",
      "Ꞧ": "R",
      "Ꞃ": "R",
      "Ⓢ": "S",
      "Ｓ": "S",
      "ẞ": "S",
      "Ś": "S",
      "Ṥ": "S",
      "Ŝ": "S",
      "Ṡ": "S",
      "Š": "S",
      "Ṧ": "S",
      "Ṣ": "S",
      "Ṩ": "S",
      "Ș": "S",
      "Ş": "S",
      "Ȿ": "S",
      "Ꞩ": "S",
      "Ꞅ": "S",
      "Ⓣ": "T",
      "Ｔ": "T",
      "Ṫ": "T",
      "Ť": "T",
      "Ṭ": "T",
      "Ț": "T",
      "Ţ": "T",
      "Ṱ": "T",
      "Ṯ": "T",
      "Ŧ": "T",
      "Ƭ": "T",
      "Ʈ": "T",
      "Ⱦ": "T",
      "Ꞇ": "T",
      "Ꜩ": "TZ",
      "Ⓤ": "U",
      "Ｕ": "U",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ũ": "U",
      "Ṹ": "U",
      "Ū": "U",
      "Ṻ": "U",
      "Ŭ": "U",
      "Ü": "U",
      "Ǜ": "U",
      "Ǘ": "U",
      "Ǖ": "U",
      "Ǚ": "U",
      "Ủ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ǔ": "U",
      "Ȕ": "U",
      "Ȗ": "U",
      "Ư": "U",
      "Ừ": "U",
      "Ứ": "U",
      "Ữ": "U",
      "Ử": "U",
      "Ự": "U",
      "Ụ": "U",
      "Ṳ": "U",
      "Ų": "U",
      "Ṷ": "U",
      "Ṵ": "U",
      "Ʉ": "U",
      "Ⓥ": "V",
      "Ｖ": "V",
      "Ṽ": "V",
      "Ṿ": "V",
      "Ʋ": "V",
      "Ꝟ": "V",
      "Ʌ": "V",
      "Ꝡ": "VY",
      "Ⓦ": "W",
      "Ｗ": "W",
      "Ẁ": "W",
      "Ẃ": "W",
      "Ŵ": "W",
      "Ẇ": "W",
      "Ẅ": "W",
      "Ẉ": "W",
      "Ⱳ": "W",
      "Ⓧ": "X",
      "Ｘ": "X",
      "Ẋ": "X",
      "Ẍ": "X",
      "Ⓨ": "Y",
      "Ｙ": "Y",
      "Ỳ": "Y",
      "Ý": "Y",
      "Ŷ": "Y",
      "Ỹ": "Y",
      "Ȳ": "Y",
      "Ẏ": "Y",
      "Ÿ": "Y",
      "Ỷ": "Y",
      "Ỵ": "Y",
      "Ƴ": "Y",
      "Ɏ": "Y",
      "Ỿ": "Y",
      "Ⓩ": "Z",
      "Ｚ": "Z",
      "Ź": "Z",
      "Ẑ": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "Ẓ": "Z",
      "Ẕ": "Z",
      "Ƶ": "Z",
      "Ȥ": "Z",
      "Ɀ": "Z",
      "Ⱬ": "Z",
      "Ꝣ": "Z",
      "ⓐ": "a",
      "ａ": "a",
      "ẚ": "a",
      "à": "a",
      "á": "a",
      "â": "a",
      "ầ": "a",
      "ấ": "a",
      "ẫ": "a",
      "ẩ": "a",
      "ã": "a",
      "ā": "a",
      "ă": "a",
      "ằ": "a",
      "ắ": "a",
      "ẵ": "a",
      "ẳ": "a",
      "ȧ": "a",
      "ǡ": "a",
      "ä": "a",
      "ǟ": "a",
      "ả": "a",
      "å": "a",
      "ǻ": "a",
      "ǎ": "a",
      "ȁ": "a",
      "ȃ": "a",
      "ạ": "a",
      "ậ": "a",
      "ặ": "a",
      "ḁ": "a",
      "ą": "a",
      "ⱥ": "a",
      "ɐ": "a",
      "ꜳ": "aa",
      "æ": "ae",
      "ǽ": "ae",
      "ǣ": "ae",
      "ꜵ": "ao",
      "ꜷ": "au",
      "ꜹ": "av",
      "ꜻ": "av",
      "ꜽ": "ay",
      "ⓑ": "b",
      "ｂ": "b",
      "ḃ": "b",
      "ḅ": "b",
      "ḇ": "b",
      "ƀ": "b",
      "ƃ": "b",
      "ɓ": "b",
      "ⓒ": "c",
      "ｃ": "c",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "ç": "c",
      "ḉ": "c",
      "ƈ": "c",
      "ȼ": "c",
      "ꜿ": "c",
      "ↄ": "c",
      "ⓓ": "d",
      "ｄ": "d",
      "ḋ": "d",
      "ď": "d",
      "ḍ": "d",
      "ḑ": "d",
      "ḓ": "d",
      "ḏ": "d",
      "đ": "d",
      "ƌ": "d",
      "ɖ": "d",
      "ɗ": "d",
      "ꝺ": "d",
      "ǳ": "dz",
      "ǆ": "dz",
      "ⓔ": "e",
      "ｅ": "e",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ề": "e",
      "ế": "e",
      "ễ": "e",
      "ể": "e",
      "ẽ": "e",
      "ē": "e",
      "ḕ": "e",
      "ḗ": "e",
      "ĕ": "e",
      "ė": "e",
      "ë": "e",
      "ẻ": "e",
      "ě": "e",
      "ȅ": "e",
      "ȇ": "e",
      "ẹ": "e",
      "ệ": "e",
      "ȩ": "e",
      "ḝ": "e",
      "ę": "e",
      "ḙ": "e",
      "ḛ": "e",
      "ɇ": "e",
      "ɛ": "e",
      "ǝ": "e",
      "ⓕ": "f",
      "ｆ": "f",
      "ḟ": "f",
      "ƒ": "f",
      "ꝼ": "f",
      "ⓖ": "g",
      "ｇ": "g",
      "ǵ": "g",
      "ĝ": "g",
      "ḡ": "g",
      "ğ": "g",
      "ġ": "g",
      "ǧ": "g",
      "ģ": "g",
      "ǥ": "g",
      "ɠ": "g",
      "ꞡ": "g",
      "ᵹ": "g",
      "ꝿ": "g",
      "ⓗ": "h",
      "ｈ": "h",
      "ĥ": "h",
      "ḣ": "h",
      "ḧ": "h",
      "ȟ": "h",
      "ḥ": "h",
      "ḩ": "h",
      "ḫ": "h",
      "ẖ": "h",
      "ħ": "h",
      "ⱨ": "h",
      "ⱶ": "h",
      "ɥ": "h",
      "ƕ": "hv",
      "ⓘ": "i",
      "ｉ": "i",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "ï": "i",
      "ḯ": "i",
      "ỉ": "i",
      "ǐ": "i",
      "ȉ": "i",
      "ȋ": "i",
      "ị": "i",
      "į": "i",
      "ḭ": "i",
      "ɨ": "i",
      "ı": "i",
      "ⓙ": "j",
      "ｊ": "j",
      "ĵ": "j",
      "ǰ": "j",
      "ɉ": "j",
      "ⓚ": "k",
      "ｋ": "k",
      "ḱ": "k",
      "ǩ": "k",
      "ḳ": "k",
      "ķ": "k",
      "ḵ": "k",
      "ƙ": "k",
      "ⱪ": "k",
      "ꝁ": "k",
      "ꝃ": "k",
      "ꝅ": "k",
      "ꞣ": "k",
      "ⓛ": "l",
      "ｌ": "l",
      "ŀ": "l",
      "ĺ": "l",
      "ľ": "l",
      "ḷ": "l",
      "ḹ": "l",
      "ļ": "l",
      "ḽ": "l",
      "ḻ": "l",
      "ſ": "l",
      "ł": "l",
      "ƚ": "l",
      "ɫ": "l",
      "ⱡ": "l",
      "ꝉ": "l",
      "ꞁ": "l",
      "ꝇ": "l",
      "ǉ": "lj",
      "ⓜ": "m",
      "ｍ": "m",
      "ḿ": "m",
      "ṁ": "m",
      "ṃ": "m",
      "ɱ": "m",
      "ɯ": "m",
      "ⓝ": "n",
      "ｎ": "n",
      "ǹ": "n",
      "ń": "n",
      "ñ": "n",
      "ṅ": "n",
      "ň": "n",
      "ṇ": "n",
      "ņ": "n",
      "ṋ": "n",
      "ṉ": "n",
      "ƞ": "n",
      "ɲ": "n",
      "ŉ": "n",
      "ꞑ": "n",
      "ꞥ": "n",
      "ǌ": "nj",
      "ⓞ": "o",
      "ｏ": "o",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "ồ": "o",
      "ố": "o",
      "ỗ": "o",
      "ổ": "o",
      "õ": "o",
      "ṍ": "o",
      "ȭ": "o",
      "ṏ": "o",
      "ō": "o",
      "ṑ": "o",
      "ṓ": "o",
      "ŏ": "o",
      "ȯ": "o",
      "ȱ": "o",
      "ö": "o",
      "ȫ": "o",
      "ỏ": "o",
      "ő": "o",
      "ǒ": "o",
      "ȍ": "o",
      "ȏ": "o",
      "ơ": "o",
      "ờ": "o",
      "ớ": "o",
      "ỡ": "o",
      "ở": "o",
      "ợ": "o",
      "ọ": "o",
      "ộ": "o",
      "ǫ": "o",
      "ǭ": "o",
      "ø": "o",
      "ǿ": "o",
      "ɔ": "o",
      "ꝋ": "o",
      "ꝍ": "o",
      "ɵ": "o",
      "ƣ": "oi",
      "ȣ": "ou",
      "ꝏ": "oo",
      "ⓟ": "p",
      "ｐ": "p",
      "ṕ": "p",
      "ṗ": "p",
      "ƥ": "p",
      "ᵽ": "p",
      "ꝑ": "p",
      "ꝓ": "p",
      "ꝕ": "p",
      "ⓠ": "q",
      "ｑ": "q",
      "ɋ": "q",
      "ꝗ": "q",
      "ꝙ": "q",
      "ⓡ": "r",
      "ｒ": "r",
      "ŕ": "r",
      "ṙ": "r",
      "ř": "r",
      "ȑ": "r",
      "ȓ": "r",
      "ṛ": "r",
      "ṝ": "r",
      "ŗ": "r",
      "ṟ": "r",
      "ɍ": "r",
      "ɽ": "r",
      "ꝛ": "r",
      "ꞧ": "r",
      "ꞃ": "r",
      "ⓢ": "s",
      "ｓ": "s",
      "ß": "s",
      "ś": "s",
      "ṥ": "s",
      "ŝ": "s",
      "ṡ": "s",
      "š": "s",
      "ṧ": "s",
      "ṣ": "s",
      "ṩ": "s",
      "ș": "s",
      "ş": "s",
      "ȿ": "s",
      "ꞩ": "s",
      "ꞅ": "s",
      "ẛ": "s",
      "ⓣ": "t",
      "ｔ": "t",
      "ṫ": "t",
      "ẗ": "t",
      "ť": "t",
      "ṭ": "t",
      "ț": "t",
      "ţ": "t",
      "ṱ": "t",
      "ṯ": "t",
      "ŧ": "t",
      "ƭ": "t",
      "ʈ": "t",
      "ⱦ": "t",
      "ꞇ": "t",
      "ꜩ": "tz",
      "ⓤ": "u",
      "ｕ": "u",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ũ": "u",
      "ṹ": "u",
      "ū": "u",
      "ṻ": "u",
      "ŭ": "u",
      "ü": "u",
      "ǜ": "u",
      "ǘ": "u",
      "ǖ": "u",
      "ǚ": "u",
      "ủ": "u",
      "ů": "u",
      "ű": "u",
      "ǔ": "u",
      "ȕ": "u",
      "ȗ": "u",
      "ư": "u",
      "ừ": "u",
      "ứ": "u",
      "ữ": "u",
      "ử": "u",
      "ự": "u",
      "ụ": "u",
      "ṳ": "u",
      "ų": "u",
      "ṷ": "u",
      "ṵ": "u",
      "ʉ": "u",
      "ⓥ": "v",
      "ｖ": "v",
      "ṽ": "v",
      "ṿ": "v",
      "ʋ": "v",
      "ꝟ": "v",
      "ʌ": "v",
      "ꝡ": "vy",
      "ⓦ": "w",
      "ｗ": "w",
      "ẁ": "w",
      "ẃ": "w",
      "ŵ": "w",
      "ẇ": "w",
      "ẅ": "w",
      "ẘ": "w",
      "ẉ": "w",
      "ⱳ": "w",
      "ⓧ": "x",
      "ｘ": "x",
      "ẋ": "x",
      "ẍ": "x",
      "ⓨ": "y",
      "ｙ": "y",
      "ỳ": "y",
      "ý": "y",
      "ŷ": "y",
      "ỹ": "y",
      "ȳ": "y",
      "ẏ": "y",
      "ÿ": "y",
      "ỷ": "y",
      "ẙ": "y",
      "ỵ": "y",
      "ƴ": "y",
      "ɏ": "y",
      "ỿ": "y",
      "ⓩ": "z",
      "ｚ": "z",
      "ź": "z",
      "ẑ": "z",
      "ż": "z",
      "ž": "z",
      "ẓ": "z",
      "ẕ": "z",
      "ƶ": "z",
      "ȥ": "z",
      "ɀ": "z",
      "ⱬ": "z",
      "ꝣ": "z",
      "Ά": "Α",
      "Έ": "Ε",
      "Ή": "Η",
      "Ί": "Ι",
      "Ϊ": "Ι",
      "Ό": "Ο",
      "Ύ": "Υ",
      "Ϋ": "Υ",
      "Ώ": "Ω",
      "ά": "α",
      "έ": "ε",
      "ή": "η",
      "ί": "ι",
      "ϊ": "ι",
      "ΐ": "ι",
      "ό": "ο",
      "ύ": "υ",
      "ϋ": "υ",
      "ΰ": "υ",
      "ω": "ω",
      "ς": "σ"
    };
    DataUtil2.fnOperators = {
      /**
       * Returns true when the actual input is equal to the given input.
       *
       * @param {string|number|boolean} actual
       * @param {string|number|boolean} expected
       * @param {boolean} ignoreCase?
       * @param {boolean} ignoreAccent?
       * @param ignoreCase
       * @param ignoreAccent
       */
      equal: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return DataUtil2.toLowerCase(actual) === DataUtil2.toLowerCase(expected);
        }
        return actual === expected;
      },
      /**
       * Returns true when the actual input is not equal to the given input.
       *
       * @param {string|number|boolean} actual
       * @param {string|number|boolean} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       * @param ignoreAccent
       */
      notequal: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        return !DataUtil2.fnOperators.equal(actual, expected, ignoreCase);
      },
      /**
       * Returns true when the actual input is less than to the given input.
       *
       * @param {string|number|boolean} actual
       * @param {string|number|boolean} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       */
      lessthan: function(actual, expected, ignoreCase) {
        if (ignoreCase) {
          return DataUtil2.toLowerCase(actual) < DataUtil2.toLowerCase(expected);
        }
        if (isNullOrUndefined(actual)) {
          actual = void 0;
        }
        return actual < expected;
      },
      /**
       * Returns true when the actual input is greater than to the given input.
       *
       * @param {string|number|boolean} actual
       * @param {string|number|boolean} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       */
      greaterthan: function(actual, expected, ignoreCase) {
        if (ignoreCase) {
          return DataUtil2.toLowerCase(actual) > DataUtil2.toLowerCase(expected);
        }
        if (isNullOrUndefined(actual)) {
          actual = void 0;
        }
        return actual > expected;
      },
      /**
       * Returns true when the actual input is less than or equal to the given input.
       *
       * @param {string|number|boolean} actual
       * @param {string|number|boolean} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       */
      lessthanorequal: function(actual, expected, ignoreCase) {
        if (ignoreCase) {
          return DataUtil2.toLowerCase(actual) <= DataUtil2.toLowerCase(expected);
        }
        if (isNullOrUndefined(actual)) {
          actual = void 0;
        }
        return actual <= expected;
      },
      /**
       * Returns true when the actual input is greater than or equal to the given input.
       *
       * @param {string|number|boolean} actual
       * @param {string|number|boolean} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       */
      greaterthanorequal: function(actual, expected, ignoreCase) {
        if (ignoreCase) {
          return DataUtil2.toLowerCase(actual) >= DataUtil2.toLowerCase(expected);
        }
        return actual >= expected;
      },
      /**
       * Returns true when the actual input contains the given string.
       *
       * @param {string|number} actual
       * @param {string|number} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       * @param ignoreAccent
       */
      contains: function(actual, expected, ignoreCase, ignoreAccent) {
        if (expected === "") {
          return true;
        }
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) && DataUtil2.toLowerCase(actual).indexOf(DataUtil2.toLowerCase(expected)) !== -1;
        }
        return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) && actual.toString().indexOf(expected) !== -1;
      },
      /**
       * Returns true when the actual input not contains the given string.
       *
       * @param  {string|number} actual
       * @param  {string|number} expected
       * @param  {boolean} ignoreCase?
       */
      doesnotcontain: function(actual, expected, ignoreCase, ignoreAccent) {
        if (expected === "") {
          return false;
        }
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) && DataUtil2.toLowerCase(actual).indexOf(DataUtil2.toLowerCase(expected)) === -1;
        }
        return !isNullOrUndefined(actual) && !isNullOrUndefined(expected) && actual.toString().indexOf(expected) === -1;
      },
      /**
       * Returns true when the given input value is not null.
       *
       * @param  {string|number} actual
       * @returns boolean
       */
      isnotnull: function(actual) {
        return actual !== null && actual !== void 0;
      },
      /**
       * Returns true when the given input value is null.
       *
       * @param  {string|number} actual
       * @returns boolean
       */
      isnull: function(actual) {
        return actual === null || actual === void 0;
      },
      /**
       * Returns true when the actual input starts with the given string
       *
       * @param {string} actual
       * @param {string} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       * @param ignoreAccent
       */
      startswith: function(actual, expected, ignoreCase, ignoreAccent) {
        if (expected === "") {
          return true;
        }
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return actual && expected && DataUtil2.startsWith(DataUtil2.toLowerCase(actual), DataUtil2.toLowerCase(expected));
        }
        return actual && expected && DataUtil2.startsWith(actual, expected);
      },
      /**
       * Returns true when the actual input not starts with the given string
       *
       * @param  {string} actual
       * @param  {string} expected
       * @param  {boolean} ignoreCase?
       */
      doesnotstartwith: function(actual, expected, ignoreCase, ignoreAccent) {
        if (expected === "") {
          return false;
        }
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return actual && expected && DataUtil2.notStartsWith(DataUtil2.toLowerCase(actual), DataUtil2.toLowerCase(expected));
        }
        return actual && expected && DataUtil2.notStartsWith(actual, expected);
      },
      /**
       * Returns true when the actual input like with the given string.
       *
       * @param  {string} actual
       * @param  {string} expected
       * @param  {boolean} ignoreCase?
       */
      like: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return actual && expected && DataUtil2.like(DataUtil2.toLowerCase(actual), DataUtil2.toLowerCase(expected));
        }
        return actual && expected && DataUtil2.like(actual, expected);
      },
      /**
       * Returns true when the given input value is empty.
       *
       * @param  {string|number} actual
       * @returns boolean
       */
      isempty: function(actual) {
        return actual === void 0 || actual === "";
      },
      /**
       * Returns true when the given input value is not empty.
       *
       * @param  {string|number} actual
       * @returns boolean
       */
      isnotempty: function(actual) {
        return actual !== void 0 && actual !== "";
      },
      /**
       * Returns true when the actual input pattern(wildcard) matches with the given string.
       *
       * @param  {string|Date} actual
       * @param  {string} expected
       * @param  {boolean} ignoreCase?
       */
      wildcard: function(actual, expected, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return (actual || typeof actual === "boolean") && expected && typeof actual !== "object" && DataUtil2.wildCard(DataUtil2.toLowerCase(actual), DataUtil2.toLowerCase(expected));
        }
        return (actual || typeof actual === "boolean") && expected && DataUtil2.wildCard(actual, expected);
      },
      /**
       * Returns true when the actual input ends with the given string.
       *
       * @param {string} actual
       * @param {string} expected
       * @param {boolean} ignoreCase?
       * @param ignoreCase
       * @param ignoreAccent
       */
      endswith: function(actual, expected, ignoreCase, ignoreAccent) {
        if (expected === "") {
          return true;
        }
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return actual && expected && DataUtil2.endsWith(DataUtil2.toLowerCase(actual), DataUtil2.toLowerCase(expected));
        }
        return actual && expected && DataUtil2.endsWith(actual, expected);
      },
      /**
       * Returns true when the actual input not ends with the given string.
       *
       * @param  {string} actual
       * @param  {string} expected
       * @param  {boolean} ignoreCase?
       */
      doesnotendwith: function(actual, expected, ignoreCase, ignoreAccent) {
        if (expected === "") {
          return false;
        }
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expected = DataUtil2.ignoreDiacritics(expected);
        }
        if (ignoreCase) {
          return actual && expected && DataUtil2.notEndsWith(DataUtil2.toLowerCase(actual), DataUtil2.toLowerCase(expected));
        }
        return actual && expected && DataUtil2.notEndsWith(actual, expected);
      },
      /**
       * It will return the filter operator based on the filter symbol.
       *
       * @param  {string} operator
       * @hidden
       */
      processSymbols: function(operator) {
        var fnName = DataUtil2.operatorSymbols[operator];
        if (fnName) {
          var fn = DataUtil2.fnOperators[fnName];
          return fn;
        }
        return DataUtil2.throwError("Query - Process Operator : Invalid operator");
      },
      /**
       * It will return the valid filter operator based on the specified operators.
       *
       * @param  {string} operator
       * @hidden
       */
      processOperator: function(operator) {
        var fn = DataUtil2.fnOperators[operator];
        if (fn) {
          return fn;
        }
        return DataUtil2.fnOperators.processSymbols(operator);
      },
      /**
       * Checks if the specified value exists in the given array, with optional case and accent insensitivity.
       *
       * @param {string | number} actual - The value to check.
       * @param {Array<string | number>} expectedArray - The array to search within.
       * @param {boolean} [ignoreCase] - Whether to perform a case-insensitive comparison.
       * @param {boolean} [ignoreAccent] - Whether to ignore accents/diacritics.
       * @returns {boolean} `true` if the value is found, otherwise `false`.
       */
      in: function(actual, expectedArray, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expectedArray = DataUtil2.ignoreDiacriticsForArrays(expectedArray);
        }
        if (ignoreCase) {
          return !isNullOrUndefined(actual) && expectedArray && expectedArray.length > 0 && expectedArray.map(function(item) {
            return DataUtil2.toLowerCase(item);
          }).indexOf(DataUtil2.toLowerCase(actual)) > -1;
        }
        if (actual instanceof Date) {
          return !isNullOrUndefined(actual) && expectedArray && expectedArray.length > 0 && Array.isArray(expectedArray) && expectedArray.some(function(item) {
            return item instanceof Date && item.getTime() === actual.getTime();
          });
        }
        return !isNullOrUndefined(actual) && expectedArray && expectedArray.length > 0 && expectedArray.indexOf(actual) > -1;
      },
      /**
       * Checks if the specified value is not present in the given array, with optional case and accent insensitivity.
       *
       * @param {string | number} actual - The value to check.
       * @param {Array<string | number>} expectedArray - The array to search within.
       * @param {boolean} [ignoreCase] - Whether to perform a case-insensitive comparison.
       * @param {boolean} [ignoreAccent] - Whether to ignore accents/diacritics.
       * @returns {boolean} `true` if the value is not found, otherwise `false`.
       */
      notin: function(actual, expectedArray, ignoreCase, ignoreAccent) {
        if (ignoreAccent) {
          actual = DataUtil2.ignoreDiacritics(actual);
          expectedArray = DataUtil2.ignoreDiacriticsForArrays(expectedArray);
        }
        if (ignoreCase) {
          return !isNullOrUndefined(actual) && expectedArray && expectedArray.length > 0 && expectedArray.map(function(item) {
            return DataUtil2.toLowerCase(item);
          }).indexOf(DataUtil2.toLowerCase(actual)) === -1;
        }
        if (actual instanceof Date) {
          return !isNullOrUndefined(actual) && expectedArray && expectedArray.length > 0 && Array.isArray(expectedArray) && expectedArray.every(function(item) {
            return !(item instanceof Date) || item.getTime() !== actual.getTime();
          });
        }
        return !isNullOrUndefined(actual) && expectedArray && expectedArray.length > 0 && expectedArray.indexOf(actual) === -1;
      }
    };
    DataUtil2.parse = {
      /**
       * Parse the given string to the plain JavaScript object.
       *
       * @param  {string|Object|Object[]} jsonText
       */
      parseJson: function(jsonText) {
        if (typeof jsonText === "string" && (/^[\s]*\[|^[\s]*\{(.)+:/g.test(jsonText) || jsonText.indexOf('"') === -1)) {
          jsonText = JSON.parse(jsonText, DataUtil2.parse.jsonReviver);
        } else if (jsonText instanceof Array) {
          DataUtil2.parse.iterateAndReviveArray(jsonText);
        } else if (typeof jsonText === "object" && jsonText !== null) {
          DataUtil2.parse.iterateAndReviveJson(jsonText);
        }
        return jsonText;
      },
      /**
       * It will perform on array of values.
       *
       * @param  {string[]|Object[]} array
       * @hidden
       */
      iterateAndReviveArray: function(array) {
        for (var i = 0; i < array.length; i++) {
          if (typeof array[i] === "object" && array[i] !== null) {
            DataUtil2.parse.iterateAndReviveJson(array[i]);
          } else if (typeof array[i] === "string" && (!/^[\s]*\[|^[\s]*\{(.)+:|\"/g.test(array[i]) || array[i].toString().indexOf('"') === -1)) {
            array[i] = DataUtil2.parse.jsonReviver("", array[i]);
          } else {
            array[i] = DataUtil2.parse.parseJson(array[i]);
          }
        }
      },
      /**
       * It will perform on JSON values
       *
       * @param  {JSON} json
       * @hidden
       */
      iterateAndReviveJson: function(json) {
        var value;
        var keys2 = Object.keys(json);
        for (var _i = 0, keys_2 = keys2; _i < keys_2.length; _i++) {
          var prop = keys_2[_i];
          if (DataUtil2.startsWith(prop, "__")) {
            continue;
          }
          value = json[prop];
          if (typeof value === "object") {
            if (value instanceof Array) {
              DataUtil2.parse.iterateAndReviveArray(value);
            } else if (value) {
              DataUtil2.parse.iterateAndReviveJson(value);
            }
          } else {
            json[prop] = DataUtil2.parse.jsonReviver(json[prop], value);
          }
        }
      },
      /**
       * It will perform on JSON values
       *
       * @param  {string} field
       * @param  {string|Date} value
       * @hidden
       */
      jsonReviver: function(field, value) {
        if (typeof value === "string") {
          var ms = /^\/Date\(([+-]?[0-9]+)([+-][0-9]{4})?\)\/$/.exec(value);
          var offSet = DataUtil2.timeZoneHandling ? DataUtil2.serverTimezoneOffset : null;
          if (ms) {
            return DataUtil2.dateParse.toTimeZone(new Date(parseInt(ms[1], 10)), offSet, true);
          } else if (/^(\d{4}\-\d\d\-\d\d([tT][\d:\.]*){1})([zZ]|([+\-])(\d\d):?(\d\d))?$/.test(value)) {
            var isUTC = value.indexOf("Z") > -1 || value.indexOf("z") > -1;
            var arr = value.split(/[^0-9.]/);
            if (isUTC) {
              if (arr[5].indexOf(".") > -1) {
                var secondsMs = arr[5].split(".");
                arr[5] = secondsMs[0];
                arr[6] = new Date(value).getUTCMilliseconds().toString();
              } else {
                arr[6] = "00";
              }
              value = DataUtil2.dateParse.toTimeZone(new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5] ? arr[5] : "00", 10), parseInt(arr[6], 10)), DataUtil2.serverTimezoneOffset, false);
            } else {
              var utcFormat = new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5] ? arr[5] : "00", 10));
              var hrs = parseInt(arr[6], 10);
              var mins = parseInt(arr[7], 10);
              if (isNaN(hrs) && isNaN(mins)) {
                return utcFormat;
              }
              if (value.indexOf("+") > -1) {
                utcFormat.setHours(utcFormat.getHours() - hrs, utcFormat.getMinutes() - mins);
              } else {
                utcFormat.setHours(utcFormat.getHours() + hrs, utcFormat.getMinutes() + mins);
              }
              value = DataUtil2.dateParse.toTimeZone(utcFormat, DataUtil2.serverTimezoneOffset, false);
            }
            if (DataUtil2.serverTimezoneOffset == null) {
              value = DataUtil2.dateParse.addSelfOffset(value);
            }
          }
        }
        return value;
      },
      /**
       * Check wheather the given value is JSON or not.
       *
       * @param  {Object[]} jsonData
       */
      isJson: function(jsonData) {
        if (typeof jsonData[0] === "string") {
          return jsonData;
        }
        return DataUtil2.parse.parseJson(jsonData);
      },
      /**
       * Checks wheather the given value is GUID or not.
       *
       * @param  {string} value
       */
      isGuid: function(value) {
        var regex = /[A-Fa-f0-9]{8}(?:-[A-Fa-f0-9]{4}){3}-[A-Fa-f0-9]{12}/i;
        var match = regex.exec(value);
        return match != null;
      },
      /**
       * The method used to replace the value based on the type.
       *
       * @param  {Object} value
       * @param  {boolean} stringify
       * @hidden
       */
      replacer: function(value, stringify) {
        if (DataUtil2.isPlainObject(value)) {
          return DataUtil2.parse.jsonReplacer(value, stringify);
        }
        if (value instanceof Array) {
          return DataUtil2.parse.arrayReplacer(value);
        }
        if (value instanceof Date) {
          return DataUtil2.parse.jsonReplacer({ val: value }, stringify).val;
        }
        return value;
      },
      /**
       * It will replace the JSON value.
       *
       * @param {string} key
       * @param {Object} val
       * @param stringify
       * @hidden
       */
      jsonReplacer: function(val, stringify) {
        var value;
        var keys2 = Object.keys(val);
        for (var _i = 0, keys_3 = keys2; _i < keys_3.length; _i++) {
          var prop = keys_3[_i];
          value = val[prop];
          if (!(value instanceof Date)) {
            continue;
          }
          var d = value;
          if (DataUtil2.serverTimezoneOffset == null) {
            val[prop] = DataUtil2.dateParse.toTimeZone(d, null).toJSON();
          } else {
            d = new Date(+d + DataUtil2.serverTimezoneOffset * 36e5);
            val[prop] = DataUtil2.dateParse.toTimeZone(DataUtil2.dateParse.addSelfOffset(d), null).toJSON();
          }
        }
        return val;
      },
      /**
       * It will replace the Array of value.
       *
       * @param  {string} key
       * @param  {Object[]} val
       * @hidden
       */
      arrayReplacer: function(val) {
        for (var i = 0; i < val.length; i++) {
          if (DataUtil2.isPlainObject(val[i])) {
            val[i] = DataUtil2.parse.jsonReplacer(val[i]);
          } else if (val[i] instanceof Date) {
            val[i] = DataUtil2.parse.jsonReplacer({ date: val[i] }).date;
          }
        }
        return val;
      },
      /**
       * It will replace the Date object with respective to UTC format value.
       *
       * @param  {string} key
       * @param  {any} value
       * @hidden
       */
      /* eslint-disable @typescript-eslint/no-explicit-any */
      /* tslint:disable-next-line:no-any */
      jsonDateReplacer: function(key, value) {
        if (key === "value" && value) {
          if (typeof value === "string") {
            var ms = /^\/Date\(([+-]?[0-9]+)([+-][0-9]{4})?\)\/$/.exec(value);
            if (ms) {
              value = DataUtil2.dateParse.toTimeZone(new Date(parseInt(ms[1], 10)), null, true);
            } else if (/^(\d{4}\-\d\d\-\d\d([tT][\d:\.]*){1})([zZ]|([+\-])(\d\d):?(\d\d))?$/.test(value)) {
              var arr = value.split(/[^0-9]/);
              value = DataUtil2.dateParse.toTimeZone(new Date(parseInt(arr[0], 10), parseInt(arr[1], 10) - 1, parseInt(arr[2], 10), parseInt(arr[3], 10), parseInt(arr[4], 10), parseInt(arr[5], 10)), null, true);
            }
          }
          if (value instanceof Date) {
            value = DataUtil2.dateParse.addSelfOffset(value);
            if (DataUtil2.serverTimezoneOffset === null) {
              return DataUtil2.dateParse.toTimeZone(DataUtil2.dateParse.addSelfOffset(value), null).toJSON();
            } else {
              value = DataUtil2.dateParse.toTimeZone(value, value.getTimezoneOffset() / 60 - DataUtil2.serverTimezoneOffset, false);
              return value.toJSON();
            }
          }
        }
        return value;
      }
    };
    DataUtil2.dateParse = {
      addSelfOffset: function(input) {
        return new Date(+input - input.getTimezoneOffset() * 6e4);
      },
      toUTC: function(input) {
        return new Date(+input + input.getTimezoneOffset() * 6e4);
      },
      toTimeZone: function(input, offset, utc) {
        if (offset === null) {
          return input;
        }
        var unix = utc ? DataUtil2.dateParse.toUTC(input) : input;
        return new Date(+unix - offset * 36e5);
      },
      toLocalTime: function(input) {
        var datefn = input;
        var timeZone = -datefn.getTimezoneOffset();
        var differenceString = timeZone >= 0 ? "+" : "-";
        var localtimefn = function(num) {
          var norm = Math.floor(Math.abs(num));
          return (norm < 10 ? "0" : "") + norm;
        };
        var val = datefn.getFullYear() + "-" + localtimefn(datefn.getMonth() + 1) + "-" + localtimefn(datefn.getDate()) + "T" + localtimefn(datefn.getHours()) + ":" + localtimefn(datefn.getMinutes()) + ":" + localtimefn(datefn.getSeconds()) + differenceString + localtimefn(timeZone / 60) + ":" + localtimefn(timeZone % 60);
        return val;
      }
    };
    return DataUtil2;
  })()
);

// node_modules/@syncfusion/ej2-data/src/adaptors.js
var __extends21 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var consts2 = { GroupGuid: "{271bbba0-1ee7}" };
var Adaptor = (
  /** @class */
  (function() {
    function Adaptor2(ds) {
      this.options = {
        from: "table",
        requestType: "json",
        sortBy: "sorted",
        select: "select",
        skip: "skip",
        group: "group",
        take: "take",
        search: "search",
        count: "requiresCounts",
        where: "where",
        aggregates: "aggregates",
        expand: "expand"
      };
      this.type = Adaptor2;
      this.dataSource = ds;
      this.pvt = {};
    }
    Adaptor2.prototype.processResponse = function(data, ds, query, xhr) {
      return data;
    };
    return Adaptor2;
  })()
);
var JsonAdaptor = (
  /** @class */
  (function(_super) {
    __extends21(JsonAdaptor2, _super);
    function JsonAdaptor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    JsonAdaptor2.prototype.processQuery = function(dataManager, query) {
      var result = dataManager.dataSource.json.slice(0);
      var count = result.length;
      var countFlg = true;
      var ret;
      var key;
      var lazyLoad = {};
      var keyCount = 0;
      var group = [];
      var sort = [];
      var page;
      for (var i = 0; i < query.lazyLoad.length; i++) {
        keyCount++;
        lazyLoad[query.lazyLoad[i].key] = query.lazyLoad[i].value;
      }
      var agg = {};
      var isGroupByFormat = false;
      if (query.lazyLoad.length) {
        for (var i = 0; i < query.queries.length; i++) {
          key = query.queries[i];
          if (key.fn === "onGroup" && !isNullOrUndefined(key.e.format)) {
            isGroupByFormat = true;
            break;
          }
        }
      }
      for (var i = 0; i < query.queries.length; i++) {
        key = query.queries[i];
        if ((key.fn === "onPage" || key.fn === "onGroup" || key.fn === "onSortBy" && !isGroupByFormat) && query.lazyLoad.length) {
          if (key.fn === "onGroup") {
            group.push(key.e);
          }
          if (key.fn === "onPage") {
            page = key.e;
          }
          if (key.fn === "onSortBy") {
            sort.unshift(key.e);
          }
          continue;
        }
        ret = this[key.fn].call(this, result, key.e, query);
        if (key.fn === "onAggregates") {
          agg[key.e.field + " - " + key.e.type] = ret;
        } else {
          result = ret !== void 0 ? ret : result;
        }
        if (key.fn === "onPage" || key.fn === "onSkip" || key.fn === "onTake" || key.fn === "onRange") {
          countFlg = false;
        }
        if (countFlg) {
          count = result.length;
        }
      }
      if (keyCount) {
        var args = {
          query,
          lazyLoad,
          result,
          group,
          page,
          sort
        };
        var lazyLoadData = this.lazyLoadGroup(args);
        result = lazyLoadData.result;
        count = lazyLoadData.count;
      }
      if (query.isCountRequired) {
        result = {
          result,
          count,
          aggregates: agg
        };
      }
      return result;
    };
    JsonAdaptor2.prototype.lazyLoadGroup = function(args) {
      var count = 0;
      var agg = this.getAggregate(args.query);
      var result = args.result;
      if (!isNullOrUndefined(args.lazyLoad.onDemandGroupInfo)) {
        var req = args.lazyLoad.onDemandGroupInfo;
        for (var i = req.where.length - 1; i >= 0; i--) {
          result = this.onWhere(result, req.where[i]);
        }
        if (args.group.length !== req.level) {
          var field = args.group[req.level].fieldName;
          result = DataUtil.group(result, field, agg, null, null, args.group[req.level].comparer, true);
          if (args.sort.length) {
            result = this.onSortBy(result, args.sort[parseInt(req.level.toString(), 10)], args.query, true);
          }
        } else {
          for (var i = args.sort.length - 1; i >= req.level; i--) {
            result = this.onSortBy(result, args.sort[parseInt(i.toString(), 10)], args.query, false);
          }
        }
        count = result.length;
        var data = result;
        result = result.slice(req.skip);
        result = result.slice(0, req.take);
        if (args.group.length !== req.level) {
          this.formGroupResult(result, data);
        }
      } else {
        var field_1 = args.group[0].fieldName;
        result = DataUtil.group(result, field_1, agg, null, null, args.group[0].comparer, true);
        count = result.length;
        var data = result;
        if (args.sort.length) {
          var sort = args.sort.length > 1 ? args.sort.filter(function(x) {
            return x.fieldName === field_1;
          })[0] : args.sort[0];
          result = this.onSortBy(result, sort, args.query, true);
        }
        if (args.page) {
          result = this.onPage(result, args.page, args.query);
        }
        this.formGroupResult(result, data);
      }
      return { result, count };
    };
    JsonAdaptor2.prototype.formGroupResult = function(result, data) {
      if (result.length && data.length) {
        var uid = "GroupGuid";
        var childLevel = "childLevels";
        var level = "level";
        var records = "records";
        result[uid] = data[uid];
        result[childLevel] = data[childLevel];
        result[level] = data[level];
        result[records] = data[records];
      }
      return result;
    };
    JsonAdaptor2.prototype.getAggregate = function(query) {
      var aggQuery = Query.filterQueries(query.queries, "onAggregates");
      var agg = [];
      if (aggQuery.length) {
        var tmp = void 0;
        for (var i = 0; i < aggQuery.length; i++) {
          tmp = aggQuery[i].e;
          agg.push({ type: tmp.type, field: DataUtil.getValue(tmp.field, query) });
        }
      }
      return agg;
    };
    JsonAdaptor2.prototype.batchRequest = function(dm, changes, e) {
      var i;
      var deletedRecordsLen = changes.deletedRecords.length;
      for (i = 0; i < changes.addedRecords.length; i++) {
        this.insert(dm, changes.addedRecords[i]);
      }
      for (i = 0; i < changes.changedRecords.length; i++) {
        this.update(dm, e.key, changes.changedRecords[i]);
      }
      for (i = 0; i < deletedRecordsLen; i++) {
        this.remove(dm, e.key, changes.deletedRecords[i]);
      }
      return changes;
    };
    JsonAdaptor2.prototype.onWhere = function(ds, e) {
      if (!ds || !ds.length) {
        return ds;
      }
      return ds.filter(function(obj) {
        if (e) {
          return e.validate(obj);
        }
      });
    };
    JsonAdaptor2.prototype.onAggregates = function(ds, e) {
      var fn = DataUtil.aggregates[e.type];
      if (!ds || !fn || ds.length === 0) {
        return null;
      }
      return fn(ds, e.field);
    };
    JsonAdaptor2.prototype.onSearch = function(ds, e) {
      if (!ds || !ds.length) {
        return ds;
      }
      if (e.fieldNames.length === 0) {
        DataUtil.getFieldList(ds[0], e.fieldNames);
      }
      return ds.filter(function(obj) {
        for (var j = 0; j < e.fieldNames.length; j++) {
          if (e.comparer.call(obj, DataUtil.getObject(e.fieldNames[j], obj), e.searchKey, e.ignoreCase, e.ignoreAccent)) {
            return true;
          }
        }
        return false;
      });
    };
    JsonAdaptor2.prototype.onSortBy = function(ds, e, query, isLazyLoadGroupSort) {
      if (!ds || !ds.length) {
        return ds;
      }
      var fnCompare;
      var field = DataUtil.getValue(e.fieldName, query);
      if (!field) {
        return ds.sort(e.comparer);
      }
      if (field instanceof Array) {
        field = field.slice(0);
        for (var i = field.length - 1; i >= 0; i--) {
          if (!field[i]) {
            continue;
          }
          fnCompare = e.comparer;
          if (DataUtil.endsWith(field[i], " desc")) {
            fnCompare = DataUtil.fnSort("descending");
            field[i] = field[i].replace(" desc", "");
          }
          ds = DataUtil.sort(ds, field[i], fnCompare);
        }
        return ds;
      }
      return DataUtil.sort(ds, isLazyLoadGroupSort ? "key" : field, e.comparer);
    };
    JsonAdaptor2.prototype.onGroup = function(ds, e, query) {
      if (!ds || !ds.length) {
        return ds;
      }
      var agg = this.getAggregate(query);
      return DataUtil.group(ds, DataUtil.getValue(e.fieldName, query), agg, null, null, e.comparer);
    };
    JsonAdaptor2.prototype.onPage = function(ds, e, query) {
      var size = DataUtil.getValue(e.pageSize, query);
      var start = (DataUtil.getValue(e.pageIndex, query) - 1) * size;
      var end = start + size;
      if (!ds || !ds.length) {
        return ds;
      }
      return ds.slice(start, end);
    };
    JsonAdaptor2.prototype.onRange = function(ds, e) {
      if (!ds || !ds.length) {
        return ds;
      }
      return ds.slice(DataUtil.getValue(e.start), DataUtil.getValue(e.end));
    };
    JsonAdaptor2.prototype.onTake = function(ds, e) {
      if (!ds || !ds.length) {
        return ds;
      }
      return ds.slice(0, DataUtil.getValue(e.nos));
    };
    JsonAdaptor2.prototype.onSkip = function(ds, e) {
      if (!ds || !ds.length) {
        return ds;
      }
      return ds.slice(DataUtil.getValue(e.nos));
    };
    JsonAdaptor2.prototype.onSelect = function(ds, e) {
      if (!ds || !ds.length) {
        return ds;
      }
      return DataUtil.select(ds, DataUtil.getValue(e.fieldNames));
    };
    JsonAdaptor2.prototype.insert = function(dm, data, tableName, query, position) {
      if (isNullOrUndefined(position)) {
        return dm.dataSource.json.push(data);
      } else {
        return dm.dataSource.json.splice(position, 0, data);
      }
    };
    JsonAdaptor2.prototype.remove = function(dm, keyField, value, tableName) {
      var ds = dm.dataSource.json;
      var i;
      if (typeof value === "object" && !(value instanceof Date)) {
        value = DataUtil.getObject(keyField, value);
      }
      for (i = 0; i < ds.length; i++) {
        if (DataUtil.getObject(keyField, ds[i]) === value) {
          break;
        }
      }
      return i !== ds.length ? ds.splice(i, 1) : null;
    };
    JsonAdaptor2.prototype.update = function(dm, keyField, value, tableName) {
      var ds = dm.dataSource.json;
      var i;
      var key;
      if (!isNullOrUndefined(keyField)) {
        key = getValue(keyField, value);
      }
      for (i = 0; i < ds.length; i++) {
        if (!isNullOrUndefined(keyField) && getValue(keyField, ds[i]) === key) {
          break;
        }
      }
      return i < ds.length ? merge(ds[i], value) : null;
    };
    return JsonAdaptor2;
  })(Adaptor)
);
var UrlAdaptor = (
  /** @class */
  (function(_super) {
    __extends21(UrlAdaptor2, _super);
    function UrlAdaptor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    UrlAdaptor2.prototype.processQuery = function(dm, query, hierarchyFilters) {
      var queries = this.getQueryRequest(query);
      var singles = Query.filterQueryLists(query.queries, ["onSelect", "onPage", "onSkip", "onTake", "onRange"]);
      var params = query.params;
      var url = dm.dataSource.url;
      var temp;
      var skip;
      var take = null;
      var options = this.options;
      var request = { sorts: [], groups: [], filters: [], searches: [], aggregates: [] };
      if ("onPage" in singles) {
        temp = singles.onPage;
        skip = DataUtil.getValue(temp.pageIndex, query);
        take = DataUtil.getValue(temp.pageSize, query);
        skip = (skip - 1) * take;
      } else if ("onRange" in singles) {
        temp = singles.onRange;
        skip = temp.start;
        take = temp.end - temp.start;
      }
      for (var i = 0; i < queries.sorts.length; i++) {
        temp = DataUtil.getValue(queries.sorts[i].e.fieldName, query);
        request.sorts.push(DataUtil.callAdaptorFunction(this, "onEachSort", { name: temp, direction: queries.sorts[i].e.direction }, query));
      }
      if (hierarchyFilters) {
        temp = this.getFiltersFrom(hierarchyFilters, query);
        if (temp) {
          request.filters.push(DataUtil.callAdaptorFunction(this, "onEachWhere", temp.toJson(), query));
        }
      }
      for (var i = 0; i < queries.filters.length; i++) {
        var res = DataUtil.callAdaptorFunction(this, "onEachWhere", queries.filters[i].e.toJson(), query);
        if (this.getModuleName && this.getModuleName() === "ODataV4Adaptor" && !isNullOrUndefined(queries.filters[i].e.key) && queries.filters.length > 1) {
          res = "(" + res + ")";
        }
        request.filters.push(res);
        var keys_3 = typeof request.filters[i] === "object" ? Object.keys(request.filters[i]) : [];
        for (var _i = 0, keys_1 = keys_3; _i < keys_1.length; _i++) {
          var prop = keys_1[_i];
          if (DataUtil.isNull(request[prop])) {
            delete request[prop];
          }
        }
      }
      for (var i = 0; i < queries.searches.length; i++) {
        temp = queries.searches[i].e;
        request.searches.push(DataUtil.callAdaptorFunction(this, "onEachSearch", {
          fields: temp.fieldNames,
          operator: temp.operator,
          key: temp.searchKey,
          ignoreCase: temp.ignoreCase,
          ignoreAccent: temp.ignoreAccent
        }, query));
      }
      for (var i = 0; i < queries.groups.length; i++) {
        request.groups.push(DataUtil.getValue(queries.groups[i].e.fieldName, query));
      }
      for (var i = 0; i < queries.aggregates.length; i++) {
        temp = queries.aggregates[i].e;
        request.aggregates.push({ type: temp.type, field: DataUtil.getValue(temp.field, query) });
      }
      var req = {};
      this.getRequestQuery(options, query, singles, request, req);
      DataUtil.callAdaptorFunction(this, "addParams", { dm, query, params, reqParams: req });
      if (query.lazyLoad.length) {
        for (var i = 0; i < query.lazyLoad.length; i++) {
          req[query.lazyLoad[i].key] = query.lazyLoad[i].value;
        }
      }
      var keys2 = Object.keys(req);
      for (var _a = 0, keys_2 = keys2; _a < keys_2.length; _a++) {
        var prop = keys_2[_a];
        if (DataUtil.isNull(req[prop]) || req[prop] === "" || req[prop].length === 0) {
          delete req[prop];
        }
      }
      if (!(options.skip in req && options.take in req) && take !== null) {
        req[options.skip] = DataUtil.callAdaptorFunction(this, "onSkip", skip, query);
        req[options.take] = DataUtil.callAdaptorFunction(this, "onTake", take, query);
      }
      var p = this.pvt;
      this.pvt = {};
      if (this.options.requestType === "json") {
        return {
          data: JSON.stringify(req, DataUtil.parse.jsonDateReplacer),
          url,
          pvtData: p,
          type: "POST",
          contentType: "application/json; charset=utf-8"
        };
      }
      temp = this.convertToQueryString(req, query, dm);
      temp = (dm.dataSource.url.indexOf("?") !== -1 ? "&" : "/") + temp;
      return {
        type: "GET",
        url: temp.length ? url.replace(/\/*$/, temp) : url,
        pvtData: p
      };
    };
    UrlAdaptor2.prototype.getRequestQuery = function(options, query, singles, request, request1) {
      var param = "param";
      var req = request1;
      req[options.from] = query.fromTable;
      if (options.apply && query.distincts.length) {
        req[options.apply] = "onDistinct" in this ? DataUtil.callAdaptorFunction(this, "onDistinct", query.distincts) : "";
      }
      if (!query.distincts.length && options.expand) {
        req[options.expand] = "onExpand" in this && "onSelect" in singles ? DataUtil.callAdaptorFunction(this, "onExpand", { selects: DataUtil.getValue(singles.onSelect.fieldNames, query), expands: query.expands }, query) : query.expands;
      }
      req[options.select] = "onSelect" in singles && !query.distincts.length ? DataUtil.callAdaptorFunction(this, "onSelect", DataUtil.getValue(singles.onSelect.fieldNames, query), query) : "";
      req[options.count] = query.isCountRequired ? DataUtil.callAdaptorFunction(this, "onCount", query.isCountRequired, query) : "";
      req[options.search] = request.searches.length ? DataUtil.callAdaptorFunction(this, "onSearch", request.searches, query) : "";
      req[options.skip] = "onSkip" in singles ? DataUtil.callAdaptorFunction(this, "onSkip", DataUtil.getValue(singles.onSkip.nos, query), query) : "";
      req[options.take] = "onTake" in singles ? DataUtil.callAdaptorFunction(this, "onTake", DataUtil.getValue(singles.onTake.nos, query), query) : "";
      req[options.where] = request.filters.length || request.searches.length ? DataUtil.callAdaptorFunction(this, "onWhere", request.filters, query) : "";
      req[options.sortBy] = request.sorts.length ? DataUtil.callAdaptorFunction(this, "onSortBy", request.sorts, query) : "";
      req[options.group] = request.groups.length ? DataUtil.callAdaptorFunction(this, "onGroup", request.groups, query) : "";
      req[options.aggregates] = request.aggregates.length ? DataUtil.callAdaptorFunction(this, "onAggregates", request.aggregates, query) : "";
      req[param] = [];
    };
    UrlAdaptor2.prototype.convertToQueryString = function(request, query, dm) {
      return "";
    };
    UrlAdaptor2.prototype.processResponse = function(data, ds, query, xhr, request, changes) {
      if (xhr && xhr.headers.get("Content-Type") && xhr.headers.get("Content-Type").indexOf("application/json") !== -1) {
        var handleTimeZone = DataUtil.timeZoneHandling;
        if (ds && !ds.timeZoneHandling) {
          DataUtil.timeZoneHandling = false;
        }
        if (!ds.enableCache) {
          data = DataUtil.parse.parseJson(data);
        }
        DataUtil.timeZoneHandling = handleTimeZone;
      }
      var requests = request;
      var pvt = requests.pvtData || {};
      var groupDs = data ? data.groupDs : [];
      if (xhr && xhr.headers.get("Content-Type") && xhr.headers.get("Content-Type").indexOf("xml") !== -1) {
        return query.isCountRequired ? { result: [], count: 0 } : [];
      }
      var d = JSON.parse(requests.data);
      if (d && d.action === "batch" && data && data.addedRecords && !isNullOrUndefined(changes)) {
        changes.addedRecords = data.addedRecords;
        return changes;
      }
      if (data && data.d) {
        data = data.d;
      }
      var args = {};
      if (data && "count" in data) {
        args.count = data.count;
      }
      args.result = data && data.result ? data.result : data;
      var isExpand = false;
      if (Array.isArray(data.result) && data.result.length) {
        var key = "key";
        var val = "value";
        var level = "level";
        if (!isNullOrUndefined(data.result[0][key])) {
          args.result = this.formRemoteGroupedData(args.result, 1, pvt.groups.length - 1);
        }
        if (query && query.lazyLoad.length && pvt.groups.length) {
          for (var i = 0; i < query.lazyLoad.length; i++) {
            if (query.lazyLoad[i][key] === "onDemandGroupInfo") {
              var value = query.lazyLoad[i][val][level];
              if (pvt.groups.length === value) {
                isExpand = true;
              }
            }
          }
        }
      }
      if (!isExpand) {
        this.getAggregateResult(pvt, data, args, groupDs, query);
      }
      return DataUtil.isNull(args.count) ? args.result : { result: args.result, count: args.count, aggregates: args.aggregates };
    };
    UrlAdaptor2.prototype.formRemoteGroupedData = function(data, level, childLevel) {
      for (var i = 0; i < data.length; i++) {
        if (data[i].items.length && Object.keys(data[i].items[0]).indexOf("key") > -1) {
          this.formRemoteGroupedData(data[i].items, level + 1, childLevel - 1);
        }
      }
      var uid = "GroupGuid";
      var childLvl = "childLevels";
      var lvl = "level";
      var records = "records";
      data[uid] = consts2[uid];
      data[lvl] = level;
      data[childLvl] = childLevel;
      data[records] = data[0].items.length ? this.getGroupedRecords(data, !isNullOrUndefined(data[0].items[records])) : [];
      return data;
    };
    UrlAdaptor2.prototype.getGroupedRecords = function(data, hasRecords) {
      var childGroupedRecords = [];
      var records = "records";
      for (var i = 0; i < data.length; i++) {
        if (!hasRecords) {
          for (var j = 0; j < data[i].items.length; j++) {
            childGroupedRecords.push(data[i].items[j]);
          }
        } else {
          childGroupedRecords = childGroupedRecords.concat(data[i].items[records]);
        }
      }
      return childGroupedRecords;
    };
    UrlAdaptor2.prototype.onGroup = function(e) {
      this.pvt.groups = e;
      return e;
    };
    UrlAdaptor2.prototype.onAggregates = function(e) {
      this.pvt.aggregates = e;
    };
    UrlAdaptor2.prototype.batchRequest = function(dm, changes, e, query, original) {
      var url;
      var key;
      return {
        type: "POST",
        url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.removeUrl || dm.dataSource.url,
        contentType: "application/json; charset=utf-8",
        dataType: "json",
        data: JSON.stringify(extend({}, {
          changed: changes.changedRecords,
          added: changes.addedRecords,
          deleted: changes.deletedRecords,
          action: "batch",
          table: e[url],
          key: e[key]
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    UrlAdaptor2.prototype.beforeSend = function(dm, request, settings) {
    };
    UrlAdaptor2.prototype.insert = function(dm, data, tableName, query) {
      return {
        url: dm.dataSource.insertUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        data: JSON.stringify(extend({}, {
          value: data,
          table: tableName,
          action: "insert"
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    UrlAdaptor2.prototype.remove = function(dm, keyField, value, tableName, query) {
      return {
        type: "POST",
        url: dm.dataSource.removeUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        data: JSON.stringify(extend({}, {
          key: value,
          keyColumn: keyField,
          table: tableName,
          action: "remove"
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    UrlAdaptor2.prototype.update = function(dm, keyField, value, tableName, query) {
      return {
        type: "POST",
        url: dm.dataSource.updateUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        data: JSON.stringify(extend({}, {
          value,
          action: "update",
          keyColumn: keyField,
          key: DataUtil.getObject(keyField, value),
          table: tableName
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    UrlAdaptor2.prototype.getFiltersFrom = function(data, query) {
      var key = query.fKey;
      var value;
      var prop = key;
      var pKey = query.key;
      var predicats = [];
      if (typeof data[0] !== "object") {
        prop = null;
      }
      for (var i = 0; i < data.length; i++) {
        if (typeof data[0] === "object") {
          value = DataUtil.getObject(pKey || prop, data[i]);
        } else {
          value = data[i];
        }
        predicats.push(new Predicate(key, "equal", value));
      }
      return Predicate.or(predicats);
    };
    UrlAdaptor2.prototype.getAggregateResult = function(pvt, data, args, groupDs, query) {
      var pData = data;
      if (data && data.result) {
        pData = data.result;
      }
      if (pvt && pvt.aggregates && pvt.aggregates.length) {
        var agg = pvt.aggregates;
        var fn = void 0;
        var aggregateData = pData;
        var res = {};
        if (data.aggregate) {
          aggregateData = data.aggregate;
        }
        for (var i = 0; i < agg.length; i++) {
          fn = DataUtil.aggregates[agg[i].type];
          if (fn) {
            res[agg[i].field + " - " + agg[i].type] = fn(aggregateData, agg[i].field);
          }
        }
        args.aggregates = res;
      }
      var key = "key";
      var isServerGrouping = Array.isArray(data.result) && data.result.length && !isNullOrUndefined(data.result[0][key]);
      if (pvt && pvt.groups && pvt.groups.length && !isServerGrouping) {
        var groups = pvt.groups;
        for (var i = 0; i < groups.length; i++) {
          var level = null;
          if (!isNullOrUndefined(groupDs)) {
            groupDs = DataUtil.group(groupDs, groups[i]);
          }
          var groupQuery = Query.filterQueries(query.queries, "onGroup")[i].e;
          pData = DataUtil.group(pData, groups[i], pvt.aggregates, level, groupDs, groupQuery.comparer);
        }
        args.result = pData;
      }
      return args;
    };
    UrlAdaptor2.prototype.getQueryRequest = function(query) {
      var req = { sorts: [], groups: [], filters: [], searches: [], aggregates: [] };
      req.sorts = Query.filterQueries(query.queries, "onSortBy");
      req.groups = Query.filterQueries(query.queries, "onGroup");
      req.filters = Query.filterQueries(query.queries, "onWhere");
      req.searches = Query.filterQueries(query.queries, "onSearch");
      req.aggregates = Query.filterQueries(query.queries, "onAggregates");
      return req;
    };
    UrlAdaptor2.prototype.addParams = function(options) {
      var req = options.reqParams;
      if (options.params.length) {
        req.params = {};
      }
      for (var _i = 0, _a = options.params; _i < _a.length; _i++) {
        var tmp = _a[_i];
        if (req[tmp.key]) {
          throw new Error("Query() - addParams: Custom Param is conflicting other request arguments");
        }
        req[tmp.key] = tmp.value;
        if (tmp.fn) {
          req[tmp.key] = tmp.fn.call(options.query, tmp.key, options.query, options.dm);
        }
        req.params[tmp.key] = req[tmp.key];
      }
    };
    return UrlAdaptor2;
  })(Adaptor)
);
var ODataAdaptor = (
  /** @class */
  (function(_super) {
    __extends21(ODataAdaptor2, _super);
    function ODataAdaptor2(props) {
      var _this = _super.call(this) || this;
      _this.options = extend({}, _this.options, {
        requestType: "get",
        accept: "application/json;odata=light;q=1,application/json;odata=verbose;q=0.5",
        multipartAccept: "multipart/mixed",
        sortBy: "$orderby",
        select: "$select",
        skip: "$skip",
        take: "$top",
        count: "$inlinecount",
        where: "$filter",
        expand: "$expand",
        batch: "$batch",
        changeSet: "--changeset_",
        batchPre: "batch_",
        contentId: "Content-Id: ",
        batchContent: "Content-Type: multipart/mixed; boundary=",
        changeSetContent: "Content-Type: application/http\nContent-Transfer-Encoding: binary ",
        batchChangeSetContentType: "Content-Type: application/json; charset=utf-8 ",
        updateType: "PUT"
      });
      extend(_this.options, props || {});
      return _this;
    }
    ODataAdaptor2.prototype.getModuleName = function() {
      return "ODataAdaptor";
    };
    ODataAdaptor2.prototype.onPredicate = function(predicate, query, requiresCast) {
      var returnValue = "";
      var operator;
      var guid;
      var val = predicate.value;
      var type = typeof val;
      var field = predicate.field ? ODataAdaptor2.getField(predicate.field) : null;
      if (val instanceof Date) {
        val = "datetime'" + DataUtil.parse.replacer(val) + "'";
      }
      if (type === "string") {
        val = val.replace(/'/g, "''");
        if (predicate.ignoreCase) {
          val = val.toLowerCase();
        }
        if (predicate.operator !== "like") {
          val = encodeURIComponent(val);
        }
        if (predicate.operator !== "wildcard" && predicate.operator !== "like") {
          val = "'" + val + "'";
        }
        if (requiresCast) {
          field = "cast(" + field + ", 'Edm.String')";
        }
        if (DataUtil.parse.isGuid(val)) {
          guid = "guid";
        }
        if (predicate.ignoreCase) {
          if (!guid) {
            field = "tolower(" + field + ")";
          }
          val = val.toLowerCase();
        }
      }
      if (predicate.operator === "isempty" || predicate.operator === "isnull" || predicate.operator === "isnotempty" || predicate.operator === "isnotnull") {
        operator = predicate.operator.indexOf("isnot") !== -1 ? DataUtil.odBiOperator["notequal"] : DataUtil.odBiOperator["equal"];
        val = predicate.operator === "isnull" || predicate.operator === "isnotnull" ? null : "''";
      } else {
        operator = DataUtil.odBiOperator[predicate.operator];
      }
      if (operator) {
        returnValue += field;
        returnValue += operator;
        if (guid) {
          returnValue += guid;
        }
        return returnValue + val;
      }
      if (!isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor") {
        operator = DataUtil.odv4UniOperator[predicate.operator];
      } else {
        operator = DataUtil.odUniOperator[predicate.operator];
      }
      if (operator === "like") {
        val = val;
        if (val.indexOf("%") !== -1) {
          if (val.charAt(0) === "%" && val.lastIndexOf("%") < 2) {
            val = val.substring(1, val.length);
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["startswith"] : DataUtil.odUniOperator["startswith"];
          } else if (val.charAt(val.length - 1) === "%" && val.indexOf("%") > val.length - 3) {
            val = val.substring(0, val.length - 1);
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["endswith"] : DataUtil.odUniOperator["endswith"];
          } else if (val.lastIndexOf("%") !== val.indexOf("%") && val.lastIndexOf("%") > val.indexOf("%") + 1) {
            val = val.substring(val.indexOf("%") + 1, val.lastIndexOf("%"));
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["contains"] : DataUtil.odUniOperator["contains"];
          } else {
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["contains"] : DataUtil.odUniOperator["contains"];
          }
        }
        val = encodeURIComponent(val);
        val = "'" + val + "'";
      } else if (operator === "wildcard") {
        val = val;
        if (val.indexOf("*") !== -1) {
          var splittedStringValue = val.split("*");
          var splittedValue = void 0;
          var count = 0;
          if (val.indexOf("*") !== 0 && splittedStringValue[0].indexOf("%3f") === -1 && splittedStringValue[0].indexOf("?") === -1) {
            splittedValue = splittedStringValue[0];
            splittedValue = "'" + splittedValue + "'";
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["startswith"] : DataUtil.odUniOperator["startswith"];
            returnValue += operator + "(";
            returnValue += field + ",";
            if (guid) {
              returnValue += guid;
            }
            returnValue += splittedValue + ")";
            count++;
          }
          if (val.lastIndexOf("*") !== val.length - 1 && splittedStringValue[splittedStringValue.length - 1].indexOf("%3f") === -1 && splittedStringValue[splittedStringValue.length - 1].indexOf("?") === -1) {
            splittedValue = splittedStringValue[splittedStringValue.length - 1];
            splittedValue = "'" + splittedValue + "'";
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["endswith"] : DataUtil.odUniOperator["endswith"];
            if (count > 0) {
              returnValue += " and ";
            }
            returnValue += operator + "(";
            returnValue += field + ",";
            if (guid) {
              returnValue += guid;
            }
            returnValue += splittedValue + ")";
            count++;
          }
          if (splittedStringValue.length > 2) {
            for (var i = 1; i < splittedStringValue.length - 1; i++) {
              if (splittedStringValue[i].indexOf("%3f") === -1 && splittedStringValue[i].indexOf("?") === -1) {
                splittedValue = splittedStringValue[i];
                splittedValue = "'" + splittedValue + "'";
                operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["contains"] : DataUtil.odUniOperator["contains"];
                if (count > 0) {
                  returnValue += " and ";
                }
                if (operator === "substringof" || operator === "not substringof") {
                  var temp = splittedValue;
                  splittedValue = field;
                  field = temp;
                }
                returnValue += operator + "(";
                returnValue += field + ",";
                if (guid) {
                  returnValue += guid;
                }
                returnValue += splittedValue + ")";
                count++;
              }
            }
          }
          if (count === 0) {
            operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["contains"] : DataUtil.odUniOperator["contains"];
            if (val.indexOf("?") !== -1 || val.indexOf("%3f") !== -1) {
              val = val.indexOf("?") !== -1 ? val.split("?").join("") : val.split("%3f").join("");
            }
            val = "'" + val + "'";
          } else {
            operator = "wildcard";
          }
        } else {
          operator = !isNullOrUndefined(this.getModuleName) && this.getModuleName() === "ODataV4Adaptor" ? DataUtil.odv4UniOperator["contains"] : DataUtil.odUniOperator["contains"];
          if (val.indexOf("?") !== -1 || val.indexOf("%3f") !== -1) {
            val = val.indexOf("?") !== -1 ? val.split("?").join("") : val.split("%3f").join("");
          }
          val = "'" + val + "'";
        }
      }
      if (operator === "substringof" || operator === "not substringof") {
        var temp = val;
        val = field;
        field = temp;
      }
      if (operator !== "wildcard") {
        returnValue += operator + "(";
        returnValue += field + ",";
        if (guid) {
          returnValue += guid;
        }
        returnValue += val + ")";
      }
      return returnValue;
    };
    ODataAdaptor2.prototype.addParams = function(options) {
      _super.prototype.addParams.call(this, options);
      delete options.reqParams.params;
    };
    ODataAdaptor2.prototype.onComplexPredicate = function(predicate, query, requiresCast) {
      var res = [];
      for (var i = 0; i < predicate.predicates.length; i++) {
        res.push("(" + this.onEachWhere(predicate.predicates[i], query, requiresCast) + ")");
      }
      return res.join(" " + predicate.condition + " ");
    };
    ODataAdaptor2.prototype.onEachWhere = function(filter2, query, requiresCast) {
      return filter2.isComplex ? this.onComplexPredicate(filter2, query, requiresCast) : this.onPredicate(filter2, query, requiresCast);
    };
    ODataAdaptor2.prototype.onWhere = function(filters) {
      if (this.pvt.search) {
        filters.push(this.onEachWhere(this.pvt.search, null, true));
      }
      return filters.join(" and ");
    };
    ODataAdaptor2.prototype.onEachSearch = function(e) {
      if (e.fields && e.fields.length === 0) {
        DataUtil.throwError("Query() - Search : oData search requires list of field names to search");
      }
      var filter2 = this.pvt.search || [];
      for (var i = 0; i < e.fields.length; i++) {
        filter2.push(new Predicate(e.fields[i], e.operator, e.key, e.ignoreCase));
      }
      this.pvt.search = filter2;
    };
    ODataAdaptor2.prototype.onSearch = function(e) {
      this.pvt.search = Predicate.or(this.pvt.search);
      return "";
    };
    ODataAdaptor2.prototype.onEachSort = function(e) {
      var res = [];
      if (e.name instanceof Array) {
        for (var i = 0; i < e.name.length; i++) {
          res.push(ODataAdaptor2.getField(e.name[i]) + (e.direction === "descending" ? " desc" : ""));
        }
      } else {
        res.push(ODataAdaptor2.getField(e.name) + (e.direction === "descending" ? " desc" : ""));
      }
      return res.join(",");
    };
    ODataAdaptor2.prototype.onSortBy = function(e) {
      return e.reverse().join(",");
    };
    ODataAdaptor2.prototype.onGroup = function(e) {
      this.pvt.groups = e;
      return [];
    };
    ODataAdaptor2.prototype.onSelect = function(e) {
      for (var i = 0; i < e.length; i++) {
        e[i] = ODataAdaptor2.getField(e[i]);
      }
      return e.join(",");
    };
    ODataAdaptor2.prototype.onAggregates = function(e) {
      this.pvt.aggregates = e;
      return "";
    };
    ODataAdaptor2.prototype.onCount = function(e) {
      return e === true ? "allpages" : "";
    };
    ODataAdaptor2.prototype.beforeSend = function(dm, request, settings) {
      if (DataUtil.endsWith(settings.url, this.options.batch) && settings.type.toLowerCase() === "post") {
        request.headers.set("Accept", this.options.multipartAccept);
        request.headers.set("DataServiceVersion", "2.0");
      } else {
        request.headers.set("Accept", this.options.accept);
      }
      request.headers.set("DataServiceVersion", "2.0");
      request.headers.set("MaxDataServiceVersion", "2.0");
    };
    ODataAdaptor2.prototype.processResponse = function(data, ds, query, xhr, request, changes) {
      var metaCheck = "odata.metadata";
      if (request && request.type === "GET" && !this.rootUrl && data[metaCheck]) {
        var dataUrls = data[metaCheck].split("/$metadata#");
        this.rootUrl = dataUrls[0];
        this.resourceTableName = dataUrls[1];
      }
      var pvtData = "pvtData";
      if (!isNullOrUndefined(data.d)) {
        var dataCopy = query && query.isCountRequired ? data.d.results : data.d;
        var metaData = "__metadata";
        if (!isNullOrUndefined(dataCopy)) {
          for (var i = 0; i < dataCopy.length; i++) {
            if (!isNullOrUndefined(dataCopy[i][metaData])) {
              delete dataCopy[i][metaData];
            }
          }
        }
      }
      var pvt = request && request[pvtData];
      var emptyAndBatch = this.processBatchResponse(data, query, xhr, request, changes);
      if (emptyAndBatch) {
        return emptyAndBatch;
      }
      var versionCheck = xhr && request.fetchRequest.headers.get("DataServiceVersion");
      var count = null;
      var version = versionCheck && parseInt(versionCheck, 10) || 2;
      if (query && query.isCountRequired) {
        var oDataCount = "__count";
        if (data[oDataCount] || data["odata.count"]) {
          count = data[oDataCount] || data["odata.count"];
        }
        if (data.d) {
          data = data.d;
        }
        if (data[oDataCount] || data["odata.count"]) {
          count = data[oDataCount] || data["odata.count"];
        }
      }
      if (version === 3 && data.value) {
        data = data.value;
      }
      if (data.d) {
        data = data.d;
      }
      if (version < 3 && data.results) {
        data = data.results;
      }
      var args = {};
      args.count = count;
      args.result = data;
      this.getAggregateResult(pvt, data, args, null, query);
      return DataUtil.isNull(count) ? args.result : { result: args.result, count: args.count, aggregates: args.aggregates };
    };
    ODataAdaptor2.prototype.convertToQueryString = function(request, query, dm) {
      var res = [];
      var table = "table";
      var tableName = request[table] || "";
      var format = "$format";
      delete request[table];
      if (dm.dataSource.requiresFormat) {
        request[format] = "json";
      }
      var keys2 = Object.keys(request);
      for (var _i = 0, keys_4 = keys2; _i < keys_4.length; _i++) {
        var prop = keys_4[_i];
        res.push(prop + "=" + request[prop]);
      }
      res = res.join("&");
      if (dm.dataSource.url && dm.dataSource.url.indexOf("?") !== -1 && !tableName) {
        return res;
      }
      return res.length ? tableName + "?" + res : tableName || "";
    };
    ODataAdaptor2.prototype.localTimeReplacer = function(key, convertObj) {
      for (var _i = 0, _a = !isNullOrUndefined(convertObj) ? Object.keys(convertObj) : []; _i < _a.length; _i++) {
        var prop = _a[_i];
        if (convertObj[prop] instanceof Date) {
          convertObj[prop] = DataUtil.dateParse.toLocalTime(convertObj[prop]);
        }
      }
      return convertObj;
    };
    ODataAdaptor2.prototype.insert = function(dm, data, tableName) {
      return {
        url: (dm.dataSource.insertUrl || dm.dataSource.url).replace(/\/*$/, tableName ? "/" + tableName : ""),
        data: JSON.stringify(data, this.options.localTime ? this.localTimeReplacer : null)
      };
    };
    ODataAdaptor2.prototype.remove = function(dm, keyField, value, tableName) {
      var url;
      if (typeof value === "string" && !DataUtil.parse.isGuid(value)) {
        url = "('" + value + "')";
      } else {
        url = "(" + value + ")";
      }
      return {
        type: "DELETE",
        url: (dm.dataSource.removeUrl || dm.dataSource.url).replace(/\/*$/, tableName ? "/" + tableName : "") + url
      };
    };
    ODataAdaptor2.prototype.update = function(dm, keyField, value, tableName, query, original) {
      if (this.options.updateType === "PATCH" && !isNullOrUndefined(original)) {
        value = this.compareAndRemove(value, original, keyField);
      }
      var url;
      if (typeof value[keyField] === "string" && !DataUtil.parse.isGuid(value[keyField])) {
        url = "('" + value[keyField] + "')";
      } else {
        url = "(" + value[keyField] + ")";
      }
      return {
        type: this.options.updateType,
        url: (dm.dataSource.updateUrl || dm.dataSource.url).replace(/\/*$/, tableName ? "/" + tableName : "") + url,
        data: JSON.stringify(value, this.options.localTime ? this.localTimeReplacer : null),
        accept: this.options.accept
      };
    };
    ODataAdaptor2.prototype.batchRequest = function(dm, changes, e, query, original) {
      var initialGuid = e.guid = DataUtil.getGuid(this.options.batchPre);
      var url = dm.dataSource.batchUrl || this.rootUrl ? (dm.dataSource.batchUrl || this.rootUrl) + "/" + this.options.batch : (dm.dataSource.batchUrl || dm.dataSource.url).replace(/\/*$/, "/" + this.options.batch);
      e.url = this.resourceTableName ? this.resourceTableName : e.url;
      var args = {
        url: e.url,
        key: e.key,
        cid: 1,
        cSet: DataUtil.getGuid(this.options.changeSet)
      };
      var req = "--" + initialGuid + "\n";
      req += "Content-Type: multipart/mixed; boundary=" + args.cSet.replace("--", "") + "\n";
      this.pvt.changeSet = 0;
      req += this.generateInsertRequest(changes.addedRecords, args, dm);
      req += this.generateUpdateRequest(changes.changedRecords, args, dm, original ? original.changedRecords : []);
      req += this.generateDeleteRequest(changes.deletedRecords, args, dm);
      req += args.cSet + "--\n";
      req += "--" + initialGuid + "--";
      return {
        type: "POST",
        url,
        dataType: "json",
        contentType: "multipart/mixed; charset=UTF-8;boundary=" + initialGuid,
        data: req
      };
    };
    ODataAdaptor2.prototype.generateDeleteRequest = function(arr, e, dm) {
      if (!arr) {
        return "";
      }
      var req = "";
      var stat = {
        "method": "DELETE ",
        "url": function(data, i, key) {
          var url = DataUtil.getObject(key, data[i]);
          if (typeof url === "number" || DataUtil.parse.isGuid(url)) {
            return "(" + url + ")";
          } else if (url instanceof Date) {
            var dateTime = data[i][key];
            return "(" + dateTime.toJSON() + ")";
          } else {
            return "('" + url + "')";
          }
        },
        "data": function(data, i) {
          return "";
        }
      };
      req = this.generateBodyContent(arr, e, stat, dm);
      return req + "\n";
    };
    ODataAdaptor2.prototype.generateInsertRequest = function(arr, e, dm) {
      if (!arr) {
        return "";
      }
      var req = "";
      var stat = {
        "method": "POST ",
        "url": function(data, i, key) {
          return "";
        },
        "data": function(data, i) {
          return JSON.stringify(data[i]) + "\n\n";
        }
      };
      req = this.generateBodyContent(arr, e, stat, dm);
      return req;
    };
    ODataAdaptor2.prototype.generateUpdateRequest = function(arr, e, dm, org) {
      var _this = this;
      if (!arr) {
        return "";
      }
      var req = "";
      arr.forEach(function(change) {
        return change = _this.compareAndRemove(change, org.filter(function(o) {
          return DataUtil.getObject(e.key, o) === DataUtil.getObject(e.key, change);
        })[0], e.key);
      });
      var stat = {
        "method": this.options.updateType + " ",
        "url": function(data, i, key) {
          if (typeof data[i][key] === "number" || DataUtil.parse.isGuid(data[i][key])) {
            return "(" + data[i][key] + ")";
          } else if (data[i][key] instanceof Date) {
            var date = data[i][key];
            return "(" + date.toJSON() + ")";
          } else {
            return "('" + data[i][key] + "')";
          }
        },
        "data": function(data, i) {
          return JSON.stringify(data[i]) + "\n\n";
        }
      };
      req = this.generateBodyContent(arr, e, stat, dm);
      return req;
    };
    ODataAdaptor2.getField = function(prop) {
      return prop.replace(/\./g, "/");
    };
    ODataAdaptor2.prototype.generateBodyContent = function(arr, e, stat, dm) {
      var req = "";
      for (var i = 0; i < arr.length; i++) {
        req += "\n" + e.cSet + "\n";
        req += this.options.changeSetContent + "\n\n";
        req += stat.method;
        if (stat.method === "POST ") {
          req += (dm.dataSource.insertUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + " HTTP/1.1\n";
        } else if (stat.method === "PUT " || stat.method === "PATCH ") {
          req += (dm.dataSource.updateUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + " HTTP/1.1\n";
        } else if (stat.method === "DELETE ") {
          req += (dm.dataSource.removeUrl || dm.dataSource.crudUrl || e.url) + stat.url(arr, i, e.key) + " HTTP/1.1\n";
        }
        req += "Accept: " + this.options.accept + "\n";
        req += "Content-Id: " + this.pvt.changeSet++ + "\n";
        req += this.options.batchChangeSetContentType + "\n";
        if (!isNullOrUndefined(arr[i]["@odata.etag"])) {
          req += "If-Match: " + arr[i]["@odata.etag"] + "\n\n";
          delete arr[i]["@odata.etag"];
        } else {
          req += "\n";
        }
        req += stat.data(arr, i);
      }
      return req;
    };
    ODataAdaptor2.prototype.processBatchResponse = function(data, query, xhr, request, changes) {
      if (xhr && xhr.headers.get("Content-Type") && xhr.headers.get("Content-Type").indexOf("xml") !== -1) {
        return query.isCountRequired ? { result: [], count: 0 } : [];
      }
      if (request && this.options.batch && DataUtil.endsWith(request.url, this.options.batch) && request.type.toLowerCase() === "post") {
        var guid = xhr.headers.get("Content-Type");
        var cIdx = void 0;
        var jsonObj = void 0;
        var d = data + "";
        guid = guid.substring(guid.indexOf("=batchresponse") + 1);
        d = d.split(guid);
        if (d.length < 2) {
          return {};
        }
        d = d[1];
        var exVal = /(?:\bContent-Type.+boundary=)(changesetresponse.+)/i.exec(d);
        if (exVal) {
          d.replace(exVal[0], "");
        }
        var changeGuid = exVal ? exVal[1] : "";
        d = d.split(changeGuid);
        for (var i = d.length; i > -1; i--) {
          if (!/\bContent-ID:/i.test(d[i]) || !/\bHTTP.+201/.test(d[i])) {
            continue;
          }
          cIdx = parseInt(/\bContent-ID: (\d+)/i.exec(d[i])[1], 10);
          if (changes.addedRecords[cIdx]) {
            jsonObj = DataUtil.parse.parseJson(/^\{.+\}/m.exec(d[i])[0]);
            extend({}, changes.addedRecords[cIdx], this.processResponse(jsonObj));
          }
        }
        return changes;
      }
      return null;
    };
    ODataAdaptor2.prototype.compareAndRemove = function(data, original, key) {
      var _this = this;
      if (isNullOrUndefined(original)) {
        return data;
      }
      Object.keys(data).forEach(function(prop) {
        if (prop !== key && prop !== "@odata.etag") {
          if (DataUtil.isPlainObject(data[prop])) {
            _this.compareAndRemove(data[prop], original[prop]);
            var final = Object.keys(data[prop]).filter(function(data2) {
              return data2 !== "@odata.etag";
            });
            if (final.length === 0) {
              delete data[prop];
            }
          } else if (data[prop] === original[prop]) {
            delete data[prop];
          } else if (data[prop] && original[prop] && data[prop].valueOf() === original[prop].valueOf()) {
            delete data[prop];
          }
        }
      });
      return data;
    };
    return ODataAdaptor2;
  })(UrlAdaptor)
);
var ODataV4Adaptor = (
  /** @class */
  (function(_super) {
    __extends21(ODataV4Adaptor2, _super);
    function ODataV4Adaptor2(props) {
      var _this = _super.call(this, props) || this;
      _this.options = extend({}, _this.options, {
        requestType: "get",
        accept: "application/json, text/javascript, */*; q=0.01",
        multipartAccept: "multipart/mixed",
        sortBy: "$orderby",
        select: "$select",
        skip: "$skip",
        take: "$top",
        count: "$count",
        search: "$search",
        where: "$filter",
        expand: "$expand",
        batch: "$batch",
        changeSet: "--changeset_",
        batchPre: "batch_",
        contentId: "Content-Id: ",
        batchContent: "Content-Type: multipart/mixed; boundary=",
        changeSetContent: "Content-Type: application/http\nContent-Transfer-Encoding: binary ",
        batchChangeSetContentType: "Content-Type: application/json; charset=utf-8 ",
        updateType: "PATCH",
        localTime: false,
        apply: "$apply"
      });
      extend(_this.options, props || {});
      return _this;
    }
    ODataV4Adaptor2.prototype.getModuleName = function() {
      return "ODataV4Adaptor";
    };
    ODataV4Adaptor2.prototype.onCount = function(e) {
      return e === true ? "true" : "";
    };
    ODataV4Adaptor2.prototype.onPredicate = function(predicate, query, requiresCast) {
      var returnValue = "";
      var val = predicate.value;
      var isDate = val instanceof Date;
      if (query instanceof Query) {
        var queries = this.getQueryRequest(query);
        for (var i = 0; i < queries.filters.length; i++) {
          if (queries.filters[i].e.key === predicate.value) {
            requiresCast = true;
          }
        }
      }
      returnValue = _super.prototype.onPredicate.call(this, predicate, query, requiresCast);
      if (isDate) {
        returnValue = returnValue.replace(/datetime'(.*)'$/, "$1");
      }
      if (DataUtil.parse.isGuid(val)) {
        returnValue = returnValue.replace("guid", "").replace(/'/g, "");
      }
      return returnValue;
    };
    ODataV4Adaptor2.prototype.onEachSearch = function(e) {
      var search = this.pvt.searches || [];
      search.push(e.key);
      this.pvt.searches = search;
    };
    ODataV4Adaptor2.prototype.onSearch = function(e) {
      return this.pvt.searches.join(" OR ");
    };
    ODataV4Adaptor2.prototype.onExpand = function(e) {
      var _this = this;
      var selected = {};
      var expanded = {};
      var expands = e.expands.slice();
      var exArr = [];
      var selects = e.selects.filter(function(item) {
        return item.indexOf(".") > -1;
      });
      selects.forEach(function(select2) {
        var splits = select2.split(".");
        if (!(splits[0] in selected)) {
          selected[splits[0]] = [];
        }
        if (splits.length === 2) {
          if (selected[splits[0]].length && Object.keys(selected).indexOf(splits[0]) !== -1) {
            if (selected[splits[0]][0].indexOf("$expand") !== -1 && selected[splits[0]][0].indexOf(";$select=") === -1) {
              selected[splits[0]][0] = selected[splits[0]][0] + ";$select=" + splits[1];
            } else {
              selected[splits[0]][0] = selected[splits[0]][0] + "," + splits[1];
            }
          } else {
            selected[splits[0]].push("$select=" + splits[1]);
          }
        } else {
          var sel = "$select=" + splits[splits.length - 1];
          var exp2 = "";
          var close_1 = "";
          for (var i = 1; i < splits.length - 1; i++) {
            exp2 = exp2 + "$expand=" + splits[i] + "(";
            close_1 = close_1 + ")";
          }
          var combineVal = exp2 + sel + close_1;
          if (selected[splits[0]].length && Object.keys(selected).indexOf(splits[0]) !== -1 && _this.expandQueryIndex(selected[splits[0]], true)) {
            var idx = _this.expandQueryIndex(selected[splits[0]]);
            selected[splits[0]][idx] = selected[splits[0]][idx] + combineVal.replace("$expand=", ",");
          } else {
            selected[splits[0]].push(combineVal);
          }
        }
      });
      Object.keys(selected).forEach(function(expand) {
        if (expands.indexOf(expand) === -1) {
          expands.push(expand);
        }
      });
      expands.forEach(function(expand) {
        expanded[expand] = expand in selected ? expand + "(" + selected[expand].join(";") + ")" : expand;
      });
      Object.keys(expanded).forEach(function(ex) {
        return exArr.push(expanded[ex]);
      });
      return exArr.join(",");
    };
    ODataV4Adaptor2.prototype.expandQueryIndex = function(query, isExpand) {
      for (var i = 0; i < query.length; i++) {
        if (query[i].indexOf("$expand") !== -1) {
          return isExpand ? true : i;
        }
      }
      return isExpand ? false : 0;
    };
    ODataV4Adaptor2.prototype.onDistinct = function(distinctFields) {
      var fields = distinctFields.map(function(field) {
        return ODataAdaptor.getField(field);
      }).join(",");
      return "groupby((" + fields + "))";
    };
    ODataV4Adaptor2.prototype.onSelect = function(e) {
      return _super.prototype.onSelect.call(this, e.filter(function(item) {
        return item.indexOf(".") === -1;
      }));
    };
    ODataV4Adaptor2.prototype.beforeSend = function(dm, request, settings) {
      if (settings.type === "POST" || settings.type === "PUT" || settings.type === "PATCH") {
        request.headers.set("Prefer", "return=representation");
      }
      request.headers.set("Accept", this.options.accept);
    };
    ODataV4Adaptor2.prototype.processResponse = function(data, ds, query, xhr, request, changes) {
      var metaName = "@odata.context";
      var metaV4Name = "@context";
      if (request && request.type === "GET" && !this.rootUrl && (data[metaName] || data[metaV4Name])) {
        var dataUrl = data[metaName] ? data[metaName].split("/$metadata#") : data[metaV4Name].split("/$metadata#");
        this.rootUrl = dataUrl[0];
        this.resourceTableName = dataUrl[1];
      }
      var pvtData = "pvtData";
      var pvt = request && request[pvtData];
      var emptyAndBatch = _super.prototype.processBatchResponse.call(this, data, query, xhr, request, changes);
      if (emptyAndBatch) {
        return emptyAndBatch;
      }
      var count = null;
      var dataCount = "@odata.count";
      var dataV4Count = "@count";
      if (query && query.isCountRequired) {
        if (dataCount in data) {
          count = data[dataCount];
        } else if (dataV4Count in data) {
          count = data[dataV4Count];
        }
      }
      data = !isNullOrUndefined(data.value) ? data.value : data;
      var args = {};
      args.count = count;
      args.result = data;
      this.getAggregateResult(pvt, data, args, null, query);
      return DataUtil.isNull(count) ? args.result : { result: args.result, count, aggregates: args.aggregates };
    };
    return ODataV4Adaptor2;
  })(ODataAdaptor)
);
var WebApiAdaptor = (
  /** @class */
  (function(_super) {
    __extends21(WebApiAdaptor2, _super);
    function WebApiAdaptor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    WebApiAdaptor2.prototype.getModuleName = function() {
      return "WebApiAdaptor";
    };
    WebApiAdaptor2.prototype.insert = function(dm, data, tableName) {
      return {
        type: "POST",
        url: dm.dataSource.url,
        data: JSON.stringify(data)
      };
    };
    WebApiAdaptor2.prototype.remove = function(dm, keyField, value, tableName) {
      return {
        type: "DELETE",
        url: dm.dataSource.url + "/" + value,
        data: JSON.stringify(value)
      };
    };
    WebApiAdaptor2.prototype.update = function(dm, keyField, value, tableName) {
      return {
        type: "PUT",
        url: dm.dataSource.url,
        data: JSON.stringify(value)
      };
    };
    WebApiAdaptor2.prototype.batchRequest = function(dm, changes, e) {
      var _this = this;
      var initialGuid = e.guid = DataUtil.getGuid(this.options.batchPre);
      var url = dm.dataSource.url.replace(/\/*$/, "/" + this.options.batch);
      e.url = this.resourceTableName ? this.resourceTableName : e.url;
      var req = [];
      var _loop_1 = function(i2, x2) {
        changes.addedRecords.forEach(function(j, d) {
          var stat = {
            "method": "POST ",
            "url": function(data, i3, key) {
              return "";
            },
            "data": function(data, i3) {
              return JSON.stringify(data[i3]) + "\n\n";
            }
          };
          req.push("--" + initialGuid);
          req.push("Content-Type: application/http; msgtype=request", "");
          req.push("POST /api/" + (dm.dataSource.insertUrl || dm.dataSource.crudUrl || e.url) + stat.url(changes.addedRecords, i2, e.key) + " HTTP/1.1");
          req.push("Content-Type: application/json; charset=utf-8");
          req.push("Host: " + location.host);
          req.push("", j ? JSON.stringify(j) : "");
        });
      };
      for (var i = 0, x = changes.addedRecords.length; i < x; i++) {
        _loop_1(i, x);
      }
      var _loop_2 = function(i2, x2) {
        changes.changedRecords.forEach(function(j, d) {
          var stat = {
            "method": _this.options.updateType + " ",
            "url": function(data, i3, key) {
              return "";
            },
            "data": function(data, i3) {
              return JSON.stringify(data[i3]) + "\n\n";
            }
          };
          req.push("--" + initialGuid);
          req.push("Content-Type: application/http; msgtype=request", "");
          req.push("PUT /api/" + (dm.dataSource.updateUrl || dm.dataSource.crudUrl || e.url) + stat.url(changes.changedRecords, i2, e.key) + " HTTP/1.1");
          req.push("Content-Type: application/json; charset=utf-8");
          req.push("Host: " + location.host);
          req.push("", j ? JSON.stringify(j) : "");
        });
      };
      for (var i = 0, x = changes.changedRecords.length; i < x; i++) {
        _loop_2(i, x);
      }
      var _loop_3 = function(i2, x2) {
        changes.deletedRecords.forEach(function(j, d) {
          var state = {
            "mtd": "DELETE ",
            "url": function(data, i3, key) {
              var url2 = DataUtil.getObject(key, data[i3]);
              if (typeof url2 === "number" || DataUtil.parse.isGuid(url2)) {
                return "/" + url2;
              } else if (url2 instanceof Date) {
                var datTime = data[i3][key];
                return "/" + datTime.toJSON();
              } else {
                return "/'" + url2 + "'";
              }
            },
            "data": function(data, i3) {
              return "";
            }
          };
          req.push("--" + initialGuid);
          req.push("Content-Type: application/http; msgtype=request", "");
          req.push("DELETE /api/" + (dm.dataSource.removeUrl || dm.dataSource.crudUrl || e.url) + state.url(changes.deletedRecords, i2, e.key) + " HTTP/1.1");
          req.push("Content-Type: application/json; charset=utf-8");
          req.push("Host: " + location.host);
          req.push("", j ? JSON.stringify(j) : "");
        });
      };
      for (var i = 0, x = changes.deletedRecords.length; i < x; i++) {
        _loop_3(i, x);
      }
      req.push("--" + initialGuid + "--", "");
      return {
        type: "POST",
        url,
        contentType: "multipart/mixed; boundary=" + initialGuid,
        data: req.join("\r\n")
      };
    };
    WebApiAdaptor2.prototype.beforeSend = function(dm, request, settings) {
      request.headers.set("Accept", "application/json, text/javascript, */*; q=0.01");
    };
    WebApiAdaptor2.prototype.processResponse = function(data, ds, query, xhr, request, changes) {
      var pvtData = "pvtData";
      var pvt = request && request[pvtData];
      var count = null;
      var args = {};
      if (request && request.type.toLowerCase() !== "post") {
        var versionCheck = xhr && request.fetchRequest.headers.get("DataServiceVersion");
        var version = versionCheck && parseInt(versionCheck, 10) || 2;
        if (query && query.isCountRequired) {
          if (!DataUtil.isNull(data.Count)) {
            count = data.Count;
          }
        }
        if (version < 3 && data.Items) {
          data = data.Items;
        }
        args.count = count;
        args.result = data;
        this.getAggregateResult(pvt, data, args, null, query);
      }
      args.result = args.result || data;
      return DataUtil.isNull(count) ? args.result : { result: args.result, count: args.count, aggregates: args.aggregates };
    };
    return WebApiAdaptor2;
  })(ODataAdaptor)
);
var WebMethodAdaptor = (
  /** @class */
  (function(_super) {
    __extends21(WebMethodAdaptor2, _super);
    function WebMethodAdaptor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    WebMethodAdaptor2.prototype.processQuery = function(dm, query, hierarchyFilters) {
      var obj = new UrlAdaptor().processQuery(dm, query, hierarchyFilters);
      var getData = "data";
      var data = DataUtil.parse.parseJson(obj[getData]);
      var result = {};
      var value = "value";
      if (data.param) {
        for (var i = 0; i < data.param.length; i++) {
          var param = data.param[i];
          var key = Object.keys(param)[0];
          result[key] = param[key];
        }
      }
      result[value] = data;
      var pvtData = "pvtData";
      var url = "url";
      return {
        data: JSON.stringify(result, DataUtil.parse.jsonDateReplacer),
        url: obj[url],
        pvtData: obj[pvtData],
        type: "POST",
        contentType: "application/json; charset=utf-8"
      };
    };
    return WebMethodAdaptor2;
  })(UrlAdaptor)
);
var RemoteSaveAdaptor = (
  /** @class */
  (function(_super) {
    __extends21(RemoteSaveAdaptor2, _super);
    function RemoteSaveAdaptor2() {
      return _super.call(this) || this;
    }
    RemoteSaveAdaptor2.prototype.insert = function(dm, data, tableName, query, position) {
      this.pvt.position = position;
      this.updateType = "add";
      return {
        url: dm.dataSource.insertUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        data: JSON.stringify(extend({}, {
          value: data,
          table: tableName,
          action: "insert"
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    RemoteSaveAdaptor2.prototype.remove = function(dm, keyField, val, tableName, query) {
      _super.prototype.remove.call(this, dm, keyField, val);
      return {
        type: "POST",
        url: dm.dataSource.removeUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        data: JSON.stringify(extend({}, {
          key: val,
          keyColumn: keyField,
          table: tableName,
          action: "remove"
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    RemoteSaveAdaptor2.prototype.update = function(dm, keyField, val, tableName, query) {
      this.updateType = "update";
      this.updateKey = keyField;
      return {
        type: "POST",
        url: dm.dataSource.updateUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        data: JSON.stringify(extend({}, {
          value: val,
          action: "update",
          keyColumn: keyField,
          key: val[keyField],
          table: tableName
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    RemoteSaveAdaptor2.prototype.processResponse = function(data, ds, query, xhr, request, changes, e) {
      var i;
      var newData = request ? JSON.parse(request.data) : data;
      data = newData.action === "batch" ? DataUtil.parse.parseJson(data) : data;
      if (this.updateType === "add") {
        _super.prototype.insert.call(this, ds, data, null, null, this.pvt.position);
      }
      if (this.updateType === "update") {
        _super.prototype.update.call(this, ds, this.updateKey, data);
      }
      this.updateType = void 0;
      if (data.added) {
        for (i = 0; i < data.added.length; i++) {
          _super.prototype.insert.call(this, ds, data.added[i]);
        }
      }
      if (data.changed) {
        for (i = 0; i < data.changed.length; i++) {
          _super.prototype.update.call(this, ds, e.key, data.changed[i]);
        }
      }
      if (data.deleted) {
        for (i = 0; i < data.deleted.length; i++) {
          _super.prototype.remove.call(this, ds, e.key, data.deleted[i]);
        }
      }
      return data;
    };
    RemoteSaveAdaptor2.prototype.batchRequest = function(dm, changes, e, query, original) {
      return {
        type: "POST",
        url: dm.dataSource.batchUrl || dm.dataSource.crudUrl || dm.dataSource.url,
        contentType: "application/json; charset=utf-8",
        dataType: "json",
        data: JSON.stringify(extend({}, {
          changed: changes.changedRecords,
          added: changes.addedRecords,
          deleted: changes.deletedRecords,
          action: "batch",
          table: e.url,
          key: e.key
        }, DataUtil.getAddParams(this, dm, query)))
      };
    };
    RemoteSaveAdaptor2.prototype.addParams = function(options) {
      var urlParams = new UrlAdaptor();
      urlParams.addParams(options);
    };
    RemoteSaveAdaptor2.prototype.beforeSend = function(dm, request, settings) {
    };
    return RemoteSaveAdaptor2;
  })(JsonAdaptor)
);
var CustomDataAdaptor = (
  /** @class */
  (function(_super) {
    __extends21(CustomDataAdaptor2, _super);
    function CustomDataAdaptor2(props) {
      var _this = _super.call(this) || this;
      _this.options = extend({}, _this.options, {
        getData: function() {
        },
        addRecord: function() {
        },
        updateRecord: function() {
        },
        deleteRecord: function() {
        },
        batchUpdate: function() {
        }
      });
      extend(_this.options, props || {});
      return _this;
    }
    CustomDataAdaptor2.prototype.getModuleName = function() {
      return "CustomDataAdaptor";
    };
    return CustomDataAdaptor2;
  })(UrlAdaptor)
);
var GraphQLAdaptor = (
  /** @class */
  (function(_super) {
    __extends21(GraphQLAdaptor2, _super);
    function GraphQLAdaptor2(options) {
      var _this = _super.call(this) || this;
      _this.opt = options;
      _this.schema = _this.opt.response;
      _this.query = _this.opt.query;
      _this.getVariables = _this.opt.getVariables ? _this.opt.getVariables : function() {
      };
      _this.getQuery = function() {
        return _this.query;
      };
      return _this;
    }
    GraphQLAdaptor2.prototype.getModuleName = function() {
      return "GraphQLAdaptor";
    };
    GraphQLAdaptor2.prototype.processQuery = function(datamanager, query) {
      var urlQuery = _super.prototype.processQuery.apply(this, arguments);
      var dm = JSON.parse(urlQuery.data);
      var keys2 = [
        "skip",
        "take",
        "sorted",
        "table",
        "select",
        "where",
        "search",
        "requiresCounts",
        "aggregates",
        "params"
      ];
      var temp = {};
      var str = "searchwhereparams";
      keys2.filter(function(e) {
        temp[e] = str.indexOf(e) > -1 ? JSON.stringify(dm[e]) : dm[e];
      });
      var vars = this.getVariables() || {};
      vars["datamanager"] = temp;
      var data = JSON.stringify({
        query: this.getQuery(),
        variables: vars
      });
      urlQuery.data = data;
      return urlQuery;
    };
    GraphQLAdaptor2.prototype.processResponse = function(resData, ds, query, xhr, request) {
      var res = resData;
      var count;
      var aggregates;
      var result = getValue(this.schema.result, res.data);
      if (this.schema.count) {
        count = getValue(this.schema.count, res.data);
      }
      if (this.schema.aggregates) {
        aggregates = getValue(this.schema.aggregates, res.data);
        aggregates = !isNullOrUndefined(aggregates) ? DataUtil.parse.parseJson(aggregates) : aggregates;
      }
      var pvt = request.pvtData || {};
      var args = { result, aggregates };
      var data = args;
      if (pvt && pvt.groups && pvt.groups.length) {
        this.getAggregateResult(pvt, data, args, null, query);
      }
      return !isNullOrUndefined(count) ? { result: args.result, count, aggregates } : args.result;
    };
    GraphQLAdaptor2.prototype.insert = function() {
      var inserted = _super.prototype.insert.apply(this, arguments);
      return this.generateCrudData(inserted, "insert");
    };
    GraphQLAdaptor2.prototype.update = function() {
      var inserted = _super.prototype.update.apply(this, arguments);
      return this.generateCrudData(inserted, "update");
    };
    GraphQLAdaptor2.prototype.remove = function() {
      var inserted = _super.prototype.remove.apply(this, arguments);
      return this.generateCrudData(inserted, "remove");
    };
    GraphQLAdaptor2.prototype.batchRequest = function(dm, changes, e, query, original) {
      var batch = _super.prototype.batchRequest.apply(this, arguments);
      var bData = JSON.parse(batch.data);
      bData.key = e.key;
      batch.data = JSON.stringify(bData);
      return this.generateCrudData(batch, "batch");
    };
    GraphQLAdaptor2.prototype.generateCrudData = function(crudData, action) {
      var parsed = JSON.parse(crudData.data);
      crudData.data = JSON.stringify({
        query: this.opt.getMutation(action),
        variables: parsed
      });
      return crudData;
    };
    return GraphQLAdaptor2;
  })(UrlAdaptor)
);
var CacheAdaptor = (
  /** @class */
  (function(_super) {
    __extends21(CacheAdaptor2, _super);
    function CacheAdaptor2(adaptor, timeStamp, pageSize) {
      var _this = _super.call(this) || this;
      _this.isCrudAction = false;
      _this.isInsertAction = false;
      if (!isNullOrUndefined(adaptor)) {
        _this.cacheAdaptor = adaptor;
      }
      _this.pageSize = pageSize;
      _this.guidId = DataUtil.getGuid("cacheAdaptor");
      var obj = { keys: [], results: [] };
      window.localStorage.setItem(_this.guidId, JSON.stringify(obj));
      var guid = _this.guidId;
      if (!isNullOrUndefined(timeStamp)) {
        setInterval(function() {
          var data = DataUtil.parse.parseJson(window.localStorage.getItem(guid));
          var forDel = [];
          for (var i = 0; i < data.results.length; i++) {
            var currentTime = +/* @__PURE__ */ new Date();
            var requestTime = +new Date(data.results[i].timeStamp);
            data.results[i].timeStamp = currentTime - requestTime;
            if (currentTime - requestTime > timeStamp) {
              forDel.push(i);
            }
          }
          for (var i = 0; i < forDel.length; i++) {
            data.results.splice(forDel[i], 1);
            data.keys.splice(forDel[i], 1);
          }
          window.localStorage.removeItem(guid);
          window.localStorage.setItem(guid, JSON.stringify(data));
        }, timeStamp);
      }
      return _this;
    }
    CacheAdaptor2.prototype.generateKey = function(url, query) {
      var queries = this.getQueryRequest(query);
      var singles = Query.filterQueryLists(query.queries, ["onSelect", "onPage", "onSkip", "onTake", "onRange"]);
      var key = url;
      var page = "onPage";
      if (page in singles) {
        key += singles[page].pageIndex;
      }
      queries.sorts.forEach(function(obj) {
        key += obj.e.direction + obj.e.fieldName;
      });
      queries.groups.forEach(function(obj) {
        key += obj.e.fieldName;
      });
      queries.searches.forEach(function(obj) {
        key += obj.e.searchKey;
      });
      for (var filter2 = 0; filter2 < queries.filters.length; filter2++) {
        var currentFilter = queries.filters[filter2];
        if (currentFilter.e.isComplex) {
          var newQuery = query.clone();
          newQuery.queries = [];
          for (var i = 0; i < currentFilter.e.predicates.length; i++) {
            newQuery.queries.push({ fn: "onWhere", e: currentFilter.e.predicates[i], filter: query.queries.filter });
          }
          key += currentFilter.e.condition + this.generateKey(url, newQuery);
        } else {
          key += currentFilter.e.field + currentFilter.e.operator + currentFilter.e.value;
        }
      }
      return key;
    };
    CacheAdaptor2.prototype.processQuery = function(dm, query, hierarchyFilters) {
      var key = this.generateKey(dm.dataSource.url, query);
      var cachedItems = DataUtil.parse.parseJson(window.localStorage.getItem(this.guidId));
      var data = cachedItems ? cachedItems.results[cachedItems.keys.indexOf(key)] : null;
      if (data != null && !this.isCrudAction && !this.isInsertAction) {
        return data;
      }
      this.isCrudAction = null;
      this.isInsertAction = null;
      return this.cacheAdaptor.processQuery.apply(this.cacheAdaptor, [].slice.call(arguments, 0));
    };
    CacheAdaptor2.prototype.processResponse = function(data, ds, query, xhr, request, changes) {
      if (this.isInsertAction || request && this.cacheAdaptor.options.batch && DataUtil.endsWith(request.url, this.cacheAdaptor.options.batch) && request.type.toLowerCase() === "post") {
        return this.cacheAdaptor.processResponse(data, ds, query, xhr, request, changes);
      }
      data = this.cacheAdaptor.processResponse.apply(this.cacheAdaptor, [].slice.call(arguments, 0));
      var key = query ? this.generateKey(ds.dataSource.url, query) : ds.dataSource.url;
      var obj = {};
      obj = DataUtil.parse.parseJson(window.localStorage.getItem(this.guidId));
      var index = obj.keys.indexOf(key);
      if (index !== -1) {
        obj.results.splice(index, 1);
        obj.keys.splice(index, 1);
      }
      obj.results[obj.keys.push(key) - 1] = { keys: key, result: data.result, timeStamp: /* @__PURE__ */ new Date(), count: data.count };
      while (obj.results.length > this.pageSize) {
        obj.results.splice(0, 1);
        obj.keys.splice(0, 1);
      }
      window.localStorage.setItem(this.guidId, JSON.stringify(obj));
      return data;
    };
    CacheAdaptor2.prototype.beforeSend = function(dm, request, settings) {
      if (!isNullOrUndefined(this.cacheAdaptor.options.batch) && DataUtil.endsWith(settings.url, this.cacheAdaptor.options.batch) && settings.type.toLowerCase() === "post") {
        request.headers.set("Accept", this.cacheAdaptor.options.multipartAccept);
      }
      if (!dm.dataSource.crossDomain) {
        request.headers.set("Accept", this.cacheAdaptor.options.accept);
      }
    };
    CacheAdaptor2.prototype.update = function(dm, keyField, value, tableName) {
      this.isCrudAction = true;
      return this.cacheAdaptor.update(dm, keyField, value, tableName);
    };
    CacheAdaptor2.prototype.insert = function(dm, data, tableName) {
      this.isInsertAction = true;
      return this.cacheAdaptor.insert(dm, data, tableName);
    };
    CacheAdaptor2.prototype.remove = function(dm, keyField, value, tableName) {
      this.isCrudAction = true;
      return this.cacheAdaptor.remove(dm, keyField, value, tableName);
    };
    CacheAdaptor2.prototype.batchRequest = function(dm, changes, e) {
      return this.cacheAdaptor.batchRequest(dm, changes, e);
    };
    return CacheAdaptor2;
  })(UrlAdaptor)
);

// node_modules/@syncfusion/ej2-data/src/manager.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var DataManager = (
  /** @class */
  (function() {
    function DataManager2(dataSource, query, adaptor) {
      var _this = this;
      this.dateParse = true;
      this.timeZoneHandling = true;
      this.persistQuery = {};
      this.isInitialLoad = false;
      this.requests = [];
      this.isEnableCache = false;
      this.isInitialLoad = true;
      this.isEnableCache = false;
      if (!dataSource && !this.dataSource) {
        dataSource = [];
      }
      adaptor = adaptor || dataSource.adaptor;
      if (dataSource && dataSource.timeZoneHandling === false) {
        this.timeZoneHandling = dataSource.timeZoneHandling;
      }
      var data;
      if (dataSource instanceof Array) {
        data = {
          json: dataSource,
          offline: true
        };
      } else if (typeof dataSource === "object") {
        if (!dataSource.json) {
          dataSource.json = [];
        }
        if (!dataSource.enablePersistence) {
          dataSource.enablePersistence = false;
        }
        if (!dataSource.id) {
          dataSource.id = "";
        }
        if (!dataSource.ignoreOnPersist) {
          dataSource.ignoreOnPersist = [];
        }
        data = {
          url: dataSource.url,
          insertUrl: dataSource.insertUrl,
          removeUrl: dataSource.removeUrl,
          updateUrl: dataSource.updateUrl,
          crudUrl: dataSource.crudUrl,
          batchUrl: dataSource.batchUrl,
          json: dataSource.json,
          headers: dataSource.headers,
          accept: dataSource.accept,
          data: dataSource.data,
          enableCache: dataSource.enableCache,
          timeTillExpiration: dataSource.timeTillExpiration,
          cachingPageSize: dataSource.cachingPageSize,
          enableCaching: dataSource.enableCaching,
          requestType: dataSource.requestType,
          key: dataSource.key,
          crossDomain: dataSource.crossDomain,
          jsonp: dataSource.jsonp,
          dataType: dataSource.dataType,
          offline: dataSource.offline !== void 0 ? dataSource.offline : dataSource.adaptor instanceof RemoteSaveAdaptor || dataSource.adaptor instanceof CustomDataAdaptor ? false : dataSource.url ? false : true,
          requiresFormat: dataSource.requiresFormat,
          enablePersistence: dataSource.enablePersistence,
          id: dataSource.id,
          ignoreOnPersist: dataSource.ignoreOnPersist
        };
      } else {
        DataUtil.throwError("DataManager: Invalid arguments");
      }
      if (data.requiresFormat === void 0 && !DataUtil.isCors()) {
        data.requiresFormat = isNullOrUndefined(data.crossDomain) ? true : data.crossDomain;
      }
      if (data.dataType === void 0) {
        data.dataType = "json";
      }
      this.isEnableCache = data.enableCache;
      this.dataSource = data;
      this.defaultQuery = query;
      if (this.dataSource.enablePersistence && this.dataSource.id) {
        window.addEventListener("unload", this.setPersistData.bind(this));
      }
      if (data.url && data.offline && !data.json.length) {
        this.isDataAvailable = false;
        this.adaptor = adaptor || new ODataAdaptor();
        this.dataSource.offline = false;
        this.ready = this.executeQuery(query || new Query());
        this.ready.then(function(e) {
          _this.dataSource.offline = true;
          _this.isDataAvailable = true;
          data.json = e.result;
          _this.adaptor = new JsonAdaptor();
        });
      } else {
        this.adaptor = data.offline ? new JsonAdaptor() : new ODataAdaptor();
      }
      if (!data.jsonp && this.adaptor instanceof ODataAdaptor) {
        data.jsonp = "callback";
      }
      this.adaptor = adaptor || this.adaptor;
      if (this.isEnableCache) {
        this.guidId = DataUtil.getGuid("cacheAdaptor");
        var obj = { keys: [], results: [] };
        window.localStorage.setItem(this.guidId, JSON.stringify(obj));
      }
      if (data.enableCaching) {
        this.adaptor = new CacheAdaptor(this.adaptor, data.timeTillExpiration, data.cachingPageSize);
      }
      return this;
    }
    Object.defineProperty(DataManager2.prototype, "moduleName", {
      /** @hidden */
      get: function() {
        return "datamanager";
      },
      enumerable: true,
      configurable: true
    });
    ;
    DataManager2.prototype.getPersistedData = function(id) {
      var persistedData = localStorage.getItem(id || this.dataSource.id);
      return JSON.parse(persistedData);
    };
    DataManager2.prototype.setPersistData = function(e, id, persistData) {
      localStorage.setItem(id || this.dataSource.id, JSON.stringify(persistData || this.persistQuery));
    };
    DataManager2.prototype.setPersistQuery = function(query) {
      var _this = this;
      var persistedQuery = this.getPersistedData();
      if (this.isInitialLoad && persistedQuery && Object.keys(persistedQuery).length) {
        this.persistQuery = persistedQuery;
        this.persistQuery.queries = this.persistQuery.queries.filter(function(query2) {
          if (_this.dataSource.ignoreOnPersist && _this.dataSource.ignoreOnPersist.length) {
            if (query2.fn && _this.dataSource.ignoreOnPersist.some(function(keyword) {
              return query2.fn === keyword;
            })) {
              return false;
            }
          }
          if (query2.fn === "onWhere") {
            var e = query2.e;
            if (e && e.isComplex && e.predicates instanceof Array) {
              var allPredicates = e.predicates.map(function(predicateObj) {
                if (predicateObj.predicates && predicateObj.predicates instanceof Array) {
                  var nestedPredicates = predicateObj.predicates.map(function(nestedPredicate) {
                    var field2 = nestedPredicate.field, operator2 = nestedPredicate.operator, value2 = nestedPredicate.value, ignoreCase2 = nestedPredicate.ignoreCase, ignoreAccent2 = nestedPredicate.ignoreAccent, matchCase2 = nestedPredicate.matchCase;
                    return new Predicate(field2, operator2, value2, ignoreCase2, ignoreAccent2, matchCase2);
                  });
                  return predicateObj.condition === "and" ? Predicate.and(nestedPredicates) : Predicate.or(nestedPredicates);
                } else {
                  var field = predicateObj.field, operator = predicateObj.operator, value = predicateObj.value, ignoreCase = predicateObj.ignoreCase, ignoreAccent = predicateObj.ignoreAccent, matchCase = predicateObj.matchCase;
                  return new Predicate(field, operator, value, ignoreCase, ignoreAccent, matchCase);
                }
              });
              query2.e = new Predicate(allPredicates[0], e.condition, allPredicates.slice(1));
            }
          }
          return true;
        });
        var newQuery = extend(new Query(), this.persistQuery);
        this.isInitialLoad = false;
        return newQuery;
      } else {
        this.persistQuery = query;
        this.isInitialLoad = false;
        return query;
      }
    };
    DataManager2.prototype.setDefaultQuery = function(query) {
      this.defaultQuery = query;
      return this;
    };
    DataManager2.prototype.executeLocal = function(query) {
      if (!this.defaultQuery && !(query instanceof Query)) {
        DataUtil.throwError("DataManager - executeLocal() : A query is required to execute");
      }
      if (!this.dataSource.json) {
        DataUtil.throwError("DataManager - executeLocal() : Json data is required to execute");
      }
      if (this.dataSource.enablePersistence && this.dataSource.id) {
        query = this.setPersistQuery(query);
      }
      query = query || this.defaultQuery;
      var result = this.adaptor.processQuery(this, query);
      if (query.subQuery) {
        var from = query.subQuery.fromTable;
        var lookup = query.subQuery.lookups;
        var res = query.isCountRequired ? result.result : result;
        if (lookup && lookup instanceof Array) {
          DataUtil.buildHierarchy(query.subQuery.fKey, from, res, lookup, query.subQuery.key);
        }
        for (var j = 0; j < res.length; j++) {
          if (res[j][from] instanceof Array) {
            res[j] = extend({}, {}, res[j]);
            res[j][from] = this.adaptor.processResponse(query.subQuery.using(new DataManager2(res[j][from].slice(0))).executeLocal(), this, query);
          }
        }
      }
      return this.adaptor.processResponse(result, this, query);
    };
    DataManager2.prototype.executeQuery = function(query, done, fail, always) {
      var _this = this;
      var makeRequest = "makeRequest";
      if (this.dataSource.enablePersistence && this.dataSource.id) {
        query = this.setPersistQuery(query);
      }
      if (typeof query === "function") {
        always = fail;
        fail = done;
        done = query;
        query = null;
      }
      if (!query) {
        query = this.defaultQuery;
      }
      if (!(query instanceof Query)) {
        DataUtil.throwError("DataManager - executeQuery() : A query is required to execute");
      }
      var deffered = new Deferred();
      var args = { query };
      if (!this.dataSource.offline && (this.dataSource.url !== void 0 && this.dataSource.url !== "") || !isNullOrUndefined(this.adaptor[makeRequest]) || this.isCustomDataAdaptor(this.adaptor)) {
        var result = this.isEnableCache ? this.processQuery(query) : this.adaptor.processQuery(this, query);
        if (!isNullOrUndefined(this.adaptor[makeRequest])) {
          this.adaptor[makeRequest](result, deffered, args, query);
        } else if (!isNullOrUndefined(result.url) || this.isCustomDataAdaptor(this.adaptor)) {
          this.requests = [];
          this.makeRequest(result, deffered, args, query);
        } else {
          args = DataManager2.getDeferedArgs(query, result, args);
          deffered.resolve(args);
        }
      } else {
        DataManager2.nextTick(function() {
          var res = _this.executeLocal(query);
          args = DataManager2.getDeferedArgs(query, res, args);
          deffered.resolve(args);
        });
      }
      if (done || fail) {
        deffered.promise.then(done, fail);
      }
      if (always) {
        deffered.promise.then(always, always);
      }
      return deffered.promise;
    };
    DataManager2.prototype.getQueryRequest = function(query) {
      var req = { sorts: [], groups: [], filters: [], searches: [], aggregates: [] };
      req.sorts = Query.filterQueries(query.queries, "onSortBy");
      req.groups = Query.filterQueries(query.queries, "onGroup");
      req.filters = Query.filterQueries(query.queries, "onWhere");
      req.searches = Query.filterQueries(query.queries, "onSearch");
      req.aggregates = Query.filterQueries(query.queries, "onAggregates");
      return req;
    };
    DataManager2.prototype.generateKey = function(url, query) {
      var queries = this.getQueryRequest(query);
      var singles = Query.filterQueryLists(query.queries, ["onSelect", "onPage", "onSkip", "onTake", "onRange"]);
      var key = url;
      var page = "onPage";
      queries.sorts.forEach(function(obj2) {
        key += obj2.e.direction + obj2.e.fieldName;
      });
      queries.groups.forEach(function(obj2) {
        key += obj2.e.fieldName;
      });
      queries.searches.forEach(function(obj2) {
        key += obj2.e.searchKey;
      });
      for (var filter2 = 0; filter2 < queries.filters.length; filter2++) {
        var currentFilter = queries.filters[filter2];
        if (currentFilter.e.isComplex) {
          var newQuery = query.clone();
          newQuery.queries = [];
          for (var i = 0; i < currentFilter.e.predicates.length; i++) {
            newQuery.queries.push({ fn: "onWhere", e: currentFilter.e.predicates[i], filter: query.queries.filter });
          }
          key += currentFilter.e.condition + this.generateKey(url, newQuery);
        } else {
          key += currentFilter.e.field + currentFilter.e.operator + currentFilter.e.value;
        }
      }
      if (!isNullOrUndefined(this.previousCacheQuery) && this.previousCacheQuery !== key) {
        var obj = { keys: [], results: [] };
        window.localStorage.setItem(this.guidId, JSON.stringify(obj));
      }
      this.previousCacheQuery = key;
      if (page in singles) {
        key += singles[page].pageIndex;
      }
      return key;
    };
    DataManager2.prototype.processQuery = function(query) {
      var key = this.generateKey(this.dataSource.url, query);
      var cachedItems = JSON.parse(window.localStorage.getItem(this.guidId));
      var data = cachedItems ? cachedItems.results[cachedItems.keys.indexOf(key)] : null;
      if (data != null) {
        return DataUtil.parse.parseJson(data);
      }
      return this.adaptor.processQuery(this, query);
    };
    DataManager2.getDeferedArgs = function(query, result, args) {
      if (query.isCountRequired) {
        args.result = result.result;
        args.count = result.count;
        args.aggregates = result.aggregates;
      } else {
        args.result = result;
      }
      return args;
    };
    DataManager2.nextTick = function(fn) {
      (window.setImmediate || window.setTimeout)(fn, 0);
    };
    DataManager2.prototype.extendRequest = function(url, fnSuccess, fnFail) {
      return extend({}, {
        type: "GET",
        dataType: this.dataSource.dataType,
        crossDomain: this.dataSource.crossDomain,
        jsonp: this.dataSource.jsonp,
        cache: true,
        processData: false,
        onSuccess: fnSuccess,
        onFailure: fnFail
      }, url);
    };
    DataManager2.prototype.makeRequest = function(url, deffered, args, query) {
      var _this = this;
      var isSelector = !!query.subQuerySelector;
      var fnFail = function(e) {
        args.error = e;
        deffered.reject(args);
      };
      var process = function(data, count, xhr, request2, actual, aggregates, virtualSelectRecords) {
        args.xhr = xhr;
        args.count = count ? parseInt(count.toString(), 10) : 0;
        args.result = data;
        args.request = request2;
        args.aggregates = aggregates;
        args.actual = actual;
        args.virtualSelectRecords = virtualSelectRecords;
        deffered.resolve(args);
      };
      var fnQueryChild = function(data, selector) {
        var subDeffer = new Deferred();
        var childArgs = { parent: args };
        query.subQuery.isChild = true;
        var subUrl = _this.adaptor.processQuery(_this, query.subQuery, data ? _this.adaptor.processResponse(data) : selector);
        var childReq = _this.makeRequest(subUrl, subDeffer, childArgs, query.subQuery);
        if (!isSelector) {
          subDeffer.then(function(subData) {
            if (data) {
              DataUtil.buildHierarchy(query.subQuery.fKey, query.subQuery.fromTable, data, subData, query.subQuery.key);
              process(data, subData.count, subData.xhr);
            }
          }, fnFail);
        }
        return childReq;
      };
      var fnSuccess = function(data, request2) {
        if (_this.isGraphQLAdaptor(_this.adaptor)) {
          if (!isNullOrUndefined(data["errors"])) {
            return fnFail(data["errors"], request2);
          }
        }
        if (_this.isCustomDataAdaptor(_this.adaptor)) {
          request2 = extend({}, _this.fetchReqOption, request2);
        }
        if (request2.contentType.indexOf("xml") === -1 && _this.dateParse && !_this.isEnableCache) {
          data = DataUtil.parse.parseJson(data);
        }
        var result;
        var promise2 = _this.afterReponseRequest(data);
        promise2.then(function(data2) {
          result = _this.adaptor.processResponse(data2, _this, query, request2.fetchRequest, request2);
          if (_this.isEnableCache) {
            var key = query ? _this.generateKey(_this.dataSource.url, query) : _this.dataSource.url;
            var obj = {};
            obj = JSON.parse(window.localStorage.getItem(_this.guidId));
            var index = obj.keys.indexOf(key);
            if (index !== -1) {
              obj.results.splice(index, 1);
              obj.keys.splice(index, 1);
            }
            obj.results[obj.keys.push(key) - 1] = { keys: key, result: result.result, timeStamp: /* @__PURE__ */ new Date(), count: result.count };
            window.localStorage.setItem(_this.guidId, JSON.stringify(obj));
          }
          if (request2.contentType.indexOf("xml") === -1 && _this.dateParse && _this.isEnableCache) {
            result = DataUtil.parse.parseJson(result);
          }
          var count = 0;
          var aggregates = null;
          var virtualSelectRecords = "virtualSelectRecords";
          var virtualRecords = data2[virtualSelectRecords];
          if (query.isCountRequired) {
            count = result.count;
            aggregates = result.aggregates;
            result = result.result;
          }
          if (!query.subQuery) {
            process(result, count, request2.fetchRequest, request2.type, data2, aggregates, virtualRecords);
            return;
          }
          if (!isSelector) {
            fnQueryChild(result, request2);
          }
          ;
        }).catch(function(e) {
          return _this.dataManagerFailure(e, deffered, args);
        });
      };
      var req = this.extendRequest(url, fnSuccess, fnFail);
      if (!this.isCustomDataAdaptor(this.adaptor)) {
        var promise = this.useMiddleware(req);
        var fetch_1;
        promise.then(function(response) {
          fetch_1 = new Fetch(req);
          fetch_1.beforeSend = function() {
            _this.beforeSend(fetch_1.fetchRequest, fetch_1, response);
          };
          req = fetch_1.send();
          req.catch(function(e) {
            return true;
          });
          _this.requests.push(fetch_1);
        }).catch(function(e) {
          return _this.dataManagerFailure(e, deffered, args);
        });
      } else {
        this.fetchReqOption = req;
        var request = req;
        this.adaptor.options.getData({
          data: request.data,
          onSuccess: request.onSuccess,
          onFailure: request.onFailure
        });
      }
      if (isSelector) {
        var promise = void 0;
        var res = query.subQuerySelector.call(this, { query: query.subQuery, parent: query });
        if (res && res.length) {
          promise = Promise.all([req, fnQueryChild(null, res)]);
          promise.then(function() {
            var args2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args2[_i] = arguments[_i];
            }
            var result = args2[0];
            var pResult = _this.adaptor.processResponse(result[0], _this, query, _this.requests[0].fetchRequest, _this.requests[0]);
            var count = 0;
            if (query.isCountRequired) {
              count = pResult.count;
              pResult = pResult.result;
            }
            var cResult = _this.adaptor.processResponse(result[1], _this, query.subQuery, _this.requests[1].fetchRequest, _this.requests[1]);
            count = 0;
            if (query.subQuery.isCountRequired) {
              count = cResult.count;
              cResult = cResult.result;
            }
            DataUtil.buildHierarchy(query.subQuery.fKey, query.subQuery.fromTable, pResult, cResult, query.subQuery.key);
            isSelector = false;
            process(pResult, count, _this.requests[0].fetchRequest);
          });
        } else {
          isSelector = false;
        }
      }
      return req;
    };
    DataManager2.prototype.dataManagerFailure = function(e, deffered, args) {
      args.error = e;
      deffered.reject(args);
    };
    DataManager2.prototype.afterReponseRequest = function(data) {
      return __awaiter(this, void 0, void 0, function() {
        var reponse, deffered;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, this.applyPostRequestMiddlewares(data)];
            case 1:
              reponse = _a.sent();
              deffered = new Deferred();
              deffered.resolve(reponse);
              return [2, deffered.promise];
          }
        });
      });
    };
    DataManager2.prototype.applyPostRequestMiddlewares = function(response) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          return [2, response];
        });
      });
    };
    DataManager2.prototype.useMiddleware = function(request) {
      return __awaiter(this, void 0, void 0, function() {
        var reponse, deffered;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, this.applyPreRequestMiddlewares(request)];
            case 1:
              reponse = _a.sent();
              deffered = new Deferred();
              deffered.resolve(reponse);
              return [2, deffered.promise];
          }
        });
      });
    };
    DataManager2.prototype.applyPreRequestMiddlewares = function(request) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          return [2, request];
        });
      });
    };
    DataManager2.prototype.beforeSend = function(request, settings, response) {
      this.adaptor.beforeSend(this, request, settings);
      var headers = [];
      if (this.dataSource.headers) {
        headers = headers.concat(this.dataSource.headers);
      }
      var props;
      if (response && response.headers) {
        headers = headers.concat(response.headers);
      }
      for (var i = 0; headers && i < headers.length; i++) {
        props = [];
        var keys2 = Object.keys(headers[i]);
        for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
          var prop = keys_1[_i];
          props.push(prop);
          request.headers.set(prop, headers[i][prop]);
        }
      }
    };
    DataManager2.prototype.saveChanges = function(changes, key, tableName, query, original) {
      var _this = this;
      if (tableName instanceof Query) {
        query = tableName;
        tableName = null;
      }
      var args = {
        url: tableName,
        key: key || this.dataSource.key
      };
      var req = this.adaptor.batchRequest(this, changes, args, query || new Query(), original);
      var dofetchRequest = "dofetchRequest";
      if (this.dataSource.offline) {
        return req;
      }
      if (!isNullOrUndefined(this.adaptor[dofetchRequest])) {
        return this.adaptor[dofetchRequest](req);
      } else if (!this.isCustomDataAdaptor(this.adaptor)) {
        var deff_1 = new Deferred();
        var fetch_2 = new Fetch(req);
        fetch_2.beforeSend = function() {
          _this.beforeSend(fetch_2.fetchRequest, fetch_2);
        };
        fetch_2.onSuccess = function(data, request) {
          if (_this.isGraphQLAdaptor(_this.adaptor)) {
            if (!isNullOrUndefined(data["errors"])) {
              fetch_2.onFailure(JSON.stringify(data["errors"]));
            }
          }
          deff_1.resolve(_this.adaptor.processResponse(data, _this, null, request.fetchRequest, request, changes, args));
        };
        fetch_2.onFailure = function(e) {
          deff_1.reject([{ error: e }]);
        };
        fetch_2.send().catch(function(e) {
          return true;
        });
        return deff_1.promise;
      } else {
        return this.dofetchRequest(req, this.adaptor.options.batchUpdate, changes);
      }
    };
    DataManager2.prototype.insert = function(data, tableName, query, position) {
      if (tableName instanceof Query) {
        query = tableName;
        tableName = null;
      }
      var req = this.adaptor.insert(this, data, tableName, query, position);
      var dofetchRequest = "dofetchRequest";
      if (this.dataSource.offline) {
        return req;
      }
      if (!isNullOrUndefined(this.adaptor[dofetchRequest])) {
        return this.adaptor[dofetchRequest](req);
      } else {
        return this.dofetchRequest(req, this.adaptor.options.addRecord);
      }
    };
    DataManager2.prototype.remove = function(keyField, value, tableName, query) {
      if (typeof value === "object") {
        value = DataUtil.getObject(keyField, value);
      }
      if (tableName instanceof Query) {
        query = tableName;
        tableName = null;
      }
      var res = this.adaptor.remove(this, keyField, value, tableName, query);
      var dofetchRequest = "dofetchRequest";
      if (this.dataSource.offline) {
        return res;
      }
      if (!isNullOrUndefined(this.adaptor[dofetchRequest])) {
        return this.adaptor[dofetchRequest](res);
      } else {
        var remove2 = this.adaptor.options.deleteRecord;
        return this.dofetchRequest(res, remove2);
      }
    };
    DataManager2.prototype.update = function(keyField, value, tableName, query, original) {
      if (tableName instanceof Query) {
        query = tableName;
        tableName = null;
      }
      if (this.isEnableCache) {
        this.cacheQuery = this.generateKey(this.dataSource.url, query);
      }
      var res = this.adaptor.update(this, keyField, value, tableName, query, original);
      var dofetchRequest = "dofetchRequest";
      if (this.dataSource.offline) {
        return res;
      }
      if (!isNullOrUndefined(this.adaptor[dofetchRequest])) {
        return this.adaptor[dofetchRequest](res);
      } else {
        var update = this.adaptor.options.updateRecord;
        return this.dofetchRequest(res, update);
      }
    };
    DataManager2.prototype.isCustomDataAdaptor = function(dataSource) {
      return this.adaptor.getModuleName && this.adaptor.getModuleName() === "CustomDataAdaptor";
    };
    DataManager2.prototype.isGraphQLAdaptor = function(dataSource) {
      return this.adaptor.getModuleName && this.adaptor.getModuleName() === "GraphQLAdaptor";
    };
    DataManager2.prototype.successFunc = function(record, request, changes) {
      if (this.isGraphQLAdaptor(this.adaptor)) {
        var data = typeof record === "object" ? record : JSON.parse(record);
        if (!isNullOrUndefined(data["errors"])) {
          this.failureFunc(JSON.stringify(data["errors"]));
        }
      }
      if (this.isCustomDataAdaptor(this.adaptor)) {
        request = extend({}, this.fetchReqOption, request);
      }
      try {
        DataUtil.parse.parseJson(record);
      } catch (e) {
        record = [];
      }
      if (this.isEnableCache) {
        var requests = JSON.parse(request.data);
        if (requests.action === "insert" || requests.action === "remove") {
          var obj = { keys: [], results: [] };
          window.localStorage.setItem(this.guidId, JSON.stringify(obj));
        } else if (requests.action === "update") {
          var cachedItems = JSON.parse(window.localStorage.getItem(this.guidId));
          var data = cachedItems ? cachedItems.results[cachedItems.keys.indexOf(this.cacheQuery)] : null;
          if (data && data.result) {
            var cacheData = data.result;
            for (var i = 0; i < cacheData.length; i++) {
              if (cacheData[i][requests.keyColumn] === requests.key) {
                cacheData[i] = requests.value;
                window.localStorage.setItem(this.guidId, JSON.stringify(cachedItems));
                break;
              }
            }
          }
        }
      }
      record = this.adaptor.processResponse(DataUtil.parse.parseJson(record), this, null, request.fetchRequest, request, changes);
      this.fetchDeffered.resolve(record);
    };
    DataManager2.prototype.failureFunc = function(e) {
      if (this.isEnableCache) {
        this.cacheQuery = "";
      }
      this.fetchDeffered.reject([{ error: e }]);
    };
    DataManager2.prototype.dofetchRequest = function(res, fetchFunc, changes) {
      var _this = this;
      res = extend({}, {
        type: "POST",
        contentType: "application/json; charset=utf-8",
        processData: false
      }, res);
      this.fetchDeffered = new Deferred();
      if (!this.isCustomDataAdaptor(this.adaptor)) {
        var promise = this.useMiddleware(res);
        var fetch_3;
        promise.then(function(response) {
          fetch_3 = new Fetch(res);
          fetch_3.beforeSend = function() {
            _this.beforeSend(fetch_3.fetchRequest, fetch_3, response);
          };
          fetch_3.onSuccess = _this.successFunc.bind(_this);
          fetch_3.onFailure = _this.failureFunc.bind(_this);
          res = fetch_3.send();
          res.catch(function(e) {
            return true;
          });
        }).catch(function(e) {
          return _this.dataManagerFailure(e, _this.fetchDeffered, {});
        });
      } else {
        this.fetchReqOption = res;
        fetchFunc.call(this, {
          data: res.data,
          onSuccess: this.successFunc.bind(this),
          onFailure: this.failureFunc.bind(this),
          changes
        });
      }
      return this.fetchDeffered.promise;
    };
    DataManager2.prototype.clearPersistence = function() {
      window.removeEventListener("unload", this.setPersistData.bind(this));
      this.dataSource.enablePersistence = false;
      this.persistQuery = {};
      window.localStorage.setItem(this.dataSource.id, "[]");
    };
    return DataManager2;
  })()
);
var Deferred = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Deferred2() {
      var _this = this;
      this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
      this.then = this.promise.then.bind(this.promise);
      this.catch = this.promise.catch.bind(this.promise);
    }
    return Deferred2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/maps.js
var __extends22 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Maps = (
  /** @class */
  (function(_super) {
    __extends22(Maps2, _super);
    function Maps2(options, element) {
      var _this = _super.call(this, options, element) || this;
      _this.isTileMap = false;
      _this.isResize = false;
      _this.isReset = false;
      _this.baseSize = new Size2(0, 0);
      _this.translatePoint = new Point(0, 0);
      _this.baseTranslatePoint = new Point(0, 0);
      _this.zoomTranslatePoint = new Point(0, 0);
      _this.markerZoomedState = true;
      _this.zoomPersistence = false;
      _this.defaultState = true;
      _this.centerPositionChanged = false;
      _this.markerNullCount = 0;
      _this.tileTranslatePoint = new Point(0, 0);
      _this.baseTileTranslatePoint = new Point(0, 0);
      _this.isDevice = false;
      _this.staticMapZoom = _this.zoomSettings.enable ? _this.zoomSettings.zoomFactor : 0;
      _this.zoomNotApplied = false;
      _this.dataLabelShape = [];
      _this.zoomShapeCollection = [];
      _this.zoomLabelPositions = [];
      _this.mouseDownEvent = { x: null, y: null };
      _this.mouseClickEvent = { x: null, y: null };
      _this.selectedElementId = [];
      _this.selectedMarkerElementId = [];
      _this.selectedBubbleElementId = [];
      _this.selectedNavigationElementId = [];
      _this.selectedPolygonElementId = [];
      _this.selectedLegendElementId = [];
      _this.legendSelectionCollection = [];
      _this.shapeSelections = true;
      _this.legendSelection = true;
      _this.toggledLegendId = [];
      _this.toggledElementId = [];
      _this.checkInitialRender = true;
      _this.initialTileTranslate = new Point(0, 0);
      _this.isMarkerZoomCompleted = false;
      _this.markerDragId = "";
      _this.initialCheck = true;
      _this.applyZoomReset = false;
      _this.markerClusterExpandCheck = false;
      _this.markerClusterExpand = false;
      _this.mouseMoveId = "";
      _this.shapeSelectionItem = [];
      _this.markerDragArgument = null;
      setValue("mergePersistData", _this.mergePersistMapsData, _this);
      return _this;
    }
    Object.defineProperty(Maps2.prototype, "isShapeSelected", {
      /**
       *
       * Specifies whether the shape is selected in the maps or not.
       *
       * @returns {boolean} - Returns a boolean value to specify whether the shape is selected in the maps or not.
       */
      get: function() {
        return this.mapSelect;
      },
      enumerable: true,
      configurable: true
    });
    Maps2.prototype.mergePersistMapsData = function() {
      var data;
      var windowData;
      try {
        windowData = window.localStorage;
      } catch (e) {
        windowData = null;
      }
      if (!isNullOrUndefined(windowData)) {
        data = window.localStorage.getItem(this.getModuleName() + this.element.id);
      }
      if (!(isNullOrUndefined(data) || data === "")) {
        var dataObj = JSON.parse(data);
        var keys2 = Object.keys(dataObj);
        this.isProtectedOnChange = true;
        for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          if (typeof this[key] === "object" && !isNullOrUndefined(this[key])) {
            extend(this[key], dataObj[key]);
          } else {
            this[key] = dataObj[key];
          }
        }
        this.isProtectedOnChange = false;
      }
    };
    Maps2.prototype.getLocalizedLabel = function(key) {
      return this.localeObject.getConstant(key);
    };
    Maps2.prototype.preRender = function() {
      this.isDevice = Browser.isDevice;
      this.initPrivateVariable();
      this.allowServerDataBinding = false;
      this.unWireEVents();
      this.wireEVents();
      this.setCulture();
    };
    Maps2.prototype.renderElements = function() {
      if (!this.isDestroyed) {
        this.trigger(load, { maps: this });
        this.createSVG();
        this.findBaseAndSubLayers();
        if (!isNullOrUndefined(this.markerModule) && this.markerModule.getMapsInstance()) {
          this.markerModule.initializeMarkerClusterList();
        }
        this.createSecondaryElement();
        this.addTabIndex();
        this.themeStyle = getThemeStyle(this.theme);
        this.renderBorder();
        this.renderTitle(this.titleSettings, "title", null, null);
        this.renderArea();
        this.processRequestJsonData();
        this.renderComplete();
        this.isAddLayer = !this.isTileMap ? false : this.isAddLayer;
      }
    };
    Maps2.prototype.render = function() {
      this.renderElements();
    };
    Maps2.prototype.processRequestJsonData = function() {
      var _this = this;
      var length = this.layersCollection.length - 1;
      this.serverProcess = { request: 0, response: 0 };
      var queryModule;
      var dataModule;
      Array.prototype.forEach.call(this.layersCollection, function(layer, layerIndex) {
        if (layer.shapeData instanceof DataManager) {
          _this.serverProcess["request"]++;
          dataModule = layer.shapeData;
          queryModule = layer.query instanceof Query ? layer.query : new Query();
          var dataManager = dataModule.executeQuery(queryModule);
          dataManager.then(function(e) {
            _this.processResponseJsonData("DataManager", e, layer, "ShapeData");
          });
        } else if (layer.shapeData instanceof MapAjax || layer.shapeData) {
          if (!isNullOrUndefined(layer.shapeData["dataOptions"])) {
            _this.processAjaxRequest(layer, layer.shapeData, "ShapeData");
          }
        }
        if (layer.dataSource instanceof DataManager) {
          _this.serverProcess["request"]++;
          dataModule = layer.dataSource;
          queryModule = layer.query instanceof Query ? layer.query : new Query();
          var dataManager = dataModule.executeQuery(queryModule);
          dataManager.then(function(e) {
            layer.dataSource = processResult(e);
          });
        }
        if (layer.markerSettings.length > 0) {
          var _loop_1 = function(i2) {
            if (layer.markerSettings[i2].dataSource instanceof DataManager) {
              _this.serverProcess["request"]++;
              dataModule = layer.markerSettings[i2].dataSource;
              queryModule = layer.markerSettings[i2].query instanceof Query ? layer.markerSettings[i2].query : new Query();
              var dataManager2 = dataModule.executeQuery(queryModule);
              dataManager2.then(function(e) {
                layer.markerSettings[i2].dataSource = processResult(e);
              });
            }
          };
          for (var i = 0; i < layer.markerSettings.length; i++) {
            _loop_1(i);
          }
        }
        if (layer.bubbleSettings.length > 0) {
          var _loop_2 = function(i2) {
            if (layer.bubbleSettings[i2].dataSource instanceof DataManager) {
              _this.serverProcess["request"]++;
              dataModule = layer.bubbleSettings[i2].dataSource;
              queryModule = layer.bubbleSettings[i2].query instanceof Query ? layer.bubbleSettings[i2].query : new Query();
              var dataManager2 = dataModule.executeQuery(queryModule);
              dataManager2.then(function(e) {
                layer.bubbleSettings[i2].dataSource = processResult(e);
              });
            }
          };
          for (var i = 0; i < layer.bubbleSettings.length; i++) {
            _loop_2(i);
          }
        }
        if (layer.dataSource instanceof MapAjax || !isNullOrUndefined(layer.dataSource) && !isNullOrUndefined(layer.dataSource["dataOptions"])) {
          _this.processAjaxRequest(layer, layer.dataSource, "DataSource");
        }
        if (_this.serverProcess["request"] === _this.serverProcess["response"] && length === layerIndex) {
          _this.processResponseJsonData(null);
        }
      });
    };
    Maps2.prototype.processAjaxRequest = function(layer, localAjax, type) {
      var _this = this;
      this.serverProcess["request"]++;
      var fetchApiModule = new Fetch(localAjax.dataOptions, localAjax.type, localAjax.contentType);
      fetchApiModule.onSuccess = function(args) {
        if (!isNullOrUndefined(args.type) && args.type === "application/octet-stream") {
          var reader_1 = new FileReader();
          var map_1 = _this;
          reader_1.onload = function() {
            args = JSON.parse(reader_1.result.toString());
            map_1.processResponseJsonData("Fetch", args, layer, type);
          };
          reader_1.readAsText(args);
        } else {
          _this.processResponseJsonData("Fetch", args, layer, type);
        }
      };
      fetchApiModule.send(localAjax.sendData);
    };
    Maps2.prototype.processResponseJsonData = function(processType, data, layer, dataType) {
      this.serverProcess["response"]++;
      if (processType) {
        if (dataType === "ShapeData") {
          layer.shapeData = processType === "DataManager" ? processResult(data) : data;
        } else {
          layer.dataSource = processType === "DataManager" ? processResult(data) : data;
        }
      }
      if (!isNullOrUndefined(processType) && this.serverProcess["request"] === this.serverProcess["response"]) {
        var collection = this.layersCollection;
        this.layersCollection = [];
        for (var i = 0; i < collection.length; i++) {
          if (collection[i].isBaseLayer) {
            this.layersCollection.push(collection[i]);
          }
        }
        for (var j = 0; j < collection.length; j++) {
          if (!collection[j].isBaseLayer) {
            this.layersCollection.push(collection[j]);
          }
        }
        this.renderMap();
      } else if (isNullOrUndefined(processType)) {
        this.renderMap();
      }
    };
    Maps2.prototype.renderMap = function() {
      if (this.legendModule && this.legendSettings.visible) {
        this.legendModule.renderLegend();
      }
      this.createTile();
      if (this.zoomSettings.enable && this.zoomModule) {
        this.zoomModule.createZoomingToolbars();
      }
      if (!isNullOrUndefined(this.dataLabelModule)) {
        this.dataLabelModule.dataLabelCollections = [];
      }
      this.mapLayerPanel.measureLayerPanel();
      if (!isNullOrUndefined(this.svgObject)) {
        this.element.appendChild(this.svgObject);
      }
      this.setSecondaryElementPosition();
      for (var i = 0; i < this.layers.length; i++) {
        if (this.layers[i].selectionSettings && this.layers[i].selectionSettings.enable && this.layers[i].initialShapeSelection.length > 0 && this.checkInitialRender) {
          var checkSelection = this.layers[i].selectionSettings.enableMultiSelect;
          this.layers[i].selectionSettings.enableMultiSelect = checkSelection ? checkSelection : true;
          var shapeSelection = this.layers[i].initialShapeSelection;
          for (var j = 0; j < this.layers[i].initialShapeSelection.length; j++) {
            this.shapeSelection(i, shapeSelection[j].shapePath, shapeSelection[j].shapeValue, true);
          }
          this.layers[i].selectionSettings.enableMultiSelect = checkSelection;
          if (i === this.layers.length - 1) {
            this.checkInitialRender = false;
          }
        }
        if (!this.isResize) {
          for (var k = 0; k < this.layers[i].markerSettings.length; k++) {
            if (this.layers[i].markerSettings[k].selectionSettings && this.layers[i].markerSettings[k].selectionSettings.enable && this.layers[i].markerSettings[k].initialMarkerSelection.length > 0) {
              var markerSelectionValues = this.layers[i].markerSettings[k].initialMarkerSelection;
              for (var j = 0; j < markerSelectionValues.length; j++) {
                this.markerInitialSelection(i, k, this.layers[i].markerSettings[k], markerSelectionValues[j].latitude, markerSelectionValues[j].longitude);
              }
            }
          }
        }
      }
      if (!isNullOrUndefined(document.getElementById(this.element.id + "_tile_parent"))) {
        var svg = this.svgObject.getBoundingClientRect();
        var element = document.getElementById(this.element.id);
        var tileElement = document.getElementById(this.element.id + "_tile_parent");
        var tileElement1 = document.getElementById(this.element.id + "_tiles");
        var tile = tileElement.getBoundingClientRect();
        var top_1;
        var left = void 0;
        left = parseFloat(tileElement.style.left);
        var bottom = svg.bottom - tile.bottom - element.offsetTop;
        top_1 = parseFloat(tileElement.style.top);
        top_1 = bottom <= 11 ? top_1 : !isNullOrUndefined(this.legendModule) && this.legendSettings.position === "Bottom" ? this.mapAreaRect.y : top_1 * 2;
        left = bottom <= 11 ? left : !isNullOrUndefined(this.legendModule) ? left : left * 2;
        tileElement.style.top = top_1 + "px";
        tileElement.style.left = left + "px";
        tileElement1.style.top = top_1 + "px";
        tileElement1.style.left = left + "px";
        if (!isNullOrUndefined(this.legendModule) && this.legendModule.totalPages.length > 0) {
          tileElement.style.height = tileElement1.style.height = this.legendModule.legendTotalRect.height + "px";
          tileElement.style.width = tileElement1.style.width = this.legendModule.legendTotalRect.width + "px";
        }
      }
      this.arrangeTemplate();
      if (this.annotationsModule) {
        if (this.width !== "0px" && this.height !== "0px" && this.width !== "0%" && this.height !== "0%") {
          this.annotationsModule.renderAnnotationElements();
        }
      }
      this.element.style.outline = "none";
      this.element.style.position = "relative";
      for (var i = 0; i < document.getElementsByTagName("path").length - 1; i++) {
        if (document.getElementsByTagName("path")[i].id.indexOf("shapeIndex") > -1) {
          document.getElementsByTagName("path")[i].style.outline = "none";
        }
      }
      this.zoomingChange();
      if (this.zoomModule && this.isDevice) {
        this.zoomModule.removeToolbarOpacity(this.isTileMap ? Math.round(this.tileZoomLevel) : this.mapScaleValue, this.element.id + "_Zooming_");
      }
      if (!this.isZoomByPosition && !this.zoomNotApplied) {
        this.triggerZoomEvent();
      }
      this.isResize = false;
    };
    Maps2.prototype.triggerZoomEvent = function() {
      var loadedArgs;
      var minMaxLatitudeLongitude = this.getMinMaxLatitudeLongitude();
      loadedArgs = {
        maps: this,
        isResized: this.isResize,
        minLatitude: minMaxLatitudeLongitude.minLatitude,
        maxLatitude: minMaxLatitudeLongitude.maxLatitude,
        minLongitude: minMaxLatitudeLongitude.minLongitude,
        maxLongitude: minMaxLatitudeLongitude.maxLongitude,
        cancel: false,
        name: "Loaded"
      };
      this.trigger("loaded", loadedArgs);
    };
    Maps2.prototype.markerSelection = function(selectionSettings, map, targetElement, data) {
      var border = {
        color: selectionSettings.border.color,
        width: selectionSettings.border.width / map.scale,
        opacity: selectionSettings.border.opacity
      };
      var markerSelectionProperties = {
        opacity: selectionSettings.opacity,
        fill: selectionSettings.fill,
        border,
        target: targetElement.id,
        cancel: false,
        data,
        maps: map
      };
      if (!getElement2("MarkerselectionMap")) {
        document.body.appendChild(createStyle("MarkerselectionMap", "MarkerselectionMapStyle", markerSelectionProperties));
      } else {
        customizeStyle("MarkerselectionMap", "MarkerselectionMapStyle", markerSelectionProperties);
      }
      if (this.selectedMarkerElementId.length === 0 || selectionSettings.enableMultiSelect) {
        if (targetElement.tagName === "g") {
          targetElement.children[0].setAttribute("class", "MarkerselectionMapStyle");
          this.selectedMarkerElementId.push(targetElement.children[0].id);
        } else {
          targetElement.setAttribute("class", "MarkerselectionMapStyle");
          this.selectedMarkerElementId.push(targetElement.id);
        }
      }
    };
    Maps2.prototype.markerInitialSelection = function(layerIndex, markerIndex, markerSettings, latitude, longitude) {
      var selectionSettings = markerSettings.selectionSettings;
      if (selectionSettings.enable) {
        for (var i = 0; i < markerSettings.dataSource["length"]; i++) {
          var data = markerSettings.dataSource[i];
          if (data["latitude"] === latitude && data["longitude"] === longitude) {
            var targetId = this.element.id + "_LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex + "_dataIndex_" + i;
            this.markerSelection(selectionSettings, this, getElement2(targetId), data);
          }
        }
      }
    };
    Maps2.prototype.renderArea = function() {
      var width = this.mapsArea.border.width;
      var background = this.mapsArea.background;
      if (width > 0 || (background || this.themeStyle.areaBackgroundColor)) {
        var mapBorder = {
          opacity: isNullOrUndefined(this.mapsArea.border.opacity) ? 1 : this.mapsArea.border.opacity,
          color: this.mapsArea.border.color,
          width: this.mapsArea.border.width
        };
        var rect = new RectOption(this.element.id + "_MapAreaBorder", background || this.themeStyle.areaBackgroundColor, mapBorder, 1, this.mapAreaRect);
        this.svgObject.appendChild(this.renderer.drawRectangle(rect));
      }
    };
    Maps2.prototype.addTabIndex = function() {
      this.element.setAttribute("aria-label", this.description || "Maps Element");
      this.element.setAttribute("role", "region");
      this.element.tabIndex = this.tabIndex;
    };
    Maps2.prototype.setSecondaryElementPosition = function() {
      var element = getElementByID(this.element.id + "_Secondary_Element");
      var rect = this.element.getBoundingClientRect();
      var svgElement = getElementByID(this.element.id + "_svg");
      if (!isNullOrUndefined(svgElement)) {
        var svgRect = svgElement.getBoundingClientRect();
        element.style.left = Math.max(svgRect.left - rect.left, 0) + "px";
        element.style.top = Math.max(svgRect.top - rect.top, 0) + "px";
      }
    };
    Maps2.prototype.zoomingChange = function() {
      var left;
      var top;
      if (getElementByID(this.element.id + "_Layer_Collections") && this.zoomModule) {
        this.zoomModule.layerCollectionEle = getElementByID(this.element.id + "_Layer_Collections");
      }
      if (this.isTileMap && getElementByID(this.element.id + "_Tile_SVG") && getElementByID(this.element.id + "_tile_parent")) {
        var tileElement = getElementByID(this.element.id + "_tile_parent");
        var tileSvgElement = getElementByID(this.element.id + "_Tile_SVG");
        var tileSvgParentElement = getElementByID(this.element.id + "_Tile_SVG_Parent");
        var tileRect = tileElement.getBoundingClientRect();
        var tileSvgRect = tileSvgElement.getBoundingClientRect();
        left = tileRect.left - tileSvgRect.left;
        top = tileRect.top - tileSvgRect.top;
        tileSvgParentElement.style.left = left + "px";
        tileSvgParentElement.style.top = top + "px";
        if (!isNullOrUndefined(this.legendModule) && this.legendModule.totalPages.length > 0) {
          tileElement.style.width = tileSvgElement.style.width = this.legendModule.legendTotalRect.width.toString();
          tileElement.style.height = tileSvgElement.style.height = this.legendModule.legendTotalRect.height.toString();
          tileSvgParentElement.style.width = this.legendModule.legendTotalRect.width + "px";
          tileSvgParentElement.style.height = this.legendModule.legendTotalRect.height + "px";
        }
        var markerTemplateElements = document.getElementsByClassName("template");
        if (!isNullOrUndefined(markerTemplateElements) && markerTemplateElements.length > 0) {
          for (var i = 0; i < markerTemplateElements.length; i++) {
            var templateGroupEle = markerTemplateElements[i];
            templateGroupEle.style.left = left + "px";
            templateGroupEle.style.top = top + "px";
          }
        }
      }
      if (this.zoomSettings.zoomFactor >= 0) {
        if (this.zoomModule && this.zoomModule.toolBarGroup && this.zoomSettings.enable) {
          this.zoomModule.alignToolBar();
        }
        var elements = document.getElementById(this.element.id + "_Layer_Collections");
        if (!isNullOrUndefined(elements) && elements.childElementCount > 0) {
          for (var i = 0; i < elements.childNodes.length; i++) {
            var childElement = elements.childNodes[i];
            if (childElement.tagName === "g" && childElement.id.indexOf("_Legend_Group") === -1) {
              var layerIndex = parseFloat(childElement.id.split("_LayerIndex_")[1].split("_")[0]);
              for (var j = 0; j < childElement.childNodes.length; j++) {
                var childNode = childElement.childNodes[j];
                if (!(childNode.id.indexOf("_Markers_Group") > -1) && !(childNode.id.indexOf("_bubble_Group") > -1) && !(childNode.id.indexOf("_dataLableIndex_Group") > -1)) {
                  changeBorderWidth(childNode, layerIndex, this.scale, this);
                }
              }
            }
          }
        }
        if (this.zoomModule && (this.previousScale !== this.scale || this.zoomNotApplied || this.isZoomByPosition)) {
          this.zoomModule.applyTransform(this, false, true);
        }
      }
    };
    Maps2.prototype.createSecondaryElement = function() {
      if (isNullOrUndefined(document.getElementById(this.element.id + "_Secondary_Element"))) {
        var secondaryElement = createElement("div", {
          id: this.element.id + "_Secondary_Element"
        });
        secondaryElement.style.cssText = "position: relative;z-index:2;";
        this.element.appendChild(secondaryElement);
      }
    };
    Maps2.prototype.getMinMaxLatitudeLongitude = function() {
      var mapsElement = document.getElementById(this.element.id);
      if (!isNullOrUndefined(mapsElement)) {
        var element = mapsElement.getBoundingClientRect();
        var marginLeft = getProcessedMarginValue(this.margin.left);
        var minPosition = this.isTileMap ? this.pointToLatLong(this.mapAreaRect.x - marginLeft, -this.mapAreaRect.y) : this.getGeoLocation(0, this.mapAreaRect.x + element.left, this.mapAreaRect.y);
        var maxPosition = this.isTileMap ? this.pointToLatLong(this.mapAreaRect.width, this.mapAreaRect.height - this.mapAreaRect.y) : this.getGeoLocation(0, this.mapAreaRect.x + element.left + this.mapAreaRect.width, this.mapAreaRect.y + this.mapAreaRect.height);
        var MinMaxLatitudeLongitude = {
          minLatitude: minPosition.latitude,
          maxLatitude: maxPosition.latitude,
          minLongitude: minPosition.longitude,
          maxLongitude: maxPosition.longitude
        };
        return MinMaxLatitudeLongitude;
      } else {
        return {
          minLatitude: 0,
          maxLatitude: 0,
          minLongitude: 0,
          maxLongitude: 0
        };
      }
    };
    Maps2.prototype.arrangeTemplate = function() {
      var _this = this;
      if (document.getElementById(this.element.id + "_Legend_Border")) {
        document.getElementById(this.element.id + "_Legend_Border").style.pointerEvents = "none";
      }
      var templateElements = document.getElementsByClassName(this.element.id + "_template");
      if (!isNullOrUndefined(templateElements) && templateElements.length > 0 && getElementByID(this.element.id + "_Layer_Collections") && !this.isTileMap) {
        Array.prototype.forEach.call(templateElements, function(templateGroupEle) {
          var offSetLetValue = 0;
          var offSetTopValue = 0;
          if (!isNullOrUndefined(templateGroupEle) && templateGroupEle.childElementCount > 0) {
            var layerOffset = getElementByID(_this.element.id + "_Layer_Collections").getBoundingClientRect();
            var elementOffset = getElementByID(templateGroupEle.id).getBoundingClientRect();
            if (templateGroupEle.id.indexOf("Marker") === -1) {
              offSetLetValue = _this.isTileMap ? 0 : layerOffset.left < elementOffset.left ? -Math.abs(elementOffset.left - layerOffset.left) : Math.abs(elementOffset.left - layerOffset.left);
              offSetTopValue = _this.isTileMap ? 0 : layerOffset.top < elementOffset.top ? -Math.abs(elementOffset.top - layerOffset.top) : Math.abs(elementOffset.top - layerOffset.top);
            }
            Array.prototype.forEach.call(templateGroupEle.childNodes, function(currentTemplate) {
              if (currentTemplate.id.indexOf("Marker") === -1) {
                currentTemplate.style.left = parseFloat(currentTemplate.style.left) + offSetLetValue + "px";
                currentTemplate.style.top = parseFloat(currentTemplate.style.top) + offSetTopValue + "px";
                currentTemplate.style.transform = "translate(-50%, -50%)";
              }
            });
          }
        });
      }
    };
    Maps2.prototype.createTile = function() {
      var mainLayer = this.layersCollection[0];
      var padding = 0;
      if (mainLayer.isBaseLayer && (!isNullOrUndefined(mainLayer.urlTemplate) && mainLayer.urlTemplate !== "" && isNullOrUndefined(mainLayer.shapeData))) {
        removeElement2(this.element.id + "_tile_parent");
        removeElement2(this.element.id + "_tiles");
        removeElement2("animated_tiles");
        var ele = createElement("div", {
          id: this.element.id + "_tile_parent"
        });
        var marginRight = getProcessedMarginValue(this.margin.right);
        ele.style.cssText = "position: absolute; left: " + this.mapAreaRect.x + "px; right: " + marginRight + "px; top: " + (this.mapAreaRect.y + padding) + "px; height: " + this.mapAreaRect.height + "px; width: " + this.mapAreaRect.width + "px; overflow: hidden;";
        var ele1 = createElement("div", {
          id: this.element.id + "_tiles"
        });
        ele1.style.cssText = "position: absolute; left: " + this.mapAreaRect.x + "px;  right: " + marginRight + "px; top: " + (this.mapAreaRect.y + padding) + "px; height: " + this.mapAreaRect.height + "px; width: " + this.mapAreaRect.width + "px; overflow: hidden;";
        this.element.appendChild(ele);
        this.element.appendChild(ele1);
      }
    };
    Maps2.prototype.initPrivateVariable = function() {
      if (this.element.id === "") {
        var collection = document.getElementsByClassName("e-maps").length;
        this.element.id = "maps_control_" + collection;
      }
      this.renderer = new SvgRenderer(this.element.id);
      this.mapLayerPanel = new LayerPanel(this);
    };
    Maps2.prototype.findBaseAndSubLayers = function() {
      var _this = this;
      var baseIndex = this.baseLayerIndex;
      var mainLayers = [];
      var subLayers = [];
      this.layersCollection = [];
      Array.prototype.forEach.call(this.layers, function(layer) {
        layer.type === "Layer" ? mainLayers.push(layer) : subLayers.push(layer);
      });
      for (var i = 0; i < mainLayers.length; i++) {
        var baseLayer = mainLayers[i];
        if (baseLayer.visible && baseIndex === i) {
          baseLayer.isBaseLayer = true;
          this.isTileMap = !isNullOrUndefined(baseLayer.shapeData) ? false : true;
          this.layersCollection.push(baseLayer);
          break;
        } else if (i === mainLayers.length - 1) {
          this.layersCollection.push(mainLayers[0]);
          break;
        }
      }
      subLayers.map(function(subLayer) {
        if (subLayer.visible) {
          _this.layersCollection.push(subLayer);
        }
      });
    };
    Maps2.prototype.renderBorder = function() {
      var width = this.border.width;
      var borderElement = this.svgObject.querySelector("#" + this.element.id + "_MapBorder");
      if ((width > 0 || (this.background || this.themeStyle.backgroundColor)) && isNullOrUndefined(borderElement)) {
        var border = {
          opacity: isNullOrUndefined(this.border.opacity) ? 1 : this.border.opacity,
          color: this.border.color,
          width: this.border.width
        };
        var borderRect = new RectOption(this.element.id + "_MapBorder", this.background || this.themeStyle.backgroundColor, border, 1, new Rect2(width / 2, width / 2, this.availableSize.width - width, this.availableSize.height - width));
        this.svgObject.appendChild(this.renderer.drawRectangle(borderRect));
      } else {
        borderElement.setAttribute("fill", this.background || this.themeStyle.backgroundColor);
      }
    };
    Maps2.prototype.renderTitle = function(title, type, bounds, groupEle) {
      var style = {
        size: title.textStyle.size,
        color: title.textStyle.color,
        fontFamily: title.textStyle.fontFamily,
        fontWeight: title.textStyle.fontWeight,
        fontStyle: title.textStyle.fontStyle,
        opacity: title.textStyle.opacity
      };
      var height;
      var marginTop = getProcessedMarginValue(this.margin.top);
      var marginBottom = getProcessedMarginValue(this.margin.bottom);
      var marginLeft = getProcessedMarginValue(this.margin.left);
      var marginRight = getProcessedMarginValue(this.margin.right);
      var width = Math.abs(marginLeft + marginRight - this.availableSize.width);
      style.fontFamily = !isNullOrUndefined(style.fontFamily) ? style.fontFamily : this.themeStyle.fontFamily;
      style.fontWeight = type === "title" ? style.fontWeight || this.themeStyle.titleFontWeight : style.fontWeight || this.themeStyle.titleFontWeight;
      style.size = type === "title" ? style.size || this.themeStyle.titleFontSize : style.size || this.themeStyle.subTitleFontSize || Theme.mapsSubTitleFont.size;
      if (title.text) {
        if (isNullOrUndefined(groupEle)) {
          groupEle = this.renderer.createGroup({ id: this.element.id + "_Title_Group" });
        }
        var trimmedTitle = textTrim(width, title.text, style);
        var elementSize = measureText2(trimmedTitle, style);
        var rect = isNullOrUndefined(bounds) ? new Rect2(marginLeft, marginTop, this.availableSize.width, this.availableSize.height) : bounds;
        var location_1 = findPosition(rect, !isNullOrUndefined(title.alignment) ? title.alignment : "Center", elementSize, type);
        var options = new TextOption2(this.element.id + "_Map_" + type, location_1.x, location_1.y, "start", trimmedTitle);
        var titleBounds = new Rect2(location_1.x, location_1.y, elementSize.width, elementSize.height);
        var element = renderTextElement(options, style, style.color || (type === "title" ? this.themeStyle.titleFontColor : this.themeStyle.subTitleFontColor), groupEle);
        element.setAttribute("aria-label", title.text);
        element.setAttribute("role", "region");
        if (type === "title" && !title.subtitleSettings.text || type === "subtitle") {
          height = Math.abs(titleBounds.y + marginBottom - this.availableSize.height);
          this.mapAreaRect = new Rect2(marginLeft, titleBounds.y + 10, width, height - 10);
        }
        if (type !== "subtitle" && title.subtitleSettings.text) {
          this.renderTitle(title.subtitleSettings, "subtitle", titleBounds, groupEle);
        } else {
          this.svgObject.appendChild(groupEle);
        }
      } else {
        height = Math.abs(marginTop + marginBottom - this.availableSize.height);
        this.mapAreaRect = new Rect2(marginLeft, marginTop, width, height);
      }
    };
    Maps2.prototype.createSVG = function() {
      this.removeSvg();
      createSvg(this);
    };
    Maps2.prototype.removeSvg = function() {
      removeElement2(this.element.id + "_Secondary_Element");
      removeElement2(this.element.id + "_tile_parent");
      removeElement2(this.element.id + "_tiles");
      if (this.svgObject) {
        while (this.svgObject.childNodes.length > 0) {
          this.svgObject.removeChild(this.svgObject.firstChild);
        }
        if (!this.svgObject.hasChildNodes() && this.svgObject.parentNode) {
          remove(this.svgObject);
        }
      }
      this.clearTemplate();
    };
    Maps2.prototype.wireEVents = function() {
      EventHandler.add(this.element, "click", this.mapsOnClick, this);
      EventHandler.add(this.element, "contextmenu", this.mapsOnRightClick, this);
      EventHandler.add(this.element, "dblclick", this.mapsOnDoubleClick, this);
      EventHandler.add(this.element, Browser.touchStartEvent, this.mouseDownOnMap, this);
      EventHandler.add(this.element, Browser.touchMoveEvent, this.mouseMoveOnMap, this);
      EventHandler.add(this.element, Browser.touchEndEvent, this.mouseEndOnMap, this);
      EventHandler.add(this.element, "pointerleave mouseleave", this.mouseLeaveOnMap, this);
      EventHandler.add(this.element, "keydown", this.keyDownHandler, this);
      EventHandler.add(this.element, "keyup", this.keyUpHandler, this);
      this.resizeEvent = this.mapsOnResize.bind(this);
      window.addEventListener(Browser.isTouch && ("orientation" in window && "onorientationchange" in window) ? "orientationchange" : "resize", this.resizeEvent);
    };
    Maps2.prototype.unWireEVents = function() {
      EventHandler.remove(this.element, "click", this.mapsOnClick);
      EventHandler.remove(this.element, "contextmenu", this.mapsOnRightClick);
      EventHandler.remove(this.element, "dblclick", this.mapsOnDoubleClick);
      EventHandler.remove(this.element, Browser.touchStartEvent, this.mouseDownOnMap);
      EventHandler.remove(this.element, Browser.touchMoveEvent, this.mouseMoveOnMap);
      EventHandler.remove(this.element, Browser.touchEndEvent, this.mouseEndOnMap);
      EventHandler.remove(this.element, "pointerleave mouseleave", this.mouseLeaveOnMap);
      EventHandler.remove(this.element, "keydown", this.keyDownHandler);
      EventHandler.remove(this.element, "keyup", this.keyUpHandler);
      window.removeEventListener(Browser.isTouch && ("orientation" in window && "onorientationchange" in window) ? "orientationchange" : "resize", this.resizeEvent);
    };
    Maps2.prototype.mouseLeaveOnMap = function(e) {
      if (document.getElementsByClassName("highlightMapStyle").length > 0 && this.legendModule) {
        this.legendModule.removeShapeHighlightCollection();
        removeClass2(document.getElementsByClassName("highlightMapStyle")[0]);
      }
    };
    Maps2.prototype.keyUpHandler = function(event) {
      var id = event.target["id"];
      if (this.isTileMap) {
        this.removeTileMap();
      }
      if (event.code === "Tab" && id.indexOf("_LayerIndex_") > -1 && id.indexOf("shapeIndex") > -1) {
        this.keyboardHighlightSelection(id, event);
      } else if (id.indexOf("_LayerIndex_") === -1 && id.indexOf("shapeIndex") === -1 && getElementsByClassName("highlightMapStyle").length > 0) {
        removeClass2(getElementsByClassName("highlightMapStyle")[0]);
        if (this.legendSettings.visible && this.legendModule) {
          this.legendModule.removeShapeHighlightCollection();
        }
      }
    };
    Maps2.prototype.keyboardHighlightSelection = function(id, event) {
      var key = event.type;
      var layerIndex = parseInt(id.split("_LayerIndex_")[1].split("_")[0], 10);
      var shapeIndex = parseInt(id.split("_shapeIndex_")[1].split("_")[0], 10);
      var shapeData = this.layers[layerIndex].shapeData["features"]["length"] > shapeIndex ? this.layers[layerIndex].shapeData["features"][shapeIndex]["properties"] : null;
      var dataIndex = parseInt(id.split("_dataIndex_")[1].split("_")[0], 10);
      var data = isNullOrUndefined(dataIndex) ? null : this.layers[layerIndex].dataSource[dataIndex];
      if (this.layers[layerIndex].selectionSettings.enable && key === "keydown" && this.selectionModule) {
        this.selectionModule.selectionsettings = this.layers[layerIndex].selectionSettings;
        this.selectionModule.selectionType = "Shape";
        this.selectionModule.selectElement(event.target, layerIndex, data, shapeData);
      } else if (this.highlightModule && (this.layers[layerIndex].highlightSettings.enable && key === "keyup" && !event.target.classList.contains("ShapeselectionMapStyle"))) {
        this.highlightModule.highlightSettings = this.layers[layerIndex].highlightSettings;
        this.highlightModule.handleHighlight(event.target, layerIndex, data, shapeData);
      }
    };
    Maps2.prototype.keyDownHandler = function(event) {
      var zoom = this.zoomModule;
      var id = event.target["id"];
      if ((event.code === "ArrowUp" || event.code === "ArrowDown" || event.code === "ArrowLeft" || event.code === "ArrowRight") && zoom) {
        var animatedTiles = document.getElementById(this.element.id + "_animated_tiles");
        if (this.isTileMap && !isNullOrUndefined(animatedTiles)) {
          this.currentTiles = animatedTiles.cloneNode(true);
        }
      }
      if (this.zoomSettings.enable && zoom && (event.key === "+" || event.code === "Equal")) {
        zoom.performZoomingByToolBar("zoomin");
      } else if (this.zoomSettings.enable && zoom && (event.key === "-" || event.code === "Minus")) {
        zoom.performZoomingByToolBar("zoomout");
      } else if (this.zoomSettings.enable && zoom && event["keyCode"] === 82) {
        zoom.performZoomingByToolBar("reset");
        zoom.isPanModeEnabled = false;
      } else if (this.zoomSettings.enable && this.zoomSettings.enablePanning && zoom && (event.code === "ArrowUp" || event.code === "ArrowDown")) {
        event.preventDefault();
        zoom.mouseDownLatLong["x"] = 0;
        zoom.mouseMoveLatLong["y"] = this.mapAreaRect.height / 7;
        zoom.panning("None", zoom.mouseDownLatLong["x"], event.code === "ArrowUp" ? -zoom.mouseMoveLatLong["y"] : zoom.mouseMoveLatLong["y"], event);
        zoom.mouseDownLatLong["y"] = zoom.mouseMoveLatLong["y"];
      } else if (this.zoomSettings.enable && this.zoomSettings.enablePanning && zoom && (event.code === "ArrowLeft" || event.code === "ArrowRight")) {
        event.preventDefault();
        zoom.mouseDownLatLong["y"] = 0;
        zoom.mouseMoveLatLong["x"] = this.mapAreaRect.width / 7;
        zoom.panning("None", event.code === "ArrowLeft" ? -zoom.mouseMoveLatLong["x"] : zoom.mouseMoveLatLong["x"], zoom.mouseDownLatLong["y"], event);
        zoom.mouseDownLatLong["x"] = zoom.mouseMoveLatLong["x"];
      } else if (event.code === "Enter") {
        id = event.target["id"];
        event.preventDefault();
        if (this.legendModule && (id.indexOf("_Left_Page_Rect") > -1 || id.indexOf("_Right_Page_Rect") > -1)) {
          this.mapAreaRect = this.legendModule.initialMapAreaRect;
          this.legendModule.currentPage = id.indexOf("_Left_Page_") > -1 ? this.legendModule.currentPage - 1 : this.legendModule.currentPage + 1;
          this.legendModule.legendGroup = this.renderer.createGroup({ id: this.element.id + "_Legend_Group" });
          this.legendModule.drawLegendItem(this.legendModule.currentPage);
          var textContent = document.getElementById(this.element.id + "_Paging_Text").textContent;
          var text = textContent.split("/").map(Number);
          if (id.indexOf("_Left_Page_Rect") > -1) {
            if (text[0] !== 1) {
              event.target.focus();
            }
            event.target.style.outlineColor = text[0] - 1 !== text[1] ? "" : "transparent";
          } else if (id.indexOf("_Right_Page_Rect") > -1) {
            if (text[0] !== text[1]) {
              event.target.focus();
            }
            event.target.style.outlineColor = text[0] !== text[1] + 1 ? "" : "transparent";
          }
          if (querySelector(this.element.id + "_Legend_Border", this.element.id)) {
            querySelector(this.element.id + "_Legend_Border", this.element.id).style.pointerEvents = "none";
          }
        }
        if (id.indexOf("shapeIndex") > -1) {
          this.keyboardHighlightSelection(id, event);
        }
      }
      if (this.zoomModule) {
        this.zoomModule.removeToolbarOpacity(this.isTileMap ? Math.round(this.tileZoomLevel) : this.mapScaleValue, this.mouseMoveId);
      }
    };
    Maps2.prototype.SelectedElement = function(targetEle) {
      var isSelect = false;
      if (targetEle.getAttribute("class") === "ShapeselectionMapStyle") {
        isSelect = true;
      }
      return isSelect;
    };
    Maps2.prototype.mapsOnClick = function(e) {
      var _this = this;
      var targetEle = e.target;
      var targetId = targetEle.id;
      var latitude = null;
      var longitude = null;
      this.mouseClickEvent = { x: e.x, y: e.y };
      if (targetEle.id.indexOf("_ToolBar") === -1) {
        var latLongValue = this.getClickLocation(targetId, e.pageX, e.pageY, targetEle, e["layerX"], e["layerY"]);
        if (!isNullOrUndefined(latLongValue)) {
          latitude = latLongValue.latitude;
          longitude = latLongValue.longitude;
        }
        var eventArgs_1 = {
          cancel: false,
          name: click,
          target: targetId,
          x: e.clientX,
          y: e.clientY,
          latitude,
          longitude,
          isShapeSelected: this.SelectedElement(targetEle)
        };
        if (this.onclick) {
          eventArgs_1.name = onclick;
          this.trigger("onclick", eventArgs_1, function(mouseArgs) {
            _this.clickHandler(e, eventArgs_1, targetEle);
          });
        } else {
          this.trigger("click", eventArgs_1, function(mouseArgs) {
            _this.clickHandler(e, eventArgs_1, targetEle);
          });
        }
      }
      if (this.zoomModule) {
        this.zoomModule.removeToolbarOpacity(this.isTileMap ? Math.round(this.tileZoomLevel) : this.mapScaleValue, targetId);
        if (this.isDevice) {
          this.zoomModule.removeToolbarClass("", "", "", "", "");
        }
      }
    };
    Maps2.prototype.clickHandler = function(e, eventArgs, targetEle) {
      if (targetEle.id.indexOf("shapeIndex") > -1) {
        this.mergeCluster();
        if (getElement2(this.element.id + "_mapsTooltip") && this.mapsTooltipModule.tooltipTargetID.indexOf("_MarkerIndex_") > -1) {
          removeElement2(this.element.id + "_mapsTooltip");
        }
      }
      if (this.markerModule) {
        this.markerModule.markerClusterClick(e);
      }
      if (!eventArgs.cancel) {
        this.notify(click, targetEle);
      }
      if (!eventArgs.cancel && targetEle.id.indexOf("shapeIndex") !== -1) {
        this.triggerShapeSelection(targetEle);
      }
    };
    Maps2.prototype.triggerShapeSelection = function(targetEle) {
      var layerIndex = parseInt(targetEle.id.split("_LayerIndex_")[1].split("_")[0], 10);
      var shapeSelectedEventArgs = triggerShapeEvent(targetEle.id, this.layers[layerIndex].selectionSettings, this, shapeSelected);
      if (!shapeSelectedEventArgs.cancel && this.selectionModule && !isNullOrUndefined(this.shapeSelected)) {
        customizeStyle(this.selectionModule.selectionType + "selectionMap", this.selectionModule.selectionType + "selectionMapStyle", shapeSelectedEventArgs);
      } else if (shapeSelectedEventArgs.cancel && this.selectionModule && isNullOrUndefined(shapeSelectedEventArgs["data"])) {
        removeClass2(targetEle);
        this.selectionModule.removedSelectionList(targetEle);
      }
    };
    Maps2.prototype.getMarkerClickLocation = function(pageX, pageY, x, y, marker2, isDragEnd) {
      document.getElementById(this.element.id + "_svg").style.cursor = "grabbing";
      var targetElement = getElement2(marker2.targetId);
      var latLongValue = this.getClickLocation(marker2.targetId, pageX, pageY, targetElement, x, y);
      var location2 = this.isTileMap ? convertTileLatLongToPoint(new MapLocation(latLongValue.longitude, latLongValue.latitude), this.tileZoomLevel, this.tileTranslatePoint, true) : convertGeoToPoint(latLongValue.latitude, latLongValue.longitude, this.mapLayerPanel.currentFactor, this.layersCollection[marker2.layerIndex], this);
      var transPoint = this.translatePoint;
      var translateX = this.isTileMap ? location2.x : (location2.x + transPoint.x) * this.scale;
      var translateY = this.isTileMap ? location2.y : (location2.y + transPoint.y) * this.scale;
      if (this.markerDragArgument.shape !== "Balloon") {
        targetElement.setAttribute("transform", "translate( " + translateX + " " + translateY + " )");
      } else {
        targetElement.parentElement.setAttribute("transform", "translate( " + translateX + " " + translateY + " )");
      }
      if (isDragEnd) {
        var markerSettings = this.layers[marker2.layerIndex].markerSettings[marker2.markerIndex];
        latLongValue = this.getClickLocation(marker2.targetId, pageX - markerSettings.offset.x, pageY - markerSettings.offset.y, targetElement, x - markerSettings.offset.x, y - markerSettings.offset.y);
      }
      return latLongValue;
    };
    Maps2.prototype.getClickLocation = function(targetId, pageX, pageY, targetElement, x, y, type) {
      var layerIndex = 0;
      var latLongValue;
      if (targetId.indexOf("_LayerIndex_") !== -1 && !this.isTileMap && (!isNullOrUndefined(type) || parseInt(this.mouseDownEvent["x"], 10) === parseInt(this.mouseClickEvent["x"], 10) && parseInt(this.mouseDownEvent["y"], 10) === parseInt(this.mouseClickEvent["y"], 10))) {
        layerIndex = parseFloat(targetId.split("_LayerIndex_")[1].split("_")[0]);
        if (this.layers[layerIndex].geometryType === "Normal") {
          if (targetId.indexOf("_shapeIndex_") > -1) {
            var immediateParent = targetElement.parentElement;
            var parentElement = immediateParent.id.indexOf("_Point_Group") > -1 || immediateParent.id.indexOf("_LineString_Group") > -1 || immediateParent.id.indexOf("_MultiLineString_Group") > -1 || immediateParent.id.indexOf("_Polygon_Group") > -1 ? immediateParent.parentElement : immediateParent;
            var location_2 = getMousePosition(pageX, pageY, parentElement);
            var zoomScaleValue = this.mapLayerPanel.currentFactor * this.mapScaleValue;
            var minLongitude = Math.abs(-this.baseMapBounds.longitude.min * zoomScaleValue);
            var minLatitude = Math.abs(this.baseMapBounds.latitude.max * zoomScaleValue);
            latLongValue = {
              latitude: Math.abs(this.baseMapBounds.latitude.max - location_2.y / zoomScaleValue),
              longitude: Math.abs(location_2.x / zoomScaleValue + this.baseMapBounds.longitude.min)
            };
            if (this.baseMapBounds.longitude.min < 0 && minLongitude > location_2.x) {
              latLongValue.longitude = -latLongValue.longitude;
            }
            if (this.baseMapBounds.latitude.min < 0 && minLatitude > location_2.y) {
              latLongValue.latitude = -latLongValue.latitude;
            }
          } else if (targetId.indexOf("_MarkerIndex_") > -1 && this.markerModule && !this.markerDragArgument) {
            var markerIndex = parseInt(targetId.split("_MarkerIndex_")[1].split("_")[0], 10);
            var dataIndex = parseInt(targetId.split("_dataIndex_")[1].split("_")[0], 10);
            if (!isNaN(markerIndex) && !isNaN(dataIndex)) {
              var dataObject = this.layers[layerIndex].markerSettings[markerIndex].dataSource[dataIndex];
              latLongValue = { latitude: dataObject["latitude"], longitude: dataObject.longitude };
            } else {
              latLongValue = { latitude: null, longitude: null };
            }
          } else if (targetId.indexOf("_MarkerIndex_") > -1 && this.markerModule && this.markerDragArgument) {
            var element = document.getElementById(this.element.id + "_LayerIndex_" + this.markerDragArgument.layerIndex);
            var elementRect = element.getBoundingClientRect();
            var location_3 = new MapLocation(pageX > elementRect.left ? Math.abs(elementRect.left - pageX) : 0, pageY > elementRect.top ? Math.abs(elementRect.top - pageY) : 0);
            var minLongitude = Math.abs(-this.baseMapBounds.longitude.min * this.mapLayerPanel.currentFactor);
            var minLatitude = Math.abs(this.baseMapBounds.latitude.max * this.mapLayerPanel.currentFactor);
            latLongValue = {
              latitude: Math.abs(this.baseMapBounds.latitude.max - location_3.y / (this.mapLayerPanel.currentFactor * this.scale)),
              longitude: Math.abs(location_3.x / (this.mapLayerPanel.currentFactor * this.scale) + this.baseMapBounds.longitude.min)
            };
            if (this.baseMapBounds.longitude.min < 0 && minLongitude > location_3.x) {
              latLongValue.longitude = -latLongValue.longitude;
            }
            if (this.baseMapBounds.latitude.min < 0 && minLatitude > location_3.y) {
              latLongValue.latitude = -latLongValue.latitude;
            }
          } else {
            latLongValue = { latitude: null, longitude: null };
          }
        } else {
          latLongValue = this.getGeoLocation(layerIndex, pageX, pageY);
        }
      } else if (this.isTileMap && (!isNullOrUndefined(type) || parseInt(this.mouseDownEvent["x"], 10) === parseInt(this.mouseClickEvent["x"], 10) && parseInt(this.mouseDownEvent["y"], 10) === parseInt(this.mouseClickEvent["y"], 10))) {
        latLongValue = this.getTileGeoLocation(x, y);
      }
      return latLongValue;
    };
    Maps2.prototype.removeTileMap = function() {
      var animateElement = document.getElementById(this.element.id + "_animated_tiles");
      if (!isNullOrUndefined(this.currentTiles) && animateElement.childElementCount < this.currentTiles.childElementCount) {
        for (var l = animateElement.childElementCount - 1; l >= this.currentTiles.childElementCount; l--) {
          animateElement.removeChild(animateElement.children[l]);
        }
      }
      this.currentTiles = null;
    };
    Maps2.prototype.mouseEndOnMap = function(e) {
      var pageX;
      var pageY;
      var touchArg;
      var layerX = 0;
      var layerY = 0;
      if (e.type.indexOf("touch") !== -1) {
        this.isTouch = true;
        touchArg = e;
        layerX = pageX = touchArg.changedTouches[0].pageX;
        pageY = touchArg.changedTouches[0].pageY;
        layerY = pageY - (this.isTileMap ? 10 : 0);
        this.mouseClickEvent = { x: pageX, y: pageY };
      } else {
        this.isTouch = e.pointerType === "touch";
        pageX = e.pageX;
        pageY = e.pageY;
        layerX = e["layerX"];
        layerY = e["layerY"] - (this.isTileMap ? 10 : 0);
      }
      if (this.isTileMap) {
        this.removeTileMap();
      }
      if (this.isTouch) {
        this.titleTooltip(e, pageX, pageY, true);
        if (!isNullOrUndefined(this.legendModule)) {
          this.legendTooltip(e, e.pageX, e.pageY, true);
        }
      }
      this.notify(Browser.touchEndEvent, e);
      if (e.cancelable && !this.isTouch) {
        e.preventDefault();
      }
      if (!isNullOrUndefined(this.markerDragArgument)) {
        var marker2 = this.markerDragArgument;
        this.mouseClickEvent["x"] = this.mouseDownEvent["x"];
        this.mouseClickEvent["y"] = this.mouseDownEvent["y"];
        var latLongValue = this.getMarkerClickLocation(pageX, pageY, layerX, layerY, this.markerDragArgument, true);
        var markerObject = this.layers[marker2.layerIndex].markerSettings[marker2.markerIndex];
        document.getElementById(this.element.id + "_svg").style.cursor = markerObject.enableDrag ? "pointer" : "grabbing";
        var dragEventArgs = {
          name: "markerDragEnd",
          x: pageX,
          y: pageY,
          latitude: latLongValue.latitude,
          longitude: latLongValue.longitude,
          layerIndex: marker2.layerIndex,
          markerIndex: marker2.markerIndex,
          dataIndex: marker2.dataIndex
        };
        if (isNullOrUndefined(markerObject.latitudeValuePath) && isNullOrUndefined(markerObject.longitudeValuePath)) {
          var data = markerObject.dataSource[marker2.dataIndex];
          if (!isNullOrUndefined(data["Longitude"]) && !isNullOrUndefined(data["Latitude"])) {
            markerObject.dataSource[marker2.dataIndex].Latitude = dragEventArgs.latitude;
            markerObject.dataSource[marker2.dataIndex].Longitude = dragEventArgs.longitude;
          } else {
            markerObject.dataSource[marker2.dataIndex].latitude = dragEventArgs.latitude;
            markerObject.dataSource[marker2.dataIndex].longitude = dragEventArgs.longitude;
          }
        } else {
          markerObject.dataSource[marker2.dataIndex][markerObject.latitudeValuePath] = dragEventArgs.latitude;
          markerObject.dataSource[marker2.dataIndex][markerObject.longitudeValuePath] = dragEventArgs.longitude;
        }
        this.markerDragId = "";
        this.markerDragArgument = null;
        this.trigger("markerDragEnd", dragEventArgs);
      } else {
        document.getElementById(this.element.id + "_svg").style.cursor = "auto";
      }
      if (this.zoomModule && this.isDevice) {
        this.zoomModule.removeToolbarOpacity(this.isTileMap ? Math.round(this.tileZoomLevel) : this.scale, this.element.id + "_Zooming_");
        this.zoomModule.removeToolbarClass("", "", "", "", "");
      }
      return false;
    };
    Maps2.prototype.mouseDownOnMap = function(e) {
      this.mouseDownEvent = { x: e.x, y: e.y };
      if (e.type.indexOf("touch") !== -1 && e.changedTouches) {
        this.mouseDownEvent = { x: e.changedTouches[0].pageX, y: e.changedTouches[0].pageY };
      }
      if (this.isDevice && !isNullOrUndefined(this.mapsTooltipModule)) {
        this.mapsTooltipModule.renderTooltip(e);
      }
      var element = e.target;
      this.markerDragId = element.id;
      var animatedTiles = document.getElementById(this.element.id + "_animated_tiles");
      if (this.isTileMap && !isNullOrUndefined(animatedTiles)) {
        this.currentTiles = animatedTiles.cloneNode(true);
      }
      if (element.id.indexOf("_ToolBar") === -1) {
        var markerModule = this.markerModule;
        if (element.id.indexOf("shapeIndex") > -1 || element.id.indexOf("Tile") > -1) {
          this.mergeCluster();
        }
        if (markerModule) {
          markerModule.markerClick(e);
          markerModule.markerClusterClick(e);
        }
        if (this.bubbleModule) {
          this.bubbleModule.bubbleClick(e);
        }
      }
      this.notify(Browser.touchStartEvent, e);
    };
    Maps2.prototype.mergeCluster = function() {
      if (this.markerModule && this.markerModule.sameMarkerData.length > 0 && (this.zoomModule ? this.zoomModule.isSingleClick : true)) {
        mergeSeparateCluster(this.markerModule.sameMarkerData, this);
        this.markerModule.sameMarkerData = [];
      }
    };
    Maps2.prototype.mapsOnRightClick = function(e) {
      var targetEle = e.target;
      var targetId = targetEle.id;
      var latitude = null;
      var longitude = null;
      this.mouseClickEvent = this.mouseDownEvent = { x: e.x, y: e.y };
      if (targetEle.id.indexOf("_ToolBar") === -1) {
        var latLongValue = this.getClickLocation(targetId, e.pageX, e.pageY, targetEle, e["layerX"], e["layerY"]);
        if (!isNullOrUndefined(latLongValue)) {
          latitude = latLongValue.latitude;
          longitude = latLongValue.longitude;
        }
        var eventArgs = {
          cancel: false,
          name: rightClick,
          target: targetId,
          x: e.clientX,
          y: e.clientY,
          latitude,
          longitude,
          isShapeSelected: false
        };
        this.trigger("rightClick", eventArgs);
      }
    };
    Maps2.prototype.mapsOnDoubleClick = function(e) {
      this.notify("dblclick", e);
      var targetElement = e.target;
      var targetId = targetElement.id;
      var layerIndex = 0;
      var latLongValue;
      var latitude = null;
      var longitude = null;
      if (targetElement.id.indexOf("_ToolBar") === -1) {
        if (targetElement.id.indexOf("_LayerIndex_") !== -1 && !this.isTileMap && this.mouseDownEvent["x"] === e.clientX && this.mouseDownEvent["y"] === e.clientY) {
          layerIndex = parseFloat(targetElement.id.split("_LayerIndex_")[1].split("_")[0]);
          latLongValue = this.getGeoLocation(layerIndex, e["layerX"], e["layerY"]);
          latitude = latLongValue["latitude"];
          longitude = latLongValue["longitude"];
        } else if (this.isTileMap && this.mouseDownEvent["x"] === e.clientX && this.mouseDownEvent["y"] === e.clientY) {
          latLongValue = this.getTileGeoLocation(e["layerX"], e["layerY"]);
          latitude = latLongValue["latitude"];
          longitude = latLongValue["longitude"];
        }
        var doubleClickArgs = {
          cancel: false,
          name: doubleClick,
          x: e.clientX,
          y: e.clientY,
          target: targetId,
          latitude,
          longitude,
          isShapeSelected: null
        };
        this.trigger("doubleClick", doubleClickArgs);
      }
    };
    Maps2.prototype.mouseMoveOnMap = function(e) {
      var target;
      target = e.type === "touchmove" ? e.target : target = e.target;
      this.mouseMoveEvent(e);
      if (this.markerModule) {
        this.markerModule.markerMove(e);
        this.markerModule.markerClusterMouseMove(e);
      }
      if (this.bubbleModule) {
        this.bubbleModule.bubbleMove(e);
      }
      if (target.id.indexOf("MarkerIndex") === -1) {
        document.getElementById(this.element.id + "_svg").style.cursor = "auto";
      }
      this.onMouseMove(e);
      this.notify(Browser.touchMoveEvent, e);
    };
    Maps2.prototype.mouseMoveEvent = function(e) {
      var targetId = e.target.id;
      var layerIndex;
      var eventArgs;
      if (this.isTileMap) {
        var latLongValue = this.getTileGeoLocation(e["layerX"], e["layerY"]);
        eventArgs = {
          x: e.clientX,
          y: e.clientY,
          latitude: latLongValue.latitude,
          longitude: latLongValue.longitude,
          target: e.target
        };
      } else {
        layerIndex = targetId.indexOf("_LayerIndex_") > -1 ? parseInt(targetId.split("_LayerIndex_")[1].split("_")[0], 10) : this.baseLayerIndex;
        var latLongValue = this.getGeoLocation(layerIndex, e.clientX, e.clientY);
        eventArgs = {
          x: e.clientX,
          y: e.clientY,
          latitude: latLongValue.latitude,
          longitude: latLongValue.longitude,
          target: e.target
        };
      }
      this.trigger(mouseMove, eventArgs);
    };
    Maps2.prototype.onMouseMove = function(e) {
      var element = e.target;
      this.mouseMoveId = element["id"];
      var pageX;
      var pageY;
      var touches = null;
      var layerX = 0;
      var layerY = 0;
      if (e.type.indexOf("touch") === -1) {
        pageX = e.pageX;
        pageY = e.pageY;
        layerX = e["layerX"];
        layerY = e["layerY"] - (this.isTileMap ? 10 : 0);
        this.titleTooltip(e, e.pageX, e.pageY);
        if (!isNullOrUndefined(this.legendModule)) {
          this.legendTooltip(e, e.pageX, e.pageY, true);
        }
      } else {
        touches = e.touches;
        layerX = pageX = touches[0].clientX;
        layerY = pageY = touches[0].clientY - (this.isTileMap ? 10 : 0);
      }
      if (!isNullOrUndefined(this.markerDragArgument)) {
        var marker2 = this.markerDragArgument;
        this.mouseClickEvent["x"] = this.mouseDownEvent["x"];
        this.mouseClickEvent["y"] = this.mouseDownEvent["y"];
        this.getMarkerClickLocation(pageX, pageY, layerX, layerY, marker2, false);
      }
      if (this.zoomModule) {
        this.zoomModule.removeToolbarOpacity(this.isTileMap ? Math.round(this.tileZoomLevel) : this.scale, e.target.id);
      }
      return false;
    };
    Maps2.prototype.legendTooltip = function(event, x, y, isTouch) {
      var targetId = event.target.id;
      var legendText;
      var page = this.legendModule.currentPage;
      var legendIndex = event.target.id.split("_Index_")[1];
      var collection;
      page = this.legendModule.totalPages.length <= this.legendModule.currentPage ? this.legendModule.totalPages.length - 1 : this.legendModule.currentPage < 0 ? 0 : this.legendModule.currentPage;
      var count = this.legendModule.totalPages.length !== 0 ? this.legendModule.totalPages[page]["Collection"].length : this.legendModule.totalPages.length;
      for (var i = 0; i < count; i++) {
        collection = this.legendModule.totalPages[page]["Collection"][i];
        legendText = collection["DisplayText"];
        targetId = event.target["id"];
        legendIndex = event.target["id"].split("_Index_")[1];
        if (targetId === this.element.id + "_Legend_Text_Index_" + legendIndex && event.target.textContent.indexOf("...") > -1 && collection["idIndex"] === parseInt(legendIndex, 10)) {
          showTooltip(legendText, this.legendSettings.textStyle.size, x, y, this.element.offsetWidth, this.element.offsetHeight, this.element.id + "_EJ2_Legend_Text_Tooltip", getElement2(this.element.id + "_Secondary_Element"), isTouch);
        }
      }
      if (targetId !== this.element.id + "_Legend_Text_Index_" + legendIndex) {
        removeElement2(this.element.id + "_EJ2_Legend_Text_Tooltip");
      }
    };
    Maps2.prototype.titleTooltip = function(event, x, y, isTouch) {
      var targetId = event.target.id;
      if (targetId === this.element.id + "_LegendTitle" && event.target.textContent.indexOf("...") > -1) {
        showTooltip(this.legendSettings.title.text, this.legendSettings.titleStyle.size, x, y, this.element.offsetWidth, this.element.offsetHeight, this.element.id + "_EJ2_LegendTitle_Tooltip", getElement2(this.element.id + "_Secondary_Element"), isTouch);
      } else {
        removeElement2(this.element.id + "_EJ2_LegendTitle_Tooltip");
      }
      if (targetId === this.element.id + "_Map_title" && event.target.textContent.indexOf("...") > -1) {
        showTooltip(this.titleSettings.text, this.titleSettings.textStyle.size || this.themeStyle.titleFontSize, x, y, this.element.offsetWidth, this.element.offsetHeight, this.element.id + "_EJ2_Title_Tooltip", getElement2(this.element.id + "_Secondary_Element"), isTouch);
      } else {
        removeElement2(this.element.id + "_EJ2_Title_Tooltip");
      }
    };
    Maps2.prototype.mapsOnResize = function(e) {
      var _this = this;
      if (!this.isDestroyed && !this.isExportInitialTileMap) {
        this.isResize = this.isReset = true;
        var args = {
          cancel: false,
          name: resize,
          previousSize: this.availableSize,
          currentSize: calculateSize(this),
          maps: this
        };
        this.trigger(resize, args);
        if (!args.cancel) {
          if (this.resizeTo) {
            clearTimeout(this.resizeTo);
          }
          if (!isNullOrUndefined(this.element) && this.element.classList.contains("e-maps")) {
            this.resizeTo = setTimeout(function() {
              _this.unWireEVents();
              _this.createSVG();
              _this.refreshing = true;
              _this.wireEVents();
              _this.render();
              _this.refreshing = false;
            }, 500);
          }
        }
      }
      return false;
    };
    Maps2.prototype.zoomByPosition = function(centerPosition, zoomFactor) {
      if (!this.isDestroyed) {
        this.zoomNotApplied = this.isMarkerZoomCompleted = false;
        var isRefresh = this.zoomSettings.zoomFactor === zoomFactor;
        this.previousProjection = null;
        if (!this.isTileMap && this.zoomModule) {
          if (!isNullOrUndefined(centerPosition)) {
            this.zoomSettings.zoomFactor = zoomFactor;
            isRefresh = this.centerPosition.latitude === centerPosition.latitude && this.centerPosition.longitude === centerPosition.longitude ? true : isRefresh;
            this.centerPosition = centerPosition;
            this.isZoomByPosition = true;
            this.mapScaleValue = null;
          } else {
            this.zoomSettings.zoomFactor = zoomFactor;
            this.isZoomByPosition = true;
            this.mapScaleValue = null;
          }
        } else if (this.zoomModule) {
          this.tileZoomLevel = this.zoomSettings.zoomFactor = zoomFactor;
          isRefresh = this.centerPosition.latitude === centerPosition.latitude && this.centerPosition.longitude === centerPosition.longitude ? true : isRefresh;
          this.centerPosition = centerPosition;
          this.isZoomByPosition = true;
        }
        if (isRefresh) {
          this.refresh();
        }
      }
    };
    Maps2.prototype.panByDirection = function(direction, mouseLocation) {
      if (!this.isDestroyed) {
        var xDiff = 0;
        var yDiff = 0;
        switch (direction) {
          case "Left":
            xDiff = -(this.mapAreaRect.width / 7);
            break;
          case "Right":
            xDiff = this.mapAreaRect.width / 7;
            break;
          case "Top":
            yDiff = -(this.mapAreaRect.height / 7);
            break;
          case "Bottom":
            yDiff = this.mapAreaRect.height / 7;
            break;
        }
        if (this.zoomModule) {
          this.zoomModule.panning(direction, xDiff, yDiff, mouseLocation);
        }
      }
    };
    Maps2.prototype.addLayer = function(layer) {
      if (!this.isDestroyed) {
        var mapsLayer = this.layers;
        mapsLayer.push(layer);
        this.isAddLayer = true;
        this.layers = mapsLayer;
      }
    };
    Maps2.prototype.removeLayer = function(index) {
      if (!this.isDestroyed) {
        var mapsLayer = this.layers;
        mapsLayer.splice(index, 1);
        this.layers = mapsLayer;
      }
    };
    Maps2.prototype.addMarker = function(layerIndex, markerCollection) {
      if (!this.isDestroyed && !isNullOrUndefined(this.markerModule)) {
        if (!isNullOrUndefined(layerIndex) && !isNullOrUndefined(markerCollection)) {
          var layerEle = document.getElementById(this.element.id + "_LayerIndex_" + layerIndex);
          if (markerCollection.length > 0 && layerEle) {
            for (var _i = 0, markerCollection_1 = markerCollection; _i < markerCollection_1.length; _i++) {
              var newMarker = markerCollection_1[_i];
              this.layersCollection[layerIndex].markerSettings.push(new MarkerSettings(this, "markerSettings", newMarker));
            }
            this.markerModule.markerRender(this, layerEle, layerIndex, this.isTileMap ? this.tileZoomLevel : this.mapLayerPanel["currentFactor"], "AddMarker");
            this.arrangeTemplate();
          }
        } else {
          for (var i = 0; i < this.layers.length; i++) {
            var layerEle = document.getElementById(this.element.id + "_LayerIndex_" + i);
            this.markerModule.zoomedMarkerCluster[i] = [];
            this.markerModule.initialMarkerCluster[i] = [];
            this.markerModule.markerRender(this, layerEle, i, this.isTileMap ? this.tileZoomLevel : this.mapLayerPanel["currentFactor"], null);
          }
          this.arrangeTemplate();
        }
      }
    };
    Maps2.prototype.shapeSelection = function(layerIndex, propertyName, name, enable) {
      if (!this.isDestroyed && !isNullOrUndefined(this.layers[layerIndex])) {
        var targetEle = void 0;
        var subLayerIndex = void 0;
        var popertyNameArray = Array.isArray(propertyName) ? propertyName : Array(propertyName);
        if (isNullOrUndefined(enable)) {
          enable = true;
        }
        var selectionsettings = this.layers[layerIndex].selectionSettings;
        if (!selectionsettings.enableMultiSelect && this.legendSelection && enable) {
          this.removeShapeSelection();
        }
        if (this.layers[layerIndex].type === "SubLayer") {
          for (var i = 0; i < this.layersCollection.length; i++) {
            if (this.layersCollection[i].shapeData === this.layers[layerIndex].shapeData) {
              subLayerIndex = i;
              break;
            }
          }
        }
        if (!isNullOrUndefined(selectionsettings) && selectionsettings.enable) {
          var targetId = void 0;
          var dataIndex = void 0;
          var shapeIndex = void 0;
          var indexValue = void 0;
          var shapeDataValue = void 0;
          var data = void 0;
          var shapeData = this.layers[layerIndex].shapeData["features"];
          for (var i = 0; i < shapeData.length; i++) {
            for (var j = 0; j < popertyNameArray.length; j++) {
              var propertyName_1 = !isNullOrUndefined(shapeData[i]["properties"][popertyNameArray[j]]) && isNaN(shapeData[i]["properties"][popertyNameArray[j]]) ? shapeData[i]["properties"][popertyNameArray[j]].toLowerCase() : shapeData[i]["properties"][popertyNameArray[j]];
              var shapeName = !isNullOrUndefined(name) && typeof name === "string" ? name.toLowerCase() : name;
              var k = void 0;
              if (propertyName_1 === shapeName) {
                if (!isNullOrUndefined(this.layers[layerIndex].shapeSettings.colorValuePath)) {
                  k = checkShapeDataFields(
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    this.layers[layerIndex].dataSource,
                    shapeData[i]["properties"],
                    this.layers[layerIndex].shapeDataPath,
                    this.layers[layerIndex].shapePropertyPath,
                    this.layers[layerIndex]
                  );
                }
                var baseLayer = this.layers[layerIndex];
                if (this.baseLayerIndex >= 0 && baseLayer.isBaseLayer) {
                  indexValue = 0;
                } else if (this.layers[layerIndex].type === "SubLayer") {
                  indexValue = subLayerIndex;
                }
                targetId = this.element.id + "_LayerIndex_" + indexValue + "_shapeIndex_" + i + "_dataIndex_" + k;
                targetEle = getElement2(targetId);
                if (isNullOrUndefined(k) && isNullOrUndefined(targetEle)) {
                  targetId = this.element.id + "_LayerIndex_" + layerIndex + "_shapeIndex_" + i + "_dataIndex_null";
                  targetEle = getElement2(targetId);
                }
                shapeIndex = parseInt(targetEle.id.split("_shapeIndex_")[1].split("_")[0], 10);
                shapeDataValue = this.layers[layerIndex].shapeData["features"]["length"] > shapeIndex ? this.layers[layerIndex].shapeData["features"][shapeIndex]["properties"] : null;
                dataIndex = parseInt(targetEle.id.split("_dataIndex_")[1].split("_")[0], 10);
                data = isNullOrUndefined(dataIndex) ? null : this.layers[layerIndex].dataSource[dataIndex];
                if (enable) {
                  triggerItemSelectionEvent(selectionsettings, this, targetEle, shapeDataValue, data);
                  this.shapeSelectionClass = getElement2("ShapeselectionMap");
                  if (this.legendSettings.visible && targetEle.id.indexOf("_MarkerIndex_") === -1) {
                    this.legendModule.shapeHighLightAndSelection(targetEle, data, selectionsettings, "selection", layerIndex);
                  }
                  var shapeToggled = this.legendSettings.visible ? this.legendModule.shapeToggled : true;
                  if (shapeToggled) {
                    targetEle.setAttribute("class", "ShapeselectionMapStyle");
                    if (this.selectedElementId.indexOf(targetEle.getAttribute("id")) === -1) {
                      this.selectedElementId.push(targetEle.getAttribute("id"));
                    }
                    if (!selectionsettings.enableMultiSelect) {
                      return;
                    }
                  }
                } else {
                  this.legendSelection = !selectionsettings.enableMultiSelect && !this.legendSelection ? true : this.legendSelection;
                  if (this.legendSettings.visible && targetEle.id.indexOf("_MarkerIndex_") === -1 && targetEle.getAttribute("class") === "ShapeselectionMapStyle") {
                    this.legendModule.shapeHighLightAndSelection(targetEle, data, selectionsettings, "selection", layerIndex);
                  }
                  var shapeToggled = this.legendSettings.visible ? this.legendModule.shapeToggled : true;
                  if (shapeToggled) {
                    removeClass2(targetEle);
                    var selectedElementIdIndex = this.selectedElementId.indexOf(targetEle.getAttribute("id"));
                    if (selectedElementIdIndex !== -1) {
                      this.selectedElementId.splice(selectedElementIdIndex, 1);
                      if (!selectionsettings.enableMultiSelect && this.legendSelection && this.selectedElementId.length > 0) {
                        this.removeShapeSelection();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    Maps2.prototype.zoomToCoordinates = function(minLatitude, minLongitude, maxLatitude, maxLongitude) {
      var _a, _b;
      if (!this.isDestroyed) {
        this.isMarkerZoomCompleted = false;
        var centerLatitude = void 0;
        var centerLongtitude = void 0;
        var isTwoCoordinates = false;
        this.centerPosition = {
          latitude: null,
          longitude: null
        };
        this.isZoomByPosition = false;
        if (isNullOrUndefined(maxLatitude) && isNullOrUndefined(maxLongitude) || isNullOrUndefined(minLatitude) && isNullOrUndefined(minLongitude)) {
          minLatitude = isNullOrUndefined(minLatitude) ? 0 : minLatitude;
          minLongitude = isNullOrUndefined(minLatitude) ? 0 : minLongitude;
          maxLatitude = isNullOrUndefined(maxLatitude) ? minLatitude : maxLatitude;
          maxLongitude = isNullOrUndefined(maxLongitude) ? minLongitude : maxLongitude;
          isTwoCoordinates = true;
        }
        if (minLatitude > maxLatitude) {
          _a = [maxLatitude, minLatitude], minLatitude = _a[0], maxLatitude = _a[1];
        }
        if (minLongitude > maxLongitude) {
          _b = [maxLongitude, minLongitude], minLongitude = _b[0], maxLongitude = _b[1];
        }
        if (!isTwoCoordinates) {
          centerLatitude = (minLatitude + maxLatitude) / 2;
          centerLongtitude = (minLongitude + maxLongitude) / 2;
        } else {
          centerLatitude = minLatitude + maxLatitude;
          centerLongtitude = minLongitude + maxLongitude;
        }
        this.centerLatOfGivenLocation = centerLatitude;
        this.centerLongOfGivenLocation = centerLongtitude;
        this.minLatOfGivenLocation = minLatitude;
        this.minLongOfGivenLocation = minLongitude;
        this.maxLatOfGivenLocation = maxLatitude;
        this.maxLongOfGivenLocation = maxLongitude;
        this.zoomNotApplied = true;
        this.scaleOfGivenLocation = calculateZoomLevel(minLatitude, maxLatitude, minLongitude, maxLongitude, this.mapAreaRect.width, this.mapAreaRect.height, this, true);
        var minMaxLatitudeLongitude = this.getMinMaxLatitudeLongitude();
        var zoomArgs = {
          cancel: false,
          name: "zoom",
          type: zoomIn,
          maps: this,
          tileTranslatePoint: {},
          translatePoint: {},
          tileZoomLevel: this.isTileMap ? { previous: this.tileZoomLevel, current: this.scaleOfGivenLocation } : {},
          scale: !this.isTileMap ? { previous: this.scale, current: this.scaleOfGivenLocation } : { previous: this.tileZoomLevel, current: this.scaleOfGivenLocation },
          minLatitude: minMaxLatitudeLongitude.minLatitude,
          maxLatitude: minMaxLatitudeLongitude.maxLatitude,
          minLongitude: minMaxLatitudeLongitude.minLongitude,
          maxLongitude: minMaxLatitudeLongitude.maxLongitude
        };
        this.trigger("zoom", zoomArgs);
        this.refresh();
      }
    };
    Maps2.prototype.removeShapeSelection = function() {
      var selectedElements = this.selectedElementId.length;
      for (var i = 0; i < selectedElements; i++) {
        removeClass2(getElementByID(this.selectedElementId[0]));
        this.selectedElementId.splice(0, 1);
      }
      if (this.legendSettings.visible) {
        var legendSelectedElements = this.legendSelectionCollection.length;
        for (var i = 0; i < legendSelectedElements; i++) {
          removeClass2(getElementByID(this.legendSelectionCollection[i]["legendElement"]["id"]));
          this.selectedLegendElementId.splice(0, 1);
        }
      }
      this.shapeSelectionItem = [];
      this.legendSelectionCollection = [];
    };
    Maps2.prototype.setCulture = function() {
      this.intl = new Internationalization();
      this.setLocaleConstants();
      this.localeObject = new L10n(this.getModuleName(), this.defaultLocalConstants, this.locale);
    };
    Maps2.prototype.setLocaleConstants = function() {
      this.defaultLocalConstants = {
        ZoomIn: "Zoom in",
        Zoom: "Zoom",
        ZoomOut: "Zoom out",
        Pan: "Pan",
        Reset: "Reset",
        ImageNotFound: "Image Not Found"
      };
    };
    Maps2.prototype.destroy = function() {
      this.unWireEVents();
      if (!isNullOrUndefined(this.mapsTooltipModule)) {
        this.mapsTooltipModule.removeEventListener();
      }
      if (!isNullOrUndefined(this.zoomModule)) {
        this.zoomModule.removeEventListener();
      }
      if (!isNullOrUndefined(this.legendModule)) {
        this.legendModule.removeEventListener();
      }
      if (!isNullOrUndefined(this.selectionModule)) {
        this.selectionModule.removeEventListener();
      }
      if (!isNullOrUndefined(this.highlightModule)) {
        this.highlightModule.removeEventListener();
      }
      if (!isNullOrUndefined(this.bingMap)) {
        this.bingMap.destroy();
      }
      _super.prototype.destroy.call(this);
      this.shapeSelectionItem = [];
      this.toggledElementId = [];
      this.toggledLegendId = [];
      this.legendSelectionCollection = [];
      this.selectedLegendElementId = [];
      this.selectedNavigationElementId = [];
      this.selectedBubbleElementId = [];
      this.selectedMarkerElementId = [];
      this.selectedElementId = [];
      this.dataLabelShape = [];
      this.zoomShapeCollection = [];
      this.zoomLabelPositions = [];
      this.mouseDownEvent = { x: null, y: null };
      this.mouseClickEvent = { x: null, y: null };
      this.formatFunction = null;
      this.localeObject = null;
      this.defaultLocalConstants = null;
      this.intl = null;
      this.mapAreaRect = null;
      this.layersCollection = null;
      this.themeStyle = null;
      this.totalRect = null;
      this.baseSize = null;
      this.baseMapBounds = null;
      this.baseMapRectBounds = null;
      this.baseTranslatePoint = null;
      this.baseTileTranslatePoint = null;
      this.markerZoomCenterPoint = null;
      this.currentTiles = null;
      this.serverProcess = null;
      this.toolbarProperties = null;
      this.zoomLabelPositions = null;
      this.resizeEvent = null;
      this.availableSize = null;
      if (document.getElementById("mapsmeasuretext")) {
        document.getElementById("mapsmeasuretext").remove();
      }
      this.removeSvg();
      this.svgObject = null;
      this.mapLayerPanel = null;
      this.renderer = null;
      this.translatePoint = null;
      this.tileTranslatePoint = null;
      this.previousPoint = null;
      this.dataLabelShape = [];
      this.zoomShapeCollection = [];
      this.selectedElementId = [];
      this.selectedMarkerElementId = [];
      this.selectedBubbleElementId = [];
      this.shapeSelectionClass = null;
      this.markerSelectionClass = null;
      this.bubbleSelectionClass = null;
      this.navigationSelectionClass = null;
      this.selectedNavigationElementId = [];
      this.polygonSelectionClass = null;
      this.selectedPolygonElementId = [];
      this.legendSelectionClass = null;
      this.previousTranslate = null;
      this.initialTileTranslate = null;
      this.markerDragArgument = null;
    };
    Maps2.prototype.getModuleName = function() {
      return "maps";
    };
    Maps2.prototype.getPersistData = function() {
      var keyEntity = [
        "translatePoint",
        "zoomSettings",
        "mapScaleValue",
        "tileTranslatePoint",
        "baseTranslatePoint",
        "scale",
        "zoomPersistence",
        "defaultState",
        "markerZoomedState",
        "initialCheck",
        "initialZoomLevel",
        "initialTileTranslate",
        "applyZoomReset",
        "markerZoomFactor"
      ];
      return this.addOnPersist(keyEntity);
    };
    Maps2.prototype.onPropertyChanged = function(newProp, oldProp) {
      if (!this.isDestroyed) {
        var render = false;
        var isMarker = false;
        var isLayer = false;
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
          var prop = _a[_i];
          switch (prop) {
            case "background":
              this.renderBorder();
              break;
            case "height":
            case "width":
            case "layers":
            case "projectionType":
            case "centerPosition":
            case "legendSettings":
            case "baseLayerIndex":
              if (prop === "layers") {
                isLayer = true;
                var layerPropLength = Object.keys(newProp.layers).length;
                for (var x = 0; x < layerPropLength; x++) {
                  if (!isNullOrUndefined(newProp.layers[x])) {
                    var collection = Object.keys(newProp.layers[x]);
                    for (var _b = 0, collection_1 = collection; _b < collection_1.length; _b++) {
                      var collectionProp = collection_1[_b];
                      if (isNullOrUndefined(this.layers[x].shapeData) && !isNullOrUndefined(this.layers[x].urlTemplate) && this.layers[x].urlTemplate !== "") {
                        this.isReset = true;
                      } else if (collectionProp === "markerSettings") {
                        isMarker = true;
                      }
                    }
                  }
                }
              }
              render = true;
              break;
            case "zoomSettings":
              if (!isNullOrUndefined(oldProp.zoomSettings)) {
                if (newProp.zoomSettings.zoomFactor !== oldProp.zoomSettings.zoomFactor && !isLayer) {
                  render = false;
                } else if (newProp.zoomSettings.shouldZoomInitially !== oldProp.zoomSettings.shouldZoomInitially) {
                  this.zoomSettings.zoomFactor = 1;
                  this.previousProjection = null;
                  this.scale = this.isMarkerZoomCompleted ? null : this.scale;
                  this.isMarkerZoomCompleted = !newProp.zoomSettings.shouldZoomInitially;
                  render = true;
                } else if (newProp.zoomSettings.enable !== oldProp.zoomSettings.enable) {
                  this.zoomSettings.zoomFactor = 1;
                  render = true;
                } else {
                  render = true;
                }
              }
              break;
            case "locale":
            case "currencyCode":
              _super.prototype.refresh.call(this);
              break;
          }
        }
        if (render) {
          if (newProp.layers && isMarker) {
            removeElement2(this.element.id + "_Markers_Group");
            if (this.isTileMap) {
              this.mapLayerPanel.renderTileLayer(this.mapLayerPanel, this.layers["currentFactor"], this.layers.length - 1);
            } else {
              this.render();
            }
          } else {
            this.createSVG();
            this.renderElements();
          }
        }
      }
    };
    Maps2.prototype.requiredModules = function() {
      var modules = [];
      var isVisible2 = this.findVisibleLayers(this.layers);
      var annotationEnable = false;
      this.annotations.map(function(annotation) {
        annotationEnable = annotation.content != null;
      });
      if (this.isBubbleVisible()) {
        modules.push({
          member: "Bubble",
          args: [this],
          name: "Bubble"
        });
      }
      if (isVisible2.highlight) {
        modules.push({
          member: "Highlight",
          args: [this],
          name: "Highlight"
        });
      }
      if (isVisible2.selection) {
        modules.push({
          member: "Selection",
          args: [this],
          name: "Selection"
        });
      }
      if (this.legendSettings.visible) {
        modules.push({
          member: "Legend",
          args: [this],
          name: "Legend"
        });
      }
      if (this.zoomSettings.enable || this.zoomSettings.zoomFactor > this.zoomSettings.minZoom) {
        modules.push({
          member: "Zoom",
          args: [this],
          name: "Zoom"
        });
      }
      if (this.isMarkersVisible()) {
        modules.push({
          member: "Marker",
          args: [this],
          name: "Marker"
        });
      }
      if (this.isDataLabelVisible()) {
        modules.push({
          member: "DataLabel",
          args: [this],
          name: "DataLabel"
        });
      }
      if (this.isNavigationVisible()) {
        modules.push({
          member: "NavigationLine",
          args: [this],
          name: "NavigationLine"
        });
      }
      if (this.isPolygonVisible()) {
        modules.push({
          member: "Polygon",
          args: [this],
          name: "Polygon"
        });
      }
      if (isVisible2.tooltip) {
        modules.push({
          member: "MapsTooltip",
          args: [this],
          name: "MapsTooltip"
        });
      }
      if (annotationEnable) {
        modules.push({
          member: "Annotations",
          args: [this, Annotations],
          name: "Annotations"
        });
      }
      if (this.allowPrint) {
        modules.push({
          member: "Print",
          args: [this],
          name: "Print"
        });
      }
      if (this.allowImageExport) {
        modules.push({
          member: "ImageExport",
          args: [this],
          name: "ImageExport"
        });
      }
      if (this.allowPdfExport) {
        modules.push({
          member: "PdfExport",
          args: [this],
          name: "PdfExport"
        });
      }
      return modules;
    };
    Maps2.prototype.isMarkersVisible = function() {
      var isVisible2 = false;
      Array.prototype.forEach.call(this.layers, function(layer) {
        for (var i = 0; i < layer.markerSettings.length; i++) {
          if (layer.markerSettings[i].visible) {
            isVisible2 = true;
            break;
          }
        }
      });
      return isVisible2;
    };
    Maps2.prototype.isDataLabelVisible = function() {
      var isVisible2 = false;
      for (var i = 0; i < this.layers.length; i++) {
        if (this.layers[i].dataLabelSettings.visible) {
          isVisible2 = true;
          break;
        }
      }
      return isVisible2;
    };
    Maps2.prototype.isNavigationVisible = function() {
      var isVisible2 = false;
      Array.prototype.forEach.call(this.layers, function(layer) {
        for (var i = 0; i < layer.navigationLineSettings.length; i++) {
          if (layer.navigationLineSettings[i].visible) {
            isVisible2 = true;
            break;
          }
        }
      });
      return isVisible2;
    };
    Maps2.prototype.isPolygonVisible = function() {
      var isVisible2 = false;
      Array.prototype.forEach.call(this.layers, function(layer) {
        for (var i = 0; i < layer.polygonSettings.polygons.length; i++) {
          if (layer.polygonSettings.polygons.length > 0) {
            isVisible2 = true;
            break;
          }
        }
      });
      return isVisible2;
    };
    Maps2.prototype.isBubbleVisible = function() {
      var isVisible2 = false;
      for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
        var layer = _a[_i];
        if (this.getBubbleVisible(layer)) {
          isVisible2 = true;
          break;
        }
      }
      return isVisible2;
    };
    Maps2.prototype.getBubbleVisible = function(layer) {
      var isVisible2 = false;
      for (var _i = 0, _a = layer.bubbleSettings; _i < _a.length; _i++) {
        var bubble = _a[_i];
        if (bubble.visible) {
          isVisible2 = true;
          break;
        }
      }
      return isVisible2;
    };
    Maps2.prototype.print = function(id) {
      if (this.allowPrint && this.printModule && !this.isDestroyed) {
        this.printModule.print(this, id);
      }
    };
    Maps2.prototype.export = function(type, fileName, orientation, allowDownload) {
      var _this = this;
      if (!this.isDestroyed) {
        if (isNullOrUndefined(allowDownload)) {
          allowDownload = true;
        }
        if (type !== "PDF" && this.allowImageExport && this.imageExportModule) {
          return new Promise(function(resolve) {
            resolve(_this.imageExportModule.export(_this, type, fileName, allowDownload));
          });
        } else if (this.allowPdfExport && this.pdfExportModule) {
          return new Promise(function(resolve) {
            resolve(_this.pdfExportModule.export(_this, type, fileName, allowDownload, orientation));
          });
        }
      }
      return null;
    };
    Maps2.prototype.getBingUrlTemplate = function(url) {
      var promise;
      if (!this.isDestroyed) {
        promise = new Promise(function(resolve) {
          var fetchApi = new Fetch({
            url
          });
          fetchApi.onSuccess = function(json) {
            var resource = json["resourceSets"][0]["resources"][0];
            resolve(resource["imageUrl"]);
          };
          fetchApi.send();
        });
      }
      return promise;
    };
    Maps2.prototype.findVisibleLayers = function(layers, isLayerVisible, isBubblevisible, istooltipVisible, isSelection, isHighlight) {
      if (isLayerVisible === void 0) {
        isLayerVisible = false;
      }
      if (isBubblevisible === void 0) {
        isBubblevisible = false;
      }
      if (istooltipVisible === void 0) {
        istooltipVisible = false;
      }
      if (isSelection === void 0) {
        isSelection = false;
      }
      if (isHighlight === void 0) {
        isHighlight = false;
      }
      var bubbles;
      var markers;
      var polygonSetting;
      for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
        var layer = layers_1[_i];
        isLayerVisible = layer.visible || isLayerVisible;
        if (layer.visible) {
          bubbles = layer.bubbleSettings;
          markers = layer.markerSettings;
          polygonSetting = layer.polygonSettings;
          var navigationLine = layer.navigationLineSettings;
          for (var _a = 0, navigationLine_1 = navigationLine; _a < navigationLine_1.length; _a++) {
            var navigation = navigationLine_1[_a];
            if (navigation.visible) {
              isSelection = !isNullOrUndefined(navigation.highlightSettings) && navigation.highlightSettings.enable || isSelection;
              isHighlight = !isNullOrUndefined(navigation.selectionSettings) && navigation.selectionSettings.enable || isHighlight;
            }
          }
          for (var _b = 0, _c = polygonSetting.polygons; _b < _c.length; _b++) {
            var polygon = _c[_b];
            if (!isNullOrUndefined(polygon.points) && polygon.points.length > 0) {
              isSelection = layer.polygonSettings.highlightSettings.enable || isSelection;
              isHighlight = layer.polygonSettings.selectionSettings.enable || isHighlight;
              istooltipVisible = layer.polygonSettings.tooltipSettings.visible || istooltipVisible;
            }
          }
          for (var _d = 0, markers_1 = markers; _d < markers_1.length; _d++) {
            var marker2 = markers_1[_d];
            if (marker2.visible) {
              istooltipVisible = marker2.tooltipSettings.visible || istooltipVisible;
              isSelection = marker2.selectionSettings.enable || isSelection;
              isHighlight = marker2.highlightSettings.enable || isHighlight;
            }
            if (istooltipVisible) {
              break;
            }
          }
          for (var _e = 0, bubbles_1 = bubbles; _e < bubbles_1.length; _e++) {
            var bubble = bubbles_1[_e];
            if (bubble.visible) {
              istooltipVisible = bubble.tooltipSettings.visible || istooltipVisible;
              isSelection = bubble.selectionSettings.enable || isSelection;
              isHighlight = bubble.highlightSettings.enable || isHighlight;
            }
            if (istooltipVisible) {
              break;
            }
          }
          istooltipVisible = layer.tooltipSettings.visible || istooltipVisible;
          isSelection = layer.selectionSettings.enable || isSelection;
          isHighlight = layer.highlightSettings.enable || isHighlight;
        }
        if (isLayerVisible && isBubblevisible && istooltipVisible) {
          break;
        }
      }
      return {
        layer: isLayerVisible,
        bubble: isBubblevisible,
        tooltip: istooltipVisible,
        selection: isSelection,
        highlight: isHighlight
      };
    };
    Maps2.prototype.getGeoLocation = function(layerIndex, x, y) {
      var latitude = null;
      var longitude = null;
      if (!this.isDestroyed && !this.isTileMap) {
        var container = document.getElementById(this.element.id);
        var elementClientRect = this.element.getBoundingClientRect();
        var pageX = x - container.offsetLeft - (elementClientRect.left - container.offsetLeft) - window.scrollX;
        var pageY = y - container.offsetTop - (elementClientRect.top - container.offsetTop) - window.scrollY;
        var currentLayer = this.layersCollection[layerIndex];
        var translate = getTranslate(this, currentLayer, false);
        var translatePoint = translate["location"];
        var translatePointX = translatePoint.x * this.scale;
        var translatePointY = translatePoint.y * this.scale;
        var mapSize = Math.min(this.mapAreaRect.height, this.mapAreaRect.width) * this.mapLayerPanel["currentFactor"] * this.scale;
        var xx = this.clip(pageX - translatePointX, 0, mapSize - 1) / mapSize - 0.5;
        var yy = 0.5 - this.clip(pageY - translatePointY, 0, mapSize - 1) / mapSize;
        latitude = 90 - 360 * Math.atan(Math.exp(-yy * 2 * Math.PI)) / Math.PI;
        longitude = 360 * xx;
      }
      return { latitude, longitude };
    };
    Maps2.prototype.clip = function(value, minVal, maxVal) {
      return Math.min(Math.max(value, minVal), maxVal);
    };
    Maps2.prototype.getTileGeoLocation = function(x, y) {
      var latitude = null;
      var longitude = null;
      if (this.isTileMap) {
        var element = document.getElementById(this.element.id + "_tile_parent");
        if (!this.isDestroyed && !isNullOrUndefined(element)) {
          var latLong = this.pointToLatLong(x + this.mapAreaRect.x - element.offsetLeft, y + this.mapAreaRect.y - element.offsetTop);
          latitude = latLong["latitude"];
          longitude = latLong["longitude"];
        }
      }
      return { latitude, longitude };
    };
    Maps2.prototype.pointToLatLong = function(pageX, pageY) {
      var latitude = 0;
      var longitude = 0;
      if (!this.isDestroyed && !isNullOrUndefined(this.translatePoint)) {
        var padding = 10;
        pageY = !isNullOrUndefined(this.markerDragArgument) ? pageY + padding : pageY;
        var mapSize = 256 * Math.pow(2, this.tileZoomLevel);
        var x1 = this.clip(pageX - this.translatePoint.x * this.scale, 0, mapSize - 1) / mapSize - 0.5;
        var y1 = 0.5 - this.clip(pageY - this.translatePoint.y * this.scale, 0, mapSize - 1) / mapSize;
        latitude = 90 - 360 * Math.atan(Math.exp(-y1 * 2 * Math.PI)) / Math.PI;
        longitude = 360 * x1;
      }
      return { latitude, longitude };
    };
    __decorate9([
      Property(null)
    ], Maps2.prototype, "background", void 0);
    __decorate9([
      Property(false)
    ], Maps2.prototype, "useGroupingSeparator", void 0);
    __decorate9([
      Property(null)
    ], Maps2.prototype, "format", void 0);
    __decorate9([
      Property(null)
    ], Maps2.prototype, "width", void 0);
    __decorate9([
      Property(null)
    ], Maps2.prototype, "height", void 0);
    __decorate9([
      Property("MouseMove")
    ], Maps2.prototype, "tooltipDisplayMode", void 0);
    __decorate9([
      Property(false)
    ], Maps2.prototype, "allowPrint", void 0);
    __decorate9([
      Property(false)
    ], Maps2.prototype, "allowImageExport", void 0);
    __decorate9([
      Property(false)
    ], Maps2.prototype, "allowPdfExport", void 0);
    __decorate9([
      Complex({}, TitleSettings)
    ], Maps2.prototype, "titleSettings", void 0);
    __decorate9([
      Complex({}, ZoomSettings)
    ], Maps2.prototype, "zoomSettings", void 0);
    __decorate9([
      Complex({}, LegendSettings)
    ], Maps2.prototype, "legendSettings", void 0);
    __decorate9([
      Collection([], LayerSettings)
    ], Maps2.prototype, "layers", void 0);
    __decorate9([
      Collection([], Annotation)
    ], Maps2.prototype, "annotations", void 0);
    __decorate9([
      Complex({}, Margin)
    ], Maps2.prototype, "margin", void 0);
    __decorate9([
      Complex({ color: "#DDDDDD", width: 0 }, Border)
    ], Maps2.prototype, "border", void 0);
    __decorate9([
      Property("Material")
    ], Maps2.prototype, "theme", void 0);
    __decorate9([
      Property("Mercator")
    ], Maps2.prototype, "projectionType", void 0);
    __decorate9([
      Property(0)
    ], Maps2.prototype, "baseLayerIndex", void 0);
    __decorate9([
      Property(null)
    ], Maps2.prototype, "description", void 0);
    __decorate9([
      Property(0)
    ], Maps2.prototype, "tabIndex", void 0);
    __decorate9([
      Complex({ latitude: null, longitude: null }, CenterPosition)
    ], Maps2.prototype, "centerPosition", void 0);
    __decorate9([
      Complex({}, MapsAreaSettings)
    ], Maps2.prototype, "mapsArea", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "load", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "beforePrint", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "loaded", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "click", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "onclick", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "doubleClick", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "rightClick", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "resize", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "tooltipRender", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "legendRendering", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "tooltipRenderComplete", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "shapeSelected", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "itemSelection", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "itemHighlight", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "shapeHighlight", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "layerRendering", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "shapeRendering", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "markerRendering", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "markerClusterRendering", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "markerClick", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "markerDragStart", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "markerDragEnd", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "markerClusterClick", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "markerClusterMouseMove", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "markerMouseMove", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "mouseMove", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "dataLabelRendering", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "bubbleRendering", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "bubbleClick", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "bubbleMouseMove", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "animationComplete", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "annotationRendering", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "zoom", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "pan", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "panComplete", void 0);
    __decorate9([
      Event2()
    ], Maps2.prototype, "zoomComplete", void 0);
    Maps2 = __decorate9([
      NotifyPropertyChanges
    ], Maps2);
    return Maps2;
  })(Component)
);

// node_modules/@syncfusion/ej2-maps/src/maps/layers/bubble.js
var Bubble = (
  /** @class */
  (function() {
    function Bubble2(maps) {
      this.id = "";
      this.maps = maps;
      this.bubbleCollection = [];
    }
    Bubble2.prototype.renderBubble = function(bubbleSettings, shapeData, color, range, bubbleIndex, dataIndex, layerIndex, layer, group, bubbleID) {
      var _this = this;
      var layerData = layer.layerData;
      var colorValuePath = bubbleSettings.colorValuePath;
      var equalValue = !isNullOrUndefined(colorValuePath) ? colorValuePath.indexOf(".") > -1 ? getValueFromObject(shapeData, bubbleSettings.colorValuePath) : shapeData[colorValuePath] : shapeData[colorValuePath];
      var colorValue = !isNullOrUndefined(colorValuePath) ? colorValuePath.indexOf(".") > -1 ? Number(getValueFromObject(shapeData, bubbleSettings.colorValuePath)) : Number(shapeData[colorValuePath]) : Number(shapeData[colorValuePath]);
      var bubbleValue = !isNullOrUndefined(bubbleSettings.valuePath) ? bubbleSettings.valuePath.indexOf(".") > -1 ? Number(getValueFromObject(shapeData, bubbleSettings.valuePath)) : Number(shapeData[bubbleSettings.valuePath]) : Number(shapeData[bubbleSettings.valuePath]);
      var opacity;
      var bubbleColor;
      if (isNaN(bubbleValue) && isNaN(colorValue) && isNullOrUndefined(equalValue)) {
        return null;
      }
      var radius = getRatioOfBubble(bubbleSettings.minRadius, bubbleSettings.maxRadius, bubbleValue, range.min, range.max);
      var colorMapping = new ColorMapping(this.maps);
      var shapeColor = colorMapping.getColorByValue(bubbleSettings.colorMapping, colorValue, equalValue);
      bubbleColor = Object.prototype.toString.call(shapeColor) === "[object Object]" && !isNullOrUndefined(shapeColor["fill"]) ? shapeColor["fill"] : color;
      opacity = Object.prototype.toString.call(shapeColor) === "[object Object]" && !isNullOrUndefined(shapeColor["opacity"]) ? shapeColor["opacity"] : bubbleSettings.opacity;
      var shapePoints = [[]];
      this.maps.translateType = "bubble";
      var midIndex = 0;
      var pointsLength = 0;
      var currentLength = 0;
      for (var i = 0, len = layerData.length; i < len; i++) {
        var shape = layerData[i];
        shape = shape["property"];
        var shapePath = checkPropertyPath(shapeData[layer.shapeDataPath], layer.shapePropertyPath, shape);
        var shapeDataLayerPathValue = !isNullOrUndefined(shapeData[layer.shapeDataPath]) && isNaN(shapeData[layer.shapeDataPath]) ? shapeData[layer.shapeDataPath].toLowerCase() : shapeData[layer.shapeDataPath];
        var shapePathValue = !isNullOrUndefined(shape[shapePath]) && isNaN(shape[shapePath]) ? shape[shapePath].toLowerCase() : shape[shapePath];
        if (shapeDataLayerPathValue === shapePathValue && (layerData[i].type !== "LineString" && layerData[i].type !== "MultiLineString" && layerData[i]["type"] !== "Point" && layerData[i]["type"] !== "MultiPoint")) {
          if (!layerData[i]["_isMultiPolygon"]) {
            shapePoints.push(this.getPoints(layerData[i], []));
            currentLength = shapePoints[shapePoints.length - 1].length;
            if (pointsLength < currentLength) {
              pointsLength = currentLength;
              midIndex = shapePoints.length - 1;
            }
          } else {
            var layer_1 = layerData[i];
            for (var j = 0; j < layer_1.length; j++) {
              shapePoints.push(this.getPoints(layer_1[j], []));
              currentLength = shapePoints[shapePoints.length - 1].length;
              if (pointsLength < currentLength) {
                pointsLength = currentLength;
                midIndex = shapePoints.length - 1;
              }
            }
          }
        }
      }
      var projectionType = this.maps.projectionType;
      var centerY;
      var eventArgs;
      var bubbleBorder = {
        color: bubbleSettings.border.color,
        opacity: bubbleSettings.border.opacity,
        width: bubbleSettings.border.width
      };
      var center = findMidPointOfPolygon(shapePoints[midIndex], projectionType, layer.geometryType);
      if (bubbleSettings.visible) {
        if (!isNullOrUndefined(center)) {
          centerY = this.maps.projectionType === "Mercator" ? center["y"] : -center["y"];
          eventArgs = {
            cancel: false,
            name: bubbleRendering,
            border: bubbleBorder,
            cx: center["x"],
            cy: centerY,
            data: shapeData,
            fill: bubbleColor,
            maps: this.maps,
            radius
          };
        } else {
          var shapePointsLength = shapePoints.length - 1;
          if (shapePoints[shapePointsLength]["x"] && shapePoints[shapePointsLength]["y"]) {
            eventArgs = {
              cancel: false,
              name: bubbleRendering,
              border: bubbleBorder,
              cx: shapePoints[shapePointsLength]["x"],
              cy: shapePoints[shapePointsLength]["y"],
              data: shapeData,
              fill: bubbleColor,
              maps: this.maps,
              radius
            };
          } else {
            return;
          }
        }
        this.maps.trigger("bubbleRendering", eventArgs, function(bubbleArgs) {
          if (eventArgs.cancel) {
            return;
          }
          var bubbleElement;
          eventArgs.border.opacity = isNullOrUndefined(eventArgs.border.opacity) ? opacity : eventArgs.border.opacity;
          if (bubbleSettings.bubbleType === "Circle") {
            var circle = new CircleOption(bubbleID, eventArgs.fill, eventArgs.border, opacity, 0, 0, eventArgs.radius, null);
            bubbleElement = drawCircle(_this.maps, circle, group);
          } else {
            var y = _this.maps.projectionType === "Mercator" ? eventArgs.cy - radius : eventArgs.cy + radius;
            var rectangle = new RectOption(bubbleID, eventArgs.fill, eventArgs.border, opacity, new Rect2(0, 0, radius * 2, radius * 2), 2, 2);
            eventArgs.cx -= radius;
            eventArgs.cy = y;
            bubbleElement = drawRectangle(_this.maps, rectangle, group);
          }
          maintainSelection(_this.maps.selectedBubbleElementId, _this.maps.bubbleSelectionClass, bubbleElement, "BubbleselectionMapStyle");
          _this.bubbleCollection.push({
            LayerIndex: layerIndex,
            BubbleIndex: bubbleIndex,
            DataIndex: dataIndex,
            element: bubbleElement,
            center: { x: eventArgs.cx, y: eventArgs.cy }
          });
          var translate;
          var animate2 = layer.animationDuration !== 0 || animationMode === "Enable" || isNullOrUndefined(_this.maps.zoomModule);
          if (_this.maps.zoomSettings.zoomFactor > 1 && !isNullOrUndefined(_this.maps.zoomModule) && !_this.maps.isTileMap) {
            translate = getZoomTranslate(_this.maps, layer, animate2);
          } else {
            translate = getTranslate(_this.maps, layer, animate2);
          }
          var bubbleDataSource = bubbleSettings.dataSource;
          var scale = translate["scale"];
          var transPoint = translate["location"];
          var position = new MapLocation(_this.maps.isTileMap ? (eventArgs.cx + _this.maps.translatePoint.x) * _this.maps.tileZoomLevel : (eventArgs.cx + transPoint.x) * scale, _this.maps.isTileMap ? (eventArgs.cy + _this.maps.translatePoint.y) * _this.maps.tileZoomLevel : (eventArgs.cy + transPoint.y) * scale);
          bubbleElement.setAttribute("transform", "translate( " + position.x + " " + position.y + " )");
          var bubble = bubbleDataSource.length - 1 === dataIndex ? "bubble" : null;
          if (bubbleSettings.bubbleType === "Square") {
            position.x += radius;
            position.y += radius * (_this.maps.projectionType === "Mercator" ? 1 : -1);
          } else {
            radius = 0;
          }
          if (bubbleSettings.animationDuration > 0 || animationMode === "Enable") {
            elementAnimate(bubbleElement, bubbleSettings.animationDelay, bubbleSettings.animationDuration, position, _this.maps, bubble, radius);
          }
        });
      }
    };
    Bubble2.prototype.getPoints = function(shape, points) {
      if (isNullOrUndefined(shape.map)) {
        points = shape["point"];
      } else {
        shape.map(function(current) {
          points.push(new Point(current["point"]["x"], current["point"]["y"]));
        });
      }
      return points;
    };
    Bubble2.prototype.bubbleClick = function(e) {
      var target = e.target.id;
      if (target.indexOf("_LayerIndex_") === -1) {
        return;
      }
      var data = this.getbubble(target);
      if (isNullOrUndefined(data)) {
        return;
      }
      var eventArgs = {
        cancel: false,
        name: bubbleClick,
        data,
        maps: this.maps,
        target,
        x: e.clientX,
        y: e.clientY
      };
      this.maps.trigger(bubbleClick, eventArgs);
    };
    Bubble2.prototype.getbubble = function(target) {
      var id = target.split("_LayerIndex_");
      var index = parseInt(id[1].split("_")[0], 10);
      var data;
      if (target.indexOf("_BubbleIndex_") > -1) {
        var layer = this.maps.layers[index];
        var bubbleIndex = parseInt(id[1].split("_BubbleIndex_")[1], 10);
        var dataIndex = parseInt(id[1].split("_BubbleIndex_")[1].split("_dataIndex_")[1], 10);
        if (!isNaN(bubbleIndex)) {
          data = layer.bubbleSettings[bubbleIndex].dataSource[dataIndex];
          return data;
        }
      }
      return null;
    };
    Bubble2.prototype.bubbleMove = function(e) {
      var target = e.target.id;
      if (target.indexOf("_LayerIndex_") === -1) {
        return;
      }
      var data = this.getbubble(target);
      if (isNullOrUndefined(data)) {
        return;
      }
      var eventArgs = {
        cancel: false,
        name: bubbleMouseMove,
        data,
        maps: this.maps,
        target,
        x: e.clientX,
        y: e.clientY
      };
      this.maps.trigger(bubbleMouseMove, eventArgs);
    };
    Bubble2.prototype.getModuleName = function() {
      return "Bubble";
    };
    Bubble2.prototype.destroy = function() {
      this.bubbleCollection = [];
      this.maps = null;
    };
    return Bubble2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/layers/marker.js
var Marker = (
  /** @class */
  (function() {
    function Marker2(maps) {
      this.maps = maps;
      this.sameMarkerData = [];
      this.initialMarkerCluster = [];
      this.zoomedMarkerCluster = [];
    }
    Marker2.prototype.getMapsInstance = function() {
      return this.maps;
    };
    Marker2.prototype.markerRender = function(maps, layerElement, layerIndex, factor, type) {
      var _this = this;
      var templateFn;
      var markerCount = 0;
      var nullCount = 0;
      var isMarkerTemplateNewCreation = false;
      var markerTemplateCount = 0;
      maps.translateType = "marker";
      var currentLayer = maps.layersCollection[layerIndex];
      var markerElement = layerElement.querySelectorAll("#" + maps.element.id + "_Markers_Group");
      if (markerElement.length > 0) {
        this.markerSVGObject = markerElement[0];
        this.markerSVGObject.innerHTML = "";
        isMarkerTemplateNewCreation = true;
      } else {
        this.markerSVGObject = maps.renderer.createGroup({
          id: maps.element.id + "_Markers_Group",
          class: "GroupElement"
        });
      }
      this.markerSVGObject.style.pointerEvents = "auto";
      var secondaryElement = getElementByID(maps.element.id + "_Secondary_Element");
      var markerTemplateElement = secondaryElement.querySelectorAll("#" + maps.element.id + "_LayerIndex_" + layerIndex + "_Markers_Template_Group");
      var markerTemplateEle;
      if (markerTemplateElement && markerTemplateElement.length > 0 && markerTemplateElement[0].childElementCount > 0) {
        markerTemplateEle = getElementByID(maps.element.id + "_LayerIndex_" + layerIndex + "_Markers_Template_Group");
        markerTemplateEle.innerHTML = "";
        isMarkerTemplateNewCreation = true;
      } else {
        markerTemplateEle = createElement("div", {
          id: maps.element.id + "_LayerIndex_" + layerIndex + "_Markers_Template_Group",
          className: maps.element.id + "_template"
        });
        markerTemplateEle.style.cssText = "overflow: hidden; position: absolute;pointer-events: none;top:" + maps.mapAreaRect.y + "px;left:" + maps.mapAreaRect.x + "px;height:" + maps.mapAreaRect.height + "px;width:" + maps.mapAreaRect.width + "px;";
      }
      var allowInnerClusterSetting = this.allowInnerClusterSetting(currentLayer);
      var allowAnimation = currentLayer.animationDuration !== 0 || animationMode === "Enable" || isNullOrUndefined(maps.zoomModule);
      var translatePoint;
      if (!maps.isTileMap) {
        translatePoint = !isNullOrUndefined(maps.zoomModule) && maps.zoomSettings.zoomFactor > 1 ? getZoomTranslate(maps, currentLayer, allowAnimation) : getTranslate(maps, currentLayer, allowAnimation);
      }
      Array.prototype.forEach.call(currentLayer.markerSettings, function(markerSettings, markerIndex) {
        var markerData = markerSettings.dataSource;
        markerCount = 0;
        if (!isNullOrUndefined(markerSettings.dataSource)) {
          Array.prototype.forEach.call(markerData, function(data, dataIndex) {
            maps.markerNullCount = markerIndex > 0 && dataIndex === 0 ? 0 : maps.markerNullCount;
            var eventArgs = {
              cancel: false,
              name: markerRendering,
              fill: markerSettings.fill,
              height: !isNullOrUndefined(markerSettings.heightValuePath) && !isNullOrUndefined(data[markerSettings.heightValuePath]) ? data[markerSettings.heightValuePath] : markerSettings.height,
              width: !isNullOrUndefined(markerSettings.widthValuePath) && !isNullOrUndefined(data[markerSettings.widthValuePath]) ? data[markerSettings.widthValuePath] : markerSettings.width,
              imageUrl: markerSettings.imageUrl,
              shape: markerSettings.shape,
              template: markerSettings.template,
              data,
              maps,
              marker: markerSettings,
              border: markerSettings.border,
              colorValuePath: markerSettings.colorValuePath,
              shapeValuePath: markerSettings.shapeValuePath,
              imageUrlValuePath: markerSettings.imageUrlValuePath
            };
            maps.trigger("markerRendering", eventArgs, function(MarkerArgs) {
              eventArgs = markerColorChoose(eventArgs, data);
              eventArgs = markerShapeChoose(eventArgs, data);
              var lng = !isNullOrUndefined(markerSettings.longitudeValuePath) ? Number(getValueFromObject(data, markerSettings.longitudeValuePath)) : !isNullOrUndefined(data["longitude"]) ? parseFloat(data["longitude"]) : !isNullOrUndefined(data["Longitude"]) ? parseFloat(data["Longitude"]) : null;
              var lat = !isNullOrUndefined(markerSettings.latitudeValuePath) ? Number(getValueFromObject(data, markerSettings.latitudeValuePath)) : !isNullOrUndefined(data["latitude"]) ? parseFloat(data["latitude"]) : !isNullOrUndefined(data["Latitude"]) ? parseFloat(data["Latitude"]) : null;
              var offset = markerSettings.offset;
              if (!eventArgs.cancel && markerSettings.visible && !isNullOrUndefined(lng) && !isNullOrUndefined(lat)) {
                var markerID = maps.element.id + "_LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex + "_dataIndex_" + dataIndex;
                var location_1 = maps.isTileMap ? convertTileLatLongToPoint(new MapLocation(lng, lat), factor, maps.tileTranslatePoint, true) : convertGeoToPoint(lat, lng, factor, currentLayer, maps);
                if (maps.isTileMap) {
                  translatePoint = currentLayer.type === "SubLayer" && isNullOrUndefined(maps.zoomModule) ? location_1 = convertTileLatLongToPoint(new MapLocation(lng, lat), maps.tileZoomLevel, maps.tileTranslatePoint, true) : new Object();
                }
                var scale = type === "AddMarker" ? maps.scale : translatePoint["scale"];
                var transPoint = type === "AddMarker" ? maps.translatePoint : translatePoint["location"];
                if (eventArgs.template && (!isNaN(location_1.x) && !isNaN(location_1.y))) {
                  isMarkerTemplateNewCreation = false;
                  markerTemplateCount++;
                  markerTemplate(eventArgs, templateFn, markerID, data, markerIndex, markerTemplateEle, location_1, transPoint, scale, offset, maps);
                  maps.renderReactTemplates();
                } else if (!eventArgs.template && (!isNaN(location_1.x) && !isNaN(location_1.y))) {
                  isMarkerTemplateNewCreation = true;
                  markerCount++;
                  marker(eventArgs, markerSettings, markerData, dataIndex, location_1, transPoint, markerID, offset, scale, maps, _this.markerSVGObject);
                }
              }
              nullCount += !isNaN(lat) && !isNaN(lng) ? 0 : 1;
              markerTemplateCount += eventArgs.cancel ? 1 : 0;
              markerCount += eventArgs.cancel ? 1 : 0;
              maps.markerNullCount = isNullOrUndefined(lng) || isNullOrUndefined(lat) ? maps.markerNullCount + 1 : maps.markerNullCount;
              var markerDataLength = markerData.length - maps.markerNullCount;
              var isMarkersClustered = false;
              var markerGroup = markerSettings.clusterSettings.allowClustering || currentLayer.markerClusterSettings.allowClustering && currentLayer.markerSettings.length > 1 ? _this.markerSVGObject.querySelectorAll("[id*='LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex + "']:not([id*='_Group'])") : _this.markerSVGObject.childNodes;
              var templateCount = _this.markerSVGObject.childNodes === markerGroup ? markerTemplateCount : 0;
              if (markerGroup.length === markerDataLength - templateCount - nullCount && type !== "Template") {
                if (markerElement.length === 0) {
                  layerElement.appendChild(_this.markerSVGObject);
                }
                if (markerSettings.clusterSettings.allowClustering || !allowInnerClusterSetting && currentLayer.markerClusterSettings.allowClustering) {
                  if (markerElement.length === 0) {
                    maps.svgObject.appendChild(_this.markerSVGObject);
                    maps.element.appendChild(maps.svgObject);
                  }
                  if (currentLayer.urlTemplate.indexOf("openstreetmap") !== -1 && isNullOrUndefined(currentLayer.shapeData) && maps.zoomSettings.enable) {
                    isMarkersClustered = clusterTemplate(currentLayer, _this.markerSVGObject, maps, layerIndex, markerIndex, _this.markerSVGObject, layerElement, true, false, null, allowInnerClusterSetting);
                    if (markerElement.length === 0) {
                      layerElement.appendChild(_this.markerSVGObject);
                    }
                  } else {
                    isMarkersClustered = clusterTemplate(currentLayer, _this.markerSVGObject, maps, layerIndex, markerIndex, _this.markerSVGObject, layerElement, true, false, translatePoint, allowInnerClusterSetting);
                  }
                  maps.renderReactTemplates();
                }
              }
              var markerTemplateGroup = markerSettings.clusterSettings.allowClustering || currentLayer.markerClusterSettings.allowClustering && currentLayer.markerSettings.length > 1 ? markerTemplateEle.querySelectorAll("[id*='LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex + "']:not([id*='_Group'])") : markerTemplateEle.childNodes;
              if (markerTemplateGroup.length === markerDataLength - markerCount - nullCount && getElementByID(maps.element.id + "_Secondary_Element")) {
                if (!isMarkerTemplateNewCreation) {
                  getElementByID(maps.element.id + "_Secondary_Element").appendChild(markerTemplateEle);
                }
                if (maps.checkInitialRender) {
                  if ((markerSettings.clusterSettings.allowClustering || !allowInnerClusterSetting && currentLayer.markerClusterSettings.allowClustering) && !isMarkersClustered) {
                    clusterTemplate(currentLayer, markerTemplateEle, maps, layerIndex, markerIndex, _this.markerSVGObject, layerElement, false, false, translatePoint, allowInnerClusterSetting);
                    maps.renderReactTemplates();
                  }
                }
                if (currentLayer.markerClusterSettings.allowClustering && markerElement.length > 0) {
                  var layerCollectionEle = getElementByID(maps.element.id + "_Layer_Collections");
                  layerCollectionEle.appendChild(layerElement);
                }
              }
            });
          });
        }
      });
    };
    Marker2.prototype.calculateIndividualLayerMarkerZoomLevel = function(mapWidth, mapHeight, maxZoomFact) {
      var latZoom;
      var lngZoom;
      var height = Math.abs(this.maps.baseMapBounds.latitude.max - this.maps.baseMapBounds.latitude.min);
      var width = Math.abs(this.maps.baseMapBounds.longitude.max - this.maps.baseMapBounds.longitude.min);
      latZoom = Math.floor(Math.log(mapHeight / height));
      latZoom = latZoom > maxZoomFact ? maxZoomFact : latZoom;
      lngZoom = Math.floor(Math.log(mapWidth / width));
      lngZoom = lngZoom > maxZoomFact ? maxZoomFact : lngZoom;
      var result = Math.min(latZoom, lngZoom);
      var scaleFactor = Math.min(result, maxZoomFact - 1);
      if (!this.maps.isTileMap) {
        compareZoomFactor(scaleFactor, this.maps);
      }
      return scaleFactor;
    };
    Marker2.prototype.calculateZoomCenterPositionAndFactor = function(layersCollection) {
      if (!isNullOrUndefined(this.maps)) {
        if (this.maps.zoomSettings.shouldZoomInitially && this.maps.markerModule) {
          var minLong_1;
          var maxLat_1;
          var minLat_1;
          var maxLong_1;
          var zoomLevel = void 0;
          var centerLat = void 0;
          var centerLong = void 0;
          var maxZoomFact = this.maps.zoomSettings.maxZoom;
          var mapWidth = this.maps.mapAreaRect.width;
          var mapHeight = this.maps.mapAreaRect.height;
          this.maps.markerZoomedState = this.maps.markerZoomedState ? this.maps.markerZoomedState : isNullOrUndefined(this.maps.markerZoomFactor) ? !this.maps.markerZoomedState : this.maps.markerZoomFactor > 1 ? this.maps.markerZoomedState : !this.maps.markerZoomedState;
          this.maps.defaultState = this.maps.markerZoomedState ? !this.maps.markerZoomedState : this.maps.defaultState;
          Array.prototype.forEach.call(layersCollection, function(currentLayer) {
            var isMarker = currentLayer.markerSettings.length !== 0;
            if (isMarker) {
              Array.prototype.forEach.call(currentLayer.markerSettings, function(markerSetting) {
                var markerData = markerSetting.dataSource;
                if (!isNullOrUndefined(markerData) && markerData.length > 0) {
                  Array.prototype.forEach.call(markerData, function(data, dataIndex) {
                    var latitude = !isNullOrUndefined(data["latitude"]) ? parseFloat(data["latitude"]) : !isNullOrUndefined(data["Latitude"]) ? parseFloat(data["Latitude"]) : null;
                    var longitude = !isNullOrUndefined(data["longitude"]) ? parseFloat(data["longitude"]) : !isNullOrUndefined(data["Longitude"]) ? parseFloat(data["Longitude"]) : null;
                    if (!isNullOrUndefined(latitude) && !isNullOrUndefined(longitude)) {
                      minLong_1 = isNullOrUndefined(minLong_1) && dataIndex === 0 ? longitude : minLong_1;
                      maxLat_1 = isNullOrUndefined(maxLat_1) && dataIndex === 0 ? latitude : maxLat_1;
                      minLat_1 = isNullOrUndefined(minLat_1) && dataIndex === 0 ? latitude : minLat_1;
                      maxLong_1 = isNullOrUndefined(maxLong_1) && dataIndex === 0 ? longitude : maxLong_1;
                      if (minLong_1 > longitude) {
                        minLong_1 = longitude;
                      }
                      if (minLat_1 > latitude) {
                        minLat_1 = latitude;
                      }
                      if (maxLong_1 < longitude) {
                        maxLong_1 = longitude;
                      }
                      if (maxLat_1 < latitude) {
                        maxLat_1 = latitude;
                      }
                    }
                  });
                }
              });
            }
          });
          if (!isNullOrUndefined(minLat_1) && !isNullOrUndefined(minLong_1) && !isNullOrUndefined(maxLong_1) && !isNullOrUndefined(maxLat_1)) {
            centerLat = (minLat_1 + maxLat_1) / 2;
            centerLong = (minLong_1 + maxLong_1) / 2;
            this.maps.markerCenterLatitude = centerLat;
            this.maps.markerCenterLongitude = centerLong;
            if (isNullOrUndefined(this.maps.markerZoomCenterPoint) || this.maps.markerZoomedState) {
              this.maps.markerZoomCenterPoint = {
                latitude: centerLat,
                longitude: centerLong
              };
            }
            var markerFactor = void 0;
            if (this.maps.isTileMap || this.maps.baseMapRectBounds["min"]["x"] === 0) {
              zoomLevel = calculateZoomLevel(minLat_1, maxLat_1, minLong_1, maxLong_1, mapWidth, mapHeight, this.maps, false);
              if (this.maps.isTileMap) {
                markerFactor = isNullOrUndefined(this.maps.markerZoomFactor) ? zoomLevel : isNullOrUndefined(this.maps.mapScaleValue) ? zoomLevel : this.maps.mapScaleValue > 1 && this.maps.markerZoomFactor !== 1 ? this.maps.mapScaleValue : zoomLevel;
              } else {
                markerFactor = isNullOrUndefined(this.maps.mapScaleValue) ? zoomLevel : Math.floor(this.maps.scale) !== 1 && this.maps.mapScaleValue !== zoomLevel && isNullOrUndefined(this.maps.shouldZoomCurrentFactor) ? this.maps.mapScaleValue : zoomLevel;
                if (markerFactor === this.maps.mapScaleValue && (this.maps.markerZoomFactor === 1 || this.maps.mapScaleValue === 1) && !this.maps.enablePersistence) {
                  markerFactor = zoomLevel;
                }
              }
            } else {
              zoomLevel = this.calculateIndividualLayerMarkerZoomLevel(mapWidth, mapHeight, maxZoomFact);
              markerFactor = isNullOrUndefined(this.maps.mapScaleValue) ? zoomLevel : this.maps.mapScaleValue !== zoomLevel ? this.maps.mapScaleValue : zoomLevel;
            }
            this.maps.markerZoomFactor = markerFactor;
          }
        } else {
          this.maps.markerZoomedState = false;
          if (this.maps.markerZoomFactor > 1) {
            this.maps.markerCenterLatitude = null;
            this.maps.markerCenterLongitude = null;
            this.maps.markerZoomFactor = 1;
            if (!this.maps.enablePersistence) {
              this.maps.mapScaleValue = 1;
            }
          }
          if (this.maps.isTileMap && !this.maps.enablePersistence && this.maps.mapScaleValue <= 1) {
            this.maps.tileZoomLevel = this.maps.mapScaleValue === 0 ? this.maps.isZoomByPosition ? this.maps.tileZoomLevel : 1 : this.maps.mapScaleValue;
            if (this.maps.mapScaleValue === 1 && this.maps.markerZoomFactor === 1 && !isNullOrUndefined(this.maps.tileTranslatePoint)) {
              this.maps.tileTranslatePoint.x = 0;
              this.maps.tileTranslatePoint.y = 0;
            }
          }
        }
      }
    };
    Marker2.prototype.markerClick = function(e) {
      var target = e.target.id;
      if (target.indexOf(this.maps.element.id) === -1) {
        var ancestor = e.target.closest("." + this.maps.element.id + "_marker_template_element");
        if (!isNullOrUndefined(ancestor) && ancestor.id.indexOf("_MarkerIndex_") > -1) {
          target = ancestor.id;
        }
      }
      if (target.indexOf("_LayerIndex_") === -1 || target.indexOf("_cluster_") > 0) {
        return;
      }
      var options = this.getMarker(target);
      if (isNullOrUndefined(options)) {
        return;
      }
      if (options.marker.enableDrag) {
        document.getElementById(this.maps.element.id + "_svg").style.cursor = "grabbing";
      }
      var eventArgs = {
        cancel: false,
        name: markerClick,
        data: options.data,
        maps: this.maps,
        marker: options.marker,
        target,
        x: e.clientX,
        y: e.clientY,
        latitude: options.data["latitude"] || options.data["Latitude"],
        longitude: options.data["longitude"] || options.data["Longitude"],
        value: options.data["name"]
      };
      this.maps.trigger(markerClick, eventArgs);
      if (options.marker.enableDrag) {
        var isCluster = false;
        var layerIndex = parseInt(target.split("_LayerIndex_")[1].split("_")[0], 10);
        var markerIndex = parseInt(target.split("_MarkerIndex_")[1].split("_")[0], 10);
        var dataIndex_1 = parseInt(target.split("_dataIndex_")[1].split("_")[0], 10);
        var marker_1 = this.maps.layers[layerIndex].markerSettings[markerIndex];
        if (this.sameMarkerData.length > 0) {
          isCluster = this.sameMarkerData[0].data.filter(function(el) {
            return el["index"] === dataIndex_1;
          }).length > 0 && this.sameMarkerData[0].layerIndex === layerIndex && this.sameMarkerData[0].markerIndex === markerIndex;
        }
        if (!isCluster) {
          var dragEventArgs = {
            name: markerDragStart,
            x: e.clientX,
            y: e.clientY,
            latitude: options.data["latitude"] || options.data["Latitude"],
            longitude: options.data["longitude"] || options.data["Longitude"],
            layerIndex,
            markerIndex,
            dataIndex: dataIndex_1
          };
          this.maps.trigger(markerDragStart, dragEventArgs);
          this.maps.markerDragArgument = {
            targetId: target,
            x: e.clientX,
            y: e.clientY,
            latitude: options.data["latitude"] || options.data["Latitude"],
            longitude: options.data["longitude"] || options.data["Longitude"],
            shape: isNullOrUndefined(marker_1.shapeValuePath) ? marker_1.shape : marker_1.dataSource[dataIndex_1][marker_1.shapeValuePath],
            layerIndex,
            markerIndex,
            dataIndex: dataIndex_1
          };
        }
      }
    };
    Marker2.prototype.markerClusterClick = function(e) {
      var target = e.target.id;
      if (target.indexOf("_LayerIndex_") === -1 || target.indexOf("_cluster_") === -1) {
        return;
      }
      var options = this.getMarker(target);
      if (isNullOrUndefined(options)) {
        return;
      }
      if (options.clusterCollection.length > 0 && this.maps.markerClusterExpand) {
        if (getElement2(this.maps.element.id + "_mapsTooltip") && this.maps.mapsTooltipModule.tooltipTargetID.indexOf("_MarkerIndex_") > -1) {
          removeElement2(this.maps.element.id + "_mapsTooltip");
        }
        if (this.sameMarkerData.length > 0 && !this.maps.markerClusterExpandCheck) {
          this.maps.markerClusterExpandCheck = true;
          mergeSeparateCluster(this.sameMarkerData, this.maps);
        } else {
          this.sameMarkerData = options.clusterCollection;
          this.maps.markerClusterExpandCheck = false;
          clusterSeparate(this.sameMarkerData, this.maps, this.markerSVGObject, true);
        }
      }
      var eventArgs = {
        cancel: false,
        name: markerClusterClick,
        data: options,
        maps: this.maps,
        target,
        x: e.clientX,
        y: e.clientY,
        latitude: options.data["latitude"] || options.data["Latitude"],
        longitude: options.data["longitude"] || options.data["Longitude"],
        markerClusterCollection: options["markCollection"]
      };
      this.maps.trigger(markerClusterClick, eventArgs);
    };
    Marker2.prototype.getMarker = function(target) {
      var id = target.split("_LayerIndex_");
      var index = parseInt(id[1].split("_")[0], 10);
      var layer = this.maps.layers[index];
      var data;
      var markCollection = [];
      var clusterCollection = [];
      var marker2;
      if (target.indexOf("_MarkerIndex_") > -1) {
        var markerIndex = parseInt(id[1].split("_MarkerIndex_")[1].split("_")[0], 10);
        var dataIndex = parseInt(id[1].split("_dataIndex_")[1].split("_")[0], 10);
        marker2 = layer.markerSettings[markerIndex];
        var allowInnerClusterSetting = this.allowInnerClusterSetting(layer);
        this.maps.markerClusterExpand = !allowInnerClusterSetting && layer.markerClusterSettings.allowClustering ? layer.markerClusterSettings.allowClusterExpand : marker2.clusterSettings.allowClusterExpand;
        if (!isNaN(markerIndex)) {
          data = marker2.dataSource[dataIndex];
          var collection_1 = [];
          if (!marker2.template && target.indexOf("_cluster_") > -1 && this.maps.markerClusterExpand) {
            Array.prototype.forEach.call(marker2.dataSource, function(location2, index2) {
              if (location2["latitude"] === data["latitude"] && location2["longitude"] === data["longitude"]) {
                collection_1.push({ data, index: index2 });
              }
            });
          }
          if (target.indexOf("_cluster_") > -1) {
            var isClusterSame = false;
            var cluster = !allowInnerClusterSetting && layer.markerClusterSettings.allowClustering ? layer.markerClusterSettings : layer.markerSettings[markerIndex].clusterSettings;
            var clusterElement = document.getElementById(target.indexOf("_datalabel_") > -1 ? cluster.shape === "Balloon" ? target.split("_datalabel_")[0] + "_Group" : target.split("_datalabel_")[0] : cluster.shape === "Balloon" ? target + "_Group" : target);
            var indexes = cluster.shape === "Balloon" ? clusterElement.children[0].textContent.split(",").map(Number) : clusterElement.textContent.split(",").map(Number);
            collection_1 = [];
            for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
              var i = indexes_1[_i];
              collection_1.push({ data: marker2.dataSource[i], index: i });
              markCollection.push(marker2.dataSource[i]);
            }
            isClusterSame = false;
            clusterCollection.push({
              data: collection_1,
              layerIndex: index,
              markerIndex,
              dataIndex,
              targetClusterIndex: +(target.split("_cluster_")[1].indexOf("_datalabel_") > -1 ? target.split("_cluster_")[1].split("_datalabel_")[0] : target.split("_cluster_")[1]),
              isClusterSame
            });
          }
          return { marker: marker2, data, clusterCollection, markCollection };
        }
      }
      return null;
    };
    Marker2.prototype.markerMove = function(e) {
      var targetId = e.target.id;
      if (targetId.indexOf("_LayerIndex_") === -1 || targetId.indexOf("_cluster_") > 0) {
        return;
      }
      var options = this.getMarker(targetId);
      if (isNullOrUndefined(options)) {
        return;
      }
      if (options.marker.enableDrag) {
        document.getElementById(this.maps.element.id + "_svg").style.cursor = isNullOrUndefined(this.maps.markerDragArgument) ? "pointer" : "grabbing";
      }
      var eventArgs = {
        cancel: false,
        name: markerMouseMove,
        data: options.data,
        maps: this.maps,
        target: targetId,
        x: e.clientX,
        y: e.clientY
      };
      this.maps.trigger(markerMouseMove, eventArgs);
    };
    Marker2.prototype.markerClusterMouseMove = function(e) {
      var targetId = e.target.id;
      if (targetId.indexOf("_LayerIndex_") === -1 || targetId.indexOf("_cluster_") === -1) {
        return;
      }
      var options = this.getMarker(targetId);
      if (this.maps.markerClusterExpand) {
        e.target.style.cursor = "pointer";
      }
      if (isNullOrUndefined(options)) {
        return;
      }
      var eventArgs = {
        cancel: false,
        name: markerClusterMouseMove,
        data: options.data,
        maps: this.maps,
        target: targetId,
        x: e.clientX,
        y: e.clientY
      };
      this.maps.trigger(markerClusterMouseMove, eventArgs);
    };
    Marker2.prototype.allowInnerClusterSetting = function(layer) {
      var allowInnerClusterSetting = false;
      for (var markerIndex = 0; markerIndex < layer.markerSettings.length; markerIndex++) {
        if (layer.markerSettings[markerIndex].clusterSettings.allowClustering) {
          allowInnerClusterSetting = true;
          break;
        }
      }
      return allowInnerClusterSetting;
    };
    Marker2.prototype.initializeMarkerClusterList = function() {
      for (var i = 0; i < this.maps.layers.length; i++) {
        this.initialMarkerCluster[i] = [];
        this.zoomedMarkerCluster[i] = [];
      }
    };
    Marker2.prototype.getModuleName = function() {
      return "Marker";
    };
    Marker2.prototype.destroy = function() {
      this.maps = null;
      this.markerSVGObject = null;
      this.sameMarkerData = [];
      this.initialMarkerCluster = [];
      this.zoomedMarkerCluster = [];
    };
    return Marker2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/layers/polygon.js
var Polygon = (
  /** @class */
  (function() {
    function Polygon2(maps) {
    }
    Polygon2.prototype.polygonRender = function(maps, layerIndex, factor) {
      var currentLayer = maps.layersCollection[layerIndex];
      var polygonsSVGObject = maps.renderer.createGroup({
        id: maps.element.id + "_LayerIndex_" + layerIndex + "_Polygons_Group"
      });
      currentLayer.polygonSettings.polygons.map(function(polygonSetting, polygonIndex) {
        var polygonSVGObject = maps.renderer.createGroup({
          id: maps.element.id + "_LayerIndex_" + layerIndex + "_Polygons_Group_" + polygonIndex
        });
        var polygonData = polygonSetting.points;
        if (!isNullOrUndefined(polygonSetting.points) && polygonSetting.points.length > 0) {
          var path = calculatePolygonPath(maps, factor, currentLayer, polygonData);
          var pathOptions = new PathOption2(maps.element.id + "_LayerIndex_" + layerIndex + "_PolygonIndex_" + polygonIndex, polygonSetting.fill, polygonSetting.borderWidth / factor, polygonSetting.borderColor, polygonSetting.opacity, polygonSetting.borderOpacity, "", path);
          var polygonEle = maps.renderer.drawPath(pathOptions);
          maintainSelection(maps.selectedPolygonElementId, maps.polygonSelectionClass, polygonEle, "PolygonselectionMapStyle");
          polygonSVGObject.appendChild(polygonEle);
          polygonsSVGObject.appendChild(polygonSVGObject);
        }
      });
      return polygonsSVGObject;
    };
    Polygon2.prototype.getModuleName = function() {
      return "Polygon";
    };
    Polygon2.prototype.destroy = function() {
    };
    return Polygon2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/layers/data-label.js
var DataLabel = (
  /** @class */
  (function() {
    function DataLabel2(maps) {
      this.value = { rightWidth: 0, leftWidth: 0, heightTop: 0, heightBottom: 0 };
      this.maps = maps;
      this.dataLabelCollections = [];
    }
    DataLabel2.prototype.getDataLabel = function(dataSource, labelPath, shapeName, shapeDataPath) {
      var text;
      var shapeNameValue;
      for (var i = 0; i < (isNullOrUndefined(dataSource) ? 0 : dataSource.length); i++) {
        var data = dataSource[i];
        var dataShapePathValue = !isNullOrUndefined(data[shapeDataPath]) && isNaN(data[shapeDataPath]) && typeof data[shapeDataPath] === "string" ? data[shapeDataPath].toLowerCase() : data[shapeDataPath];
        shapeName = !isNullOrUndefined(shapeName) && typeof shapeName === "string" ? shapeName.toString() : shapeName;
        shapeNameValue = !isNullOrUndefined(shapeName) && typeof shapeName === "string" ? shapeName.toLowerCase() : shapeName;
        if (dataShapePathValue === shapeNameValue) {
          text = data;
          break;
        }
      }
      return text;
    };
    DataLabel2.prototype.renderLabel = function(layer, layerIndex, shape, layerData, group, labelTemplateElement, index, intersect) {
      var _this = this;
      var dataLabel = layer.dataLabelSettings;
      var style = layer.dataLabelSettings.textStyle;
      var templateFn;
      var options;
      var dataLabelSettings = layer.dataLabelSettings;
      var labelpath = layer.dataLabelSettings.labelPath;
      var shapePoint = [[]];
      var midIndex = 0;
      var pointsLength = 0;
      var shapeData = shape;
      var element;
      var rect;
      var text = "";
      var datasrcObj;
      var currentLength = 0;
      var oldIndex;
      var location2;
      var sublayerIndexLabel = false;
      var shapeProperties = shape["properties"];
      var labelId = this.maps.element.id + "_LayerIndex_" + layerIndex + "_shapeIndex_" + index + "_LabelIndex_" + index;
      var textLocation = new Point(0, 0);
      var shapes = layerData[index];
      var locationX;
      var locationY;
      style.fontFamily = this.maps.theme.toLowerCase() !== "material" ? this.maps.themeStyle.labelFontFamily : style.fontFamily;
      style.fontWeight = style.fontWeight || this.maps.themeStyle.fontWeight;
      style.size = style.size || this.maps.themeStyle.fontSize;
      shape = !isNullOrUndefined(shapes) ? shapes["property"] : null;
      var properties = Object.prototype.toString.call(layer.shapePropertyPath) === "[object Array]" ? layer.shapePropertyPath : [layer.shapePropertyPath];
      var propertyPath;
      var isPoint = false;
      var animate2 = layer.animationDuration !== 0 || animationMode === "Enable" || isNullOrUndefined(this.maps.zoomModule);
      var translate = this.maps.isTileMap ? new Object() : this.maps.zoomSettings.zoomFactor > 1 && !isNullOrUndefined(this.maps.zoomModule) ? getZoomTranslate(this.maps, layer, animate2) : getTranslate(this.maps, layer, animate2);
      var scale = this.maps.isTileMap ? this.maps.scale : translate["scale"];
      var transPoint = this.maps.isTileMap ? this.maps.translatePoint : translate["location"];
      var zoomTransPoint = this.maps.zoomTranslatePoint;
      var shapeWidth;
      var scaleZoomValue = !isNullOrUndefined(this.maps.scale) ? Math.floor(this.maps.scale) : 1;
      var zoomLabelsPosition = this.maps.zoomSettings.enable ? !isNullOrUndefined(this.maps.zoomShapeCollection) && this.maps.zoomShapeCollection.length > 0 && !this.maps.isAddLayer : this.maps.zoomSettings.enable;
      this.maps.translateType = "labels";
      for (var j = 0; j < properties.length; j++) {
        if (shapeProperties[properties[j]]) {
          propertyPath = properties[j];
          datasrcObj = this.getDataLabel(
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            layer.dataSource,
            layer.shapeDataPath,
            shapeData["properties"][propertyPath],
            layer.shapeDataPath
          );
          if (datasrcObj) {
            break;
          }
        }
      }
      datasrcObj = this.getDataLabel(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        layer.dataSource,
        layer.shapeDataPath,
        shapeData["properties"][propertyPath],
        layer.shapeDataPath
      );
      if (!isNullOrUndefined(shapes) && !isNullOrUndefined(shapes["property"])) {
        shapePoint = [[]];
        if (!layerData[index]["_isMultiPolygon"] && layerData[index]["type"] !== "Point" && layerData[index]["type"] !== "MultiPoint") {
          shapePoint.push(this.getPoint(layerData[index], []));
          currentLength = shapePoint[shapePoint.length - 1].length;
          if (pointsLength < currentLength) {
            pointsLength = currentLength;
            midIndex = shapePoint.length - 1;
          }
        } else if (layerData[index]["type"] !== "Point" && layerData[index]["type"] !== "MultiPoint") {
          var layer_1 = layerData[index];
          for (var j = 0; j < layer_1.length; j++) {
            shapePoint.push(this.getPoint(layer_1[j], []));
            currentLength = shapePoint[shapePoint.length - 1].length;
            if (pointsLength < currentLength) {
              pointsLength = currentLength;
              midIndex = shapePoint.length - 1;
            }
          }
        }
      }
      text = !isNullOrUndefined(datasrcObj) ? !isNullOrUndefined(datasrcObj[labelpath]) ? datasrcObj[labelpath].toString() : shapeData["properties"][labelpath] || datasrcObj[layer.shapeDataPath] : shapeData["properties"][labelpath];
      if (Object.prototype.toString.call(layer.shapePropertyPath) === "[object Array]" && (isNullOrUndefined(text) && (!isNullOrUndefined(layer.dataSource) && layer.dataSource["length"] === 0))) {
        for (var l = 0; l < layer.shapePropertyPath.length; l++) {
          if (shapeData["properties"][layer.shapePropertyPath[l]]) {
            text = shapeData["properties"][layer.shapePropertyPath[l]];
            break;
          }
        }
      }
      if (isNullOrUndefined(text) && (layer.dataLabelSettings.template !== "" && layer.dataSource["length"] === 0)) {
        text = shapeData["properties"][layer.shapePropertyPath];
      }
      if (isNullOrUndefined(text) && (!isNullOrUndefined(layer.dataSource) && layer.dataSource["length"] > 0)) {
        text = "";
      }
      var dataLabelText = text;
      var projectionType = this.maps.projectionType;
      if (isPoint) {
        location2 = {
          x: shapePoint[midIndex][index]["x"],
          y: shapePoint[midIndex][index]["y"],
          rightMin: 0,
          rightMax: 0,
          leftMin: 0,
          leftMax: 0,
          points: shapePoint[midIndex][index],
          topMax: 0,
          topMin: 0,
          bottomMax: 0,
          bottomMin: 0,
          height: 0
        };
      } else {
        location2 = findMidPointOfPolygon(shapePoint[midIndex], projectionType, layer.geometryType);
      }
      var firstLevelMapLocation = location2;
      if (!isNullOrUndefined(text) && !isNullOrUndefined(location2)) {
        if (zoomLabelsPosition && scaleZoomValue > 1 && !this.maps.zoomNotApplied && dataLabel.template === "") {
          if (layerIndex > 0) {
            for (var k = 0; k < this.maps.zoomLabelPositions.length; k++) {
              if (this.maps.zoomLabelPositions[k]["dataLabelText"] === text) {
                oldIndex = index;
                index = k;
                sublayerIndexLabel = true;
                break;
              }
            }
          }
          locationX = location2["x"];
          locationY = location2["y"];
          location2["x"] = (location2["x"] + zoomTransPoint["x"]) * scale;
          location2["y"] = (location2["y"] + zoomTransPoint["y"]) * scale;
        }
        location2["y"] = this.maps.projectionType === "Mercator" || layer.geometryType === "Normal" ? location2["y"] : -location2["y"];
        if (!isNullOrUndefined(this.maps.format) && !isNaN(Number(text)) && !isNaN(parseFloat(text))) {
          if (this.maps.useGroupingSeparator) {
            text = Internalize(this.maps, parseFloat(text));
            if (!isNullOrUndefined(datasrcObj)) {
              datasrcObj[labelpath] = text;
            }
          }
        }
        var eventargs_1 = {
          name: dataLabelRendering,
          maps: this.maps,
          cancel: false,
          border: {
            color: dataLabel.border.color,
            width: dataLabel.border.width,
            opacity: dataLabel.border.opacity
          },
          datalabel: dataLabel,
          fill: dataLabel.fill,
          template: dataLabel.template,
          text,
          offsetX: 0,
          offsetY: 0
        };
        this.maps.trigger("dataLabelRendering", eventargs_1, function(labelArgs) {
          if (eventargs_1.cancel) {
            return;
          }
          var position = [];
          var width = zoomLabelsPosition && scaleZoomValue > 1 && !_this.maps.zoomNotApplied && _this.maps.zoomShapeCollection.length > index ? _this.maps.dataLabelShape[index] * scale : (location2["rightMax"]["x"] - location2["leftMax"]["x"]) * scale;
          if (!isNullOrUndefined(_this.maps.dataLabelShape) && !_this.maps.isReset) {
            shapeWidth = firstLevelMapLocation["rightMax"]["x"] - firstLevelMapLocation["leftMax"]["x"];
            _this.maps.dataLabelShape.push(shapeWidth);
          }
          if (eventargs_1.text !== text && !eventargs_1.cancel) {
            text = eventargs_1.text;
          }
          var textSize = measureTextElement(text, style);
          var trimmedLable = text;
          var elementSize = textSize;
          var startY = location2["y"] - textSize["height"] / 2;
          var endY = location2["y"] + textSize["height"] / 2;
          var start = (location2["y"] + transPoint["y"]) * scale - textSize["height"] / 2;
          var end = (location2["y"] + transPoint["y"]) * scale + textSize["height"] / 2;
          position = filter(shapePoint[midIndex], startY, endY);
          if (!isPoint && position.length > 5 && shapeData["geometry"]["type"] !== "MultiPolygon" && shapeData["type"] !== "MultiPolygon") {
            var location1 = findMidPointOfPolygon(position, projectionType, layer.geometryType);
            if (zoomLabelsPosition && scaleZoomValue > 1 && !_this.maps.zoomNotApplied && eventargs_1.template === "") {
              location1["x"] = (_this.maps.zoomLabelPositions[index]["location"]["x"] + zoomTransPoint["x"]) * scale;
              location1["y"] = (_this.maps.zoomLabelPositions[index]["location"]["y"] + zoomTransPoint["y"]) * scale;
            }
            locationX = location1["x"];
            location2["x"] = location1["x"];
            width = zoomLabelsPosition && scaleZoomValue > 1 && !_this.maps.zoomNotApplied && _this.maps.zoomShapeCollection.length > index ? _this.maps.dataLabelShape[index] * scale : (location1["rightMax"]["x"] - location1["leftMax"]["x"]) * scale > 0 ? (location1["rightMax"]["x"] - location1["leftMax"]["x"]) * scale : width;
          }
          var xpositionEnds = (location2["x"] + transPoint["x"]) * scale + textSize["width"] / 2;
          var xpositionStart = (location2["x"] + transPoint["x"]) * scale - textSize["width"] / 2;
          _this.value[index] = { rightWidth: xpositionEnds, leftWidth: xpositionStart, heightTop: start, heightBottom: end };
          var labelElement;
          if (eventargs_1.template !== "") {
            templateFn = getTemplateFunction(eventargs_1.template, _this.maps);
            var templateElement = templateFn ? templateFn(!isNullOrUndefined(datasrcObj) ? datasrcObj : shapeData["properties"], _this.maps, eventargs_1.template, _this.maps.element.id + "_LabelTemplate", false) : document.createElement("div");
            templateElement.innerHTML = !templateFn ? eventargs_1.template : "";
            labelElement = convertElementFromLabel(templateElement, labelId, !isNullOrUndefined(datasrcObj) ? datasrcObj : shapeData["properties"]);
            if (_this.maps.isTileMap) {
              labelElement.style.left = (location2["x"] + transPoint["x"]) * scale - textSize["width"] / 2 + "px";
              labelElement.style.top = (location2["y"] + transPoint["y"]) * scale - textSize["height"] + "px";
            } else {
              labelElement.style.left = Math.abs(_this.maps.baseMapRectBounds["min"]["x"] - location2["x"]) * scale + labelArgs.offsetX + "px";
              labelElement.style.top = Math.abs(_this.maps.baseMapRectBounds["min"]["y"] - location2["y"]) * scale + labelArgs.offsetY + "px";
            }
            labelTemplateElement.appendChild(labelElement);
          } else {
            var smartLabelMode = !isNullOrUndefined(dataLabelSettings.smartLabelMode) ? dataLabelSettings.smartLabelMode.toString() : "None";
            if (smartLabelMode === "Trim") {
              var textType = typeof text === "number" ? text.toString() : text;
              trimmedLable = textTrim(width, textType, style, null, true);
              elementSize = measureTextElement(trimmedLable, style);
              options = new TextOption2(labelId, textLocation.x, textLocation.y, "middle", trimmedLable, "", "");
            }
            if (smartLabelMode === "None") {
              options = new TextOption2(labelId, textLocation.x, textLocation.y, "middle", text, "", "");
            }
            if (smartLabelMode === "Hide") {
              text = width >= textSize["width"] ? text : "";
              options = new TextOption2(labelId, textLocation.x, textLocation.y, "middle", text, "", "");
            }
            if (!isNullOrUndefined(options)) {
              text = options["text"];
            }
            var intersectionAction = !isNullOrUndefined(dataLabelSettings.intersectionAction) ? dataLabelSettings.intersectionAction.toString() : "None";
            if (intersectionAction === "Hide") {
              for (var i = 0; i < intersect.length; i++) {
                if (!isNullOrUndefined(intersect[i])) {
                  if (!(_this.value[index]["leftWidth"] > intersect[i]["rightWidth"] || _this.value[index]["rightWidth"] < intersect[i]["leftWidth"] || _this.value[index]["heightTop"] > intersect[i]["heightBottom"] || _this.value[index]["heightBottom"] < intersect[i]["heightTop"])) {
                    text = "";
                    break;
                  }
                }
              }
              intersect.push(_this.value[index]);
              options = new TextOption2(labelId, textLocation.x, textLocation.y, "middle", text, "", "");
            }
            var difference = void 0;
            if (intersectionAction === "Trim") {
              for (var j2 = 0; j2 < intersect.length; j2++) {
                if (!isNullOrUndefined(intersect[j2])) {
                  if (intersect[j2]["rightWidth"] < _this.value[index]["leftWidth"] || intersect[j2]["leftWidth"] > _this.value[index]["rightWidth"] || intersect[j2]["heightBottom"] < _this.value[index]["heightTop"] || intersect[j2]["heightTop"] > _this.value[index]["heightBottom"]) {
                    trimmedLable = text;
                    difference = 0;
                  } else {
                    if (_this.value[index]["leftWidth"] > intersect[j2]["leftWidth"]) {
                      width = intersect[j2]["rightWidth"] - _this.value[index]["leftWidth"];
                      difference = width - (_this.value[index]["rightWidth"] - _this.value[index]["leftWidth"]);
                      trimmedLable = textTrim(difference, text, style, null, true);
                      break;
                    }
                    if (_this.value[index]["leftWidth"] < intersect[j2]["leftWidth"]) {
                      width = _this.value[index]["rightWidth"] - intersect[j2]["leftWidth"];
                      difference = Math.abs(width - (_this.value[index]["rightWidth"] - _this.value[index]["leftWidth"]));
                      trimmedLable = textTrim(difference, text, style, null, true);
                      break;
                    }
                  }
                }
              }
              elementSize = measureTextElement(trimmedLable, style);
              intersect.push(_this.value[index]);
              options = new TextOption2(labelId, textLocation.x, textLocation.y, "middle", trimmedLable, "", "");
            }
            if (intersectionAction === "None") {
              options = new TextOption2(labelId, textLocation.x, textLocation.y, "middle", text, "", "");
            }
            if (trimmedLable.length > 1) {
              var border = eventargs_1.border;
              if (border["width"] > 1) {
                var fill = eventargs_1.fill;
                var opacity = dataLabelSettings.opacity;
                var rx = dataLabelSettings.rx;
                var ry = dataLabelSettings.ry;
                var x = void 0;
                var y = void 0;
                var padding = 5;
                if (zoomLabelsPosition && scaleZoomValue > 1 && !_this.maps.zoomNotApplied) {
                  x = location2["x"] - textSize["width"] / 2;
                  y = location2["y"] - textSize["height"] / 2 - padding;
                } else {
                  x = (location2["x"] + transPoint["x"]) * scale - textSize["width"] / 2;
                  y = (location2["y"] + transPoint["y"]) * scale - textSize["height"] / 2;
                }
                border.opacity = isNullOrUndefined(border.opacity) ? opacity : border.opacity;
                var rectOptions = new RectOption(_this.maps.element.id + "_LayerIndex_" + layerIndex + "_shapeIndex_" + index + "_rectIndex_" + index, fill, border, opacity, new Rect2(x + labelArgs.offsetX, y + labelArgs.offsetY, textSize["width"], textSize["height"]), rx, ry);
                rect = _this.maps.renderer.drawRectangle(rectOptions);
                rect.setAttribute("visibility", layer.dataLabelSettings.animationDuration > 0 || animationMode === "Enable" ? "hidden" : "visibile");
                group.appendChild(rect);
              }
            }
            element = renderTextElement(options, style, style.color || _this.maps.themeStyle.dataLabelFontColor, group);
            element.setAttribute("aria-label", text);
            element.setAttribute("role", "region");
            element.setAttribute("visibility", layer.dataLabelSettings.animationDuration > 0 || animationMode === "Enable" ? "hidden" : "visibile");
            if (zoomLabelsPosition && scaleZoomValue > 1 && !_this.maps.zoomNotApplied) {
              element.setAttribute("transform", "translate( " + (location2["x"] + labelArgs.offsetX) + " " + (location2["y"] + labelArgs.offsetY) + " )");
              location2["x"] = locationX;
              location2["y"] = locationY;
            } else {
              element.setAttribute("transform", "translate( " + ((location2["x"] + transPoint.x) * scale + labelArgs.offsetX) + " " + ((location2["y"] + transPoint.y) * scale + elementSize.height / 2 + labelArgs.offsetY) + " )");
            }
            group.appendChild(element);
          }
          _this.dataLabelCollections.push({
            location: { x: location2["x"] + labelArgs.offsetX, y: location2["y"] + labelArgs.offsetY },
            element: isNullOrUndefined(labelElement) ? element : labelElement,
            layerIndex,
            shapeIndex: sublayerIndexLabel ? oldIndex : index,
            labelIndex: sublayerIndexLabel ? oldIndex : index,
            dataLabelText
          });
          if (labelTemplateElement.childElementCount > 0 && !_this.maps.element.contains(labelTemplateElement)) {
            document.getElementById(_this.maps.element.id + "_Secondary_Element").appendChild(labelTemplateElement);
            _this.maps.renderReactTemplates();
          }
          if (layer.dataLabelSettings.animationDuration > 0 || animationMode === "Enable") {
            if (!isNullOrUndefined(element)) {
              _this.datalabelAnimate(element, dataLabelSettings.animationDuration, style.opacity, false);
              if (!isNullOrUndefined(rect)) {
                _this.datalabelAnimate(rect, dataLabelSettings.animationDuration, dataLabelSettings.opacity, true);
              }
            }
          }
        });
      }
    };
    DataLabel2.prototype.datalabelAnimate = function(element, duration, opacity, isRect) {
      var height = 0;
      new Animation({}).animate(element, {
        duration: duration === 0 && animationMode === "Enable" ? 1e3 : duration,
        delay: 0,
        progress: function(args) {
          if (args.timeStamp > args.delay) {
            height = (args.timeStamp - args.delay) / args.duration;
            element.setAttribute("style", "user-select: none; visibility: visible;");
            element.setAttribute(isRect ? "fill-opacity" : "opacity", (opacity * height).toString());
          }
        },
        end: function() {
          element.style.visibility = "visible";
          element.setAttribute(isRect ? "fill-opacity" : "opacity", opacity.toString());
        }
      });
    };
    DataLabel2.prototype.getPoint = function(shapes, points) {
      if (shapes["type"] === "MultiLineString") {
        Array.prototype.forEach.call(shapes, function(current) {
          Array.prototype.forEach.call(current, function(shape) {
            points.push(new Point(shape["point"]["x"], shape["point"]["y"]));
          });
        });
      } else {
        Array.prototype.forEach.call(shapes, function(current) {
          points.push(new Point(current["point"]["x"], current["point"]["y"]));
        });
      }
      return points;
    };
    DataLabel2.prototype.getModuleName = function() {
      return "DataLabel";
    };
    DataLabel2.prototype.destroy = function() {
      this.dataLabelCollections = [];
      this.value = null;
      this.maps = null;
    };
    return DataLabel2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/layers/navigation-selected-line.js
var NavigationLine = (
  /** @class */
  (function() {
    function NavigationLine2(maps) {
      this.maps = maps;
    }
    NavigationLine2.prototype.renderNavigation = function(layer, factor, layerIndex) {
      var group;
      if (!isNullOrUndefined(this.maps)) {
        var navigationEle = void 0;
        var navigation = layer.navigationLineSettings;
        var longitude = void 0;
        var point = [];
        var latitude = void 0;
        var visible = void 0;
        var angle = void 0;
        var width = void 0;
        var color = void 0;
        var dashArray = void 0;
        var pathOption = void 0;
        var direction = void 0;
        var showArrow = void 0;
        var arrowColor = void 0;
        var arrowSize = void 0;
        var arrowSettings = void 0;
        var arrowPosition = void 0;
        var startArrow = void 0;
        var endArrow = void 0;
        var offSet = void 0;
        var offSetValue = void 0;
        var navigationGroup = void 0;
        var d = void 0;
        group = this.maps.renderer.createGroup({
          id: this.maps.element.id + "_LayerIndex_" + layerIndex + "_line_Group"
        });
        for (var i = 0; i < navigation.length; i++) {
          latitude = navigation[i].latitude;
          longitude = navigation[i].longitude;
          visible = !isNullOrUndefined(navigation[i].visible) ? navigation[i].visible : false;
          angle = !isNullOrUndefined(navigation[i].angle) ? navigation[i].angle : 0;
          width = navigation[i].width || 1;
          color = navigation[i].color;
          dashArray = navigation[i].dashArray;
          arrowSettings = navigation[i].arrowSettings;
          showArrow = !isNullOrUndefined(arrowSettings) ? arrowSettings.showArrow : false;
          if (!isNullOrUndefined(longitude) && !isNullOrUndefined(latitude) && longitude.length === latitude.length && visible) {
            for (var i_1 = 0; i_1 < longitude.length; i_1++) {
              var location_1 = this.maps.isTileMap ? convertTileLatLongToPoint(new Point(longitude[i_1], latitude[i_1]), factor, this.maps.tileTranslatePoint, true) : convertGeoToPoint(latitude[i_1], longitude[i_1], factor, layer, this.maps);
              point.push(location_1);
            }
          }
          navigationGroup = this.maps.renderer.createGroup({
            id: this.maps.element.id + "_LayerIndex_" + layerIndex + "_NavigationGroup" + i
          });
          for (var j = 0; j < point.length - 1; j++) {
            angle = -1 > angle ? -1 : angle;
            angle = 1 < angle ? 1 : angle;
            var arcId = this.maps.element.id + "_LayerIndex_" + layerIndex + "_NavigationIndex_" + i + "_Line" + j;
            var radius = this.convertRadius(point[j], point[j + 1]);
            if (angle <= 1 && angle > 0) {
              direction = 0;
              if (point[j]["x"] > point[j + 1]["x"]) {
                direction = 1;
              }
            }
            if (angle >= -1 && angle < 0) {
              direction = 1;
              if (point[j]["x"] > point[j + 1]["x"]) {
                direction = 0;
              }
            }
            if (showArrow) {
              arrowColor = arrowSettings.color;
              arrowSize = !isNullOrUndefined(arrowSettings.size) ? arrowSettings.size : 0;
              offSetValue = !isNullOrUndefined(arrowSettings.offSet) ? arrowSettings.offSet : 0;
              var divide = Math.round(arrowSize / 2);
              arrowPosition = arrowSettings.position;
              startArrow = arrowPosition === "Start" ? "url(#triangle" + i + ")" : null;
              endArrow = arrowPosition === "End" ? "url(#triangle" + i + ")" : null;
              if (offSet !== 0 && angle === 0) {
                offSet = arrowPosition === "Start" ? offSetValue : -offSetValue;
              }
              offSet = isNullOrUndefined(offSet) ? 0 : offSet;
              var triId = this.maps.element.id + "_triangle";
              var defElement = this.maps.renderer.createDefs();
              defElement.innerHTML += '<marker id="triangle' + i + '"></marker>';
              var markerEle = defElement.querySelector("#triangle" + i);
              markerEle.setAttribute("markerWidth", arrowSize.toString());
              markerEle.setAttribute("markerHeight", arrowSize.toString());
              markerEle.setAttribute("refX", (divide - offSet).toString());
              markerEle.setAttribute("refY", divide.toString());
              markerEle.setAttribute("orient", "auto");
              var d2 = "M 0,0  L 0," + arrowSize + " L " + divide + ", " + divide + " Z";
              pathOption = new PathOption2(triId, arrowColor, width, color, 1, 1, dashArray, d2);
              navigationEle = this.maps.renderer.drawPath(pathOption);
              markerEle.appendChild(navigationEle);
              defElement.appendChild(markerEle);
              navigationGroup.appendChild(defElement);
            }
            angle = Math.abs(angle);
            d = angle === 0 ? "M " + point[j]["x"] + "," + point[j]["y"] + "L " + point[j + 1]["x"] + "," + point[j + 1]["y"] + " " : "M " + point[j]["x"] + "," + point[j]["y"] + " A " + (radius / 2 + (1 - angle) * radius / (angle * 10)) + " " + (radius / 2 + (1 - angle) * radius / (angle * 10)) + " 0,0," + direction + " , " + point[j + 1]["x"] + "," + point[j + 1]["y"] + " ";
            pathOption = new PathOption2(arcId, "none", width, color, 1, 1, dashArray, d);
            navigationEle = this.maps.renderer.drawPath(pathOption);
            if (!isNullOrUndefined(arrowPosition)) {
              var position = arrowPosition === "Start" ? navigationEle.setAttribute("marker-start", startArrow) : navigationEle.setAttribute("marker-end", endArrow);
            }
            maintainSelection(this.maps.selectedNavigationElementId, this.maps.navigationSelectionClass, navigationEle, "navigationlineselectionMapStyle");
            navigationGroup.appendChild(navigationEle);
            group.appendChild(navigationGroup);
          }
          point = [];
        }
      }
      return group;
    };
    NavigationLine2.prototype.convertRadius = function(point1, point2) {
      var value1 = point2["x"] - point1["x"];
      var value2 = point2["y"] - point1["y"];
      var value = Math.sqrt(Math.pow(value1, 2) + Math.pow(value2, 2));
      return value;
    };
    NavigationLine2.prototype.getModuleName = function() {
      return "NavigationLine";
    };
    NavigationLine2.prototype.destroy = function() {
      this.maps = null;
    };
    return NavigationLine2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/layers/legend.js
var Legend = (
  /** @class */
  (function() {
    function Legend2(maps) {
      this.legendBorderRect = new Rect2(0, 0, 0, 0);
      this.initialMapAreaRect = new Rect2(0, 0, 0, 0);
      this.legendTotalRect = new Rect2(0, 0, 0, 0);
      this.totalPages = [];
      this.page = 0;
      this.currentPage = 0;
      this.legendItemRect = new Rect2(0, 0, 0, 0);
      this.heightIncrement = 0;
      this.widthIncrement = 0;
      this.textMaxWidth = 0;
      this.shapeHighlightCollection = [];
      this.legendHighlightCollection = [];
      this.shapePreviousColor = [];
      this.selectedNonLegendShapes = [];
      this.shapeToggled = true;
      this.legendElement = null;
      this.maps = maps;
      this.addEventListener();
    }
    Legend2.prototype.renderLegend = function() {
      this.legendRenderingCollections = [];
      this.legendCollection = [];
      this.totalPages = [];
      this.widthIncrement = 0;
      this.heightIncrement = 0;
      this.defsElement = this.maps.renderer.createDefs();
      this.maps.svgObject.appendChild(this.defsElement);
      this.initialMapAreaRect = this.maps.mapAreaRect;
      this.calculateLegendBounds();
      this.drawLegend();
    };
    Legend2.prototype.calculateLegendBounds = function() {
      var _this = this;
      var map = this.maps;
      var legend = map.legendSettings;
      this.legendCollection = [];
      var spacing = 10;
      var leftPadding = 10;
      var topPadding = map.mapAreaRect.y;
      this.legendRenderingCollections = [];
      Array.prototype.forEach.call(map.layersCollection, function(layer, layerIndex) {
        if (!isNullOrUndefined(layer.shapeData)) {
          var layerData = layer.shapeData["features"];
          var dataPath = layer.shapeDataPath;
          var propertyPath = layer.shapePropertyPath;
          var dataSource = layer.dataSource;
          var colorValuePath = void 0;
          var colorMapping = void 0;
          if (legend.type === "Layers" && layer.visible) {
            colorValuePath = layer.shapeSettings.colorValuePath;
            colorMapping = layer.shapeSettings.colorMapping;
            _this.getLegends(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
          } else if (legend.type === "Bubbles") {
            for (var _i = 0, _a = layer.bubbleSettings; _i < _a.length; _i++) {
              var bubble = _a[_i];
              if (bubble.visible) {
                colorValuePath = bubble.colorValuePath;
                colorMapping = bubble.colorMapping;
                dataSource = bubble.dataSource;
                _this.getLegends(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
              }
            }
          }
        }
        if (legend.type === "Markers") {
          _this.getMarkersLegendCollections(layerIndex, layer.markerSettings);
        }
      });
      if (this.legendCollection.length > 0) {
        for (var i = 0; i < this.legendCollection.length; i++) {
          var legendItem = this.legendCollection[i];
          var eventArgs = {
            name: legendRendering,
            cancel: false,
            fill: legendItem["fill"],
            shape: legend.shape,
            shapeBorder: legend.shapeBorder,
            text: typeof legendItem["text"] === "number" ? legendItem["text"].toString() : legendItem["text"]
          };
          map.trigger("legendRendering", eventArgs);
          legendItem["fill"] = eventArgs.fill;
          legendItem["shape"] = eventArgs.shape;
          legendItem["shapeBorder"] = eventArgs.shapeBorder;
          legendItem["text"] = eventArgs.text;
          if (eventArgs.cancel) {
            this.legendCollection.splice(i, 1);
            i--;
          }
        }
      }
      var defaultSize = 25;
      var legendTitle = map.legendSettings.title.text;
      var titleTextStyle = map.legendSettings.titleStyle;
      if (this.legendCollection.length > 0) {
        var legendMode = legend.mode;
        var shapeX = 0;
        var shapeY = 0;
        var textX = 0;
        var textY = 0;
        var shapePadding = legend.shapePadding;
        var textPadding = 10;
        var shapeHeight = legend.shapeHeight;
        var shapeWidth = legend.shapeWidth;
        var shapeLocation = [];
        var textLocation = [];
        var position = legend.position;
        var labelAction = legend.labelDisplayMode;
        var arrangement = legend.orientation === "None" ? position === "Top" || position === "Bottom" ? "Horizontal" : "Vertical" : legend.orientation;
        var legendWidth = legend.width.length > 1 ? legend.width.indexOf("%") > -1 ? map.availableSize.width / 100 * parseInt(legend.width, 10) : parseInt(legend.width, 10) : null;
        var legendHeight = legend.height.length > 1 ? legend.height.indexOf("%") > -1 ? map.availableSize.height / 100 * parseInt(legend.height, 10) : parseInt(legend.height, 10) : null;
        var legendItemStartX_1;
        var legendItemStartY_1;
        var startX = 0;
        var startY = 0;
        var legendtitleSize = measureText2(legendTitle, titleTextStyle);
        if (legendMode === "Interactive") {
          var itemTextStyle = legend.textStyle;
          var legendLength = this.legendCollection.length;
          var rectWidth = arrangement === "Horizontal" ? isNullOrUndefined(legendWidth) ? map.mapAreaRect.width / legendLength : legendWidth / legendLength : isNullOrUndefined(legendWidth) ? defaultSize : legendWidth;
          var rectHeight = arrangement === "Horizontal" ? isNullOrUndefined(legendHeight) ? defaultSize : legendHeight : isNullOrUndefined(legendHeight) ? map.mapAreaRect.height / legendLength : legendHeight / legendLength;
          startX = 0;
          startY = legendtitleSize.height + spacing;
          var position_1 = legend.labelPosition;
          var textX_1 = 0;
          var textY_1 = 0;
          var textPadding_1 = 10;
          var itemStartX = 0;
          var itemStartY = 0;
          var maxTextHeight = 0;
          var maxTextWidth = 0;
          for (var i = 0; i < this.legendCollection.length; i++) {
            startX = arrangement === "Horizontal" ? startX + rectWidth : startX;
            startY = arrangement === "Horizontal" ? startY : startY + rectHeight;
            var legendText = this.legendCollection[i]["text"];
            var itemTextSize = new Size2(0, 0);
            if (labelAction === "None") {
              itemTextSize = measureText2(legendText, itemTextStyle);
            } else if (labelAction === "Trim") {
              legendText = textTrim(arrangement === "Horizontal" ? rectWidth : rectHeight, legendText, itemTextStyle);
              itemTextSize = measureText2(legendText, itemTextStyle);
            } else {
              legendText = "";
            }
            if (legend.position === "Left" || legend.position === "Right" || legend.position === "Float") {
              for (var i_1 = 0; i_1 < this.legendCollection.length; i_1++) {
                var legendItem = this.legendCollection[i_1];
                var legendTextSize = measureText2(legendItem["text"], legend.textStyle);
                this.textMaxWidth = Math.max(this.textMaxWidth, legendTextSize.width);
              }
            }
            maxTextHeight = Math.max(maxTextHeight, itemTextSize.height);
            maxTextWidth = Math.max(maxTextWidth, itemTextSize.width);
            if (itemTextSize.width > 0 && itemTextSize.height > 0) {
              if (arrangement === "Horizontal") {
                textX_1 = startX + rectWidth / 2;
                textY_1 = position_1 === "After" ? startY + rectHeight + itemTextSize.height / 2 + textPadding_1 : startY - textPadding_1;
              } else {
                textX_1 = position_1 === "After" ? startX - this.textMaxWidth / 2 - textPadding_1 : startX + rectWidth + this.textMaxWidth / 2 + textPadding_1;
                textY_1 = startY + rectHeight / 2 + itemTextSize.height / 4;
              }
            }
            if (i === 0) {
              itemStartX = arrangement === "Horizontal" ? startX : position_1 === "After" ? textX_1 - this.textMaxWidth / 2 : startX;
              itemStartY = arrangement === "Horizontal" ? position_1 === "After" ? startY : textY_1 - itemTextSize.height / 2 : startY;
              if (this.legendCollection.length === 1) {
                legendWidth = arrangement === "Horizontal" ? Math.abs(startX + rectWidth - itemStartX) : rectWidth + this.textMaxWidth + textPadding_1;
                legendHeight = arrangement === "Horizontal" ? rectHeight + maxTextHeight / 2 + textPadding_1 : Math.abs(startY + rectHeight - itemStartY);
              }
            } else if (i === this.legendCollection.length - 1) {
              legendWidth = arrangement === "Horizontal" ? Math.abs(startX + rectWidth - itemStartX) : rectWidth + this.textMaxWidth + textPadding_1;
              legendHeight = arrangement === "Horizontal" ? rectHeight + maxTextHeight / 2 + textPadding_1 : Math.abs(startY + rectHeight - itemStartY);
            }
            this.legendRenderingCollections.push({
              fill: this.legendCollection[i]["fill"],
              x: startX,
              y: startY,
              width: rectWidth,
              height: rectHeight,
              text: legendText,
              textX: textX_1,
              textY: textY_1,
              textWidth: itemTextSize.width,
              textHeight: itemTextSize.height,
              shapeBorder: this.legendCollection[i]["shapeBorder"]
            });
          }
          if (this.legendCollection.length === 1) {
            legendHeight = maxTextHeight + textPadding_1;
            legendWidth = rectWidth;
          }
          this.legendItemRect = { x: itemStartX, y: itemStartY, width: legendWidth, height: legendHeight };
        } else {
          legendWidth = isNullOrUndefined(legendWidth) ? map.mapAreaRect.width : legendWidth;
          legendHeight = isNullOrUndefined(legendHeight) ? map.mapAreaRect.height : legendHeight;
          var j = 0;
          this.page = 0;
          for (var i = 0; i < this.legendCollection.length; i++) {
            var legendItem = this.legendCollection[i];
            if (isNullOrUndefined(this.totalPages[this.page])) {
              this.totalPages[this.page] = { Page: this.page + 1, Collection: [] };
            }
            var legendTextSize = measureText2(legendItem["text"], legend.textStyle);
            this.textMaxWidth = Math.max(this.textMaxWidth, legendTextSize.width);
            if (i === 0) {
              startX = shapeX = leftPadding + shapeWidth / 2;
              startY = shapeY = topPadding + legendtitleSize.height + (shapeHeight > legendTextSize.height ? shapeHeight / 2 : legendTextSize.height / 4);
            } else {
              var maxSize = legendTextSize.height > shapeHeight ? legendTextSize.height : shapeHeight;
              if (arrangement === "Horizontal") {
                var prvePositionX = textLocation[j - 1].x + textLocation[j - 1].width + textPadding + shapeWidth;
                if (prvePositionX + shapePadding + legendTextSize.width > legendWidth) {
                  var nextPositionY = (textLocation[j - 1].y > shapeLocation[j - 1].y + shapeHeight / 2 ? textLocation[j - 1].y : shapeLocation[j - 1].y + shapeHeight / 2) + topPadding;
                  if (nextPositionY + maxSize > legendHeight) {
                    this.getPageChanged();
                    j = 0;
                    shapeLocation = [];
                    textLocation = [];
                    shapeX = startX;
                    shapeY = startY;
                  } else {
                    shapeX = shapeLocation[0].x;
                    shapeY = nextPositionY + maxSize / 2;
                  }
                } else {
                  shapeX = prvePositionX - shapeWidth / 2;
                  shapeY = shapeLocation[j - 1].y;
                }
              } else {
                var prevPositionY = textLocation[j - 1].y > shapeLocation[j - 1].y + shapeHeight / 2 ? textLocation[j - 1].y : shapeLocation[j - 1].y + shapeHeight / 2;
                if (prevPositionY + topPadding + maxSize > legendHeight) {
                  var nextPositionX = textLocation[j - 1].x + this.textMaxWidth + textPadding;
                  if (nextPositionX + shapePadding + legendTextSize.width > legendWidth) {
                    shapeX = startX;
                    shapeY = startY;
                    textLocation = [];
                    shapeLocation = [];
                    this.getPageChanged();
                    j = 0;
                  } else {
                    shapeX = nextPositionX + shapeWidth / 2;
                    shapeY = shapeLocation[0].y;
                  }
                } else {
                  var padding = 10;
                  shapeX = shapeLocation[j - 1].x;
                  shapeY = prevPositionY + padding + shapeHeight / 2;
                }
              }
            }
            textX = shapeX + shapeWidth / 2 + shapePadding;
            textY = shapeY + legendTextSize.height / 4;
            shapeLocation.push({ x: shapeX, y: shapeY });
            textLocation.push({ x: textX, y: textY, width: legendTextSize.width, height: legendTextSize.height / 2 });
            this.totalPages[this.page]["Collection"].push({
              DisplayText: legendItem["text"],
              ImageSrc: legendItem["imageSrc"],
              Shape: { x: shapeX, y: shapeY },
              Text: { x: textX, y: textY },
              Fill: legendItem["fill"],
              legendShape: legendItem["shape"],
              shapeBorder: legendItem["shapeBorder"],
              idIndex: i,
              Rect: {
                x: shapeLocation[j].x - shapeWidth / 2,
                y: shapeLocation[j].y - shapeHeight / 2 < textY - legendTextSize.height ? shapeLocation[j].y - shapeHeight / 2 : textY - legendTextSize.height,
                width: Math.abs(shapeLocation[j].x - shapeWidth / 2 - (textX + legendTextSize.width)),
                height: shapeHeight > legendTextSize.height ? shapeHeight : legendTextSize.height
              }
            });
            j++;
          }
          var collection = this.totalPages[0]["Collection"];
          Array.prototype.forEach.call(collection, function(legendObj, index) {
            var legendRect = new Rect2(legendObj["Rect"]["x"], legendObj["Rect"]["y"], legendObj["Rect"]["width"], legendObj["Rect"]["height"]);
            if (index === 0) {
              legendItemStartX_1 = legendRect.x;
              legendItemStartY_1 = legendRect.y;
            }
            _this.widthIncrement = Math.max(_this.widthIncrement, Math.abs(legendItemStartX_1 - (legendRect.x + legendRect.width)));
            _this.heightIncrement = Math.max(_this.heightIncrement, Math.abs(legendItemStartY_1 - (legendRect.y + legendRect.height)));
          });
          legendWidth = this.widthIncrement < legendWidth ? this.widthIncrement : legendWidth;
          legendHeight = this.heightIncrement < legendHeight ? this.heightIncrement : legendHeight;
          this.legendItemRect = {
            x: collection[0]["Rect"]["x"],
            y: collection[0]["Rect"]["y"],
            width: legendWidth,
            height: legendHeight
          };
        }
      }
    };
    Legend2.prototype.getLegends = function(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath) {
      this.getRangeLegendCollection(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
      this.getEqualLegendCollection(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
      this.getDataLegendCollection(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
    };
    Legend2.prototype.getPageChanged = function() {
      this.page++;
      if (isNullOrUndefined(this.totalPages[this.page])) {
        this.totalPages[this.page] = { Page: this.page + 1, Collection: [] };
      }
    };
    Legend2.prototype.legendTextTrim = function(maxWidth, text, font, legendRectSize) {
      var label = text;
      var size = measureText2(text, font).width;
      var legendWithoutTextSize = legendRectSize - size;
      if (legendRectSize > maxWidth) {
        var textLength = text.length;
        for (var i = textLength - 1; i >= 0; --i) {
          label = text.substring(0, i) + "...";
          size = measureText2(label, font).width;
          var totalSize = legendWithoutTextSize + size;
          if (totalSize <= maxWidth || label.length < 4) {
            if (label.length < 4) {
              label = " ";
            }
            return label;
          }
        }
      }
      return label;
    };
    Legend2.prototype.drawLegend = function() {
      var map = this.maps;
      var legend = map.legendSettings;
      var render = map.renderer;
      var textOptions;
      var textFont = {
        size: legend.textStyle.size,
        color: legend.textStyle.color,
        fontFamily: legend.textStyle.fontFamily,
        fontWeight: legend.textStyle.fontWeight,
        fontStyle: legend.textStyle.fontStyle,
        opacity: legend.textStyle.opacity
      };
      this.legendGroup = render.createGroup({ id: map.element.id + "_Legend_Group" });
      if (legend.mode === "Interactive") {
        for (var i = 0; i < this.legendRenderingCollections.length; i++) {
          var itemId = map.element.id + "_Legend_Index_" + i;
          var textId = map.element.id + "_Legend_Index_" + i + "_Text";
          var item = this.legendRenderingCollections[i];
          var bounds = new Rect2(item["x"], item["y"], item["width"], item["height"]);
          if (i === 0) {
            this.renderLegendBorder();
          }
          var textLocation = new Point(item["textX"], item["textY"]);
          textFont.color = textFont.color !== null ? textFont.color : this.maps.themeStyle.legendTextColor;
          var rectOptions = new RectOption(itemId, item["fill"], item["shapeBorder"], legend.opacity, bounds);
          textOptions = new TextOption2(textId, textLocation.x, textLocation.y, "middle", item["text"], "", "");
          textFont.fontFamily = !isNullOrUndefined(textFont.fontFamily) ? textFont.fontFamily : this.maps.themeStyle.fontFamily;
          textFont.size = textFont.size || map.themeStyle.legendFontSize;
          var textElement2 = renderTextElement(textOptions, textFont, textFont.color, this.legendGroup);
          textElement2.setAttribute("aria-label", item["text"]);
          textElement2.setAttribute("role", "region");
          var rectElement = render.drawRectangle(rectOptions);
          this.legendGroup.appendChild(rectElement);
          if (map.legendSettings.toggleLegendSettings.enable && (legend.type === "Layers" || legend.type === "Markers")) {
            this.maintainLegendToggle(i, rectElement, textElement2);
          }
          this.legendToggle();
        }
      } else {
        this.drawLegendItem(this.currentPage);
      }
    };
    Legend2.prototype.drawLegendItem = function(page) {
      var map = this.maps;
      var legend = map.legendSettings;
      var spacing = 10;
      var shapeSize = new Size2(legend.shapeWidth, legend.shapeHeight);
      var textOptions;
      var render = map.renderer;
      var legendShape = legend.shape;
      if (page >= 0 && page < this.totalPages.length) {
        if (querySelector(this.legendGroup.id, this.maps.element.id)) {
          remove(querySelector(this.legendGroup.id, this.maps.element.id));
        }
        for (var i = 0; i < this.totalPages[page]["Collection"].length; i++) {
          var collection = this.totalPages[page]["Collection"][i];
          var shapeBorder = collection["shapeBorder"];
          var legendElement = render.createGroup({ id: map.element.id + "_Legend_Index_" + collection["idIndex"] });
          var legendText = collection["DisplayText"];
          var pagingArrowPadding = 4;
          var strokeColor = legend.shape === "HorizontalLine" || legend.shape === "VerticalLine" || legend.shape === "Cross" ? isNullOrUndefined(legend.fill) ? "#000000" : legend.fill : shapeBorder.color;
          var strokeWidth = legend.shape === "HorizontalLine" || legend.shape === "VerticalLine" || legend.shape === "Cross" ? shapeBorder.width === 0 ? 1 : shapeBorder.width : shapeBorder.width;
          var shapeId = map.element.id + "_Legend_Shape_Index_" + collection["idIndex"];
          var textId = map.element.id + "_Legend_Text_Index_" + collection["idIndex"];
          var shapeLocation = new Point(collection["Shape"]["x"], collection["Shape"]["y"] - pagingArrowPadding);
          var textLocation = new Point(collection["Text"]["x"], collection["Text"]["y"] - pagingArrowPadding);
          var renderOptions = new PathOption2(shapeId, collection["Fill"], strokeWidth, strokeColor, legend.opacity, isNullOrUndefined(shapeBorder.opacity) ? legend.opacity : shapeBorder.opacity, "");
          var legendTextStyle = {
            fontFamily: legend.textStyle.fontFamily,
            fontStyle: legend.textStyle.fontStyle,
            fontWeight: legend.textStyle.fontWeight,
            size: legend.textStyle.size,
            color: legend.textStyle.color,
            opacity: legend.textStyle.opacity
          };
          legendTextStyle.color = legendTextStyle.color !== null ? legendTextStyle.color : this.maps.themeStyle.legendTextColor;
          legendTextStyle.fontFamily = !isNullOrUndefined(legendTextStyle.fontFamily) ? legendTextStyle.fontFamily : this.maps.themeStyle.fontFamily;
          legendTextStyle.size = legendTextStyle.size || map.themeStyle.legendFontSize;
          legendTextStyle.fontWeight = legendTextStyle.fontWeight || map.themeStyle.fontWeight;
          if (i === 0) {
            this.renderLegendBorder();
          }
          if (legend.type === "Markers" && legend.useMarkerShape) {
            var legendShapeData = this.legendCollection[collection["idIndex"]].data[0];
            var marker2 = map.layers[legendShapeData["layerIndex"]].markerSettings[legendShapeData["markerIndex"]];
            legendShape = !isNullOrUndefined(marker2.dataSource[legendShapeData["dataIndex"]][marker2["shapeValuePath"]]) && marker2.dataSource[legendShapeData["dataIndex"]][marker2["shapeValuePath"]] !== "" ? marker2.dataSource[legendShapeData["dataIndex"]][marker2["shapeValuePath"]] : marker2.shape;
          }
          if (legendShape === "Balloon") {
            legendElement.appendChild(drawBalloon(map, renderOptions, shapeSize, { x: shapeLocation.x, y: shapeLocation.y + 5 }, "Legend"));
          } else {
            legendElement.appendChild(drawSymbol2(shapeLocation, legendShape, shapeSize, collection["ImageSrc"], renderOptions));
          }
          var legendRectSize = collection["Rect"]["x"] + collection["Rect"]["width"];
          if (legendRectSize > this.legendBorderRect.width) {
            var trimmedText = this.legendTextTrim(this.legendBorderRect.width, legendText, legendTextStyle, legendRectSize);
            legendText = trimmedText;
          }
          textOptions = new TextOption2(textId, textLocation.x, textLocation.y, "start", legendText, "", "");
          var textElement2 = renderTextElement(textOptions, legendTextStyle, legendTextStyle.color, legendElement);
          textElement2.setAttribute("aria-label", legendText);
          textElement2.setAttribute("role", "region");
          this.legendGroup.appendChild(legendElement);
          if (map.legendSettings.toggleLegendSettings.enable && (legend.type === "Layers" || legend.type === "Markers")) {
            var legendShapeElement = legendElement.childNodes[0];
            this.maintainLegendToggle(collection["idIndex"], legendShapeElement, textElement2);
          }
          if (i === this.totalPages[page]["Collection"].length - 1) {
            var pagingGroup = void 0;
            var width = spacing;
            var height = spacing / 2;
            if (this.page !== 0) {
              var pagingText = page + 1 + "/" + this.totalPages.length;
              var pagingFont = legend.textStyle;
              var pagingTextSize = measureText2(pagingText, pagingFont);
              var leftPageX = this.legendItemRect.x + this.legendItemRect.width - pagingTextSize.width - width * 2 - spacing * 2 + pagingArrowPadding / 2;
              var rightPageX = this.legendItemRect.x + this.legendItemRect.width;
              var pageTextX = rightPageX - width - pagingTextSize.width / 2 - spacing / 2 - pagingArrowPadding;
              var locY = this.legendItemRect.y + this.legendItemRect.height + height / 2 + spacing;
              pagingGroup = render.createGroup({ id: map.element.id + "_Legend_Paging_Group" });
              var leftPageElement = render.createGroup({ id: map.element.id + "_Legend_Left_Paging_Group" });
              var rightPageElement = render.createGroup({ id: map.element.id + "_Legend_Right_Paging_Group" });
              var rightPath = " M " + rightPageX + " " + locY + " L " + (rightPageX - width) + " " + (locY - height) + " L " + (rightPageX - width) + " " + (locY + height) + " z ";
              var leftPath = " M " + leftPageX + " " + locY + " L " + (leftPageX + width) + " " + (locY - height) + " L " + (leftPageX + width) + " " + (locY + height) + " z ";
              var leftPageOptions = new PathOption2(map.element.id + "_Left_Page", this.maps.themeStyle.legendTextColor, 0, this.maps.themeStyle.legendTextColor, page + 1 === 1 ? 0.5 : 1, 1, "", leftPath);
              leftPageElement.appendChild(render.drawPath(leftPageOptions));
              var leftRectPageOptions = new RectOption(map.element.id + "_Left_Page_Rect", "transparent", {}, 1, new Rect2(leftPageX - width / 2, locY - height * 2, width * 2, spacing * 2), null, null, "", "");
              var pathEle = render.drawRectangle(leftRectPageOptions);
              pathEle.setAttribute("aria-label", "Navigate to the previous legend items");
              pathEle.setAttribute("role", "button");
              pathEle.tabIndex = page + 1 === 1 ? -1 : map.tabIndex;
              if (page + 1 === 1) {
                pathEle.style.cursor = "default";
                pathEle.style.setProperty("outline", "none");
              } else {
                pathEle.style.cursor = "pointer";
                pathEle.style.removeProperty("outline");
              }
              leftPageElement.appendChild(pathEle);
              this.wireEvents(leftPageElement);
              var rightPageOptions = new PathOption2(map.element.id + "_Right_Page", this.maps.themeStyle.legendTextColor, 0, this.maps.themeStyle.legendTextColor, page + 1 === this.totalPages.length ? 0.5 : 1, 1, "", rightPath);
              rightPageElement.appendChild(render.drawPath(rightPageOptions));
              var rightRectPageOptions = new RectOption(map.element.id + "_Right_Page_Rect", "transparent", {}, 1, new Rect2(rightPageX - spacing - width / 2, locY - height * 2, width * 2, spacing * 2), null, null, "", "");
              pathEle = render.drawRectangle(rightRectPageOptions);
              pathEle.setAttribute("aria-label", "Navigate to the next legend items");
              pathEle.setAttribute("role", "button");
              pathEle.tabIndex = page + 1 === this.totalPages.length ? -1 : map.tabIndex;
              if (page + 1 === this.totalPages.length) {
                pathEle.style.cursor = "default";
                pathEle.style.setProperty("outline", "none");
              } else {
                pathEle.style.cursor = "pointer";
                pathEle.style.removeProperty("outline");
              }
              rightPageElement.appendChild(pathEle);
              this.wireEvents(rightPageElement);
              pagingGroup.appendChild(leftPageElement);
              pagingGroup.appendChild(rightPageElement);
              var pageTextOptions = {
                "id": map.element.id + "_Paging_Text",
                "x": pageTextX,
                "y": locY + pagingTextSize.height / 4,
                "fill": this.maps.themeStyle.legendTextColor,
                "font-size": "14px",
                "font-style": pagingFont.fontStyle,
                "font-family": pagingFont.fontFamily,
                "font-weight": pagingFont.fontWeight,
                "text-anchor": "middle",
                "transform": "",
                "opacity": 1,
                "dominant-baseline": ""
              };
              var pagingTextElement = render.createText(pageTextOptions, pagingText);
              pagingTextElement.style.cssText = "user-select: none;";
              pagingTextElement.setAttribute("aria-label", pagingText);
              pagingTextElement.setAttribute("role", "region");
              pagingGroup.appendChild(pagingTextElement);
              this.legendGroup.appendChild(pagingGroup);
            }
            this.legendToggle();
          }
        }
      }
    };
    Legend2.prototype.maintainLegendToggle = function(legendIndex, legendShapeElement, legendTextElement) {
      if (this.maps.legendSettings.toggleLegendSettings.enable && !isNullOrUndefined(this.maps.toggledLegendId) && this.maps.toggledLegendId.indexOf(legendIndex) > -1 && !isNullOrUndefined(this.maps.toggledElementId) && this.maps.toggledElementId.length > 0) {
        var currentItem = this.legendCollection[legendIndex]["data"];
        if (!this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {
          this.setToggleAttributes(legendTextElement, legendShapeElement, this.maps.legendSettings.toggleLegendSettings.fill, this.maps.legendSettings.toggleLegendSettings.opacity, this.maps.legendSettings.toggleLegendSettings.border.color, this.maps.legendSettings.toggleLegendSettings.border.width, isNullOrUndefined(this.maps.legendSettings.toggleLegendSettings.border.opacity) ? this.maps.legendSettings.toggleLegendSettings.opacity : this.maps.legendSettings.toggleLegendSettings.border.opacity, this.maps.legendSettings.toggleLegendSettings.fill);
        } else if (currentItem[currentItem.length - 1].length > 0) {
          var layerIndex = currentItem[currentItem.length - 1].layerIndex;
          this.setToggleAttributes(
            legendTextElement,
            legendShapeElement,
            this.maps.layers[layerIndex].shapeSettings.fill,
            this.maps.layers[layerIndex].shapeSettings.opacity,
            /* eslint-disable-next-line max-len */
            this.maps.layers[layerIndex].shapeSettings.border.color || this.maps.themeStyle.shapeBorderColor,
            isNullOrUndefined(this.maps.layers[layerIndex].shapeSettings.border.width) ? 0 : this.maps.layers[layerIndex].shapeSettings.border.width,
            isNullOrUndefined(this.maps.layers[layerIndex].shapeSettings.border.opacity) ? this.maps.layers[layerIndex].shapeSettings.opacity : this.maps.layers[layerIndex].shapeSettings.border.opacity,
            this.maps.layers[layerIndex].shapeSettings.fill
          );
        }
        currentItem["_isVisible"] = false;
      }
    };
    Legend2.prototype.legendHighLightAndSelection = function(targetElement, value) {
      var shapeIndex;
      var layerIndex;
      var dataIndex;
      var pointIndex;
      var legend = this.maps.legendSettings;
      var textEle = legend.mode === "Default" ? document.getElementById(targetElement.id.replace("Shape", "Text")) : document.getElementById(targetElement.id + "_Text");
      var collection = this.maps.legendModule.legendCollection;
      var length;
      var multiSelectEnable = !isNullOrUndefined(collection[0]["data"][0]["layerIndex"]) ? this.maps.layers[collection[0]["data"][0]["layerIndex"]].selectionSettings.enableMultiSelect : false;
      var selectLength = 0;
      var interactProcess = true;
      var idIndex = parseFloat(targetElement.id.charAt(targetElement.id.length - 1));
      this.updateLegendElement();
      var toggleLegendCheck = this.maps.toggledLegendId.indexOf(idIndex);
      if (this.maps.legendSettings.toggleLegendSettings.enable && value === "highlight" && toggleLegendCheck !== -1) {
        var collectionIndex = this.getIndexofLegend(this.legendHighlightCollection, targetElement);
        if (collectionIndex !== -1) {
          this.legendHighlightCollection.splice(collectionIndex, 1);
        }
        this.removeLegendHighlightCollection();
        return null;
      }
      if (value === "selection") {
        this.shapeHighlightCollection = [];
        if (!this.maps.shapeSelections && !multiSelectEnable) {
          this.removeAllSelections();
          this.maps.shapeSelections = true;
        }
        if (this.maps.legendSelectionCollection.length > 0 && (!multiSelectEnable ? this.maps.shapeSelections : true)) {
          for (var k = 0; k < this.maps.legendSelectionCollection.length; k++) {
            if (targetElement === this.maps.legendSelectionCollection[k]["legendElement"]) {
              this.maps.legendSelectionCollection[k]["legendElement"] = targetElement;
              interactProcess = false;
              this.removeLegendSelectionCollection(this.maps.legendSelectionCollection[k]["legendElement"]);
              this.maps.selectedLegendElementId.splice(this.maps.selectedLegendElementId.indexOf(idIndex), 1);
              this.maps.legendSelectionCollection.splice(k, 1);
              this.maps.legendSelection = this.maps.legendSelectionCollection.length > 0 ? false : true;
              break;
            } else if (!multiSelectEnable) {
              if (this.maps.legendSelectionCollection.length > 1) {
                for (var z = 0; z < this.maps.legendSelectionCollection.length; z++) {
                  this.removeLegendSelectionCollection(this.maps.legendSelectionCollection[z]["legendElement"]);
                }
                this.maps.legendSelectionCollection = [];
              } else {
                this.removeLegendSelectionCollection(this.maps.legendSelectionCollection[k]["legendElement"]);
                this.maps.legendSelectionCollection.splice(k, 1);
              }
            }
          }
        }
      } else {
        if (this.maps.legendSelectionCollection.length > 0) {
          for (var k = 0; k < this.maps.legendSelectionCollection.length; k++) {
            if ((targetElement.id.indexOf("_Legend_Shape") > -1 || targetElement.id.indexOf("_Legend_Index")) && targetElement === this.maps.legendSelectionCollection[k]["legendElement"]) {
              interactProcess = false;
              break;
            } else {
              this.removeLegendHighlightCollection();
            }
          }
        }
        this.removeLegendHighlightCollection();
      }
      if (interactProcess) {
        for (var i = 0; i < collection.length; i++) {
          var idIndex_1 = this.maps.legendSettings.mode === "Interactive" ? parseFloat(targetElement.id.split("_Legend_Index_")[1]) : parseFloat(targetElement.id.split("_Legend_Shape_Index_")[1]);
          if (textEle.textContent === collection[i]["text"] && collection[i]["data"].length > 0 && idIndex_1 === i) {
            var layer = this.maps.layers[collection[i]["data"][0]["layerIndex"]];
            var enable = void 0;
            var legendModule = void 0;
            var data = void 0;
            if (!isNullOrUndefined(layer)) {
              enable = value === "selection" ? layer.selectionSettings.enable : layer.highlightSettings.enable;
              legendModule = void 0;
              legendModule = value === "selection" ? layer.selectionSettings : layer.highlightSettings;
              data = collection[i]["data"];
            }
            if (enable) {
              for (var j = 0; j < data.length; j++) {
                var shapeElement = void 0;
                shapeIndex = data[j]["shapeIndex"];
                layerIndex = data[j]["layerIndex"];
                dataIndex = data[j]["dataIndex"];
                pointIndex = data[j]["pointIndex"];
                if (pointIndex === -1) {
                  shapeElement = document.getElementById(this.maps.element.id + "_LayerIndex_" + layerIndex + "_shapeIndex_" + shapeIndex + "_dataIndex_" + dataIndex);
                } else {
                  shapeElement = document.getElementById(this.maps.element.id + "_LayerIndex_" + layerIndex + "_shapeIndex_" + shapeIndex + "_dataIndex_" + dataIndex + "_multiLine_" + pointIndex);
                }
                if (shapeElement !== null) {
                  var shapeMatch = true;
                  if (this.maps.legendSelectionCollection !== null) {
                    for (var i_2 = 0; i_2 < this.maps.legendSelectionCollection.length; i_2++) {
                      if (this.maps.legendSelectionCollection[i_2]["legendElement"] === targetElement) {
                        shapeMatch = false;
                        break;
                      }
                    }
                  }
                  if (value === "highlight" && shapeMatch) {
                    if (j === 0) {
                      this.legendHighlightCollection = [];
                      this.pushCollection(targetElement, this.legendHighlightCollection, collection[i], layer.shapeSettings);
                    }
                    length = this.legendHighlightCollection.length;
                    var legendHighlightColor = this.legendHighlightCollection[length - 1]["legendOldFill"];
                    this.legendHighlightCollection[length - 1]["MapShapeCollection"]["Elements"].push(shapeElement);
                    var shapeItemCount = this.legendHighlightCollection[length - 1]["MapShapeCollection"]["Elements"].length - 1;
                    var shapeOldFillColor = shapeElement.getAttribute("fill");
                    var shapeOldOpacity = shapeElement.getAttribute("fill-opacity");
                    this.legendHighlightCollection[length - 1]["shapeOldFillColor"].push(shapeOldFillColor);
                    this.legendHighlightCollection[length - 1]["shapeOldOpacity"] = shapeOldOpacity;
                    var shapeOldColor = this.legendHighlightCollection[length - 1]["shapeOldFillColor"][shapeItemCount];
                    var shapeOldFillOpacity = this.legendHighlightCollection[length - 1]["shapeOldOpacity"];
                    this.shapePreviousColor = this.legendHighlightCollection[length - 1]["shapeOldFillColor"];
                    this.setColor(shapeElement, !isNullOrUndefined(legendModule.fill) ? legendModule.fill : shapeOldColor, isNullOrUndefined(legendModule.opacity) ? shapeOldFillOpacity : legendModule.opacity.toString(), legendModule.border.color, legendModule.border.width.toString(), "highlight");
                    this.setColor(targetElement, !isNullOrUndefined(legendModule.fill) ? legendModule.fill : legendHighlightColor, isNullOrUndefined(legendModule.opacity) ? shapeOldFillOpacity : legendModule.opacity.toString(), legendModule.border.color, legendModule.border.width.toString(), "highlight");
                  } else if (value === "selection") {
                    this.legendHighlightCollection = [];
                    this.maps.legendSelectionClass = legendModule;
                    if (j === 0) {
                      this.pushCollection(targetElement, this.maps.legendSelectionCollection, collection[i], layer.shapeSettings);
                      if (multiSelectEnable) {
                        this.maps.selectedLegendElementId.push(i);
                      } else {
                        if (this.maps.selectedLegendElementId.length === 0) {
                          this.maps.selectedLegendElementId.push(i);
                        } else {
                          this.maps.selectedLegendElementId = [];
                          this.maps.selectedLegendElementId.push(i);
                        }
                      }
                    }
                    selectLength = this.maps.legendSelectionCollection.length;
                    var legendSelectionColor = this.maps.legendSelectionCollection[selectLength - 1]["legendOldFill"];
                    this.maps.legendSelectionCollection[selectLength - 1]["MapShapeCollection"]["Elements"].push(shapeElement);
                    this.maps.legendSelectionCollection[selectLength - 1]["shapeOldFillColor"] = this.shapePreviousColor;
                    this.setColor(targetElement, !isNullOrUndefined(legendModule.fill) ? legendModule.fill : legendSelectionColor, legendModule.opacity.toString(), legendModule.border.color, legendModule.border.width.toString(), "selection");
                    this.setColor(shapeElement, !isNullOrUndefined(legendModule.fill) ? legendModule.fill : legendSelectionColor, legendModule.opacity.toString(), legendModule.border.color, legendModule.border.width.toString(), "selection");
                    if (this.maps.selectedElementId.indexOf(shapeElement.getAttribute("id")) === -1) {
                      this.maps.selectedElementId.push(shapeElement.getAttribute("id"));
                    }
                    if (j === data.length - 1) {
                      this.maps.legendSelection = false;
                      this.removeLegend(this.maps.legendSelectionCollection);
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    Legend2.prototype.setColor = function(element, fill, opacity, borderColor, borderWidth, type) {
      var isLineStringShape = element.parentElement.id.indexOf("LineString") > -1;
      if (type === "selection") {
        maintainStyleClass(isLineStringShape ? "LineselectionMap" : "ShapeselectionMap", isLineStringShape ? "LineselectionMapStyle" : "ShapeselectionMapStyle", isLineStringShape ? "transparent" : fill, opacity, isLineStringShape ? fill : borderColor, borderWidth, this.maps);
        element.setAttribute("class", isLineStringShape ? "LineselectionMapStyle" : "ShapeselectionMapStyle");
      } else {
        element.setAttribute("fill", isLineStringShape ? "transparent" : fill);
        element.setAttribute("fill-opacity", opacity);
        element.setAttribute("stroke", isLineStringShape ? fill : borderColor);
        element.setAttribute("stroke-width", (Number(borderWidth) / this.maps.scale).toString());
      }
    };
    Legend2.prototype.pushCollection = function(targetElement, collection, oldElement, shapeSettings) {
      collection.push({
        legendElement: targetElement,
        legendOldFill: oldElement["fill"],
        legendOldOpacity: oldElement["opacity"],
        legendOldBorderColor: oldElement["borderColor"],
        legendOldBorderWidth: oldElement["borderWidth"],
        shapeOpacity: shapeSettings.opacity,
        shapeOldBorderColor: shapeSettings.border.color || this.maps.themeStyle.shapeBorderColor,
        shapeOldBorderWidth: shapeSettings.border.width
      });
      var length = collection.length;
      collection[length - 1]["MapShapeCollection"] = { Elements: [] };
      collection[length - 1]["shapeOldFillColor"] = [];
      collection[length - 1]["shapeOldOpacity"] = null;
    };
    Legend2.prototype.removeLegend = function(collection) {
      for (var i = 0; i < collection.length; i++) {
        var item = collection[i];
        this.setColor(item["legendElement"], item["legendOldFill"], item["legendOldOpacity"], item["legendOldBorderColor"], item["legendOldBorderWidth"], "highlight");
        var dataCount = item["MapShapeCollection"]["Elements"].length;
        for (var j = 0; j < dataCount; j++) {
          var shapeFillColor = item["legendOldFill"].indexOf("url") !== -1 ? item["shapeOldFillColor"][j] : item["legendOldFill"];
          var shapeOpacity = !isNullOrUndefined(item["shapeOldOpacity"]) ? item["shapeOldOpacity"] : item["shapeOpacity"];
          this.setColor(item["MapShapeCollection"]["Elements"][j], shapeFillColor, shapeOpacity, item["shapeOldBorderColor"], item["shapeOldBorderWidth"], "highlight");
        }
      }
    };
    Legend2.prototype.removeLegendHighlightCollection = function() {
      if (this.legendHighlightCollection.length > 0) {
        this.removeLegend(this.legendHighlightCollection);
        this.legendHighlightCollection = [];
      }
    };
    Legend2.prototype.removeLegendSelectionCollection = function(targetElement) {
      if (this.maps.legendSelectionCollection.length > 0) {
        removeClass2(targetElement);
        var shapeElements = this.shapesOfLegend(targetElement);
        var dataCount = shapeElements.length;
        for (var j = 0; j < dataCount; j++) {
          var shapeElement = getElement2(shapeElements[j]);
          if (shapeElement.getAttribute("class") === "ShapeselectionMapStyle" || shapeElement.getAttribute("class") === "LineselectionMapStyle") {
            removeClass2(shapeElement);
            var selectedElementIdIndex = this.maps.selectedElementId.indexOf(shapeElement.id);
            if (selectedElementIdIndex !== -1) {
              this.maps.selectedElementId.splice(selectedElementIdIndex, 1);
            }
          }
        }
      }
    };
    Legend2.prototype.removeShapeHighlightCollection = function() {
      if (this.shapeHighlightCollection.length > 0) {
        for (var i = 0; i < this.shapeHighlightCollection.length; i++) {
          var item = this.shapeHighlightCollection[i];
          var removeFill = true;
          for (var j = 0; j < this.maps.legendSelectionCollection.length; j++) {
            if (this.maps.legendSelectionCollection[j]["legendElement"] === item["legendElement"]) {
              removeFill = false;
            }
          }
          if (removeFill) {
            this.setColor(item["legendElement"], item["legendOldFill"], item["legendOldOpacity"], item["legendOldBorderColor"], item["legendOldBorderWidth"], "highlight");
          }
        }
      }
    };
    Legend2.prototype.shapeHighLightAndSelection = function(targetElement, data, legendModule, getValue3, layerIndex) {
      if (data !== void 0) {
        this.updateLegendElement();
        this.shapeToggled = true;
        var collection = this.maps.legendModule.legendCollection;
        var indexes = this.legendIndexOnShape(data, layerIndex);
        var shapeElement = this.shapeDataOnLegend(targetElement);
        var toggleLegendCheck = this.maps.toggledLegendId.indexOf(indexes["actualIndex"]);
        if (this.maps.legendSettings.toggleLegendSettings.enable && toggleLegendCheck !== -1) {
          this.shapeToggled = false;
          this.legendHighlightCollection = [];
          var collectionIndex = this.getIndexofLegend(this.shapeHighlightCollection, shapeElement["LegendEle"]);
          if (collectionIndex !== -1) {
            this.shapeHighlightCollection.splice(collectionIndex, 1);
          }
          this.removeShapeHighlightCollection();
          return null;
        }
        if (indexes["currentIndex"] === void 0 && indexes["actualIndex"] === void 0) {
          this.removeShapeHighlightCollection();
          return null;
        }
        if (indexes["currentIndex"] === void 0 && getValue3 === "selection" && !this.maps.layers[layerIndex].selectionSettings.enableMultiSelect && targetElement.getAttribute("class") !== "ShapeselectionMapStyle") {
          this.maps.legendSelection = false;
        }
        if (getValue3 === "selection" && !this.maps.layers[layerIndex].selectionSettings.enableMultiSelect && !this.maps.legendSelection) {
          this.removeAllSelections();
          this.maps.legendSelection = true;
        }
        if (indexes["currentIndex"] === void 0) {
          if (getValue3 === "selection" && indexes["actualIndex"] !== void 0) {
            var checkSelection = 0;
            for (var i = 0; i < shapeElement["Elements"].length; i++) {
              if (shapeElement["Elements"][i].getAttribute("class") === "ShapeselectionMapStyle") {
                checkSelection++;
              }
            }
            var selectionIndex = this.maps.selectedLegendElementId.indexOf(indexes["actualIndex"]);
            if (selectionIndex === -1) {
              this.maps.selectedLegendElementId.push(indexes["actualIndex"]);
              this.maps.legendSelectionClass = legendModule;
            } else {
              if (checkSelection <= 1 && (targetElement.getAttribute("class") === "ShapeselectionMapStyle" || targetElement.getAttribute("class") === "LineselectionMapStyle")) {
                if (!this.maps.layers[layerIndex].selectionSettings.enableMultiSelect) {
                  this.maps.selectedLegendElementId.splice(selectionIndex, 1);
                } else {
                  if (checkSelection <= 1 && (targetElement.getAttribute("class") === "ShapeselectionMapStyle" || targetElement.getAttribute("class") === "LineselectionMapStyle")) {
                    this.maps.selectedLegendElementId.splice(selectionIndex, 1);
                  }
                }
              }
            }
          }
          this.removeShapeHighlightCollection();
          return null;
        }
        var text = collection[indexes["actualIndex"]]["text"];
        var content = void 0;
        var legendShape = void 0;
        if (this.maps.legendSettings.mode === "Default") {
          if (indexes["currentIndex"] !== void 0) {
            content = document.getElementById(this.maps.element.id + "_Legend_Text_Index_" + indexes["actualIndex"]).textContent;
            legendShape = document.getElementById(this.maps.element.id + "_Legend_Shape_Index_" + indexes["actualIndex"]);
          }
        } else {
          content = document.getElementById(this.maps.element.id + "_Legend_Index_" + indexes["actualIndex"] + "_Text").textContent;
          legendShape = document.getElementById(this.maps.element.id + "_Legend_Index_" + indexes["actualIndex"]);
        }
        this.oldShapeElement = shapeElement["LegendEle"];
        var length_1 = this.maps.legendSelectionCollection.length;
        if (text === content) {
          var shapeMatched = true;
          if (this.maps.legendSelectionCollection) {
            for (var i = 0; i < this.maps.legendSelectionCollection.length; i++) {
              if (this.maps.legendSelectionCollection[i]["legendElement"] === shapeElement["LegendEle"]) {
                shapeMatched = false;
                break;
              }
            }
          }
          if (getValue3 === "highlight" && shapeMatched) {
            var selectionEle = this.isTargetSelected(shapeElement, this.shapeHighlightCollection);
            if (selectionEle === void 0 || selectionEle && !selectionEle["IsSelected"]) {
              this.pushCollection(legendShape, this.shapeHighlightCollection, collection[indexes["actualIndex"]], this.maps.layers[layerIndex].shapeSettings);
            }
            for (var j = 0; j < this.shapeHighlightCollection.length; j++) {
              if (shapeElement["LegendEle"].id === this.shapeHighlightCollection[j]["legendElement"].id) {
                this.shapeHighlightCollection[j]["legendElement"] = shapeElement["LegendEle"];
              }
            }
            if (length_1 > 0) {
              for (var j = 0; j < length_1; j++) {
                if (shapeElement["LegendEle"] === this.maps.legendSelectionCollection[j]["legendElement"]) {
                  this.maps.legendSelectionCollection[j]["legendElement"] = shapeElement["LegendEle"];
                  this.removeShapeHighlightCollection();
                  break;
                } else if (j === length_1 - 1) {
                  this.removeShapeHighlightCollection();
                  this.setColor(legendShape, !isNullOrUndefined(legendModule.fill) ? legendModule.fill : legendShape.getAttribute("fill"), legendModule.opacity.toString(), legendModule.border.color, legendModule.border.width.toString(), "highlight");
                }
              }
            } else {
              this.removeShapeHighlightCollection();
              this.setColor(legendShape, !isNullOrUndefined(legendModule.fill) ? legendModule.fill : legendShape.getAttribute("fill"), !isNullOrUndefined(legendModule.opacity) ? legendModule.opacity.toString() : "1", legendModule.border.color, legendModule.border.width.toString(), "highlight");
            }
          } else if (getValue3 === "selection") {
            var selectionEle = this.isTargetSelected(shapeElement, this.maps.legendSelectionCollection);
            if (length_1 > 0) {
              var j = 0;
              while (j < this.maps.legendSelectionCollection.length) {
                if (shapeElement["LegendEle"] !== this.maps.legendSelectionCollection[j]["legendElement"] && !legendModule.enableMultiSelect) {
                  var element = this.maps.legendSelectionCollection[j];
                  var selectedLegendIndex = this.maps.selectedLegendElementId.indexOf(indexes["actualIndex"]);
                  this.maps.selectedLegendElementId.splice(selectedLegendIndex, 1);
                  this.maps.legendSelectionCollection.splice(j, 1);
                  removeClass2(element["legendElement"]);
                  this.maps.shapeSelections = true;
                  j = 0;
                } else {
                  j++;
                }
              }
            }
            if (selectionEle && (selectionEle["IsSelected"] && (targetElement.getAttribute("class") === "ShapeselectionMapStyle" || targetElement.getAttribute("class") === "LineselectionMapStyle"))) {
              var multiSelection = 0;
              if (legendModule.enableMultiSelect) {
                for (var i = 0; i < shapeElement["Elements"].length; i++) {
                  if (targetElement.getAttribute("class") === shapeElement["Elements"][i].getAttribute("class")) {
                    multiSelection++;
                  }
                }
              }
              if (multiSelection <= 1 && (!legendModule.enableMultiSelect ? this.maps.legendSelection : true)) {
                this.maps.selectedLegendElementId.splice(this.maps.selectedLegendElementId.indexOf(indexes["actualIndex"]), 1);
                if (!isNullOrUndefined(shapeElement["LegendEle"])) {
                  removeClass2(shapeElement["LegendEle"]);
                }
                this.maps.legendSelectionCollection.splice(selectionEle["SelectionIndex"], 1);
                this.maps.shapeSelections = true;
              }
            } else {
              if ((selectionEle === void 0 || selectionEle && !selectionEle["IsSelected"]) && !isNullOrUndefined(legendShape)) {
                var legendSelectionIndex = this.getIndexofLegend(this.maps.legendSelectionCollection, legendShape);
                if (legendSelectionIndex === -1) {
                  this.pushCollection(legendShape, this.maps.legendSelectionCollection, collection[indexes["actualIndex"]], this.maps.layers[layerIndex].shapeSettings);
                }
              }
              var addId = true;
              for (var i = 0; i < this.maps.selectedLegendElementId.length; i++) {
                if (indexes["actualIndex"] === this.maps.selectedLegendElementId[i]) {
                  addId = false;
                }
              }
              if (addId) {
                this.maps.selectedLegendElementId.push(indexes["actualIndex"]);
              }
              this.maps.legendSelectionClass = legendModule;
              this.removeLegend(this.shapeHighlightCollection);
              if (!isNullOrUndefined(legendShape)) {
                this.setColor(legendShape, !isNullOrUndefined(legendModule.fill) ? legendModule.fill : legendShape.getAttribute("fill"), !isNullOrUndefined(legendModule.opacity) ? legendModule.opacity.toString() : "1", legendModule.border.color, legendModule.border.width.toString(), "selection");
                var legendSelectionIndex = this.getIndexofLegend(this.maps.legendSelectionCollection, legendShape);
                this.maps.legendSelectionCollection[legendSelectionIndex]["MapShapeCollection"]["Elements"].push(targetElement);
              }
              this.maps.shapeSelections = false;
            }
          } else if (document.getElementsByClassName("highlightMapStyle").length > 0) {
            this.removeShapeHighlightCollection();
            removeClass2(document.getElementsByClassName("highlightMapStyle")[0]);
          }
        }
      } else {
        this.removeShapeHighlightCollection();
      }
    };
    Legend2.prototype.isTargetSelected = function(target, collection) {
      var selectEle;
      for (var i = 0; i < collection.length; i++) {
        if (!isNullOrUndefined(target["LegendEle"].getAttribute("id")) && target["LegendEle"].getAttribute("id") === collection[i]["legendElement"].getAttribute("id")) {
          selectEle = { IsSelected: true, SelectionIndex: i };
        }
      }
      return selectEle;
    };
    Legend2.prototype.updateLegendElement = function() {
      for (var i = 0; i < this.maps.legendSelectionCollection.length; i++) {
        if (document.getElementById(this.maps.legendSelectionCollection[i]["legendElement"].id)) {
          this.maps.legendSelectionCollection[i]["legendElement"] = document.getElementById(this.maps.legendSelectionCollection[i]["legendElement"].id);
        }
      }
    };
    Legend2.prototype.getIndexofLegend = function(targetCollection, targetElement) {
      var legendIndex = targetCollection.map(function(e) {
        return e["legendElement"];
      }).indexOf(targetElement);
      return legendIndex;
    };
    Legend2.prototype.removeAllSelections = function() {
      for (var i = 0; i < this.maps.selectedElementId.length; i++) {
        var selectedElement = document.getElementById(this.maps.selectedElementId[i]);
        removeClass2(selectedElement);
      }
      for (var j = 0; j < this.maps.selectedLegendElementId.length; j++) {
        var idIndex = this.maps.legendSettings.mode === "Interactive" ? this.maps.element.id + "_Legend_Index_" : this.maps.element.id + "_Legend_Shape_Index_";
        var selectedElement = idIndex + this.maps.selectedLegendElementId[j];
        var legendElement = document.getElementById(selectedElement);
        if (!isNullOrUndefined(legendElement)) {
          removeClass2(document.getElementById(selectedElement));
        }
      }
      this.maps.legendSelectionCollection = [];
      this.maps.selectedLegendElementId = [];
      this.maps.selectedElementId = [];
    };
    Legend2.prototype.legendIndexOnShape = function(data, index) {
      var legendIndex;
      var actualIndex;
      var path = this.maps.layers[index].shapeDataPath;
      var value = data[path];
      var legendType = this.maps.legendSettings.mode;
      var collection = this.maps.legendModule.legendCollection;
      var currentCollection;
      if (legendType === "Default" && !isNullOrUndefined(this.maps.legendModule.totalPages) && this.maps.legendModule.totalPages.length > 0) {
        currentCollection = this.maps.legendModule.totalPages[this.maps.legendModule.currentPage]["Collection"];
      }
      var currentCollectionLength = legendType === "Default" && !isNullOrUndefined(currentCollection) ? currentCollection["length"] : 1;
      for (var i = 0; i < collection.length; i++) {
        var dataValue = collection[i]["data"];
        for (var k = 0; k < currentCollectionLength; k++) {
          if (legendType !== "Default" || collection[i]["text"] === currentCollection[k]["DisplayText"]) {
            for (var j = 0; j < dataValue.length; j++) {
              if (value === dataValue[j]["name"]) {
                legendIndex = k;
              }
            }
          }
        }
        for (var j = 0; j < dataValue.length; j++) {
          if (value === dataValue[j]["name"]) {
            actualIndex = i;
          }
        }
      }
      return { currentIndex: legendIndex, actualIndex };
    };
    Legend2.prototype.shapeDataOnLegend = function(targetElement) {
      var shapeIndex;
      var layerIndex;
      var dataIndex;
      var pointIndex;
      var collection = this.maps.legendModule.legendCollection;
      var legend = this.maps.legendSettings;
      for (var i = 0; i < collection.length; i++) {
        var data = collection[i]["data"];
        var process = false;
        var elements = [];
        var currentElement = { Elements: [] };
        for (var j = 0; j < data.length; j++) {
          var shapeElement = void 0;
          shapeIndex = data[j]["shapeIndex"];
          layerIndex = data[j]["layerIndex"];
          dataIndex = data[j]["dataIndex"];
          pointIndex = data[j]["pointIndex"];
          if (pointIndex === -1) {
            shapeElement = document.getElementById(this.maps.element.id + "_LayerIndex_" + layerIndex + "_shapeIndex_" + shapeIndex + "_dataIndex_" + dataIndex);
          } else {
            shapeElement = document.getElementById(this.maps.element.id + "_LayerIndex_" + layerIndex + "_shapeIndex_" + shapeIndex + "_dataIndex_" + dataIndex + "_multiLine_" + pointIndex);
          }
          if (targetElement === shapeElement) {
            process = true;
          }
          elements.push(shapeElement);
        }
        if (process) {
          if (isNullOrUndefined(currentElement["LegendEle"])) {
            currentElement["LegendEle"] = legend.mode === "Default" ? document.getElementById(this.maps.element.id + "_Legend_Shape_Index_" + i) : document.getElementById(this.maps.element.id + "_Legend_Index_" + i);
          }
          currentElement["Elements"] = elements;
          return currentElement;
        }
      }
      return null;
    };
    Legend2.prototype.shapesOfLegend = function(targetElement) {
      var shapeIndex;
      var layerIndex;
      var dataIndex;
      var pointIndex;
      var idIndex = parseFloat(targetElement.id.charAt(targetElement.id.length - 1));
      var data = this.maps.legendModule.legendCollection[idIndex]["data"];
      var legendShapeElements = [];
      for (var i = 0; i < data.length; i++) {
        var shapeElement = void 0;
        shapeIndex = data[i]["shapeIndex"];
        layerIndex = data[i]["layerIndex"];
        dataIndex = data[i]["dataIndex"];
        pointIndex = data[i]["pointIndex"];
        if (pointIndex === -1) {
          shapeElement = document.getElementById(this.maps.element.id + "_LayerIndex_" + layerIndex + "_shapeIndex_" + shapeIndex + "_dataIndex_" + dataIndex);
        } else {
          shapeElement = document.getElementById(this.maps.element.id + "_LayerIndex_" + layerIndex + "_shapeIndex_" + shapeIndex + "_dataIndex_" + dataIndex + "_multiLine_" + pointIndex);
        }
        if (!isNullOrUndefined(shapeElement)) {
          legendShapeElements.push(shapeElement.id);
        }
      }
      return legendShapeElements;
    };
    Legend2.prototype.legendToggle = function() {
      var map = this.maps;
      var legend = map.legendSettings;
      if (this.maps.selectedLegendElementId) {
        for (var j = 0; j < this.maps.selectedLegendElementId.length; j++) {
          var idIndex = legend.mode === "Interactive" ? this.maps.element.id + "_Legend_Index_" : this.maps.element.id + "_Legend_Shape_Index_";
          var selectedElement = map.svgObject.querySelector("#" + idIndex + this.maps.selectedLegendElementId[j]);
          if (!isNullOrUndefined(selectedElement)) {
            var fill = !isNullOrUndefined(this.maps.legendSelectionClass.fill) ? this.maps.legendSelectionClass.fill : selectedElement.getAttribute("fill");
            this.setColor(selectedElement, fill, this.maps.legendSelectionClass.opacity.toString(), this.maps.legendSelectionClass.border.color, this.maps.legendSelectionClass.border.width.toString(), "selection");
            for (var i = 0; i < this.maps.legendSelectionCollection.length; i++) {
              if (this.maps.legendSelectionCollection[i]["legendElement"].id === selectedElement.id) {
                this.maps.legendSelectionCollection[i]["legendElement"] = selectedElement;
              }
            }
            var legendSelectionIndex = this.getIndexofLegend(this.maps.legendSelectionCollection, selectedElement);
            if (legendSelectionIndex === -1) {
              var layerIndex = this.maps.legendModule.legendCollection[this.maps.selectedLegendElementId[j]]["data"][j]["layerIndex"];
              this.pushCollection(selectedElement, this.maps.legendSelectionCollection, this.maps.legendModule.legendCollection[this.maps.selectedLegendElementId[j]], this.maps.layers[layerIndex].shapeSettings);
            }
          }
        }
      }
      if (this.maps.toggledLegendId) {
        for (var j = 0; j < this.maps.toggledLegendId.length; j++) {
          var legendTextId = legend.mode === "Interactive" ? "#" + this.maps.element.id + "_Legend_Index_" + this.maps.toggledLegendId[j] + "_Text" : "#" + this.maps.element.id + "_Legend_Text_Index_" + this.maps.toggledLegendId[j];
          var textElement2 = map.svgObject.querySelector(legendTextId);
          if (!isNullOrUndefined(textElement2)) {
            textElement2.setAttribute("fill", "#E5E5E5");
          }
          var legendShapeId = legend.mode === "Interactive" ? "#" + this.maps.element.id + "_Legend_Index_" + this.maps.toggledLegendId[j] : "#" + this.maps.element.id + "_Legend_Shape_Index_" + this.maps.toggledLegendId[j];
          var legendElement = map.svgObject.querySelector(legendShapeId);
          if (!isNullOrUndefined(legendElement)) {
            legendElement.setAttribute("fill", "#E5E5E5");
          }
        }
      }
    };
    Legend2.prototype.renderLegendBorder = function() {
      var map = this.maps;
      var legend = map.legendSettings;
      var legendTitle = legend.title.text;
      var textStyle = {
        fontFamily: legend.titleStyle.fontFamily,
        fontStyle: legend.titleStyle.fontStyle,
        fontWeight: legend.titleStyle.fontWeight,
        size: legend.titleStyle.size,
        color: legend.titleStyle.color,
        opacity: legend.titleStyle.opacity
      };
      var textOptions;
      var spacing = 10;
      var trimTitle = textTrim(this.legendItemRect.width + spacing * 2, legendTitle, textStyle);
      var textSize = measureText2(trimTitle, textStyle);
      this.legendBorderRect = new Rect2(this.legendItemRect.x - spacing, this.legendItemRect.y - spacing - textSize.height, this.legendItemRect.width + spacing * 2, this.legendItemRect.height + spacing * 2 + textSize.height + (legend.mode === "Interactive" ? 0 : this.page !== 0 ? spacing : 0));
      var legendBorder = {
        color: legend.border.color || this.maps.themeStyle.legendBorderColor,
        opacity: legend.border.opacity,
        width: legend.border.width || this.maps.themeStyle.legendBorderWidth
      };
      legendBorder.opacity = isNullOrUndefined(legendBorder.opacity) ? 1 : legendBorder.opacity;
      var renderOptions = new RectOption(map.element.id + "_Legend_Border", legend.background, legendBorder, 1, this.legendBorderRect, null, null, "", "");
      this.legendGroup.appendChild(map.renderer.drawRectangle(renderOptions));
      this.getLegendAlignment(map, this.legendBorderRect.width, this.legendBorderRect.height, legend);
      this.legendGroup.setAttribute("transform", "translate( " + (this.translate.x + -this.legendBorderRect.x) + " " + (this.translate.y + -this.legendBorderRect.y) + " )");
      if (legend.position !== "Float") {
        map.svgObject.appendChild(this.legendGroup);
      }
      if (legendTitle) {
        textStyle.color = textStyle.color !== null ? textStyle.color : this.maps.themeStyle.legendTitleFontColor;
        textStyle.fontFamily = !isNullOrUndefined(textStyle.fontFamily) ? textStyle.fontFamily : this.maps.themeStyle.fontFamily;
        textStyle.size = !isNullOrUndefined(textStyle.size) ? textStyle.size : this.maps.themeStyle.subTitleFontSize || Theme.legendTitleFont.size;
        textStyle.fontWeight = !isNullOrUndefined(textStyle.fontWeight) ? textStyle.fontWeight : this.maps.themeStyle.titleFontWeight || Theme.legendTitleFont.fontWeight;
        textOptions = new TextOption2(map.element.id + "_LegendTitle", this.legendItemRect.x + this.legendItemRect.width / 2, this.legendItemRect.y - textSize.height / 2 - spacing / 2, "middle", trimTitle, "");
        var element = renderTextElement(textOptions, textStyle, textStyle.color, this.legendGroup);
        element.setAttribute("aria-label", legendTitle);
        element.setAttribute("role", "region");
      }
    };
    Legend2.prototype.changeNextPage = function(e) {
      this.currentPage = e.target.id.indexOf("_Left_Page_") > -1 ? this.currentPage - 1 : this.currentPage + 1;
      this.legendGroup = this.maps.renderer.createGroup({ id: this.maps.element.id + "_Legend_Group" });
      this.maps.mapAreaRect = this.initialMapAreaRect;
      this.drawLegendItem(this.currentPage);
      if (!isNullOrUndefined(this.maps.legendModule) && this.maps.legendSettings.position === "Float") {
        if (this.maps.isTileMap) {
          this.maps.mapLayerPanel.layerGroup.appendChild(this.maps.legendModule.legendGroup);
        } else {
          this.maps.svgObject.appendChild(this.maps.legendModule.legendGroup);
        }
      }
      if (querySelector(this.maps.element.id + "_Legend_Border", this.maps.element.id)) {
        querySelector(this.maps.element.id + "_Legend_Border", this.maps.element.id).style.pointerEvents = "none";
      }
    };
    Legend2.prototype.getLegendAlignment = function(map, width, height, legend) {
      var x;
      var y;
      var spacing = 10;
      var totalRect;
      totalRect = extend({}, map.mapAreaRect, totalRect, true);
      var areaX = totalRect.x;
      var areaY = totalRect.y;
      var areaHeight = totalRect.height;
      var areaWidth = totalRect.width;
      var totalWidth = map.availableSize.width;
      var totalHeight = map.availableSize.height;
      var locationX = !isNullOrUndefined(legend.location.x) ? typeof legend.location.x === "string" && legend.location.x.indexOf("%") > -1 ? map.availableSize.width / 100 * parseFloat(legend.location.x) : typeof legend.location.x === "string" ? parseFloat(legend.location.x) : legend.location.x : 0;
      var locationY = !isNullOrUndefined(legend.location.y) ? typeof legend.location.y === "string" && legend.location.y.indexOf("%") > -1 ? map.availableSize.height / 100 * parseFloat(legend.location.y) : typeof legend.location.y === "string" ? parseFloat(legend.location.y) : legend.location.y : 0;
      if (legend.position === "Float") {
        this.translate = map.isTileMap ? new Point(locationX, locationY + spacing / 4) : new Point(locationX + map.mapAreaRect.x, locationY + map.mapAreaRect.y);
        this.legendTotalRect = map.mapAreaRect;
      } else {
        switch (legend.position) {
          case "Top":
          case "Bottom":
            totalRect.height = legend.position === "Top" ? areaHeight - height : areaHeight - height - spacing * 2;
            x = totalWidth / 2 - width / 2;
            y = legend.position === "Top" ? areaY : areaY + totalRect.height;
            totalRect.y = legend.position === "Top" ? areaY + height + (map.isTileMap ? spacing / 2 : spacing) : areaY - spacing / 2;
            break;
          case "Left":
          case "Right":
            totalRect.width = areaWidth - width - map.mapAreaRect.x;
            x = legend.position === "Left" ? areaX + spacing / 2 : areaX + totalRect.width + spacing;
            y = totalHeight / 2 - height / 2;
            totalRect.x = legend.position === "Left" ? areaX + width + spacing : areaX;
            break;
        }
        switch (legend.alignment) {
          case "Near":
            if (legend.position === "Top" || legend.position === "Bottom") {
              x = totalRect.x - (legend.mode === "Interactive" ? spacing : 0);
            } else {
              y = totalRect.y - (!(legend.height && legend.width) && legend.mode === "Interactive" ? map.mapAreaRect.x : 0);
            }
            break;
          case "Far":
            if (legend.position === "Top" || legend.position === "Bottom") {
              x = totalWidth - width - (legend.mode === "Interactive" ? 0 : spacing);
            } else {
              y = totalHeight - height - (legend.mode === "Default" ? spacing : 0);
            }
            break;
        }
        if ((legend.height || legend.width) && legend.mode !== "Interactive") {
          this.legendTotalRect = map.mapAreaRect = map.totalRect = totalRect;
        } else {
          map.totalRect = null;
          if ((legend.height || legend.width) && legend.mode === "Interactive") {
            map.totalRect = totalRect;
          }
          this.legendTotalRect = map.mapAreaRect = totalRect;
        }
        if (legend.position === "Left") {
          map.mapAreaRect.width = totalRect.width;
        }
        this.translate = new Point(x, y);
      }
    };
    Legend2.prototype.getMarkersLegendCollections = function(layerIndex, markers) {
      var _this = this;
      Array.prototype.forEach.call(markers, function(marker2, markerIndex) {
        var dataSource = marker2.dataSource;
        var field = marker2.legendText;
        var templateFn;
        Array.prototype.forEach.call(dataSource, function(data, dataIndex) {
          var imageSrc = null;
          var showLegend = isNullOrUndefined(data[_this.maps.legendSettings.showLegendPath]) ? true : data[_this.maps.legendSettings.showLegendPath];
          var latitude = !isNullOrUndefined(data["latitude"]) || !isNullOrUndefined(data["Latitude"]) || !isNullOrUndefined(data[marker2.latitudeValuePath]);
          var longitude = !isNullOrUndefined(data["longitude"]) || !isNullOrUndefined(data["Longitude"]) || !isNullOrUndefined(data[marker2.longitudeValuePath]);
          if (marker2.visible && showLegend && latitude && longitude) {
            if (marker2.template) {
              templateFn = getTemplateFunction(marker2.template, _this.maps);
              var templateElement = templateFn(_this.maps);
              var markerEle = isNullOrUndefined(templateElement.childElementCount) ? templateElement[0] : templateElement;
              imageSrc = markerEle.querySelector("img").src;
            }
            var text = isNullOrUndefined(data[field]) ? "" : data[field];
            var legendFill = !isNullOrUndefined(marker2.colorValuePath) ? data[marker2.colorValuePath] : marker2.fill;
            var newData = [];
            if (_this.maps.legendSettings.removeDuplicateLegend) {
              newData.push(_this.getMarkerLegendData(layerIndex, text, legendFill));
              _this.getOverallLegendItemsCollection(text, legendFill, newData, showLegend);
            } else {
              newData.push({
                layerIndex,
                markerIndex,
                dataIndex,
                value: legendFill,
                name: text,
                shape: !isNullOrUndefined(marker2.shapeValuePath) && !isNullOrUndefined(data[marker2.shapeValuePath]) && data[marker2.shapeValuePath] !== "" ? data[marker2.shapeValuePath] : _this.maps.legendSettings.useMarkerShape ? marker2.shape : _this.maps.legendSettings.shape
              });
              _this.getOverallLegendItemsCollection(text, legendFill, newData, showLegend);
            }
          }
        });
      });
    };
    Legend2.prototype.getMarkerLegendData = function(layerIndex, text, legendFill) {
      var _this = this;
      var legendData = [];
      this.maps.layers[layerIndex].markerSettings.map(function(markerSettings, markerIndex) {
        var markerData = markerSettings.dataSource;
        Array.prototype.forEach.call(markerData, function(data, dataIndex) {
          var marker2 = _this.maps.layers[layerIndex].markerSettings[markerIndex];
          if ((text === data[marker2.legendText] || text === "") && legendFill === (data[marker2.colorValuePath] || marker2.fill)) {
            legendData.push({
              layerIndex,
              markerIndex,
              dataIndex,
              value: legendFill,
              name: text,
              shape: !isNullOrUndefined(marker2.shapeValuePath) ? data[marker2.shapeValuePath] : marker2.shape
            });
          }
        });
      });
      return legendData;
    };
    Legend2.prototype.getRangeLegendCollection = function(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath) {
      var _this = this;
      var legendText;
      var legendIndex = 0;
      var fill = this.maps.legendSettings.fill;
      var rangeData = [];
      var _loop_1 = function(colorMap2) {
        if (!isNullOrUndefined(colorMap2.from) && !isNullOrUndefined(colorMap2.to)) {
          legendText = !isNullOrUndefined(colorMap2.label) ? colorMap2.label : colorMap2.from + " - " + colorMap2.to;
          rangeData = [];
          var colorMapProcess_1 = false;
          if (!isNullOrUndefined(dataSource) && dataSource.length > 0) {
            Array.prototype.forEach.call(dataSource, function(data, dataIndex) {
              var colorValue = colorValuePath.indexOf(".") > -1 ? Number(getValueFromObject(data, colorValuePath)) : parseFloat(data[colorValuePath]);
              if (colorValue >= colorMap2.from && colorValue <= colorMap2.to) {
                colorMapProcess_1 = true;
                rangeData.push(_this.getLegendData(layerIndex, dataIndex, data, dataPath, layerData, propertyPath, colorValue));
              }
            });
          }
          if (!colorMapProcess_1) {
            rangeData.push({
              layerIndex,
              shapeIndex: null,
              dataIndex: null,
              name: null,
              value: null
            });
          }
          var legendFill = isNullOrUndefined(fill) ? Object.prototype.toString.call(colorMap2.color) === "[object Array]" ? !isNullOrUndefined(colorMap2.value) ? colorMap2.color[0] : this_1.legendGradientColor(colorMap2, legendIndex) : colorMap2.color : fill;
          legendIndex++;
          this_1.getOverallLegendItemsCollection(legendText, legendFill, rangeData, colorMap2.showLegend);
        }
      };
      var this_1 = this;
      for (var _i = 0, colorMapping_1 = colorMapping; _i < colorMapping_1.length; _i++) {
        var colorMap = colorMapping_1[_i];
        _loop_1(colorMap);
      }
    };
    Legend2.prototype.getOverallLegendItemsCollection = function(legendText, legendFill, legendData, showLegend) {
      var newColllection = [];
      var legend = this.maps.legendSettings;
      if (legendData.length > 0 && showLegend) {
        for (var i = 0; i < legendData.length; i++) {
          var collection = legendData[i];
          if (collection.length > 0) {
            for (var j = 0; j < collection.length; j++) {
              newColllection.push(collection[j]);
            }
          } else {
            newColllection.push(legendData[i]);
          }
          newColllection["_isVisible"] = true;
        }
        var isDuplicate = this.maps.legendSettings.removeDuplicateLegend ? this.removeDuplicates(this.legendCollection, legendText, legendFill) : false;
        if (!isDuplicate) {
          this.legendCollection.push({
            text: legendText,
            fill: legendFill,
            data: newColllection,
            opacity: legend.opacity,
            borderColor: legend.shapeBorder.color,
            borderWidth: legend.shapeBorder.width
          });
        } else {
          for (var i = 0; i < this.legendCollection.length; i++) {
            if (this.legendCollection[i]["text"] === legendText && this.legendCollection[i]["fill"] === legendFill) {
              this.legendCollection[i].data.push(newColllection[0]);
            }
          }
        }
      }
    };
    Legend2.prototype.removeDuplicates = function(legendCollection, text, legendFill) {
      var isDuplicate = false;
      for (var i = 0; i < legendCollection.length; i++) {
        if ((legendCollection[i]["text"] === text || legendCollection[i]["text"] === "") && legendCollection[i]["fill"] === legendFill) {
          isDuplicate = true;
          break;
        } else {
          continue;
        }
      }
      return isDuplicate;
    };
    Legend2.prototype.getEqualLegendCollection = function(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath) {
      var _this = this;
      var fill = this.maps.legendSettings.fill;
      var equalValues = [];
      var legendText;
      var equalData = [];
      var outOfRangeValues = [];
      var outOfRange = [];
      var _loop_2 = function(colorMap2) {
        if (!isNullOrUndefined(colorMap2.value)) {
          legendText = !isNullOrUndefined(colorMap2.label) ? colorMap2.label : colorMap2.value;
          equalData = [];
          var eqaulColorProcess_1 = false;
          if (!isNullOrUndefined(dataSource) && dataSource.length > 0) {
            Array.prototype.forEach.call(dataSource, function(data, dataIndex) {
              var equalValue = colorValuePath && colorValuePath.indexOf(".") > -1 ? getValueFromObject(data, colorValuePath) : data[colorValuePath];
              if (equalValue === colorMap2.value) {
                eqaulColorProcess_1 = true;
                if (equalValues.indexOf(equalValue) === -1) {
                  equalValues.push(equalValue);
                }
                equalData.push(_this.getLegendData(layerIndex, dataIndex, data, dataPath, layerData, propertyPath, equalValue));
              } else {
                if (outOfRangeValues.indexOf(equalValue) === -1) {
                  outOfRangeValues.push(equalValue);
                }
              }
            });
          }
          for (var x = 0; x < equalValues.length; x++) {
            for (var y = 0; y < outOfRangeValues.length; y++) {
              if (equalValues[x] === outOfRangeValues[y]) {
                var equalIndex = outOfRangeValues.indexOf(equalValues[x]);
                outOfRangeValues.splice(equalIndex, 1);
              }
            }
          }
          if (!eqaulColorProcess_1) {
            equalData.push({
              layerIndex,
              shapeIndex: null,
              dataIndex: null,
              name: null,
              value: null
            });
          }
          var legendFill = isNullOrUndefined(fill) ? Object.prototype.toString.call(colorMap2.color) === "[object Array]" ? colorMap2.color[0] : colorMap2.color : fill;
          this_2.getOverallLegendItemsCollection(legendText, legendFill, equalData, colorMap2.showLegend);
        } else if (isNullOrUndefined(colorMap2.minOpacity) && isNullOrUndefined(colorMap2.maxOpacity) && isNullOrUndefined(colorMap2.value) && isNullOrUndefined(colorMap2.from) && isNullOrUndefined(colorMap2.to) && !isNullOrUndefined(colorMap2.color)) {
          Array.prototype.forEach.call(dataSource, function(data, dataIndex) {
            var equalValue = colorValuePath.indexOf(".") > -1 ? getValueFromObject(data, colorValuePath) : data[colorValuePath];
            for (var k = 0; k < outOfRangeValues.length; k++) {
              if (equalValue === outOfRangeValues[k]) {
                outOfRange.push(_this.getLegendData(layerIndex, dataIndex, data, dataPath, layerData, propertyPath, equalValue));
              }
            }
          });
          if (outOfRangeValues.length === 0) {
            var range_1 = false;
            Array.prototype.forEach.call(dataSource, function(data, dataIndex) {
              range_1 = false;
              var rangeValue = data[colorValuePath];
              for (var z = 0; z < colorMapping.length; z++) {
                if (!isNullOrUndefined(rangeValue) && !isNaN(rangeValue)) {
                  if (rangeValue >= colorMapping[z].from && rangeValue <= colorMapping[z].to) {
                    range_1 = true;
                  }
                } else if (!range_1) {
                  range_1 = false;
                }
              }
              if (!range_1) {
                outOfRange.push(_this.getLegendData(layerIndex, dataIndex, data, dataPath, layerData, propertyPath, rangeValue));
              }
            });
          }
          legendText = !isNullOrUndefined(colorMap2.label) ? colorMap2.label : "Others";
          var outfill = Object.prototype.toString.call(colorMap2.color) === "[object Array]" ? colorMap2.color[0] : colorMap2.color;
          var legendOutFill = outfill;
          this_2.getOverallLegendItemsCollection(legendText, legendOutFill, outOfRange, colorMap2.showLegend);
        }
      };
      var this_2 = this;
      for (var _i = 0, colorMapping_2 = colorMapping; _i < colorMapping_2.length; _i++) {
        var colorMap = colorMapping_2[_i];
        _loop_2(colorMap);
      }
    };
    Legend2.prototype.getDataLegendCollection = function(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath) {
      var _this = this;
      var legendText;
      var fill = this.maps.legendSettings.fill;
      var valuePath = this.maps.legendSettings.valuePath;
      if (!isNullOrUndefined(colorValuePath) && !isNullOrUndefined(dataSource)) {
        Array.prototype.forEach.call(dataSource, function(data, dataIndex) {
          var showLegend = isNullOrUndefined(_this.maps.legendSettings.showLegendPath) ? true : isNullOrUndefined(data[_this.maps.legendSettings.showLegendPath]) ? false : data[_this.maps.legendSettings.showLegendPath];
          var dataValue = colorValuePath.indexOf(".") > -1 ? getValueFromObject(data, colorValuePath) : data[colorValuePath];
          var newData = [];
          var legendFill = isNullOrUndefined(fill) ? dataValue : fill;
          if (!isNullOrUndefined(dataValue) && colorMapping.length === 0 && (!isNullOrUndefined(valuePath) || !isNullOrUndefined(dataPath))) {
            legendText = !isNullOrUndefined(data[valuePath]) ? valuePath.indexOf(".") > -1 ? getValueFromObject(data, valuePath) : data[valuePath] : dataPath.indexOf(".") > -1 ? getValueFromObject(data, dataPath) : data[dataPath];
            newData.push(_this.getLegendData(layerIndex, dataIndex, data, dataPath, layerData, propertyPath, dataValue));
          }
          _this.getOverallLegendItemsCollection(legendText, legendFill, newData, showLegend);
        });
      }
    };
    Legend2.prototype.interactiveHandler = function(e) {
      var target = e.target;
      var legend = this.maps.legendSettings;
      var id = this.maps.element.id + "_Interactive_Legend";
      var hoverId = legend.type === "Layers" ? "_shapeIndex_" : legend.type === "Markers" ? "_MarkerIndex_" : "_BubbleIndex_";
      if (target.id.indexOf(hoverId) > 1) {
        var layerIndex = parseFloat(target.id.split("_LayerIndex_")[1].split("_")[0]);
        var dataIndex = parseFloat(target.id.split(/_dataIndex_/i)[1].split("_")[0]);
        var fill = void 0;
        var stroke = void 0;
        var strokeWidth = void 0;
        if (!isNullOrUndefined(querySelector(id, this.maps.element.id))) {
          remove(querySelector(id, this.maps.element.id));
        }
        var layer = this.maps.layersCollection[layerIndex];
        var markerVisible = legend.type === "Layers" ? layer.visible : legend.type === "Markers" ? layer.markerSettings[parseFloat(target.id.split("_MarkerIndex_")[1].split("_")[0])].visible : this.maps.getBubbleVisible(this.maps.layersCollection[layerIndex]);
        if (legend.visible && this.legendRenderingCollections.length > 0 && legend.mode === "Interactive" && markerVisible) {
          var svgRect = this.maps.svgObject.getBoundingClientRect();
          for (var i = 0; i < this.legendCollection.length; i++) {
            var currentData = this.legendCollection[i];
            var legendElement = querySelector(this.maps.element.id + "_Legend_Index_" + i, this.maps.element.id);
            var legendRect = legendElement.getBoundingClientRect();
            var rect = new Rect2(Math.abs(legendRect.left - svgRect.left), Math.abs(legendRect.top - svgRect.top), legendRect.width, legendRect.height);
            fill = legendElement.getAttribute("fill");
            stroke = legend.shapeBorder.color;
            strokeWidth = legend.shapeBorder.width;
            if (!isNullOrUndefined(currentData["data"])) {
              var data = currentData["data"];
              var _loop_3 = function(j2) {
                if (dataIndex === data[j2]["dataIndex"] && layerIndex === data[j2]["layerIndex"]) {
                  this_3.renderInteractivePointer(legend, fill, stroke, id, strokeWidth, rect);
                  var arrowElement_1 = querySelector(id, this_3.maps.element.id);
                  if (this_3.maps.isDevice && !isNullOrUndefined(arrowElement_1)) {
                    clearTimeout(this_3.arrowTimer);
                    this_3.arrowTimer = setTimeout(function() {
                      if (!isNullOrUndefined(arrowElement_1.parentNode)) {
                        remove(arrowElement_1);
                      }
                    }, 2e3);
                  }
                  return "break";
                }
              };
              var this_3 = this;
              for (var j = 0; j < data.length; j++) {
                var state_1 = _loop_3(j);
                if (state_1 === "break")
                  break;
              }
            }
          }
        }
      } else {
        if (!isNullOrUndefined(querySelector(id, this.maps.element.id))) {
          remove(querySelector(id, this.maps.element.id));
        }
      }
    };
    Legend2.prototype.renderInteractivePointer = function(legend, fill, stroke, id, strokeWidth, rect) {
      var path;
      var locX;
      var locY;
      var height = 10;
      var width = 10;
      var direction = legend.orientation === "None" ? legend.position === "Top" || legend.position === "Bottom" ? "Horizontal" : "Vertical" : legend.orientation;
      rect.y = legend.position === "Float" && this.maps.isTileMap ? rect.y - this.maps.mapAreaRect.y : rect.y;
      if (direction === "Horizontal") {
        if (!legend.invertedPointer) {
          locX = rect.x + rect.width / 2 - (legend.position === "Float" && this.maps.isTileMap ? this.maps.mapAreaRect.x : 0);
          locY = rect.y;
          path = " M " + locX + " " + locY + " L " + (locX - width) + " " + (locY - height) + " L " + (locX + width) + " " + (locY - height) + " Z ";
        } else {
          locX = rect.x + rect.width / 2 - (legend.position === "Float" && this.maps.isTileMap ? this.maps.mapAreaRect.x : 0);
          locY = rect.y + rect.height;
          path = " M " + locX + " " + locY + " L " + (locX - width) + " " + (locY + height) + " L " + (locX + width) + " " + (locY + height) + " Z ";
        }
      } else {
        if (!legend.invertedPointer) {
          locX = rect.x + rect.width - (legend.position === "Float" && this.maps.isTileMap ? this.maps.mapAreaRect.x : 0);
          locY = rect.y + rect.height / 2;
          path = " M " + locX + " " + locY + " L " + (locX + width) + " " + (locY - height) + " L " + (locX + width) + " " + (locY + height) + " z ";
        } else {
          locX = rect.x - (legend.position === "Float" && this.maps.isTileMap ? this.maps.mapAreaRect.x : 0);
          locY = rect.y + rect.height / 2;
          path = " M " + locX + " " + locY + " L " + (locX - width) + " " + (locY - height) + " L " + (locX - width) + " " + (locY + height) + " z ";
        }
      }
      var pathOptions = new PathOption2(id, fill, strokeWidth, stroke, 1, 1, "", path);
      if (legend.position === "Float" && this.maps.isTileMap) {
        this.maps.mapLayerPanel.layerGroup.appendChild(this.maps.renderer.drawPath(pathOptions));
      } else {
        this.maps.svgObject.appendChild(this.maps.renderer.drawPath(pathOptions));
      }
    };
    Legend2.prototype.wireEvents = function(element) {
      EventHandler.add(element, Browser.touchStartEvent, this.changeNextPage, this);
    };
    Legend2.prototype.addEventListener = function() {
      if (this.maps.isDestroyed) {
        return;
      }
      this.maps.on(Browser.touchMoveEvent, this.interactiveHandler, this);
      this.maps.on(Browser.touchEndEvent, this.interactiveHandler, this);
      this.maps.on(click, this.legendClick, this);
    };
    Legend2.prototype.markerToggleSelection = function(mapElement, layerIndex, markerIndex, legendIndex) {
      mapElement.setAttribute("fill", this.legendCollection[legendIndex]["fill"]);
      mapElement.setAttribute("stroke", this.maps.layers[layerIndex].markerSettings[markerIndex].border.color);
      mapElement.setAttribute("fill-opacity", this.maps.layers[layerIndex].markerSettings[markerIndex].opacity.toString());
      mapElement.setAttribute("stroke-width", this.maps.layers[layerIndex].markerSettings[markerIndex].border.width.toString());
      mapElement.setAttribute("stroke-opacity", (isNullOrUndefined(this.maps.layers[layerIndex].markerSettings[markerIndex].border.opacity) ? this.maps.layers[layerIndex].markerSettings[markerIndex].opacity : this.maps.layers[layerIndex].markerSettings[markerIndex].border.opacity).toString());
      var indexToRemoveSelectedElement = this.maps.toggledElementId.indexOf(mapElement.id);
      if (indexToRemoveSelectedElement !== -1) {
        this.maps.toggledElementId.splice(indexToRemoveSelectedElement, 1);
      }
    };
    Legend2.prototype.bubbleToggleSelection = function(mapElement, layerIndex, bubbleIndex, legendIndex) {
      mapElement.setAttribute("fill", this.legendCollection[legendIndex]["fill"]);
      mapElement.setAttribute("stroke", this.maps.layers[layerIndex].bubbleSettings[bubbleIndex].border.color);
      mapElement.setAttribute("fill-opacity", this.maps.layers[layerIndex].bubbleSettings[bubbleIndex].opacity.toString());
      mapElement.setAttribute("stroke-width", this.maps.layers[layerIndex].bubbleSettings[bubbleIndex].border.width.toString());
      mapElement.setAttribute("stroke-opacity", (isNullOrUndefined(this.maps.layers[layerIndex].bubbleSettings[bubbleIndex].border.opacity) ? this.maps.layers[layerIndex].bubbleSettings[bubbleIndex].opacity : this.maps.layers[layerIndex].bubbleSettings[bubbleIndex].border.opacity).toString());
    };
    Legend2.prototype.legendClick = function(targetEle) {
      var legendShapeId;
      var legendTextId;
      var legendToggleFill = this.maps.legendSettings.toggleLegendSettings.fill;
      var legendToggleOpacity = this.maps.legendSettings.toggleLegendSettings.opacity;
      var legendToggleBorderColor = this.maps.legendSettings.toggleLegendSettings.border.color;
      var legendToggleBorderWidth = this.maps.legendSettings.toggleLegendSettings.border.width;
      var legendToggleBorderOpacity = isNullOrUndefined(this.maps.legendSettings.toggleLegendSettings.border.opacity) ? this.maps.legendSettings.toggleLegendSettings.opacity : this.maps.legendSettings.toggleLegendSettings.border.opacity;
      if (!isNullOrUndefined(targetEle.parentNode) && targetEle.parentNode["id"].indexOf(this.maps.element.id + "_Legend_Index_") > -1) {
        var mapElement = void 0;
        var legendIndex = parseFloat(targetEle.parentElement.id.substr((this.maps.element.id + "_Legend_Index_").length));
        var selectedItem = this.legendCollection[legendIndex]["data"];
        var isVisible2 = selectedItem["_isVisible"];
        var shape = void 0;
        if (this.maps.legendSettings.toggleLegendSettings.enable && (this.maps.legendSettings.type === "Bubbles" || this.maps.legendSettings.type === "Markers")) {
          for (var k = 0; k < this.maps.layers.length; k++) {
            for (var j = 0; j < (this.maps.legendSettings.type === "Bubbles" ? this.maps.layers[k].bubbleSettings.length : this.maps.layers[k].markerSettings.length); j++) {
              for (var i = 0; i < selectedItem.length; i++) {
                shape = this.legendCollection[legendIndex]["data"][i];
                mapElement = this.maps.legendSettings.type === "Bubbles" ? querySelector(this.maps.element.id + "_LayerIndex_" + shape["layerIndex"] + "_BubbleIndex_" + j + "_dataIndex_" + shape["dataIndex"], this.maps.element.id) : querySelector(this.maps.element.id + "_LayerIndex_" + shape["layerIndex"] + "_MarkerIndex_" + shape["markerIndex"] + "_dataIndex_" + shape["dataIndex"], this.maps.element.id);
                if (!isNullOrUndefined(shape["shape"]) && shape["shape"] === "Balloon") {
                  mapElement = this.maps.legendSettings.type === "Bubbles" ? querySelector(this.maps.element.id + "_LayerIndex_" + shape["layerIndex"] + "_BubbleIndex_" + j + "_dataIndex_" + shape["dataIndex"] + "_Group", this.maps.element.id) : querySelector(this.maps.element.id + "_LayerIndex_" + shape["layerIndex"] + "_MarkerIndex_" + shape["markerIndex"] + "_dataIndex_" + shape["dataIndex"] + "_Group", this.maps.element.id);
                  mapElement = mapElement.children[0];
                }
                var toggledLegendIdIndex = this.maps.toggledLegendId.indexOf(legendIndex);
                if (isVisible2 && mapElement !== null) {
                  if (this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {
                    mapElement.setAttribute("fill", this.maps.layers[k].shapeSettings.fill);
                    mapElement.setAttribute("stroke", this.maps.layers[k].shapeSettings.border.color || this.maps.themeStyle.shapeBorderColor);
                    mapElement.setAttribute("fill-opacity", this.maps.layers[k].shapeSettings.opacity.toString());
                    mapElement.setAttribute("stroke-width", (isNullOrUndefined(this.maps.layers[k].shapeSettings.border.width) ? 0 : this.maps.layers[k].shapeSettings.border.width).toString());
                    mapElement.setAttribute("stroke-opacity", (isNullOrUndefined(this.maps.layers[k].shapeSettings.border.opacity) ? this.maps.layers[k].shapeSettings.opacity : this.maps.layers[k].shapeSettings.border.opacity).toString());
                  } else {
                    mapElement.setAttribute("fill", legendToggleFill);
                    mapElement.setAttribute("fill-opacity", legendToggleOpacity.toString());
                    mapElement.setAttribute("stroke", legendToggleBorderColor);
                    mapElement.setAttribute("stroke-width", legendToggleBorderWidth.toString());
                    mapElement.setAttribute("stroke-opacity", legendToggleBorderOpacity.toString());
                  }
                  if (this.maps.legendSettings.type === "Markers") {
                    if (toggledLegendIdIndex === -1) {
                      this.maps.toggledLegendId.push(legendIndex);
                    }
                    var index = this.maps.toggledElementId.indexOf(mapElement.id);
                    if (index === -1) {
                      this.maps.toggledElementId.push(mapElement.id);
                    }
                  }
                  if (targetEle !== null) {
                    legendShapeId = querySelector(this.maps.element.id + "_Legend_Shape_Index_" + legendIndex, this.maps.element.id);
                    legendTextId = querySelector(this.maps.element.id + "_Legend_Text_Index_" + legendIndex, this.maps.element.id);
                    if (!this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {
                      this.setToggleAttributes(legendTextId, legendShapeId, legendToggleFill, legendToggleOpacity, legendToggleBorderColor, legendToggleBorderWidth, legendToggleBorderOpacity, legendToggleFill);
                    } else {
                      this.setToggleAttributes(
                        legendTextId,
                        legendShapeId,
                        this.maps.layers[k].shapeSettings.fill,
                        this.maps.layers[k].shapeSettings.opacity,
                        /* eslint-disable-next-line max-len */
                        this.maps.layers[k].shapeSettings.border.color || this.maps.themeStyle.shapeBorderColor,
                        isNullOrUndefined(this.maps.layers[k].shapeSettings.border.width) ? 0 : this.maps.layers[k].shapeSettings.border.width,
                        /* eslint-disable-next-line max-len */
                        isNullOrUndefined(this.maps.layers[k].shapeSettings.border.opacity) ? this.maps.layers[k].shapeSettings.opacity : this.maps.layers[k].shapeSettings.border.opacity,
                        this.maps.layers[k].shapeSettings.fill
                      );
                    }
                  }
                } else {
                  if (this.maps.legendSettings.type === "Markers") {
                    if (toggledLegendIdIndex !== -1 && i === 0) {
                      this.maps.toggledLegendId.splice(toggledLegendIdIndex, 1);
                    }
                    this.markerToggleSelection(mapElement, k, j, legendIndex);
                  } else {
                    this.bubbleToggleSelection(mapElement, k, j, legendIndex);
                  }
                  if (targetEle !== null) {
                    legendShapeId = querySelector(this.maps.element.id + "_Legend_Shape_Index_" + legendIndex, this.maps.element.id);
                    legendTextId = querySelector(this.maps.element.id + "_Legend_Text_Index_" + legendIndex, this.maps.element.id);
                    this.setToggleAttributes(legendTextId, legendShapeId, this.legendCollection[legendIndex]["fill"], this.legendCollection[legendIndex]["opacity"], this.legendCollection[legendIndex]["shapeBorder"]["color"], this.legendCollection[legendIndex]["shapeBorder"]["width"], this.legendCollection[legendIndex]["shapeBorder"]["opacity"], this.maps.legendSettings.textStyle.color);
                    if (this.maps.legendSettings.shape === "HorizontalLine" || this.maps.legendSettings.shape === "VerticalLine" || this.maps.legendSettings.shape === "Cross") {
                      legendShapeId.setAttribute("stroke", this.legendCollection[legendIndex]["fill"]);
                    }
                  }
                }
              }
              selectedItem["_isVisible"] = isVisible2 ? false : true;
            }
          }
        }
        if (this.maps.legendSettings.type === "Layers" && this.maps.legendSettings.toggleLegendSettings.enable) {
          var layerElement = void 0;
          this.removeCollections(targetEle, legendIndex);
          var toggledLegendIdIndex = this.maps.toggledLegendId.indexOf(legendIndex);
          if (toggledLegendIdIndex !== -1) {
            isVisible2 = false;
          }
          for (var j = 0; j < this.maps.layers.length; j++) {
            for (var i = 0; i < selectedItem.length; i++) {
              shape = this.legendCollection[legendIndex]["data"][i];
              layerElement = querySelector(this.maps.element.id + "_LayerIndex_" + shape["layerIndex"] + "_shapeIndex_" + shape["shapeIndex"] + "_dataIndex_" + shape["dataIndex"], this.maps.element.id);
              if (layerElement !== null) {
                var toggledShapeIdIndex = this.maps.toggledElementId.indexOf(layerElement.id);
                if (isVisible2) {
                  if (i === 0) {
                    this.maps.toggledLegendId.push(legendIndex);
                  }
                  if (toggledShapeIdIndex === -1) {
                    this.maps.toggledElementId.push(layerElement.id);
                  }
                  if (this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {
                    layerElement.setAttribute("fill", this.maps.layers[j].shapeSettings.fill);
                    layerElement.setAttribute("fill-opacity", this.maps.layers[j].shapeSettings.opacity.toString());
                    layerElement.setAttribute("stroke", this.maps.layers[j].shapeSettings.border.color || this.maps.themeStyle.shapeBorderColor);
                    layerElement.setAttribute("stroke-width", (isNullOrUndefined(this.maps.layers[j].shapeSettings.border.width) ? 0 : this.maps.layers[j].shapeSettings.border.width).toString());
                    layerElement.setAttribute("stroke-opacity", (isNullOrUndefined(this.maps.layers[j].shapeSettings.border.opacity) ? this.maps.layers[j].shapeSettings.opacity : this.maps.layers[j].shapeSettings.border.opacity).toString());
                  } else {
                    layerElement.setAttribute("fill", legendToggleFill);
                    layerElement.setAttribute("fill-opacity", legendToggleOpacity.toString());
                    layerElement.setAttribute("stroke", legendToggleBorderColor);
                    layerElement.setAttribute("stroke-width", legendToggleBorderWidth.toString());
                    layerElement.setAttribute("stroke-opacity", legendToggleBorderOpacity.toString());
                  }
                  if (targetEle !== null) {
                    legendTextId = querySelector(this.maps.element.id + "_Legend_Text_Index_" + legendIndex, this.maps.element.id);
                    legendShapeId = querySelector(this.maps.element.id + "_Legend_Shape_Index_" + legendIndex, this.maps.element.id);
                    if (!this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {
                      this.setToggleAttributes(legendTextId, legendShapeId, legendToggleFill, legendToggleOpacity, legendToggleBorderColor, legendToggleBorderWidth, legendToggleBorderOpacity, legendToggleFill);
                    } else {
                      this.setToggleAttributes(
                        legendTextId,
                        legendShapeId,
                        this.maps.layers[j].shapeSettings.fill,
                        this.maps.layers[j].shapeSettings.opacity,
                        /* eslint-disable-next-line max-len */
                        this.maps.layers[j].shapeSettings.border.color || this.maps.themeStyle.shapeBorderColor,
                        isNullOrUndefined(this.maps.layers[j].shapeSettings.border.width) ? 0 : this.maps.layers[j].shapeSettings.border.width,
                        /* eslint-disable-next-line max-len */
                        isNullOrUndefined(this.maps.layers[j].shapeSettings.border.opacity) ? this.maps.layers[j].shapeSettings.opacity : this.maps.layers[j].shapeSettings.border.opacity,
                        this.maps.layers[j].shapeSettings.fill
                      );
                    }
                  }
                } else {
                  if (toggledLegendIdIndex !== -1 && i === 0) {
                    this.maps.toggledLegendId.splice(toggledLegendIdIndex, 1);
                  }
                  if (toggledShapeIdIndex !== -1) {
                    this.maps.toggledElementId.splice(toggledShapeIdIndex, 1);
                  }
                  layerElement.setAttribute("fill", this.legendCollection[legendIndex]["fill"]);
                  layerElement.setAttribute("stroke-opacity", (isNullOrUndefined(this.maps.layers[j].shapeSettings.border.opacity) ? this.maps.layers[j].shapeSettings.opacity : this.maps.layers[j].shapeSettings.border.opacity).toString());
                  layerElement.setAttribute("stroke-width", (isNullOrUndefined(this.maps.layers[j].shapeSettings.border.width) ? 0 : this.maps.layers[j].shapeSettings.border.width).toString());
                  layerElement.setAttribute("fill-opacity", this.maps.layers[j].shapeSettings.opacity.toString());
                  layerElement.setAttribute("stroke", this.maps.layers[j].shapeSettings.border.color || this.maps.themeStyle.shapeBorderColor);
                  if (targetEle !== null) {
                    legendTextId = querySelector(this.maps.element.id + "_Legend_Text_Index_" + legendIndex, this.maps.element.id);
                    legendShapeId = querySelector(this.maps.element.id + "_Legend_Shape_Index_" + legendIndex, this.maps.element.id);
                    this.setToggleAttributes(legendTextId, legendShapeId, this.legendCollection[legendIndex]["fill"], this.legendCollection[legendIndex]["opacity"], this.legendCollection[legendIndex]["shapeBorder"]["color"], this.legendCollection[legendIndex]["shapeBorder"]["width"], this.legendCollection[legendIndex]["shapeBorder"]["opacity"], "#757575");
                  }
                }
              }
            }
          }
          selectedItem["_isVisible"] = isVisible2 ? false : true;
        }
      } else if (!isNullOrUndefined(targetEle.id) && (targetEle.id.indexOf(this.maps.element.id + "_Legend_Shape_Index") > -1 || targetEle.id.indexOf(this.maps.element.id + "_Legend_Index") !== -1) && this.maps.legendSettings.visible && targetEle.id.indexOf("_Text") === -1) {
        var LegendInteractive = void 0;
        var legendIndex = parseFloat(targetEle.id.split(this.maps.element.id + "_Legend_Index_")[1]);
        var mapdata = void 0;
        var selectedItem = this.legendCollection[legendIndex]["data"];
        var isVisible2 = selectedItem["_isVisible"];
        if ((this.maps.legendSettings.type === "Bubbles" || this.maps.legendSettings.type === "Markers") && this.maps.legendSettings.toggleLegendSettings.enable) {
          var toggledLegendIdIndex = this.maps.toggledLegendId.indexOf(legendIndex);
          for (var k = 0; k < this.maps.layers.length; k++) {
            for (var j = 0; j < (this.maps.legendSettings.type === "Bubbles" ? this.maps.layers[k].bubbleSettings.length : this.maps.layers[k].markerSettings.length); j++) {
              for (var i = 0; i < selectedItem.length; i++) {
                mapdata = this.legendCollection[legendIndex]["data"][i];
                LegendInteractive = this.maps.legendSettings.type === "Bubbles" ? querySelector(this.maps.element.id + "_LayerIndex_" + mapdata["layerIndex"] + "_BubbleIndex_" + j + "_dataIndex_" + mapdata["dataIndex"], this.maps.element.id) : querySelector(this.maps.element.id + "_LayerIndex_" + mapdata["layerIndex"] + "_MarkerIndex_" + j + "_dataIndex_" + mapdata["dataIndex"], this.maps.element.id);
                if (!isNullOrUndefined(mapdata["shape"]) && mapdata["shape"] === "Balloon") {
                  LegendInteractive = this.maps.legendSettings.type === "Bubbles" ? querySelector(this.maps.element.id + "_LayerIndex_" + mapdata["layerIndex"] + "_BubbleIndex_" + j + "_dataIndex_" + mapdata["dataIndex"] + "_Group", this.maps.element.id) : querySelector(this.maps.element.id + "_LayerIndex_" + mapdata["layerIndex"] + "_MarkerIndex_" + j + "_dataIndex_" + mapdata["dataIndex"] + "_Group", this.maps.element.id);
                  LegendInteractive = LegendInteractive.children[0];
                }
                if (isVisible2 && LegendInteractive !== null) {
                  if (this.maps.legendSettings.type === "Markers") {
                    if (toggledLegendIdIndex === -1) {
                      this.maps.toggledLegendId.push(legendIndex);
                    }
                    var index = this.maps.toggledElementId.indexOf(LegendInteractive.id);
                    if (index === -1) {
                      this.maps.toggledElementId.push(LegendInteractive.id);
                    }
                  }
                  if (this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {
                    LegendInteractive.setAttribute("fill", this.maps.layers[k].shapeSettings.fill);
                    LegendInteractive.setAttribute("stroke", this.maps.layers[k].shapeSettings.border.color || this.maps.themeStyle.shapeBorderColor);
                    LegendInteractive.setAttribute("stroke-width", (isNullOrUndefined(this.maps.layers[k].shapeSettings.border.width) ? 0 : this.maps.layers[k].shapeSettings.border.width).toString());
                    LegendInteractive.setAttribute("stroke-opacity", (isNullOrUndefined(this.maps.layers[k].shapeSettings.border.opacity) ? this.maps.layers[k].shapeSettings.opacity : this.maps.layers[k].shapeSettings.border.opacity).toString());
                    LegendInteractive.setAttribute("fill-opacity", this.maps.layers[k].shapeSettings.opacity.toString());
                  } else {
                    LegendInteractive.setAttribute("fill", legendToggleFill);
                    LegendInteractive.setAttribute("fill-opacity", legendToggleOpacity.toString());
                    LegendInteractive.setAttribute("stroke", legendToggleBorderColor);
                    LegendInteractive.setAttribute("stroke-width", legendToggleBorderWidth.toString());
                    LegendInteractive.setAttribute("stroke-opacity", legendToggleBorderOpacity.toString());
                  }
                  if (targetEle !== null) {
                    legendTextId = querySelector(this.maps.element.id + "_Legend_Index_" + legendIndex + "_Text", this.maps.element.id);
                    legendShapeId = querySelector(this.maps.element.id + "_Legend_Index_" + legendIndex, this.maps.element.id);
                    if (!this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {
                      this.setToggleAttributes(legendTextId, legendShapeId, legendToggleFill, legendToggleOpacity, legendToggleBorderColor, legendToggleBorderWidth, legendToggleBorderOpacity, legendToggleFill);
                    } else {
                      this.setToggleAttributes(
                        legendTextId,
                        legendShapeId,
                        this.maps.layers[k].shapeSettings.fill,
                        this.maps.layers[k].shapeSettings.opacity,
                        /* eslint-disable-next-line max-len */
                        this.maps.layers[k].shapeSettings.border.color || this.maps.themeStyle.shapeBorderColor,
                        /* eslint-disable-next-line max-len */
                        isNullOrUndefined(this.maps.layers[k].shapeSettings.border.width) ? 0 : this.maps.layers[k].shapeSettings.border.width,
                        /* eslint-disable-next-line max-len */
                        isNullOrUndefined(this.maps.layers[k].shapeSettings.border.opacity) ? this.maps.layers[k].shapeSettings.opacity : this.maps.layers[k].shapeSettings.border.opacity,
                        this.maps.layers[k].shapeSettings.fill
                      );
                    }
                  }
                } else {
                  if (this.maps.legendSettings.type === "Markers") {
                    if (toggledLegendIdIndex !== -1 && i === 0) {
                      this.maps.toggledLegendId.splice(toggledLegendIdIndex, 1);
                    }
                    this.markerToggleSelection(LegendInteractive, k, j, legendIndex);
                  } else {
                    this.bubbleToggleSelection(LegendInteractive, k, j, legendIndex);
                  }
                  if (targetEle !== null) {
                    legendShapeId = querySelector(this.maps.element.id + "_Legend_Index_" + legendIndex, this.maps.element.id);
                    legendShapeId.setAttribute("fill", this.legendCollection[legendIndex]["fill"]);
                    legendShapeId.setAttribute("fill-opacity", this.legendCollection[legendIndex]["opacity"]);
                    legendShapeId.setAttribute("stroke", this.legendCollection[legendIndex]["shapeBorder"]["color"]);
                    legendShapeId.setAttribute("stroke-width", this.legendCollection[legendIndex]["shapeBorder"]["width"]);
                    legendShapeId.setAttribute("stroke-opacity", this.legendCollection[legendIndex]["shapeBorder"]["opacity"]);
                    legendTextId = querySelector(this.maps.element.id + "_Legend_Index_" + legendIndex + "_Text", this.maps.element.id);
                    legendTextId.setAttribute("fill", this.maps.legendSettings.textStyle.color);
                  }
                }
              }
              selectedItem["_isVisible"] = isVisible2 ? false : true;
            }
          }
        }
        if (this.maps.legendSettings.type === "Layers" && this.maps.legendSettings.toggleLegendSettings.enable) {
          var mapLegendElement = void 0;
          this.removeCollections(targetEle, legendIndex);
          var toggleLegendIdIndex = this.maps.toggledLegendId.indexOf(legendIndex);
          if (toggleLegendIdIndex !== -1) {
            isVisible2 = false;
          }
          for (var k = 0; k < this.maps.layers.length; k++) {
            for (var i = 0; i < selectedItem.length; i++) {
              mapdata = this.legendCollection[legendIndex]["data"][i];
              mapLegendElement = querySelector(this.maps.element.id + "_LayerIndex_" + mapdata["layerIndex"] + "_shapeIndex_" + mapdata["shapeIndex"] + "_dataIndex_" + mapdata["dataIndex"], this.maps.element.id);
              if (mapLegendElement !== null) {
                var toggledShapeIdIndex = this.maps.toggledElementId.indexOf(mapLegendElement.id);
                if (isVisible2) {
                  if (i === 0) {
                    this.maps.toggledLegendId.push(legendIndex);
                  }
                  if (toggledShapeIdIndex === -1) {
                    this.maps.toggledElementId.push(mapLegendElement.id);
                  }
                  if (this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {
                    mapLegendElement.setAttribute("fill", this.maps.layers[0].shapeSettings.fill);
                    mapLegendElement.setAttribute("stroke", this.maps.layers[0].shapeSettings.border.color || this.maps.themeStyle.shapeBorderColor);
                    mapLegendElement.setAttribute("fill-opacity", this.maps.layers[k].shapeSettings.opacity.toString());
                    mapLegendElement.setAttribute("stroke-width", (isNullOrUndefined(this.maps.layers[k].shapeSettings.border.width) ? 0 : this.maps.layers[k].shapeSettings.border.width).toString());
                    mapLegendElement.setAttribute("stroke-opacity", (isNullOrUndefined(this.maps.layers[k].shapeSettings.border.opacity) ? this.maps.layers[k].shapeSettings.opacity : this.maps.layers[k].shapeSettings.border.opacity).toString());
                  } else {
                    mapLegendElement.setAttribute("fill", legendToggleFill);
                    mapLegendElement.setAttribute("fill-opacity", legendToggleOpacity.toString());
                    mapLegendElement.setAttribute("stroke", legendToggleBorderColor);
                    mapLegendElement.setAttribute("stroke-width", legendToggleBorderWidth.toString());
                    mapLegendElement.setAttribute("stroke-opacity", legendToggleBorderOpacity.toString());
                  }
                  if (targetEle !== null) {
                    legendShapeId = querySelector(this.maps.element.id + "_Legend_Index_" + legendIndex, this.maps.element.id);
                    legendTextId = querySelector(this.maps.element.id + "_Legend_Index_" + legendIndex + "_Text", this.maps.element.id);
                    if (!this.maps.legendSettings.toggleLegendSettings.applyShapeSettings) {
                      this.setToggleAttributes(legendTextId, legendShapeId, legendToggleFill, legendToggleOpacity, legendToggleBorderColor, legendToggleBorderWidth, legendToggleBorderOpacity, legendToggleFill);
                    } else {
                      this.setToggleAttributes(
                        legendTextId,
                        legendShapeId,
                        this.maps.layers[0].shapeSettings.fill,
                        this.maps.layers[k].shapeSettings.opacity,
                        /* eslint-disable-next-line max-len */
                        this.maps.layers[0].shapeSettings.border.color || this.maps.themeStyle.shapeBorderColor,
                        isNullOrUndefined(this.maps.layers[k].shapeSettings.border.width) ? 0 : this.maps.layers[k].shapeSettings.border.width,
                        /* eslint-disable-next-line max-len */
                        isNullOrUndefined(this.maps.layers[k].shapeSettings.border.opacity) ? this.maps.layers[k].shapeSettings.opacity : this.maps.layers[k].shapeSettings.border.opacity,
                        this.maps.layers[0].shapeSettings.fill
                      );
                    }
                  }
                } else {
                  if (toggleLegendIdIndex !== -1 && i === 0) {
                    this.maps.toggledLegendId.splice(toggleLegendIdIndex, 1);
                  }
                  if (toggledShapeIdIndex !== -1) {
                    this.maps.toggledElementId.splice(toggledShapeIdIndex, 1);
                  }
                  mapLegendElement.setAttribute("fill-opacity", this.maps.layers[k].shapeSettings.opacity.toString());
                  mapLegendElement.setAttribute("stroke-width", (isNullOrUndefined(this.maps.layers[k].shapeSettings.border.width) ? 0 : this.maps.layers[k].shapeSettings.border.width).toString());
                  mapLegendElement.setAttribute("stroke", this.maps.layers[0].shapeSettings.border.color || this.maps.themeStyle.shapeBorderColor);
                  mapLegendElement.setAttribute("stroke-opacity", (isNullOrUndefined(this.maps.layers[k].shapeSettings.border.opacity) ? this.maps.layers[k].shapeSettings.opacity : this.maps.layers[k].shapeSettings.border.opacity).toString());
                  mapLegendElement.setAttribute("fill", this.legendCollection[legendIndex]["fill"]);
                  if (targetEle !== null) {
                    legendTextId = querySelector(this.maps.element.id + "_Legend_Index_" + legendIndex + "_Text", this.maps.element.id);
                    legendShapeId = querySelector(this.maps.element.id + "_Legend_Index_" + legendIndex, this.maps.element.id);
                    this.setToggleAttributes(legendTextId, legendShapeId, this.legendCollection[legendIndex]["fill"], this.legendCollection[legendIndex]["opacity"], this.legendCollection[legendIndex]["shapeBorder"]["color"], this.legendCollection[legendIndex]["shapeBorder"]["width"], this.legendCollection[legendIndex]["shapeBorder"]["opacity"], "#757575");
                  }
                }
              }
            }
          }
          selectedItem["_isVisible"] = isVisible2 ? false : true;
        }
      }
    };
    Legend2.prototype.removeCollections = function(targetEle, legendIndex) {
      this.removeLegendSelectionCollection(targetEle);
      var legendSelectionIndex = this.getIndexofLegend(this.maps.legendSelectionCollection, targetEle);
      if (legendSelectionIndex !== -1) {
        this.maps.legendSelectionCollection.splice(legendSelectionIndex, 1);
      }
      var legendHighlightIndex = this.getIndexofLegend(this.legendHighlightCollection, targetEle);
      if (legendHighlightIndex !== -1) {
        this.legendHighlightCollection.splice(legendSelectionIndex, 1);
      }
      var shapeHighlightIndex = this.getIndexofLegend(this.shapeHighlightCollection, targetEle);
      if (shapeHighlightIndex !== -1) {
        this.shapeHighlightCollection.splice(shapeHighlightIndex, 1);
      }
      var selectedIndex = this.maps.selectedLegendElementId.indexOf(legendIndex);
      if (selectedIndex !== -1) {
        this.maps.selectedLegendElementId.splice(selectedIndex, 1);
      }
    };
    Legend2.prototype.removeEventListener = function() {
      if (this.maps.isDestroyed) {
        return;
      }
      this.maps.off(Browser.touchMoveEvent, this.interactiveHandler);
      this.maps.off(Browser.touchEndEvent, this.interactiveHandler);
      this.maps.off(click, this.legendClick);
      var pagingElement = document.getElementById(this.maps.element.id + "_Legend_Paging_Group");
      if (pagingElement) {
        for (var i = 0; i < pagingElement.childElementCount; i++) {
          EventHandler.remove(pagingElement.childNodes[i], Browser.touchStartEvent, this.changeNextPage);
        }
      }
    };
    Legend2.prototype.getLegendData = function(layerIndex, dataIndex, data, dataPath, layerData, shapePropertyPath, value) {
      var legendData = [];
      if (Object.prototype.toString.call(layerData) === "[object Array]") {
        for (var i = 0; i < layerData.length; i++) {
          var shapeData = layerData[i];
          var dataPathValue = dataPath.indexOf(".") > -1 ? getValueFromObject(data, dataPath) : data[dataPath];
          var shapePath = checkPropertyPath(data[dataPath], shapePropertyPath, shapeData["properties"]);
          var dataPathValueCase = !isNullOrUndefined(dataPathValue) && typeof dataPathValue === "string" ? dataPathValue.toLowerCase() : dataPathValue;
          var shapeDataValueCase = !isNullOrUndefined(shapeData["properties"][shapePath]) && isNaN(shapeData["properties"][shapePath]) ? shapeData["properties"][shapePath].toLowerCase() : shapeData["properties"][shapePath];
          if (shapeDataValueCase === dataPathValueCase) {
            if (shapeData["geometry"]["type"] !== "MultiPoint") {
              legendData.push({
                layerIndex,
                shapeIndex: i,
                dataIndex,
                name: data[dataPath],
                value,
                pointIndex: -1
              });
            } else {
              for (var j = 0; j < shapeData["geometry"].coordinates.length; j++) {
                legendData.push({
                  layerIndex,
                  shapeIndex: i,
                  dataIndex,
                  name: data[dataPath],
                  value,
                  pointIndex: j
                });
              }
            }
          }
        }
      }
      return legendData;
    };
    Legend2.prototype.setToggleAttributes = function(textElement2, shapeElement, fillColor, fillOpacity, borderColor, borderWidth, borderOpacity, textColor) {
      textElement2.setAttribute("fill", textColor);
      shapeElement.setAttribute("fill", fillColor);
      shapeElement.setAttribute("fill-opacity", fillOpacity.toString());
      shapeElement.setAttribute("stroke", borderColor);
      shapeElement.setAttribute("stroke-width", borderWidth.toString());
      if (!isNullOrUndefined(borderOpacity)) {
        shapeElement.setAttribute("stroke-opacity", borderOpacity.toString());
      }
    };
    Legend2.prototype.legendGradientColor = function(colorMap, legendIndex) {
      var legendFillColor;
      var xmlns = "http://www.w3.org/2000/svg";
      if (!isNullOrUndefined(colorMap.color) && typeof colorMap.color === "object") {
        var linerGradientEle = document.createElementNS(xmlns, "linearGradient");
        var opacity = 1;
        var position = this.maps.legendSettings.position;
        var x2 = position === "Top" || position === "Bottom" ? "100" : "0";
        var y2 = position === "Top" || position === "Bottom" ? "0" : "100";
        linerGradientEle.setAttribute("id", "linear_" + legendIndex + "_" + this.maps.element.id);
        linerGradientEle.setAttribute("x1", "0%");
        linerGradientEle.setAttribute("y1", "0%");
        linerGradientEle.setAttribute("x2", x2 + "%");
        linerGradientEle.setAttribute("y2", y2 + "%");
        for (var b = 0; b < colorMap.color.length; b++) {
          var offsetColor = 100 / (colorMap.color.length - 1);
          var stopEle = document.createElementNS(xmlns, "stop");
          stopEle.setAttribute("offset", b * offsetColor + "%");
          stopEle.setAttribute("stop-color", colorMap.color[b]);
          stopEle.setAttribute("stop-opacity", opacity.toString());
          linerGradientEle.appendChild(stopEle);
        }
        this.legendLinearGradient = linerGradientEle;
        var color = "url(#linear_" + legendIndex + "_" + this.maps.element.id + ")";
        this.defsElement.appendChild(linerGradientEle);
        legendFillColor = color;
      }
      return legendFillColor;
    };
    Legend2.prototype.getModuleName = function() {
      return "Legend";
    };
    Legend2.prototype.destroy = function() {
      this.legendCollection = [];
      this.legendRenderingCollections = [];
      this.translate = null;
      this.legendBorderRect = null;
      this.initialMapAreaRect = null;
      this.legendTotalRect = null;
      this.totalPages = [];
      this.legendItemRect = null;
      this.legendGroup = null;
      this.shapeHighlightCollection = [];
      this.legendHighlightCollection = [];
      this.shapePreviousColor = [];
      this.selectedNonLegendShapes = [];
      this.legendLinearGradient = null;
      this.currentLayer = null;
      this.defsElement = null;
      this.legendElement = [];
      this.oldShapeElement = null;
      if (!this.maps.refreshing) {
        this.maps = null;
      }
    };
    return Legend2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/user-interaction/highlight.js
var Highlight = (
  /** @class */
  (function() {
    function Highlight2(maps) {
      this.maps = maps;
      this.addEventListener();
    }
    Highlight2.prototype.addEventListener = function() {
      if (this.maps.isDestroyed) {
        return;
      }
      this.maps.on(Browser.touchMoveEvent, this.mouseMove, this);
      this.maps.on(Browser.touchStartEvent, this.mouseMove, this);
    };
    Highlight2.prototype.removeEventListener = function() {
      if (this.maps.isDestroyed) {
        return;
      }
      this.maps.off(Browser.touchMoveEvent, this.mouseMove);
      this.maps.off(Browser.touchStartEvent, this.mouseMove);
    };
    Highlight2.prototype.addHighlight = function(layerIndex, name, enable) {
      var targetEle = getTargetElement(layerIndex, name, enable, this.maps);
      if (enable) {
        this.mapHighlight(targetEle, null, null);
      } else {
        removeClass2(targetEle);
      }
    };
    Highlight2.prototype.mouseMove = function(e) {
      var targetEle = e.target;
      var layerIndex;
      var isTouch = e.pointerType === "touch" || e.pointerType === "2" || e.type.indexOf("touch") > -1;
      if ((targetEle.id.indexOf("LayerIndex") !== -1 || targetEle.id.indexOf("NavigationIndex") > -1) && targetEle.getAttribute("class") !== "ShapeselectionMapStyle" && !isTouch && targetEle.getAttribute("class") !== "MarkerselectionMapStyle" && targetEle.getAttribute("class") !== "BubbleselectionMapStyle" && targetEle.getAttribute("class") !== "navigationlineselectionMapStyle" && targetEle.getAttribute("class") !== "PolygonselectionMapStyle" && targetEle.getAttribute("class") !== "LineselectionMapStyle") {
        layerIndex = parseInt(targetEle.id.split("_LayerIndex_")[1].split("_")[0], 10);
        var shapeData = void 0;
        var data = void 0;
        var shapeIn = void 0;
        var dataIndex = void 0;
        if (targetEle.id.indexOf("shapeIndex") > -1) {
          shapeIn = parseInt(targetEle.id.split("_shapeIndex_")[1].split("_")[0], 10);
          shapeData = this.maps.layers[layerIndex].shapeData["features"] && !isNullOrUndefined(this.maps.layersCollection[layerIndex].layerData[shapeIn]) ? this.maps.layersCollection[layerIndex].layerData[shapeIn]["property"] : null;
          dataIndex = parseInt(targetEle.id.split("_dataIndex_")[1].split("_")[0], 10);
          data = isNullOrUndefined(dataIndex) ? null : this.maps.layers[layerIndex].dataSource[dataIndex];
          this.highlightSettings = this.maps.layers[layerIndex].highlightSettings;
        } else if (targetEle.id.indexOf("BubbleIndex") > -1) {
          var bubble = parseInt(targetEle.id.split("_BubbleIndex_")[1].split("_")[0], 10);
          dataIndex = parseInt(targetEle.id.split("_dataIndex_")[1].split("_")[0], 10);
          data = this.maps.layers[layerIndex].bubbleSettings[bubble].dataSource[dataIndex];
          this.highlightSettings = this.maps.layers[layerIndex].bubbleSettings[bubble].highlightSettings;
        } else if (targetEle.id.indexOf("MarkerIndex") > -1) {
          var marker2 = parseInt(targetEle.id.split("_MarkerIndex_")[1].split("_")[0], 10);
          dataIndex = parseInt(targetEle.id.split("_dataIndex_")[1].split("_")[0], 10);
          data = this.maps.layers[layerIndex].markerSettings[marker2].dataSource[dataIndex];
          this.highlightSettings = this.maps.layers[layerIndex].markerSettings[marker2].highlightSettings;
        } else if (targetEle.id.indexOf("_PolygonIndex_") > -1) {
          dataIndex = parseInt(targetEle.id.split("_PolygonIndex_")[1].split("_")[0], 10);
          data = this.maps.layers[layerIndex].polygonSettings.polygons[dataIndex].points;
          this.highlightSettings = this.maps.layers[layerIndex].polygonSettings.highlightSettings;
        } else {
          var index = parseInt(targetEle.id.split("_NavigationIndex_")[1].split("_")[0], 10);
          layerIndex = parseInt(targetEle.id.split("_LayerIndex_")[1].split("_")[0], 10);
          shapeData = null;
          data = {
            latitude: this.maps.layers[layerIndex].navigationLineSettings[index].latitude,
            longitude: this.maps.layers[layerIndex].navigationLineSettings[index].longitude
          };
          this.highlightSettings = this.maps.layers[layerIndex].navigationLineSettings[index].highlightSettings;
        }
        if (this.highlightSettings.enable) {
          this.handleHighlight(targetEle, layerIndex, data, shapeData);
        } else {
          var element = document.getElementsByClassName("highlightMapStyle")[0];
          if (!isNullOrUndefined(element)) {
            removeClass2(element);
            if (element.id.indexOf("NavigationIndex") > -1) {
              var index = parseInt(element.id.split("_NavigationIndex_")[1].split("_")[0], 10);
              var layerIndex_1 = parseInt(element.parentElement.id.split("_LayerIndex_")[1].split("_")[0], 10);
              element.setAttribute("stroke-width", this.maps.layers[layerIndex_1].navigationLineSettings[index].width.toString());
              element.setAttribute("stroke", this.maps.layers[layerIndex_1].navigationLineSettings[index].color);
            }
          }
        }
      } else if (getElementsByClassName("highlightMapStyle").length > 0) {
        targetEle = getElementsByClassName("highlightMapStyle")[0];
        if (targetEle.id.indexOf("NavigationIndex") > -1) {
          var index = parseInt(targetEle.id.split("_NavigationIndex_")[1].split("_")[0], 10);
          layerIndex = parseInt(targetEle.parentElement.id.split("_LayerIndex_")[1].split("_")[0], 10);
          targetEle.setAttribute("stroke-width", this.maps.layers[layerIndex].navigationLineSettings[index].width.toString());
          targetEle.setAttribute("stroke", this.maps.layers[layerIndex].navigationLineSettings[index].color);
        }
        removeClass2(targetEle);
        if (this.maps.legendSettings.visible && this.maps.legendModule) {
          this.maps.legendModule.removeShapeHighlightCollection();
        }
      } else if ((targetEle.id.indexOf(this.maps.element.id + "_Legend_Shape_Index") !== -1 || targetEle.id.indexOf(this.maps.element.id + "_Legend_Index") !== -1) && this.maps.legendModule && this.maps.legendSettings.visible && targetEle.id.indexOf("_Text") === -1) {
        this.maps.legendModule.legendHighLightAndSelection(targetEle, "highlight");
      } else {
        if (this.maps.legendSettings.visible && this.maps.legendModule) {
          this.maps.legendModule.removeLegendHighlightCollection();
        }
      }
    };
    Highlight2.prototype.handleHighlight = function(targetElement, layerIndex, data, shapeData) {
      if (this.maps.legendSettings.visible && targetElement.id.indexOf("_MarkerIndex_") === -1 && this.maps.legendModule && this.maps.legendSettings.type === "Layers") {
        this.maps.legendModule.shapeHighLightAndSelection(targetElement, data, this.highlightSettings, "highlight", layerIndex);
      }
      var selectHighLight = targetElement.id.indexOf("shapeIndex") > -1 && (this.maps.legendSettings.visible && this.maps.legendModule) ? this.maps.legendModule.shapeToggled : true;
      if (selectHighLight) {
        this.mapHighlight(targetElement, shapeData, data);
      }
    };
    Highlight2.prototype.mapHighlight = function(targetEle, shapeData, data) {
      var _this = this;
      var layerIndex = parseInt(targetEle.id.split("_LayerIndex_")[1].split("_")[0], 10);
      var isMarkerSelect = false;
      if (targetEle.id.indexOf("MarkerIndex") > -1) {
        var marker2 = parseInt(targetEle.id.split("_MarkerIndex_")[1].split("_")[0], 10);
        isMarkerSelect = this.maps.layers[layerIndex].markerSettings[marker2].highlightSettings.enable;
      }
      var borderColor = targetEle.parentElement.id.indexOf("LineString") === -1 ? this.highlightSettings.border.color : this.highlightSettings.fill || this.highlightSettings.border.color;
      var borderWidth = targetEle.parentElement.id.indexOf("LineString") === -1 ? this.highlightSettings.border.width / (isMarkerSelect ? 1 : this.maps.scale) : this.highlightSettings.border.width / this.maps.scale;
      var borderOpacity = isNullOrUndefined(this.highlightSettings.border.opacity) ? this.highlightSettings.opacity : this.highlightSettings.border.opacity;
      var eventArgs = {
        opacity: this.highlightSettings.opacity,
        fill: targetEle.parentElement.id.indexOf("LineString") === -1 ? targetEle.id.indexOf("NavigationIndex") === -1 ? !isNullOrUndefined(this.highlightSettings.fill) ? this.highlightSettings.fill : targetEle.getAttribute("fill") : "none" : "transparent",
        border: { color: borderColor, width: borderWidth, opacity: borderOpacity },
        cancel: false
      };
      var shapeEventArgs = {
        opacity: eventArgs.opacity,
        fill: eventArgs.fill,
        border: { color: borderColor, width: borderWidth, opacity: borderOpacity },
        name: shapeHighlight,
        target: targetEle.id,
        cancel: false,
        shapeData,
        data,
        maps: this.maps
      };
      if (targetEle.id.indexOf("shapeIndex") > -1) {
        this.maps.trigger(shapeHighlight, shapeEventArgs, function() {
        });
      }
      var itemEventArgs = {
        opacity: eventArgs.opacity,
        fill: eventArgs.fill,
        border: { color: borderColor, width: borderWidth, opacity: borderOpacity },
        name: itemHighlight,
        target: targetEle.id,
        cancel: false,
        shapeData,
        data,
        maps: this.maps
      };
      this.maps.trigger(itemHighlight, itemEventArgs, function() {
        itemEventArgs.cancel = eventArgs.cancel !== itemEventArgs.cancel ? itemEventArgs.cancel : targetEle.id.indexOf("shapeIndex") > -1 ? shapeEventArgs.cancel : eventArgs.cancel;
        itemEventArgs.fill = eventArgs.fill !== itemEventArgs.fill ? itemEventArgs.fill : targetEle.id.indexOf("shapeIndex") > -1 ? shapeEventArgs.fill : eventArgs.fill;
        itemEventArgs.opacity = eventArgs.opacity !== itemEventArgs.opacity ? itemEventArgs.opacity : targetEle.id.indexOf("shapeIndex") > -1 ? shapeEventArgs.opacity : eventArgs.opacity;
        itemEventArgs.border.color = eventArgs.border.color !== itemEventArgs.border.color ? itemEventArgs.border.color : targetEle.id.indexOf("shapeIndex") > -1 ? shapeEventArgs.border.color : eventArgs.border.color;
        itemEventArgs.border.width = eventArgs.border.width !== itemEventArgs.border.width ? itemEventArgs.border.width : targetEle.id.indexOf("shapeIndex") > -1 ? shapeEventArgs.border.width : eventArgs.border.width;
        itemEventArgs.border.opacity = eventArgs.border.opacity !== itemEventArgs.border.opacity ? itemEventArgs.border.opacity : targetEle.id.indexOf("shapeIndex") > -1 ? shapeEventArgs.border.opacity : eventArgs.border.opacity;
        _this.highlightMap(targetEle, itemEventArgs);
      });
    };
    Highlight2.prototype.highlightMap = function(targetEle, eventArgs) {
      if (targetEle.getAttribute("class") === "highlightMapStyle" || eventArgs.cancel) {
        return;
      } else {
        if (getElementsByClassName("highlightMapStyle").length > 0) {
          var elem = getElementsByClassName("highlightMapStyle")[0];
          removeClass2(elem);
          if (elem.id.indexOf("NavigationIndex") > -1) {
            var index = parseInt(elem.id.split("_NavigationIndex_")[1].split("_")[0], 10);
            var layerIndex = parseInt(elem.parentElement.id.split("_LayerIndex_")[1].split("_")[0], 10);
            elem.setAttribute("stroke-width", this.maps.layers[layerIndex].navigationLineSettings[index].width.toString());
            elem.setAttribute("stroke", this.maps.layers[layerIndex].navigationLineSettings[index].color);
          }
        }
        if (!getElement2("highlightMap")) {
          document.body.appendChild(createStyle("highlightMap", "highlightMapStyle", eventArgs));
        } else {
          customizeStyle("highlightMap", "highlightMapStyle", eventArgs);
        }
        targetEle.setAttribute("class", "highlightMapStyle");
      }
    };
    Highlight2.prototype.getModuleName = function() {
      return "Highlight";
    };
    Highlight2.prototype.destroy = function() {
      this.highlightSettings = null;
      if (!this.maps.refreshing) {
        this.maps = null;
      }
    };
    return Highlight2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/user-interaction/selection.js
var Selection = (
  /** @class */
  (function() {
    function Selection2(maps) {
      this.maps = maps;
      this.addEventListener();
    }
    Selection2.prototype.addEventListener = function() {
      if (!this.maps.isDestroyed) {
        this.maps.on(click, this.mouseClick, this);
      }
    };
    Selection2.prototype.removeEventListener = function() {
      if (this.maps.isDestroyed) {
        return;
      }
      this.maps.off(click, this.mouseClick);
    };
    Selection2.prototype.mouseClick = function(targetElement) {
      if (!isNullOrUndefined(targetElement["type"]) && targetElement["type"].indexOf("touch") !== -1 && isNullOrUndefined(targetElement.id)) {
        targetElement = targetElement["target"];
      }
      if (!isNullOrUndefined(targetElement.id) && (targetElement.id.indexOf("LayerIndex") > -1 || targetElement.id.indexOf("NavigationIndex") > -1)) {
        var shapeData = void 0;
        var data = void 0;
        var shapeIndex = void 0;
        var dataIndex = void 0;
        var layerIndex = parseInt(targetElement.id.split("_LayerIndex_")[1].split("_")[0], 10);
        if (targetElement.id.indexOf("shapeIndex") > -1) {
          shapeIndex = parseInt(targetElement.id.split("_shapeIndex_")[1].split("_")[0], 10);
          shapeData = !isNullOrUndefined(this.maps.layers[layerIndex].shapeData["features"]) && this.maps.layers[layerIndex].shapeData["features"]["length"] > shapeIndex ? this.maps.layers[layerIndex].shapeData["features"][shapeIndex]["properties"] : !isNullOrUndefined(this.maps.layers[layerIndex].shapeData["geometries"]) && this.maps.layers[layerIndex].shapeData["geometries"]["length"] > shapeIndex ? this.maps.layers[layerIndex].shapeData["geometries"][shapeIndex]["properties"] : null;
          dataIndex = parseInt(targetElement.id.split("_dataIndex_")[1].split("_")[0], 10);
          data = isNullOrUndefined(dataIndex) ? null : this.maps.layers[layerIndex].dataSource[dataIndex];
          this.selectionsettings = this.maps.layers[layerIndex].selectionSettings;
          this.selectionType = "Shape";
        } else if (targetElement.id.indexOf("BubbleIndex") > -1) {
          var bubbleIndex = parseInt(targetElement.id.split("_BubbleIndex_")[1].split("_")[0], 10);
          dataIndex = parseInt(targetElement.id.split("_dataIndex_")[1].split("_")[0], 10);
          data = this.maps.layers[layerIndex].bubbleSettings[bubbleIndex].dataSource[dataIndex];
          this.selectionsettings = this.maps.layers[layerIndex].bubbleSettings[bubbleIndex].selectionSettings;
          this.selectionType = "Bubble";
        } else if (targetElement.id.indexOf("MarkerIndex") > -1) {
          var markerIndex = parseInt(targetElement.id.split("_MarkerIndex_")[1].split("_")[0], 10);
          dataIndex = parseInt(targetElement.id.split("_dataIndex_")[1].split("_")[0], 10);
          data = this.maps.layers[layerIndex].markerSettings[markerIndex].dataSource[dataIndex];
          this.selectionsettings = this.maps.layers[layerIndex].markerSettings[markerIndex].selectionSettings;
          this.selectionType = "Marker";
        } else if (targetElement.id.indexOf("_PolygonIndex_") > -1) {
          dataIndex = parseInt(targetElement.id.split("_PolygonIndex_")[1].split("_")[0], 10);
          data = this.maps.layers[layerIndex].polygonSettings.polygons[dataIndex].points;
          this.selectionsettings = this.maps.layers[layerIndex].polygonSettings.selectionSettings;
          this.selectionType = "Polygon";
        } else if (targetElement.id.indexOf("NavigationIndex") > -1) {
          var index = parseInt(targetElement.id.split("_NavigationIndex_")[1].split("_")[0], 10);
          shapeData = null;
          data = {
            latitude: this.maps.layers[layerIndex].navigationLineSettings[index].latitude,
            longitude: this.maps.layers[layerIndex].navigationLineSettings[index].longitude
          };
          this.selectionsettings = this.maps.layers[layerIndex].navigationLineSettings[index].selectionSettings;
          this.selectionType = "navigationline";
        }
        if (!isNullOrUndefined(this.selectionsettings) && this.selectionsettings.enable) {
          this.selectElement(targetElement, layerIndex, data, shapeData);
        }
      } else if (this.maps.legendSettings.visible && !this.maps.legendSettings.toggleLegendSettings.enable && this.maps.legendModule && !isNullOrUndefined(targetElement.id) && targetElement.id.indexOf("_Text") === -1 && (targetElement.id.indexOf(this.maps.element.id + "_Legend_Shape_Index") > -1 || targetElement.id.indexOf(this.maps.element.id + "_Legend_Index") !== -1)) {
        this.maps.legendModule.legendHighLightAndSelection(targetElement, "selection");
      }
    };
    Selection2.prototype.selectElement = function(targetElement, layerIndex, data, shapeData) {
      this.maps.mapSelect = targetElement ? true : false;
      if (this.maps.legendModule && this.maps.legendSettings.visible && targetElement.id.indexOf("_MarkerIndex_") === -1) {
        this.maps.legendModule.shapeHighLightAndSelection(targetElement, data, this.selectionsettings, "selection", layerIndex);
      }
      var shapeToggled = targetElement.id.indexOf("shapeIndex") > -1 && this.maps.legendSettings.visible && this.maps.legendModule ? this.maps.legendModule.shapeToggled : true;
      if (shapeToggled) {
        this.selectMap(targetElement, shapeData, data);
      }
    };
    Selection2.prototype.addSelection = function(layerIndex, name, enable) {
      var targetElement = getTargetElement(layerIndex, name, enable, this.maps);
      if (enable) {
        this.selectMap(targetElement, null, null);
      } else {
        removeClass2(targetElement);
      }
    };
    Selection2.prototype.selectMap = function(targetElement, shapeData, data) {
      var _this = this;
      var isLineStringShape = targetElement.parentElement.id.indexOf("LineString") > -1;
      var border = {
        color: isLineStringShape ? this.selectionsettings.fill || this.selectionsettings.border.color : this.selectionsettings.border.color,
        width: isLineStringShape ? this.selectionsettings.border.width / this.maps.scale : this.selectionsettings.border.width / (this.selectionType === "Marker" ? 1 : this.maps.scale),
        opacity: this.selectionsettings.border.opacity
      };
      var eventArgs = {
        opacity: this.selectionsettings.opacity,
        fill: isLineStringShape ? "transparent" : this.selectionType !== "navigationline" ? this.selectionsettings.fill : "none",
        border,
        name: itemSelection,
        target: targetElement.id,
        cancel: false,
        shapeData,
        data,
        maps: this.maps
      };
      this.maps.trigger("itemSelection", eventArgs, function(observedArgs) {
        eventArgs.border.opacity = isNullOrUndefined(_this.selectionsettings.border.opacity) ? _this.selectionsettings.opacity : _this.selectionsettings.border.opacity;
        if (!eventArgs.cancel) {
          if (targetElement.getAttribute("class") === _this.selectionType + "selectionMapStyle" || targetElement.getAttribute("class") === "LineselectionMapStyle") {
            removeClass2(targetElement);
            _this.removedSelectionList(targetElement);
            for (var m = 0; m < _this.maps.shapeSelectionItem.length; m++) {
              if (_this.maps.shapeSelectionItem[m] === eventArgs.shapeData) {
                _this.maps.shapeSelectionItem.splice(m, 1);
                break;
              }
            }
            if (targetElement.id.indexOf("NavigationIndex") > -1) {
              var index = parseInt(targetElement.id.split("_NavigationIndex_")[1].split("_")[0], 10);
              var layerIndex = parseInt(targetElement.parentElement.id.split("_LayerIndex_")[1].split("_")[0], 10);
              targetElement.setAttribute("stroke-width", _this.maps.layers[layerIndex].navigationLineSettings[index].width.toString());
              targetElement.setAttribute("stroke", _this.maps.layers[layerIndex].navigationLineSettings[index].color);
            }
          } else {
            var layetElement = getElementByID(_this.maps.element.id + "_Layer_Collections");
            if (!_this.selectionsettings.enableMultiSelect && (layetElement.getElementsByClassName(_this.selectionType + "selectionMapStyle").length > 0 || layetElement.getElementsByClassName("LineselectionMapStyle").length > 0)) {
              var eleCount = layetElement.getElementsByClassName(_this.selectionType + "selectionMapStyle").length;
              var ele = void 0;
              for (var k = 0; k < eleCount; k++) {
                ele = layetElement.getElementsByClassName(_this.selectionType + "selectionMapStyle")[0];
                removeClass2(ele);
                _this.removedSelectionList(ele);
              }
              if (layetElement.getElementsByClassName("LineselectionMapStyle").length > 0) {
                eleCount = layetElement.getElementsByClassName("LineselectionMapStyle").length;
                for (var k = 0; k < eleCount; k++) {
                  ele = layetElement.getElementsByClassName("LineselectionMapStyle")[0];
                  removeClass2(ele);
                  _this.removedSelectionList(ele);
                }
              }
              if (_this.selectionType === "Shape") {
                _this.maps.shapeSelectionItem = [];
                var selectionLength = _this.maps.selectedElementId.length;
                for (var i = 0; i < selectionLength; i++) {
                  ele = layetElement.getElementsByClassName(_this.selectionType + "selectionMapStyle")[0];
                  removeClass2(ele);
                  var selectedElementIdIndex = _this.maps.selectedElementId.indexOf(ele.getAttribute("id"));
                  _this.maps.selectedElementId.splice(selectedElementIdIndex, 1);
                }
              }
              if (ele.id.indexOf("NavigationIndex") > -1) {
                var index = parseInt(targetElement.id.split("_NavigationIndex_")[1].split("_")[0], 10);
                var layerIndex = parseInt(targetElement.parentElement.id.split("_LayerIndex_")[1].split("_")[0], 10);
                ele.setAttribute("stroke-width", _this.maps.layers[layerIndex].navigationLineSettings[index].width.toString());
                ele.setAttribute("stroke", _this.maps.layers[layerIndex].navigationLineSettings[index].color);
              }
            }
            if (!isLineStringShape) {
              if (!getElement2(_this.selectionType + "selectionMap")) {
                document.body.appendChild(createStyle(_this.selectionType + "selectionMap", _this.selectionType + "selectionMapStyle", eventArgs));
              } else {
                customizeStyle(_this.selectionType + "selectionMap", _this.selectionType + "selectionMapStyle", eventArgs);
              }
              targetElement.setAttribute("class", _this.selectionType + "selectionMapStyle");
            } else {
              if (!getElement2("LineselectionMap")) {
                document.body.appendChild(createStyle("LineselectionMap", "LineselectionMapStyle", eventArgs));
              } else {
                customizeStyle("LineselectionMap", "LineselectionMapStyle", eventArgs);
              }
              targetElement.setAttribute("class", "LineselectionMapStyle");
            }
            if (targetElement.getAttribute("class") === "ShapeselectionMapStyle") {
              _this.maps.shapeSelectionClass = getElement2(_this.selectionType + "selectionMap");
              _this.maps.selectedElementId.push(targetElement.getAttribute("id"));
              _this.maps.shapeSelectionItem.push(eventArgs.shapeData);
            }
            if (targetElement.getAttribute("class") === "MarkerselectionMapStyle") {
              _this.maps.markerSelectionClass = getElement2(_this.selectionType + "selectionMap");
              _this.maps.selectedMarkerElementId.push(targetElement.getAttribute("id"));
            }
            if (targetElement.getAttribute("class") === "BubbleselectionMapStyle") {
              _this.maps.bubbleSelectionClass = getElement2(_this.selectionType + "selectionMap");
              _this.maps.selectedBubbleElementId.push(targetElement.getAttribute("id"));
            }
            if (targetElement.getAttribute("class") === "navigationlineselectionMapStyle") {
              _this.maps.navigationSelectionClass = getElement2(_this.selectionType + "selectionMap");
              _this.maps.selectedNavigationElementId.push(targetElement.getAttribute("id"));
            }
            if (targetElement.getAttribute("class") === "PolygonselectionMapStyle") {
              _this.maps.polygonSelectionClass = getElement2(_this.selectionType + "selectionMap");
              _this.maps.selectedPolygonElementId.push(targetElement.getAttribute("id"));
            }
          }
        }
      });
    };
    Selection2.prototype.removedSelectionList = function(targetElement) {
      if (this.selectionType === "Shape") {
        this.maps.selectedElementId.splice(this.maps.selectedElementId.indexOf(targetElement.getAttribute("id")), 1);
      }
      if (this.selectionType === "Bubble") {
        this.maps.selectedBubbleElementId.splice(this.maps.selectedBubbleElementId.indexOf(targetElement.getAttribute("id")), 1);
      }
      if (this.selectionType === "Marker") {
        this.maps.selectedMarkerElementId.splice(this.maps.selectedMarkerElementId.indexOf(targetElement.getAttribute("id")), 1);
      }
      if (this.selectionType === "navigationline") {
        this.maps.selectedBubbleElementId.splice(this.maps.selectedBubbleElementId.indexOf(targetElement.getAttribute("id")), 1);
      }
      if (this.selectionType === "Polygon") {
        this.maps.selectedPolygonElementId.splice(this.maps.selectedPolygonElementId.indexOf(targetElement.getAttribute("id")), 1);
      }
    };
    Selection2.prototype.getModuleName = function() {
      return "Selection";
    };
    Selection2.prototype.destroy = function() {
      this.selectionsettings = null;
      if (!this.maps.refreshing) {
        this.maps = null;
      }
    };
    return Selection2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/user-interaction/tooltip.js
var MapsTooltip = (
  /** @class */
  (function() {
    function MapsTooltip2(maps) {
      this.maps = maps;
      this.tooltipId = this.maps.element.id + "_mapsTooltip";
      this.addEventListener();
    }
    MapsTooltip2.prototype.renderTooltip = function(e) {
      var _this = this;
      var pageX;
      var pageY;
      var target;
      var touchArg;
      var tooltipArgs;
      if (e.type.indexOf("touch") !== -1) {
        this.isTouch = true;
        touchArg = e;
        pageX = touchArg.changedTouches[0].pageX;
        pageY = touchArg.changedTouches[0].pageY;
        target = touchArg.target;
      } else {
        this.isTouch = e.pointerType === "touch";
        pageX = e.pageX;
        pageY = e.pageY;
        target = e.target;
      }
      if (target.id.indexOf(this.maps.element.id) === -1) {
        var ancestor = target.closest("." + this.maps.element.id + "_marker_template_element");
        if (!isNullOrUndefined(ancestor) && ancestor.id.indexOf("_MarkerIndex_") > -1) {
          target = ancestor;
        }
      }
      var option;
      var polygonTooltipOption;
      var currentData = "";
      var targetId = target.id;
      var tooltipEle;
      var templateData = [];
      var keyString;
      var index = targetId.indexOf("_LayerIndex_") > -1 && parseFloat(targetId.split("_LayerIndex_")[1].split("_")[0]);
      var layer = this.maps.layersCollection[index];
      var tooltipContent = [];
      var markerFill;
      var location2 = getMousePosition(pageX, pageY, this.maps.svgObject);
      this.tooltipTargetID = targetId;
      var polygonTextStyle;
      var polygonFill;
      var polygon;
      var latitude = null;
      var longitude = null;
      var latLongValue = this.maps.getClickLocation(targetId, e.pageX, e.pageY, target, e["layerX"], e["layerY"], "tooltip");
      if (!isNullOrUndefined(latLongValue)) {
        latitude = latLongValue.latitude;
        longitude = latLongValue.longitude;
      }
      var isPolygon = targetId.indexOf("_PolygonIndex_") > -1;
      var istooltipRender = targetId.indexOf("_shapeIndex_") > -1 || targetId.indexOf("_MarkerIndex_") > -1 || targetId.indexOf("_BubbleIndex_") > -1 || targetId.indexOf("_PolygonIndex_") > -1;
      if (istooltipRender && this.maps.markerDragArgument === null) {
        if (targetId.indexOf("_PolygonIndex_") > -1) {
          var polygonIndex = parseInt(targetId.split("_PolygonIndex_")[1].split("_")[0], 10);
          polygonTooltipOption = layer.polygonSettings.tooltipSettings;
          polygon = layer.polygonSettings.polygons[polygonIndex];
          polygonTextStyle = polygonTooltipOption.textStyle;
          polygonFill = polygonTooltipOption.fill;
          tooltipContent.push(polygon.tooltipText);
        } else if (targetId.indexOf("_shapeIndex_") > -1) {
          option = layer.tooltipSettings;
          var shape = parseInt(targetId.split("_shapeIndex_")[1].split("_")[0], 10);
          if (isNullOrUndefined(layer.layerData) || isNullOrUndefined(layer.layerData[shape])) {
            return;
          }
          var value = layer.layerData[shape]["property"];
          var isShape = false;
          var properties = Object.prototype.toString.call(layer.shapePropertyPath) === "[object Array]" ? layer.shapePropertyPath : [layer.shapePropertyPath];
          if (!isNullOrUndefined(properties)) {
            for (var k = 0; k < properties.length; k++) {
              if (!isNullOrUndefined(layer.dataSource) && !isNullOrUndefined(layer.shapeDataPath)) {
                for (var i = 0; i < layer["dataSource"]["length"]; i++) {
                  var data = layer.dataSource[i];
                  var dataPath = layer.shapeDataPath.indexOf(".") > -1 ? getValueFromObject(data, layer.shapeDataPath) : data[layer.shapeDataPath];
                  var dataPathValue = !isNullOrUndefined(dataPath) && isNaN(data[layer.shapeDataPath]) ? dataPath.toLowerCase() : dataPath;
                  var propertyValue = !isNullOrUndefined(value[properties[k]]) && isNaN(value[properties[k]]) ? value[properties[k]].toLowerCase() : value[properties[k]];
                  if (dataPathValue === propertyValue) {
                    isShape = true;
                    index = i;
                    k = properties.length;
                    break;
                  }
                }
              }
            }
            index = isShape ? index : null;
            if (layer["dataSource"] && layer["dataSource"]["length"] > 0) {
              if (!isNullOrUndefined(layer.dataSource[index])) {
                templateData = JSON.parse(JSON.stringify(layer.dataSource[index]));
                for (keyString in value) {
                  if (!templateData.hasOwnProperty(keyString)) {
                    templateData[keyString] = value[keyString];
                  }
                }
              }
            } else {
              templateData = value;
            }
          }
          if (option.visible && (!isNullOrUndefined(index) && !isNaN(index) || !isNullOrUndefined(value))) {
            if (layer.tooltipSettings.format) {
              currentData = this.formatter(layer.tooltipSettings.format, templateData);
            } else {
              var shapePath = checkPropertyPath(layer.shapeDataPath, layer.shapePropertyPath, value);
              currentData = !isNullOrUndefined(layer.dataSource) && !isNullOrUndefined(index) ? formatValue(option.valuePath.indexOf(".") > -1 ? getValueFromObject(layer.dataSource[index], option.valuePath) : layer.dataSource[index][option.valuePath], this.maps) : value[shapePath];
              if (isNullOrUndefined(currentData) && !isNullOrUndefined(option.valuePath)) {
                currentData = option.valuePath.indexOf(".") > -1 ? getValueFromObject(value, option.valuePath) : value[option.valuePath];
              }
            }
          }
        } else if (targetId.indexOf("_MarkerIndex_") > -1) {
          var markerIdex = parseInt(targetId.split("_MarkerIndex_")[1].split("_")[0], 10);
          var dataIndex = parseInt(targetId.split("_MarkerIndex_")[1].split("_")[2], 10);
          var marker2 = layer.markerSettings[markerIdex];
          option = marker2.tooltipSettings;
          templateData = marker2.dataSource[dataIndex];
          if (option.visible && !isNaN(markerIdex)) {
            if (marker2.tooltipSettings.format) {
              currentData = this.formatter(marker2.tooltipSettings.format, marker2.dataSource[dataIndex]);
            } else {
              if (typeof marker2.template !== "function" && marker2.template && !marker2.tooltipSettings.valuePath) {
                currentData = marker2.template.split(">")[1].split("<")[0];
              } else {
                if (!isNullOrUndefined(marker2.tooltipSettings.valuePath)) {
                  currentData = formatValue(marker2.tooltipSettings.valuePath.indexOf(".") > -1 ? getValueFromObject(marker2.dataSource[dataIndex], marker2.tooltipSettings.valuePath) : marker2.dataSource[dataIndex][marker2.tooltipSettings.valuePath], this.maps);
                }
              }
            }
          }
        } else if (targetId.indexOf("_BubbleIndex_") > -1) {
          var bubbleIndex = parseInt(targetId.split("_BubbleIndex_")[1].split("_")[0], 10);
          var dataIndex = parseInt(targetId.split("_BubbleIndex_")[1].split("_")[2], 10);
          var bubble = layer.bubbleSettings[bubbleIndex];
          option = bubble.tooltipSettings;
          templateData = bubble.dataSource[dataIndex];
          if (option.visible && !isNaN(dataIndex)) {
            if (bubble.tooltipSettings.format) {
              currentData = this.formatter(bubble.tooltipSettings.format, bubble.dataSource[dataIndex]);
            } else {
              if (!isNullOrUndefined(bubble.tooltipSettings.valuePath)) {
                currentData = formatValue(bubble.tooltipSettings.valuePath.indexOf(".") > -1 ? getValueFromObject(bubble.dataSource[dataIndex], bubble.tooltipSettings.valuePath) : bubble.dataSource[dataIndex][bubble.tooltipSettings.valuePath], this.maps);
              }
            }
          }
        }
        if (isPolygon ? polygonTooltipOption.visible : option.visible) {
          if (document.getElementById(this.tooltipId)) {
            tooltipEle = document.getElementById(this.tooltipId);
          } else {
            tooltipEle = createElement("div", {
              id: this.maps.element.id + "_mapsTooltip",
              className: "EJ2-maps-Tooltip"
            });
            if (isNullOrUndefined(isPolygon ? polygon.tooltipTemplate : option.template) || (isPolygon ? polygon.tooltipTemplate === "" : option.template === "") || this.maps.tooltipDisplayMode === "MouseMove") {
              tooltipEle.style.cssText = "position: absolute;pointer-events:none;";
            } else {
              tooltipEle.style.position = "absolute";
            }
            document.getElementById(this.maps.element.id + "_Secondary_Element").appendChild(tooltipEle);
          }
          if (typeof (isPolygon ? polygon.tooltipTemplate !== "function" : option.template !== "function") && (isPolygon ? polygon.tooltipTemplate !== null : option.template !== null) && Object.keys(typeof (isPolygon ? polygon.tooltipTemplate === "object" : option.template === "object") ? isPolygon ? polygon.tooltipTemplate : option.template : {}).length === 1) {
            if (isPolygon) {
              polygon.tooltipTemplate = polygon.tooltipTemplate[Object.keys(polygon.tooltipTemplate)[0]];
            } else {
              option.template = option.template[Object.keys(option.template)[0]];
            }
          }
          templateData = this.setTooltipContent(option, templateData);
          var tooltipTextStyle = {
            // eslint-disable-next-line max-len
            color: isPolygon ? polygonTextStyle.color : option.textStyle.color,
            fontFamily: isPolygon ? polygonTextStyle.fontFamily : option.textStyle.fontFamily,
            fontStyle: isPolygon ? polygonTextStyle.fontStyle : option.textStyle.fontStyle,
            // eslint-disable-next-line max-len
            fontWeight: isPolygon ? polygonTextStyle.fontWeight : option.textStyle.fontWeight,
            opacity: isPolygon ? polygonTextStyle.opacity : option.textStyle.opacity,
            size: isPolygon ? polygonTextStyle.size : option.textStyle.size
          };
          var tooltipOption = {
            location: location2,
            text: tooltipContent,
            data: templateData,
            textStyle: tooltipTextStyle,
            template: isPolygon ? polygon.tooltipTemplate : option.template
          };
          tooltipArgs = {
            cancel: false,
            name: tooltipRender,
            options: tooltipOption,
            fill: isPolygon ? polygonFill : option.fill,
            maps: this.maps,
            latitude,
            longitude,
            element: target,
            eventArgs: e,
            content: isPolygon ? !isNullOrUndefined(polygon.tooltipText) ? polygon.tooltipText : "" : !isNullOrUndefined(currentData) ? currentData.toString() : ""
          };
          if (tooltipArgs.content !== "" || tooltipArgs.options["template"] !== "") {
            this.maps.trigger(tooltipRender, tooltipArgs, function(args) {
              if (!tooltipArgs.cancel && !isNullOrUndefined(currentData) && (targetId.indexOf("_cluster_") === -1 && targetId.indexOf("_dataLabel_") === -1)) {
                _this.maps["isProtectedOnChange"] = true;
                tooltipArgs.options["textStyle"]["size"] = tooltipArgs.options["textStyle"]["size"] || _this.maps.themeStyle.fontSize;
                tooltipArgs.options["textStyle"]["color"] = tooltipArgs.options["textStyle"]["color"] || _this.maps.themeStyle.tooltipFontColor;
                tooltipArgs.options["textStyle"]["fontFamily"] = tooltipArgs.options["textStyle"]["fontFamily"] || _this.maps.themeStyle.fontFamily;
                tooltipArgs.options["textStyle"]["fontWeight"] = tooltipArgs.options["textStyle"]["fontWeight"] || _this.maps.themeStyle.fontWeight;
                tooltipArgs.options["textStyle"]["opacity"] = tooltipArgs.options["textStyle"]["opacity"] || _this.maps.themeStyle.tooltipTextOpacity;
                var borderObject = isPolygon ? {
                  color: polygonTooltipOption.border.color || _this.maps.themeStyle.tooltipBorderColor,
                  width: polygonTooltipOption.border.width,
                  opacity: polygonTooltipOption.border.opacity
                } : {
                  color: option.border.color || _this.maps.themeStyle.tooltipBorderColor,
                  width: option.border.width,
                  opacity: option.border.opacity
                };
                if (tooltipArgs.cancel) {
                  _this.svgTooltip = new Tooltip({
                    theme: _this.maps.theme,
                    enable: true,
                    header: "",
                    data: option["data"],
                    template: option["template"],
                    content: tooltipArgs.content.toString() !== currentData.toString() ? [tooltipArgs.content.toString()] : [currentData.toString()],
                    shapes: [],
                    location: option["location"],
                    palette: [markerFill],
                    areaBounds: _this.maps.mapAreaRect,
                    textStyle: option["textStyle"],
                    availableSize: _this.maps.availableSize,
                    fill: option.fill || _this.maps.themeStyle.tooltipFillColor,
                    enableShadow: true,
                    border: borderObject
                  });
                } else {
                  _this.svgTooltip = new Tooltip({
                    theme: _this.maps.theme,
                    enable: true,
                    header: "",
                    data: tooltipArgs.options["data"],
                    template: tooltipArgs.options["template"],
                    content: tooltipArgs.content.toString() !== currentData.toString() ? [tooltipArgs.content.toString()] : [currentData.toString()],
                    shapes: [],
                    location: tooltipArgs.options["location"],
                    palette: [markerFill],
                    areaBounds: _this.maps.mapAreaRect,
                    textStyle: tooltipArgs.options["textStyle"],
                    availableSize: _this.maps.availableSize,
                    fill: tooltipArgs.fill || _this.maps.themeStyle.tooltipFillColor,
                    enableShadow: true,
                    border: borderObject
                  });
                }
                if (_this.maps.isVue || _this.maps.isVue3) {
                  _this.svgTooltip.controlInstance = _this.maps;
                }
                _this.svgTooltip.opacity = _this.maps.themeStyle.tooltipFillOpacity || _this.svgTooltip.opacity;
                _this.svgTooltip.appendTo(tooltipEle);
                _this.maps.renderReactTemplates();
                if (_this.maps.isDevice) {
                  var timer = targetId.indexOf("_MarkerIndex_") > -1 || targetId.indexOf("_BubbleIndex_") > -1 || targetId.indexOf("_shapeIndex_") > -1 ? option.duration : polygonTooltipOption.duration;
                  timer = !isNullOrUndefined(timer) && timer > 0 ? timer : timer < 0 ? 2e3 : null;
                  if (timer !== null) {
                    clearTimeout(_this.tooltipTimer);
                    _this.tooltipTimer = setTimeout(_this.removeTooltip.bind(_this), timer);
                  }
                }
              } else {
                _this.clearTooltip(e.target);
              }
            });
          } else {
            this.clearTooltip(e.target);
          }
          if (this.svgTooltip) {
            this.maps.trigger("tooltipRenderComplete", {
              cancel: false,
              name: "tooltipRenderComplete",
              maps: this.maps,
              options: tooltipOption,
              element: this.svgTooltip.element
            });
          }
          if (this.svgTooltip) {
            this.maps.trigger("tooltipRenderComplete", {
              cancel: false,
              name: "tooltipRenderComplete",
              maps: this.maps,
              options: tooltipOption,
              element: this.svgTooltip.element
            });
          } else {
            this.clearTooltip(e.target);
          }
        } else {
          this.clearTooltip(e.target);
        }
      } else {
        var tooltipElement = e.target.closest("#" + this.maps.element.id + "_mapsTooltipparent_template");
        if (isNullOrUndefined(tooltipElement)) {
          this.clearTooltip(e.target);
        }
      }
    };
    MapsTooltip2.prototype.setTooltipContent = function(options, templateData) {
      var localData = extend({}, templateData, null, true);
      if (this.maps.format && !isNaN(Number(localData[options.valuePath]))) {
        localData[options.valuePath] = Internalize(this.maps, Number(localData[options.valuePath]));
      } else {
        localData = Object.keys(localData).length ? localData : void 0;
      }
      return localData;
    };
    MapsTooltip2.prototype.formatter = function(format, data) {
      if (data === void 0) {
        data = {};
      }
      var keys2 = Object.keys(data);
      for (var _i = 0, keys_1 = keys2; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        format = typeof data[key] === "object" ? convertStringToValue("", format, data, this.maps) : format.split("${" + key + "}").join(formatValue(data[key], this.maps));
      }
      return format;
    };
    MapsTooltip2.prototype.mouseUpHandler = function(e) {
      if (!isNullOrUndefined(this.maps)) {
        this.renderTooltip(e);
        if (this.maps.tooltipDisplayMode === "MouseMove") {
          clearTimeout(this.tooltipTimer);
          this.tooltipTimer = setTimeout(this.removeTooltip.bind(this), 2e3);
        }
      }
    };
    MapsTooltip2.prototype.removeTooltip = function() {
      var isTooltipRemoved = false;
      if (document.getElementsByClassName("EJ2-maps-Tooltip").length > 0) {
        remove(document.getElementsByClassName("EJ2-maps-Tooltip")[0]);
        isTooltipRemoved = true;
      }
      return isTooltipRemoved;
    };
    MapsTooltip2.prototype.clearTooltip = function(element) {
      var tooltipElement = element.closest("#" + this.maps.element.id + "_mapsTooltipparent_template");
      if (isNullOrUndefined(tooltipElement)) {
        var isTooltipRemoved = this.removeTooltip();
        if (isTooltipRemoved) {
          this.maps.clearTemplate();
        }
      }
    };
    MapsTooltip2.prototype.addEventListener = function() {
      if (this.maps.isDestroyed) {
        return;
      }
      if (this.maps.tooltipDisplayMode === "DoubleClick") {
        this.maps.on("dblclick", this.renderTooltip, this);
      } else if (this.maps.tooltipDisplayMode === "Click") {
        this.maps.on(Browser.touchEndEvent, this.mouseUpHandler, this);
      } else {
        this.maps.on(Browser.touchMoveEvent, this.renderTooltip, this);
      }
      this.maps.on(Browser.touchCancelEvent, this.removeTooltip, this);
      this.maps.element.addEventListener("contextmenu", this.removeTooltip);
    };
    MapsTooltip2.prototype.removeEventListener = function() {
      if (this.maps.isDestroyed) {
        return;
      }
      if (this.maps.tooltipDisplayMode === "DoubleClick") {
        this.maps.off("dblclick", this.renderTooltip);
      } else if (this.maps.tooltipDisplayMode === "Click") {
        this.maps.off(Browser.touchEndEvent, this.mouseUpHandler);
      } else {
        this.maps.off(Browser.touchMoveEvent, this.renderTooltip);
      }
      this.maps.off(Browser.touchCancelEvent, this.removeTooltip);
      this.maps.element.removeEventListener("contextmenu", this.removeTooltip);
    };
    MapsTooltip2.prototype.getModuleName = function() {
      return "MapsTooltip";
    };
    MapsTooltip2.prototype.destroy = function() {
      if (!isNullOrUndefined(this.svgTooltip)) {
        this.svgTooltip.destroy();
        this.svgTooltip.controlInstance = null;
        removeElement2(this.maps.element.id + "_mapsTooltip");
      }
      this.svgTooltip = null;
      if (!this.maps.refreshing) {
        this.maps = null;
      }
    };
    return MapsTooltip2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/user-interaction/zoom.js
var Zoom = (
  /** @class */
  (function() {
    function Zoom2(maps) {
      this.isPanModeEnabled = false;
      this.mouseEnter = false;
      this.isTouch = false;
      this.rectZoomingStart = false;
      this.browserName = Browser.info.name;
      this.isPointer = Browser.isPointer;
      this.handled = false;
      this.isPanningInProgress = false;
      this.isPan = false;
      this.isZoomFinal = false;
      this.isZoomSelection = false;
      this.pinchFactor = 1;
      this.startTouches = [];
      this.isCancellation = false;
      this.pinchTileZoomScale = 1;
      this.tileZoomLevel = 1;
      this.pinchZoomScale = 1;
      this.isPinchZooming = false;
      this.mouseDownLatLong = { x: 0, y: 0 };
      this.mouseMoveLatLong = { x: 0, y: 0 };
      this.isSingleClick = false;
      this.maps = maps;
      this.wheelEvent = this.browserName === "mozilla" ? this.isPointer ? "mousewheel" : "DOMMouseScroll" : "mousewheel";
      this.cancelEvent = this.isPointer ? "pointerleave" : "mouseleave";
      this.selectionColor = this.maps.zoomSettings.toolbarSettings.buttonSettings.selectionColor;
      this.fillColor = this.maps.zoomSettings.toolbarSettings.buttonSettings.color;
      this.addEventListener();
    }
    Zoom2.prototype.performZooming = function(position, newZoomFactor, type, isMouseWheel) {
      var _this = this;
      if (isMouseWheel === void 0) {
        isMouseWheel = false;
      }
      var map = this.maps;
      map.previousProjection = newZoomFactor <= 1.5 ? void 0 : map.projectionType;
      map.defaultState = false;
      map.initialCheck = false;
      map.markerZoomedState = map.isMarkerZoomCompleted = false;
      map.zoomPersistence = map.enablePersistence;
      var prevLevel = map.tileZoomLevel;
      var maxZoom = map.zoomSettings.maxZoom;
      var minZoom = map.zoomSettings.minZoom;
      newZoomFactor = maxZoom >= newZoomFactor ? newZoomFactor : maxZoom;
      var isToolbarPerform = true;
      switch (type.toLowerCase()) {
        case "zoomin":
          isToolbarPerform = newZoomFactor <= this.maps.zoomSettings.maxZoom;
          break;
        case "zoomout":
          isToolbarPerform = newZoomFactor >= this.maps.zoomSettings.minZoom;
          break;
      }
      if (isToolbarPerform) {
        var scale = map.previousScale = map.scale;
        var prevTilePoint = map.tileTranslatePoint;
        if (!map.isTileMap && ((type === "ZoomIn" ? newZoomFactor >= minZoom && newZoomFactor <= maxZoom : newZoomFactor >= minZoom) || map.isReset)) {
          var availSize = map.mapAreaRect;
          var minBounds = map.baseMapRectBounds["min"];
          var maxBounds = map.baseMapRectBounds["max"];
          var mapTotalWidth = Math.abs(minBounds["x"] - maxBounds["x"]);
          var mapTotalHeight = Math.abs(minBounds["y"] - maxBounds["y"]);
          var translatePointX = void 0;
          var translatePointY = void 0;
          if (newZoomFactor < 1.2 && map.projectionType !== "Eckert5") {
            if (mapTotalWidth === 0 || mapTotalHeight === 0 || mapTotalWidth === mapTotalHeight) {
              mapTotalWidth = availSize.width / 2;
              mapTotalHeight = availSize.height;
            }
            newZoomFactor = parseFloat(Math.min(availSize.width / mapTotalWidth, availSize.height / mapTotalHeight).toFixed(2));
            newZoomFactor = newZoomFactor > 1.05 ? 1 : newZoomFactor;
            map.translatePoint = this.calculateInitalZoomTranslatePoint(newZoomFactor, mapTotalWidth, mapTotalHeight, availSize, minBounds, map);
          } else {
            var point = map.translatePoint;
            translatePointX = point.x - (availSize.width / scale - availSize.width / newZoomFactor) / (availSize.width / position.x);
            translatePointY = point.y - (availSize.height / scale - availSize.height / newZoomFactor) / (availSize.height / position.y);
            var currentHeight = Math.abs(map.baseMapRectBounds["max"]["y"] - map.baseMapRectBounds["min"]["y"]) * newZoomFactor;
            translatePointX = currentHeight < map.mapAreaRect.height ? availSize.x + (-minBounds["x"] + (availSize.width / 2 - mapTotalWidth / 2)) : translatePointX;
            translatePointY = currentHeight < map.mapAreaRect.height ? availSize.y + (-minBounds["y"] + (availSize.height / 2 - mapTotalHeight / 2)) : translatePointY;
            map.translatePoint = new Point(translatePointX, translatePointY);
          }
          map.scale = newZoomFactor;
          map.zoomTranslatePoint = map.translatePoint;
          if (this.triggerZoomEvent(prevTilePoint, prevLevel, type)) {
            map.translatePoint = map.previousPoint;
            map.scale = map.mapScaleValue = map.previousScale;
          } else {
            this.applyTransform(map, isMouseWheel);
          }
        } else if (map.isTileMap && (newZoomFactor >= minZoom && newZoomFactor <= maxZoom)) {
          this.getTileTranslatePosition(prevLevel, newZoomFactor, position, type);
          map.tileZoomLevel = newZoomFactor;
          map.zoomSettings.zoomFactor = newZoomFactor;
          map.scale = Math.pow(2, newZoomFactor - 1);
          if (type === "ZoomOut" && map.zoomSettings.resetToInitial && map.applyZoomReset && newZoomFactor <= map.initialZoomLevel) {
            map.initialCheck = true;
            map.zoomPersistence = false;
            map.tileTranslatePoint.x = map.initialTileTranslate.x;
            map.tileTranslatePoint.y = map.initialTileTranslate.y;
            newZoomFactor = map.tileZoomLevel = map.mapScaleValue = map.initialZoomLevel;
            map.scale = Math.pow(2, newZoomFactor - 1);
          }
          map.mapScaleValue = isNaN(map.mapScaleValue) ? 1 : map.mapScaleValue;
          map.translatePoint.y = (map.tileTranslatePoint.y - 0.01 * map.mapScaleValue) / map.scale;
          map.translatePoint.x = (map.tileTranslatePoint.x - 0.01 * map.mapScaleValue) / map.scale;
          if (this.triggerZoomEvent(prevTilePoint, prevLevel, type)) {
            map.translatePoint = map.tileTranslatePoint = new Point(0, 0);
            map.scale = map.previousScale;
            map.tileZoomLevel = prevLevel;
            map.zoomSettings.zoomFactor = map.previousScale;
          } else {
            if (document.querySelector(".GroupElement")) {
              document.querySelector(".GroupElement").style.display = "none";
            }
            if (document.getElementById(this.maps.element.id + "_LayerIndex_1")) {
              document.getElementById(this.maps.element.id + "_LayerIndex_1").style.display = "none";
            }
            this.markerLineAnimation(map);
            map.mapLayerPanel.generateTiles(newZoomFactor, map.tileTranslatePoint, type + "wheel", null, position);
            var animationDuration = this.maps.layersCollection[0].animationDuration === 0 && animationMode === "Enable" ? 1e3 : this.maps.layersCollection[0].animationDuration;
            setTimeout(function() {
              _this.applyTransform(_this.maps, isMouseWheel);
              if (document.getElementById(_this.maps.element.id + "_LayerIndex_1")) {
                document.getElementById(_this.maps.element.id + "_LayerIndex_1").style.display = "block";
              }
            }, animationDuration);
          }
        }
        this.triggerZoomComplete(map, prevLevel, type);
      }
      this.maps.zoomNotApplied = false;
      if (this.maps.isDevice) {
        this.removeToolbarOpacity(map.isTileMap ? Math.round(map.tileZoomLevel) : map.scale, map.element.id + "_Zooming_");
      }
    };
    Zoom2.prototype.calculateInitalZoomTranslatePoint = function(newZoomFactor, mapTotalWidth, mapTotalHeight, availSize, minBounds, map) {
      mapTotalWidth *= newZoomFactor;
      mapTotalHeight *= newZoomFactor;
      var widthDiff = minBounds["x"] !== 0 && map.translateType === "layers" ? map.availableSize.width - availSize.width : 0;
      var translatePointX = availSize.x + (-minBounds["x"] + (availSize.width / 2 - mapTotalWidth / 2)) - widthDiff;
      var translatePointY = availSize.y + (-minBounds["y"] + (availSize.height / 2 - mapTotalHeight / 2));
      return new Point(translatePointX, translatePointY);
    };
    Zoom2.prototype.triggerZoomEvent = function(prevTilePoint, prevLevel, type) {
      var map = this.maps;
      var zoomArgs;
      if (map.isTileMap) {
        map.mapScaleValue = isNullOrUndefined(map.mapScaleValue) ? 1 : map.mapScaleValue;
        map.translatePoint.y = (map.tileTranslatePoint.y - 0.01 * map.mapScaleValue) / map.scale;
        map.translatePoint.x = (map.tileTranslatePoint.x - 0.01 * map.mapScaleValue) / map.scale;
      }
      var minMaxLatitudeLongitude = this.maps.getMinMaxLatitudeLongitude();
      if (!map.isTileMap) {
        zoomArgs = {
          cancel: false,
          name: "zoom",
          type,
          maps: map,
          tileTranslatePoint: {},
          translatePoint: { previous: map.previousPoint, current: map.translatePoint },
          tileZoomLevel: {},
          scale: { previous: map.previousScale, current: map.scale },
          minLatitude: minMaxLatitudeLongitude.minLatitude,
          maxLatitude: minMaxLatitudeLongitude.maxLatitude,
          minLongitude: minMaxLatitudeLongitude.minLongitude,
          maxLongitude: minMaxLatitudeLongitude.maxLongitude
        };
      } else {
        zoomArgs = {
          cancel: false,
          name: "zoom",
          type,
          maps: map,
          tileTranslatePoint: { previous: prevTilePoint, current: map.tileTranslatePoint },
          translatePoint: { previous: map.previousPoint, current: map.translatePoint },
          tileZoomLevel: { previous: prevLevel, current: map.tileZoomLevel },
          scale: { previous: map.previousScale, current: map.scale },
          minLatitude: minMaxLatitudeLongitude.minLatitude,
          maxLatitude: minMaxLatitudeLongitude.maxLatitude,
          minLongitude: minMaxLatitudeLongitude.minLongitude,
          maxLongitude: minMaxLatitudeLongitude.maxLongitude
        };
      }
      map.trigger("zoom", zoomArgs);
      return zoomArgs.cancel;
    };
    Zoom2.prototype.getTileTranslatePosition = function(prevLevel, currentLevel, position, type) {
      var map = this.maps;
      var tileDefaultSize = 256;
      var padding = type === "ZoomOut" ? 10 : type === "Reset" && currentLevel > 1 ? 0 : 10;
      var bounds = map.availableSize;
      var prevSize = Math.pow(2, prevLevel) * 256;
      var totalSize = Math.pow(2, currentLevel) * 256;
      var x = (position.x - map.tileTranslatePoint.x) / prevSize * 100;
      var y = (position.y - map.tileTranslatePoint.y) / prevSize * 100;
      map.tileTranslatePoint.x = currentLevel === 1 ? bounds.width / 2 - tileDefaultSize * 2 / 2 : position.x - x * totalSize / 100;
      map.tileTranslatePoint.y = currentLevel === 1 ? bounds.height / 2 - tileDefaultSize * 2 / 2 + padding * 2 : position.y - y * totalSize / 100;
    };
    Zoom2.prototype.getTileTranslate = function(currentLevel, type) {
      var map = this.maps;
      var padding = type === "ZoomOut" ? 10 : type === "Reset" && currentLevel > 1 ? 0 : 10;
      var bounds = map.availableSize;
      var totalSize = Math.pow(2, currentLevel) * 256;
      var x = bounds.width / 2 - totalSize / 2;
      var y = bounds.height / 2 - totalSize / 2;
      var position = convertTileLatLongToPoint(new MapLocation(this.pinchStartLatLong["longitude"], this.pinchStartLatLong["latitude"]), currentLevel, { x, y }, true);
      x -= position.x - bounds.width / 2;
      y = y - (position.y - bounds.height / 2) + padding;
      var scale = Math.pow(2, currentLevel - 1);
      map.tileTranslatePoint.x = x;
      map.tileTranslatePoint.y = y;
      map.translatePoint.x = (x - 0.01 * this.tileZoomLevel) / scale;
      map.translatePoint.y = (y - 0.01 * this.tileZoomLevel) / scale;
    };
    Zoom2.prototype.performRectZooming = function() {
      this.isDragZoom = true;
      var map = this.maps;
      var size = map.availableSize;
      map.previousProjection = map.projectionType;
      var prevLevel = map.tileZoomLevel;
      var prevTilePoint = map.tileTranslatePoint;
      var zoomRect = this.zoomingRect;
      var maxZoom = map.zoomSettings.maxZoom;
      var minZoom = map.zoomSettings.minZoom;
      var isZoomCancelled;
      if (zoomRect.height > 0 && zoomRect.width > 0) {
        var x = this.zoomingRect.x + this.zoomingRect.width / 2;
        var y = this.zoomingRect.y + this.zoomingRect.height / 2;
        var zoomCalculationFactor = void 0;
        if (!map.isTileMap) {
          var scale = map.previousScale = map.scale;
          zoomCalculationFactor = scale + Math.round((size.width / zoomRect.width + size.height / zoomRect.height) / 2);
          zoomCalculationFactor = zoomCalculationFactor < this.maps.zoomSettings.maxZoom ? zoomCalculationFactor : this.maps.zoomSettings.maxZoom;
          var translatePoint = map.previousPoint = map.translatePoint;
          if (zoomCalculationFactor <= maxZoom) {
            var translatePointX = translatePoint.x - (size.width / scale - size.width / zoomCalculationFactor) / (size.width / x);
            var translatePointY = translatePoint.y - (size.height / scale - size.height / zoomCalculationFactor) / (size.height / y);
            map.translatePoint = new Point(translatePointX, translatePointY);
          }
          map.scale = zoomCalculationFactor < this.maps.zoomSettings.maxZoom ? zoomCalculationFactor : this.maps.zoomSettings.maxZoom;
          isZoomCancelled = this.triggerZoomEvent(prevTilePoint, prevLevel, "");
          if (isZoomCancelled) {
            map.translatePoint = map.previousPoint;
            map.scale = map.previousScale;
          }
          map.zoomTranslatePoint = map.translatePoint;
        } else {
          zoomCalculationFactor = prevLevel + Math.round(prevLevel + (size.width / zoomRect.width + size.height / zoomRect.height) / 2);
          zoomCalculationFactor = zoomCalculationFactor >= minZoom && zoomCalculationFactor <= maxZoom ? zoomCalculationFactor : maxZoom;
          map.zoomSettings.zoomFactor = zoomCalculationFactor;
          this.getTileTranslatePosition(prevLevel, zoomCalculationFactor, { x, y });
          map.tileZoomLevel = zoomCalculationFactor;
          map.translatePoint.x = (map.tileTranslatePoint.x - 0.5 * Math.pow(2, zoomCalculationFactor)) / Math.pow(2, zoomCalculationFactor);
          map.translatePoint.y = (map.tileTranslatePoint.y - 0.5 * Math.pow(2, zoomCalculationFactor)) / Math.pow(2, zoomCalculationFactor);
          map.scale = Math.pow(2, zoomCalculationFactor);
          isZoomCancelled = this.triggerZoomEvent(prevTilePoint, prevLevel, "");
          if (isZoomCancelled) {
            map.translatePoint = map.tileTranslatePoint = new Point(0, 0);
            map.scale = map.tileZoomLevel = map.zoomSettings.zoomFactor = prevLevel;
          } else {
            map.mapLayerPanel.generateTiles(zoomCalculationFactor, map.tileTranslatePoint);
          }
        }
        if (!isZoomCancelled) {
          map.mapScaleValue = zoomCalculationFactor;
          this.applyTransform(map, false, true);
          this.maps.zoomNotApplied = false;
          this.zoomingRect = null;
        }
      }
      this.isZoomFinal = this.isZoomSelection && Math.round(map.scale) === this.maps.zoomSettings.maxZoom;
      this.triggerZoomComplete(map, prevLevel, "");
      this.removeToolbarOpacity(map.scale, this.maps.element.id + "_Zooming_");
    };
    Zoom2.prototype.setInteraction = function(newInteraction) {
      this.lastScale = 1;
      this.interaction = newInteraction;
    };
    Zoom2.prototype.updateInteraction = function() {
      if (this.fingers === 2) {
        this.setInteraction("zoom");
      } else {
        this.setInteraction(null);
      }
    };
    Zoom2.prototype.tilePinchingProcess = function(scale) {
      this.tileZoomLevel = Math.round(scale);
      this.getTileTranslate(this.tileZoomLevel);
      this.maps.mapLayerPanel.generateTiles(this.tileZoomLevel, this.maps.tileTranslatePoint, null, null, null, true);
    };
    Zoom2.prototype.performPinchZooming = function(e) {
      var map = this.maps;
      var prevLevel = map.tileZoomLevel;
      var zoomCalculationFactor = this.pinchFactor;
      var isZoomCancelled;
      var prevTilePoint = map.tileTranslatePoint;
      this.maps.mergeCluster();
      if (!map.isTileMap) {
        var availSize = map.mapAreaRect;
        map.isMarkerZoomCompleted = false;
        map.previousScale = map.scale;
        map.previousPoint = map.translatePoint;
        map.previousProjection = map.projectionType;
        var scale = calculateScale(this.touchStartList, this.touchMoveList);
        var touchCenter = getTouchCenter(getTouches(this.touchMoveList, this.maps));
        var newScale = scale / this.lastScale;
        this.lastScale = scale;
        this.pinchFactor *= newScale;
        this.pinchFactor = Math.min(this.maps.zoomSettings.maxZoom, Math.max(this.pinchFactor, this.maps.zoomSettings.minZoom));
        var minBounds = map.baseMapRectBounds["min"];
        var maxBounds = map.baseMapRectBounds["max"];
        var mapTotalHeight = Math.abs(minBounds["y"] - maxBounds["y"]);
        var mapTotalWidth = Math.abs(minBounds["x"] - maxBounds["x"]);
        var translatePoint = map.translatePoint;
        var translatePointX = void 0;
        var translatePointY = void 0;
        if (zoomCalculationFactor < 1.2 && map.projectionType !== "Eckert5") {
          if (mapTotalWidth === 0 || mapTotalHeight === 0 || mapTotalWidth === mapTotalHeight) {
            mapTotalWidth = availSize.width / 2;
            mapTotalHeight = availSize.height;
          }
          zoomCalculationFactor = parseFloat(Math.min(availSize.width / mapTotalWidth, availSize.height / mapTotalHeight).toFixed(2));
          zoomCalculationFactor = zoomCalculationFactor > 1.05 ? 1 : zoomCalculationFactor;
          map.translatePoint = this.calculateInitalZoomTranslatePoint(zoomCalculationFactor, mapTotalWidth, mapTotalHeight, availSize, minBounds, map);
        } else {
          var currentHeight = Math.abs(map.baseMapRectBounds["max"]["y"] - map.baseMapRectBounds["min"]["y"]) * zoomCalculationFactor;
          translatePointX = translatePoint.x - (availSize.width / map.scale - availSize.width / zoomCalculationFactor) / (availSize.width / touchCenter.x);
          translatePointY = translatePoint.y - (availSize.height / map.scale - availSize.height / zoomCalculationFactor) / (availSize.height / touchCenter.y);
          translatePointX = currentHeight < map.mapAreaRect.height ? availSize.x + (-minBounds["x"] + (availSize.width / 2 - mapTotalWidth / 2)) : translatePointX;
          translatePointY = currentHeight < map.mapAreaRect.height ? availSize.y + (-minBounds["y"] + (availSize.height / 2 - mapTotalHeight / 2)) : translatePointY;
          map.translatePoint = new Point(translatePointX, translatePointY);
        }
        map.scale = zoomCalculationFactor;
        isZoomCancelled = this.triggerZoomEvent(prevTilePoint, prevLevel, "");
        if (isZoomCancelled) {
          map.translatePoint = map.previousPoint;
          map.scale = map.previousScale;
        }
      } else {
        this.isPinchZooming = true;
        var touchCenter = this.touchCenter;
        var touchOnePoint = this.getMousePosition(this.touchMoveList[0].pageX, this.touchMoveList[0].pageY);
        var touchTwoPoint = this.getMousePosition(this.touchMoveList[1].pageX, this.touchMoveList[1].pageY);
        var distance = Math.sqrt(Math.pow(touchOnePoint.x - touchTwoPoint.x, 2) + Math.pow(touchOnePoint.y - touchTwoPoint.y, 2));
        var pinchScale = distance / this.startDistance;
        if (!isNullOrUndefined(this.pinchDistance)) {
          var pinchZoomFactor = Math.log2(pinchScale * (256 * Math.pow(2, prevLevel)) / 256);
          pinchZoomFactor = Math.min(map.zoomSettings.maxZoom, Math.max(map.zoomSettings.minZoom, pinchZoomFactor));
          var scaleFactor = this.pinchDistance > distance ? prevLevel * pinchScale : pinchZoomFactor;
          var factor = pinchZoomFactor;
          var isZoomOut = false;
          if (this.pinchDistance > distance) {
            factor = scaleFactor % 1;
            isZoomOut = true;
          } else if (this.pinchDistance < distance) {
            factor = scaleFactor % 1 + 1;
          }
          var zoomFactor = Math.ceil(scaleFactor);
          if (zoomFactor > map.zoomSettings.minZoom && zoomFactor <= map.zoomSettings.maxZoom) {
            var element = document.getElementById(map.element.id);
            if (element) {
              element.style.overflow = "hidden";
            }
            this.tileZoomLevel = zoomFactor;
            var transformOriginX = touchCenter.x / (map.mapAreaRect.width - map.mapAreaRect.x) * 100;
            var transformOriginY = touchCenter.y / (map.mapAreaRect.height - map.mapAreaRect.y) * 100;
            var tilesParent = document.getElementById(map.element.id + "_tile_parent");
            var copyTilesParent = document.getElementById(map.element.id + "_tiles");
            if (!copyTilesParent) {
              copyTilesParent = document.createElement("div");
              copyTilesParent.id = map.element.id + "_tiles";
              map.element.appendChild(copyTilesParent);
              this.copyStyles(tilesParent, copyTilesParent);
              copyTilesParent.style.zIndex = "0";
            }
            copyTilesParent.style.visibility = "hidden";
            tilesParent.style.transformOrigin = transformOriginX + "% " + transformOriginY + "%";
            tilesParent.style.transform = "scale(" + factor + ")";
            var svgElement = document.getElementById(map.element.id + "_Tile_SVG_Parent");
            svgElement.style.transformOrigin = transformOriginX + "% " + transformOriginY + "%";
            svgElement.style.transform = "scale(" + factor + ")";
            if (!this.isCancellation && (0.2 >= scaleFactor % 1 && scaleFactor % 1 >= 0.1 && !isZoomOut) || scaleFactor % 1 <= 0.9 && isZoomOut) {
              var animateTile = document.getElementById(map.element.id + "_animates_tiles");
              if (!animateTile) {
                animateTile = document.createElement("div");
                animateTile.id = map.element.id + "_animates_tiles";
                animateTile.classList.add(this.tileZoomLevel.toString());
                copyTilesParent.appendChild(animateTile);
              }
              if (animateTile.childElementCount === 0) {
                this.pinchZoomScale = isZoomOut ? Math.floor(scaleFactor) : Math.ceil(scaleFactor);
                this.tilePinchingProcess(this.pinchZoomScale);
                this.isCancellation = true;
              }
            }
            if (this.isCancellation && (scaleFactor % 1 >= 0.99 && !isZoomOut) || scaleFactor % 1 <= 0.1 && isZoomOut) {
              if (tilesParent.style.transformOrigin !== "" && this.isCancellation) {
                tilesParent.style.transformOrigin = "";
                tilesParent.style.transform = "";
                svgElement.style.transformOrigin = "";
                svgElement.style.transform = "";
                this.pinchTileZoomScale = isZoomOut ? Math.floor(scaleFactor) : Math.ceil(scaleFactor);
                this.getTileTranslate(this.pinchTileZoomScale);
                var targetElement_1 = document.getElementById(map.element.id + "_animated_tiles");
                var sourceElement = document.getElementById(map.element.id + "_animates_tiles");
                while (targetElement_1.firstChild) {
                  targetElement_1.removeChild(targetElement_1.firstChild);
                }
                Array.from(sourceElement.children).forEach(function(child) {
                  targetElement_1.appendChild(child.cloneNode(true));
                });
                document.getElementById(map.element.id + "_animated_tiles")["className"] = this.pinchTileZoomScale.toFixed(0);
                if (sourceElement) {
                  while (sourceElement.firstChild) {
                    sourceElement.removeChild(sourceElement.firstChild);
                  }
                }
                this.isCancellation = false;
                map.mapScaleValue = this.pinchTileZoomScale;
                map.scale = Math.pow(2, this.pinchTileZoomScale - 1);
                this.applyTransform(map);
              }
            }
          }
        }
        this.pinchDistance = distance;
      }
      if (!map.isTileMap) {
        map.mapScaleValue = zoomCalculationFactor;
        if (!isZoomCancelled) {
          this.applyTransform(map);
        }
        this.triggerZoomComplete(map, prevLevel, "");
      }
      if (Browser.isDevice) {
        this.removeToolbarOpacity(map.isTileMap ? Math.round(map.tileZoomLevel) : map.scale, map.element.id + "_Zooming_");
      }
    };
    Zoom2.prototype.copyStyles = function(sourceElement, targetElement) {
      var sourceStyles = window.getComputedStyle(sourceElement);
      Array.from(sourceStyles).forEach(function(style) {
        targetElement.style[style] = sourceStyles.getPropertyValue(style);
      });
    };
    Zoom2.prototype.getTouchCenterPoint = function() {
      var touchList = [];
      for (var i = 0; i < this.touchMoveList.length; i++) {
        touchList.push(this.getMousePosition(this.touchMoveList[i].pageX, this.touchMoveList[i].pageY));
      }
      return {
        x: (touchList[0].x + touchList[1].x) / 2,
        y: (touchList[0].y + touchList[1].y) / 2
      };
    };
    Zoom2.prototype.triggerZoomComplete = function(map, prevLevel, type) {
      if (map.zoomSettings.enable) {
        var zoomArgs = void 0;
        if (map.isTileMap) {
          map.mapScaleValue = isNullOrUndefined(map.mapScaleValue) ? 1 : map.mapScaleValue;
          map.translatePoint.y = (map.tileTranslatePoint.y - 0.01 * map.mapScaleValue) / map.scale;
          map.translatePoint.x = (map.tileTranslatePoint.x - 0.01 * map.mapScaleValue) / map.scale;
        }
        var minMaxLatitudeLongitude = this.maps.getMinMaxLatitudeLongitude();
        if (!map.isTileMap) {
          zoomArgs = {
            cancel: false,
            name: "zoomComplete",
            type,
            maps: map,
            tileTranslatePoint: {},
            translatePoint: { previous: map.previousPoint, current: map.translatePoint },
            tileZoomLevel: {},
            scale: { previous: map.previousScale, current: map.scale },
            minLatitude: minMaxLatitudeLongitude.minLatitude,
            maxLatitude: minMaxLatitudeLongitude.maxLatitude,
            minLongitude: minMaxLatitudeLongitude.minLongitude,
            maxLongitude: minMaxLatitudeLongitude.maxLongitude
          };
        } else {
          zoomArgs = {
            cancel: false,
            name: "zoomComplete",
            type,
            maps: map,
            tileTranslatePoint: { previous: map.tileTranslatePoint, current: map.tileTranslatePoint },
            translatePoint: { previous: map.previousPoint, current: map.translatePoint },
            tileZoomLevel: { previous: prevLevel, current: map.tileZoomLevel },
            scale: { previous: map.previousScale, current: map.scale },
            minLatitude: minMaxLatitudeLongitude.minLatitude,
            maxLatitude: minMaxLatitudeLongitude.maxLatitude,
            minLongitude: minMaxLatitudeLongitude.minLongitude,
            maxLongitude: minMaxLatitudeLongitude.maxLongitude
          };
        }
        this.maps.trigger("zoomComplete", zoomArgs);
      }
    };
    Zoom2.prototype.drawZoomRectangle = function() {
      var map = this.maps;
      var down = this.mouseDownPoints;
      var move = this.mouseMovePoints;
      var border = { width: 1, color: this.maps.themeStyle.rectangleZoomBorderColor };
      var width = Math.abs(move.x - down.x);
      var height = Math.abs(move.y - down.y);
      var x = move.x > down.x ? down.x : down.x - width;
      var y = move.y > down.y ? down.y : down.y - height;
      if (x > map.mapAreaRect.x && x < map.mapAreaRect.x + map.mapAreaRect.width && y > map.mapAreaRect.y && y < map.mapAreaRect.y + map.mapAreaRect.height) {
        this.zoomingRect = new Rect2(x, y, width, height);
        var rectSVGObject = map.renderer.createSvg({
          id: map.element.id + "_Selection_Rect_Zooming",
          width: map.availableSize.width,
          height: map.availableSize.height,
          style: "position: absolute;"
        });
        rectSVGObject.style.position = "absolute";
        var rectOption = new RectOption(map.element.id + "_ZoomRect", this.maps.themeStyle.rectangleZoomFillColor, border, this.maps.themeStyle.rectangleZoomFillOpacity, this.zoomingRect, 0, 0, "", "3");
        rectSVGObject.appendChild(map.renderer.drawRectangle(rectOption));
        getElementByID(map.element.id + "_Secondary_Element").appendChild(rectSVGObject);
      }
    };
    Zoom2.prototype.animateTransform = function(element, animate2, x, y, scale) {
      var duration = this.currentLayer.animationDuration === 0 && animationMode === "Enable" ? 1e3 : this.currentLayer.animationDuration;
      if (!animate2 || duration === 0 || this.maps.isTileMap) {
        if (!(this.maps.isTileMap && element.id.indexOf("_Polygons_Group") > -1)) {
          element.setAttribute("transform", "scale(" + scale + ") translate( " + x + " " + y + " )");
        }
        return;
      }
      if (!this.maps.isTileMap) {
        zoomAnimate(element, 0, duration, new MapLocation(x, y), scale, this.maps.mapAreaRect, this.maps);
      }
    };
    Zoom2.prototype.applyTransform = function(maps, isMouseWheel, animate2, isPanning) {
      var _this = this;
      var layerIndex;
      this.templateCount = 0;
      var markerStyle;
      var scale = maps.scale;
      var x = maps.translatePoint.x;
      var y = maps.translatePoint.y;
      var currentLabelIndex = 0;
      maps.zoomShapeCollection = [];
      this.isPanningInProgress = isPanning || false;
      if (document.getElementById(maps.element.id + "_mapsTooltip")) {
        removeElement2(maps.element.id + "_mapsTooltip");
      }
      if (maps.isTileMap) {
        var element = document.getElementById(maps.element.id + "_svg");
        if (element) {
          for (var k = 0; k < maps.layers.length; k++) {
            var layerElement = element.querySelector("#" + maps.element.id + "_LayerIndex_" + k);
            if (layerElement) {
              element.removeChild(layerElement);
            }
          }
        }
      }
      if (this.layerCollectionEle) {
        var _loop_1 = function(i2) {
          var layerElement2 = this_1.layerCollectionEle.childNodes[i2];
          if (layerElement2.tagName === "g") {
            this_1.templateCount++;
            this_1.index = layerElement2.id.indexOf("_LayerIndex_") > -1 && parseFloat(layerElement2.id.split("_LayerIndex_")[1].split("_")[0]);
            this_1.currentLayer = maps.layersCollection[this_1.index];
            var factor_1 = maps.mapLayerPanel.calculateFactor(this_1.currentLayer);
            var elementCount = layerElement2.childElementCount;
            var templateElement = document.getElementById(maps.element.id + "_LayerIndex_" + this_1.index + "_Markers_Template_Group");
            var _loop_2 = function(j2) {
              var currentEle = layerElement2.childNodes[j2];
              if (!(currentEle.id.indexOf("_Markers_Group") > -1) && !(currentEle.id.indexOf("_bubble_Group") > -1) && !(currentEle.id.indexOf("_dataLableIndex_Group") > -1)) {
                if (maps.isTileMap && currentEle.id.indexOf("_line_Group") > -1) {
                  currentEle.remove();
                  if (layerElement2.children.length > 0 && layerElement2.children[0]) {
                    layerElement2.insertBefore(maps.navigationLineModule.renderNavigation(this_1.currentLayer, this_1.isPinchZooming ? this_1.pinchZoomScale : maps.tileZoomLevel, this_1.index), layerElement2.children[1]);
                  } else {
                    layerElement2.appendChild(maps.navigationLineModule.renderNavigation(this_1.currentLayer, this_1.isPinchZooming ? this_1.pinchZoomScale : maps.tileZoomLevel, this_1.index));
                  }
                } else if (maps.isTileMap && currentEle.id.indexOf("_Polygons_Group") > -1) {
                  if (this_1.currentLayer.polygonSettings.polygons.length > 0) {
                    this_1.currentLayer.polygonSettings.polygons.map(function(polygonSettings, polygonIndex) {
                      var markerData = polygonSettings.points;
                      var path = calculatePolygonPath(maps, _this.isPinchZooming ? _this.pinchZoomScale : maps.tileZoomLevel, _this.currentLayer, markerData);
                      var element2 = document.getElementById(maps.element.id + "_LayerIndex_" + _this.index + "_PolygonIndex_" + polygonIndex);
                      if (!isNullOrUndefined(element2)) {
                        element2.setAttribute("d", path);
                      }
                    });
                    document.getElementById(maps.element.id + "_LayerIndex_" + this_1.index + "_Polygons_Group").style.visibility = "";
                  }
                } else if (currentEle.id.indexOf("Legend") === -1) {
                  changeBorderWidth(currentEle, this_1.index, scale, maps);
                  maps.zoomTranslatePoint = maps.translatePoint;
                  this_1.animateTransform(currentEle, animate2, x, y, scale);
                }
              } else if (currentEle.id.indexOf("_Markers_Group") > -1) {
                if ((!this_1.isPanModeEnabled || !isPanning) && (!isNullOrUndefined(currentEle.childNodes[0]) || !isNullOrUndefined(templateElement.childNodes[0]))) {
                  var processElement = !isNullOrUndefined(currentEle.childNodes[0]) ? currentEle.childNodes[0] : templateElement.childNodes[0];
                  this_1.markerTranslates(processElement, factor_1, x, y, scale, "Marker", layerElement2);
                }
                currentEle = layerElement2.childNodes[j2];
                if (!isNullOrUndefined(currentEle) && currentEle.id.indexOf("Markers") !== -1) {
                  Array.prototype.forEach.call(currentEle.childNodes, function(childNode, k3) {
                    _this.markerTranslate(childNode, factor_1, x, y, scale, "Marker", animate2);
                    var dataIndex2 = parseInt(childNode["id"].split("_dataIndex_")[1].split("_")[0], 10);
                    var markerIndex = parseInt(childNode["id"].split("_MarkerIndex_")[1].split("_")[0], 10);
                    if (_this.currentLayer.markerSettings[markerIndex].initialMarkerSelection.length > 0) {
                      var markerSelectionValues = _this.currentLayer.markerSettings[markerIndex].dataSource[dataIndex2];
                      for (var x_1 = 0; x_1 < _this.currentLayer.markerSettings[markerIndex].initialMarkerSelection.length; x_1++) {
                        if (_this.currentLayer.markerSettings[markerIndex].initialMarkerSelection[x_1]["latitude"] === markerSelectionValues["latitude"] || _this.currentLayer.markerSettings[markerIndex].initialMarkerSelection[x_1]["longitude"] === markerSelectionValues["longitude"]) {
                          maps.markerSelection(_this.currentLayer.markerSettings[markerIndex].selectionSettings, maps, currentEle.children[k3], _this.currentLayer.markerSettings[markerIndex].dataSource[dataIndex2]);
                        }
                      }
                    }
                    if ((_this.currentLayer.animationDuration > 0 || animationMode === "Enable" || (maps.layersCollection[0].animationDuration > 0 || animationMode === "Enable") && _this.currentLayer.type === "SubLayer") && !_this.isPanModeEnabled) {
                      if (!maps.isTileMap) {
                        markerStyle = isMouseWheel ? markerStyle : "visibility:hidden";
                        if (!isNullOrUndefined(markerStyle)) {
                          currentEle.style.cssText = markerStyle;
                        }
                      }
                    }
                  });
                  if (this_1.isPanModeEnabled && maps.markerModule.sameMarkerData.length > 0) {
                    clusterSeparate(maps.markerModule.sameMarkerData, maps, currentEle, true);
                  } else if (maps.markerModule.sameMarkerData.length > 0) {
                    maps.markerModule.sameMarkerData = [];
                    if (document.getElementById(maps.element.id + "_mapsTooltip")) {
                      removeElement2(maps.element.id + "_mapsTooltip");
                    }
                  }
                  if (document.getElementById(maps.element.id + "_mapsTooltip") && maps.mapsTooltipModule.tooltipTargetID.indexOf("_MarkerIndex_") && !this_1.isPanModeEnabled) {
                    var mapsTooltip = maps.mapsTooltipModule;
                    var tooltipElement = currentEle.querySelector("#" + mapsTooltip.tooltipTargetID);
                    if (!isNullOrUndefined(tooltipElement)) {
                      if (tooltipElement["style"]["visibility"] === "hidden") {
                        removeElement2(maps.element.id + "_mapsTooltip");
                      } else {
                        var x_2 = parseFloat(tooltipElement.getAttribute("transform").split("(")[1].split(")")[0].split(" ")[1]);
                        var y_1 = parseFloat(tooltipElement.getAttribute("transform").split("(")[1].split(")")[0].split(" ")[2]);
                        if (maps.isTileMap) {
                          x_2 += +getElement2(maps.element.id + "_tile_parent")["style"]["left"].split("px")[0];
                          y_1 += +getElement2(maps.element.id + "_tile_parent")["style"]["top"].split("px")[0];
                        }
                        mapsTooltip.svgTooltip.location.x = x_2;
                        mapsTooltip.svgTooltip.location.y = y_1;
                        mapsTooltip.svgTooltip.enableAnimation = false;
                      }
                    }
                  }
                }
              } else if (currentEle.id.indexOf("_bubble_Group") > -1) {
                var childElement = void 0;
                for (var k2 = 0; k2 < currentEle.childElementCount; k2++) {
                  childElement = currentEle.childNodes[k2];
                  layerIndex = parseFloat(childElement.id.split("_LayerIndex_")[1].split("_")[0]);
                  var bubleIndex = parseFloat(childElement.id.split("_BubbleIndex_")[1].split("_")[0]);
                  var dataIndex = parseFloat(childElement.id.split("_BubbleIndex_")[1].split("_")[2]);
                  for (var l = 0; l < maps.bubbleModule.bubbleCollection.length; l++) {
                    var bubbleCollection = maps.bubbleModule.bubbleCollection[l];
                    if (bubbleCollection["LayerIndex"] === layerIndex && bubbleCollection["BubbleIndex"] === bubleIndex && bubbleCollection["DataIndex"] === dataIndex) {
                      var centerX = bubbleCollection["center"]["x"];
                      var centerY = bubbleCollection["center"]["y"];
                      var currentX = (centerX + x) * scale;
                      var currentY = (centerY + y) * scale;
                      var duration = this_1.currentLayer.animationDuration === 0 && animationMode === "Enable" ? 1e3 : this_1.currentLayer.animationDuration;
                      if (!animate2 || duration === 0) {
                        childElement.setAttribute("transform", "translate( " + currentX + " " + currentY + " )");
                      } else {
                        smoothTranslate(childElement, 0, duration, new MapLocation(currentX, currentY));
                      }
                      break;
                    }
                  }
                }
              } else if (currentEle.id.indexOf("_dataLableIndex_Group") > -1 && !isNullOrUndefined(maps.layers[this_1.index])) {
                maps.zoomLabelPositions = [];
                maps.zoomLabelPositions = maps.dataLabelModule.dataLabelCollections;
                var labelAnimate_1 = !maps.isTileMap && animate2;
                var intersect_1 = [];
                Array.prototype.forEach.call(currentEle.childNodes, function(childNode, k3) {
                  if (currentEle.childNodes[k3]["id"].indexOf("_LabelIndex_") > -1) {
                    var labelIndex = parseFloat(currentEle.childNodes[k3]["id"].split("_LabelIndex_")[1].split("_")[0]);
                    var zoomShapeWidth = currentEle.childNodes[k3].id;
                    maps.zoomShapeCollection.push(zoomShapeWidth);
                    _this.dataLabelTranslate(currentEle.childNodes[k3], factor_1, x, y, scale, "DataLabel", labelAnimate_1, currentLabelIndex, isPanning, intersect_1);
                    currentLabelIndex++;
                    var dataLabel = maps.layers[_this.index].dataLabelSettings;
                    var border = dataLabel.border;
                    if (k3 > 0 && border["width"] > 1) {
                      if (currentEle.childNodes[k3 - 1]["id"].indexOf("_rectIndex_") > -1 && !isNullOrUndefined(maps.zoomLabelPositions[labelIndex])) {
                        var labelX = (maps.zoomLabelPositions[labelIndex]["location"]["x"] + x) * scale;
                        var labelY = (maps.zoomLabelPositions[labelIndex]["location"]["y"] + y) * scale;
                        var zoomtext = currentEle.childNodes[k3]["textContent"];
                        var style = maps.layers[_this.index].dataLabelSettings.textStyle;
                        var zoomtextSize = measureText2(zoomtext, style);
                        var padding = 5;
                        var rectElement = currentEle.childNodes[k3 - 1];
                        var rectX = labelX - zoomtextSize["width"] / 2;
                        var rectY = labelY - zoomtextSize["height"] / 2 - padding;
                        rectElement["setAttribute"]("x", rectX);
                        rectElement["setAttribute"]("y", rectY);
                      }
                    }
                  }
                });
              }
            };
            for (var j = 0; j < elementCount; j++) {
              _loop_2(j);
            }
          }
          maps.arrangeTemplate();
        };
        var this_1 = this;
        for (var i = 0; i < this.layerCollectionEle.childElementCount; i++) {
          _loop_1(i);
        }
        if (!isNullOrUndefined(this.currentLayer)) {
          if (!animate2 || this.currentLayer.animationDuration === 0 || maps.isTileMap) {
            this.processTemplate(x, y, scale, maps);
          }
        }
      }
    };
    Zoom2.prototype.markerTranslates = function(element, factor, x, y, scale, type, layerElement) {
      var _this = this;
      var templateFn;
      var nullCount = 0;
      var markerCounts = 0;
      var markerTemplateCounts = 0;
      var layerIndex = parseInt((element ? element : layerElement).id.split("_LayerIndex_")[1].split("_")[0], 10);
      var markerSVGObject = this.maps.renderer.createGroup({
        id: this.maps.element.id + "_Markers_Group",
        class: "GroupElement"
      });
      markerSVGObject.style.pointerEvents = "auto";
      if (document.getElementById(markerSVGObject.id)) {
        removeElement2(markerSVGObject.id);
      }
      var mapsAreaRect = this.maps.mapAreaRect;
      var markerTemplateElements = createElement("div", {
        id: this.maps.element.id + "_LayerIndex_" + layerIndex + "_Markers_Template_Group",
        className: "template"
      });
      markerTemplateElements.style.cssText = "overflow: hidden; position: absolute;pointer-events: none;top:" + mapsAreaRect.y + "px;left:" + mapsAreaRect.x + "px;height:" + mapsAreaRect.height + "px;width:" + mapsAreaRect.width + "px;";
      if (document.getElementById(markerTemplateElements.id)) {
        removeElement2(markerTemplateElements.id);
      }
      var currentLayers = this.maps.layersCollection[layerIndex];
      var allowInnerClusterSetting = this.maps.markerModule.allowInnerClusterSetting(currentLayers);
      Array.prototype.forEach.call(currentLayers.markerSettings, function(markerSettings, markerIndex) {
        markerTemplateCounts = 0;
        markerCounts = 0;
        var markerDatas = markerSettings.dataSource;
        if (!isNullOrUndefined(markerDatas)) {
          Array.prototype.forEach.call(markerDatas, function(data, dataIndex) {
            _this.maps.markerNullCount = markerIndex >= 0 && dataIndex === 0 ? 0 : _this.maps.markerNullCount;
            var eventArgs = {
              template: markerSettings.template,
              data,
              maps: _this.maps,
              marker: markerSettings,
              cancel: false,
              name: markerRendering,
              fill: markerSettings.fill,
              colorValuePath: markerSettings.colorValuePath,
              shapeValuePath: markerSettings.shapeValuePath,
              height: !isNullOrUndefined(markerSettings.heightValuePath) && !isNullOrUndefined(data[markerSettings.heightValuePath]) ? data[markerSettings.heightValuePath] : markerSettings.height,
              width: !isNullOrUndefined(markerSettings.widthValuePath) && !isNullOrUndefined(data[markerSettings.widthValuePath]) ? data[markerSettings.widthValuePath] : markerSettings.width,
              imageUrl: markerSettings.imageUrl,
              imageUrlValuePath: markerSettings.imageUrlValuePath,
              shape: markerSettings.shape,
              border: markerSettings.border
            };
            eventArgs = markerShapeChoose(eventArgs, data);
            eventArgs = markerColorChoose(eventArgs, data);
            _this.maps.trigger("markerRendering", eventArgs, function(MarkerArgs) {
              if (markerSettings.shapeValuePath !== eventArgs.shapeValuePath) {
                eventArgs = markerShapeChoose(eventArgs, data);
              }
              if (markerSettings.colorValuePath !== eventArgs.colorValuePath) {
                eventArgs = markerColorChoose(eventArgs, data);
              }
              var lati = !isNullOrUndefined(markerSettings.latitudeValuePath) ? Number(getValueFromObject(data, markerSettings.latitudeValuePath)) : !isNullOrUndefined(data["latitude"]) ? parseFloat(data["latitude"]) : !isNullOrUndefined(data["Latitude"]) ? data["Latitude"] : null;
              var long = !isNullOrUndefined(markerSettings.longitudeValuePath) ? Number(getValueFromObject(data, markerSettings.longitudeValuePath)) : !isNullOrUndefined(data["longitude"]) ? parseFloat(data["longitude"]) : !isNullOrUndefined(data["Longitude"]) ? data["Longitude"] : null;
              var offset = markerSettings.offset;
              if (!eventArgs.cancel && markerSettings.visible && !isNullOrUndefined(long) && !isNullOrUndefined(lati)) {
                var markerID = _this.maps.element.id + "_LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex + "_dataIndex_" + dataIndex;
                var location_1 = _this.maps.isTileMap ? convertTileLatLongToPoint(new MapLocation(long, lati), _this.isPinchZooming ? _this.pinchZoomScale : _this.maps.tileZoomLevel, _this.maps.tileTranslatePoint, true) : convertGeoToPoint(lati, long, factor, currentLayers, _this.maps);
                var transPoint = { x, y };
                if (eventArgs.template && (!isNaN(location_1.x) && !isNaN(location_1.y))) {
                  markerTemplateCounts++;
                  markerTemplate(eventArgs, templateFn, markerID, data, markerIndex, markerTemplateElements, location_1, transPoint, scale, offset, _this.maps);
                } else if (!eventArgs.template && (!isNaN(location_1.x) && !isNaN(location_1.y))) {
                  markerCounts++;
                  marker(eventArgs, markerSettings, markerDatas, dataIndex, location_1, transPoint, markerID, offset, scale, _this.maps, markerSVGObject);
                }
              }
              nullCount += !isNaN(lati) && !isNaN(long) ? 0 : 1;
              markerTemplateCounts += eventArgs.cancel ? 1 : 0;
              markerCounts += eventArgs.cancel ? 1 : 0;
              _this.maps.markerNullCount = isNullOrUndefined(lati) || isNullOrUndefined(long) ? _this.maps.markerNullCount + 1 : _this.maps.markerNullCount;
              var markerDataLength = markerDatas.length - _this.maps.markerNullCount;
              var isMarkersClustered = false;
              var markerGroup = markerSettings.clusterSettings.allowClustering || currentLayers.markerClusterSettings.allowClustering && currentLayers.markerSettings.length > 1 ? markerSVGObject.querySelectorAll("[id*='LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex + "']:not([id*='_Group'])") : markerSVGObject.childNodes;
              if (markerGroup.length === markerDataLength - markerTemplateCounts - nullCount && type !== "Template") {
                if (_this.maps.isTileMap) {
                  var polygonsElement = document.getElementById(_this.maps.element.id + "_LayerIndex_" + layerIndex + "_Polygons_Group");
                  var polygonElement = document.getElementById(_this.maps.element.id + "_LayerIndex_" + layerIndex + "_Polygon_Group");
                  if (!isNullOrUndefined(polygonsElement)) {
                    polygonsElement.insertAdjacentElement("afterend", markerSVGObject);
                  } else {
                    if (!isNullOrUndefined(polygonElement)) {
                      polygonElement.insertAdjacentElement("afterend", markerSVGObject);
                    } else {
                      layerElement.insertBefore(markerSVGObject, layerElement.firstElementChild);
                    }
                  }
                } else {
                  layerElement.appendChild(markerSVGObject);
                }
                if (currentLayers.markerSettings[markerIndex].clusterSettings.allowClustering || !allowInnerClusterSetting && currentLayers.markerClusterSettings.allowClustering) {
                  _this.maps.svgObject.appendChild(markerSVGObject);
                  _this.maps.element.appendChild(_this.maps.svgObject);
                  isMarkersClustered = clusterTemplate(currentLayers, markerSVGObject, _this.maps, layerIndex, markerIndex, markerSVGObject, layerElement, true, true, null, allowInnerClusterSetting);
                }
              }
              var markerTemplateGroup = markerSettings.clusterSettings.allowClustering || currentLayers.markerClusterSettings.allowClustering && currentLayers.markerSettings.length > 1 ? markerTemplateElements.querySelectorAll("[id*='LayerIndex_" + layerIndex + "_MarkerIndex_" + markerIndex + "']:not([id*='_Group'])") : markerTemplateElements.childNodes;
              if (markerTemplateGroup.length === markerDataLength - markerCounts - nullCount && getElementByID(_this.maps.element.id + "_Secondary_Element")) {
                getElementByID(_this.maps.element.id + "_Secondary_Element").appendChild(markerTemplateElements);
                if (scale >= 1) {
                  if ((markerSettings.clusterSettings.allowClustering || !allowInnerClusterSetting && currentLayers.markerClusterSettings.allowClustering) && !isMarkersClustered) {
                    clusterTemplate(currentLayers, markerTemplateElements, _this.maps, layerIndex, markerIndex, markerSVGObject, layerElement, false, true, null, allowInnerClusterSetting);
                  }
                }
              }
            });
          });
        }
      });
    };
    Zoom2.prototype.processTemplate = function(x, y, scale, maps) {
      var currentLabelIndex = 0;
      for (var i = 0; i < this.templateCount; i++) {
        var factor = maps.mapLayerPanel.calculateFactor(this.currentLayer);
        var markerTemplateElement = getElementByID(maps.element.id + "_LayerIndex_" + i + "_Markers_Template_Group");
        var datalabelTemplateElemement = getElementByID(maps.element.id + "_LayerIndex_" + i + "_Label_Template_Group");
        var polygonElement = getElementByID(maps.element.id + "_LayerIndex_" + i + "_Polygons_Group");
        if (!isNullOrUndefined(markerTemplateElement) && markerTemplateElement.childElementCount > 0) {
          markerTemplateElement.style.visibility = "visible";
          for (var k = 0; k < markerTemplateElement.childElementCount; k++) {
            this.markerTranslate(markerTemplateElement.childNodes[k], factor, x, y, scale, "Template");
          }
        }
        if (!isNullOrUndefined(datalabelTemplateElemement) && datalabelTemplateElemement.childElementCount > 0) {
          for (var k = 0; k < datalabelTemplateElemement.childElementCount; k++) {
            this.dataLabelTranslate(datalabelTemplateElemement.childNodes[k], factor, x, y, scale, "Template", false, currentLabelIndex);
            currentLabelIndex++;
          }
        }
        if (!isNullOrUndefined(polygonElement)) {
          for (var k = 0; k < polygonElement.childElementCount; k++) {
            var width = maps.layersCollection[i].polygonSettings.polygons[k].borderWidth;
            polygonElement.childNodes[k].childNodes[0].setAttribute("stroke-width", (width / scale).toString());
          }
        }
      }
    };
    Zoom2.prototype.dataLabelTranslate = function(element, factor, x, y, scale, type, animate2, currentLabelIndex, isPanning, intersect) {
      if (animate2 === void 0) {
        animate2 = false;
      }
      var labelCollection = this.maps.dataLabelModule.dataLabelCollections;
      var text;
      var trimmedLable;
      var style = this.maps.layers[this.index].dataLabelSettings.textStyle;
      var zoomtext;
      var zoomtextSize;
      var zoomtrimLabel;
      var layerIndex = parseFloat(element.id.split("_LayerIndex_")[1].split("_")[0]);
      var shapeIndex = parseFloat(element.id.split("_shapeIndex_")[1].split("_")[0]);
      var labelIndex;
      if (element.id.indexOf("_LabelIndex_") > -1) {
        labelIndex = parseFloat(element.id.split("_LabelIndex_")[1].split("_")[0]);
      }
      var duration = this.currentLayer.animationDuration === 0 && animationMode === "Enable" ? 1e3 : this.currentLayer.animationDuration;
      var label = labelCollection[currentLabelIndex];
      var index = currentLabelIndex;
      if (label["layerIndex"] === layerIndex && label["shapeIndex"] === shapeIndex && label["labelIndex"] === labelIndex) {
        var labelX = label["location"]["x"];
        var labelY = label["location"]["y"];
        if (type === "Template") {
          var locationX = 0;
          var locationY = 0;
          if (this.maps.isTileMap) {
            zoomtext = label["dataLabelText"];
            zoomtextSize = measureText2(zoomtext, style);
            locationX = (labelX + x) * scale - zoomtextSize["width"] / 2;
            locationY = (labelY + y) * scale - zoomtextSize["height"];
          } else {
            var layerEle = getElementByID(this.maps.element.id + "_Layer_Collections");
            labelX = Math.abs(this.maps.baseMapRectBounds["min"]["x"] - labelX) * scale;
            labelY = Math.abs(this.maps.baseMapRectBounds["min"]["y"] - labelY) * scale;
            var layerOffset = layerEle.getBoundingClientRect();
            var elementOffset = element.parentElement.getBoundingClientRect();
            locationX = labelX + (layerOffset.left - elementOffset.left);
            locationY = labelY + (layerOffset.top - elementOffset.top);
          }
          element.style.left = locationX + "px";
          element.style.top = locationY + "px";
        } else {
          labelX = (labelX + x) * scale;
          labelY = (labelY + y) * scale;
          zoomtext = label["dataLabelText"];
          if (!animate2 || duration === 0) {
            element.setAttribute("transform", "translate( " + labelX + " " + labelY + " )");
          }
          if ((isNullOrUndefined(isPanning) || !isPanning) && (this.maps.layers[this.index].dataLabelSettings.smartLabelMode !== "None" || this.maps.layers[this.index].dataLabelSettings.intersectionAction !== "None")) {
            zoomtextSize = measureTextElement(zoomtext, style);
            var start = labelY - zoomtextSize["height"] / 2;
            var end = labelY + zoomtextSize["height"] / 2;
            var xpositionEnds = labelX + zoomtextSize["width"] / 2;
            var xpositionStart = labelX - zoomtextSize["width"] / 2;
            var textLocations = { rightWidth: xpositionEnds, leftWidth: xpositionStart, heightTop: start, heightBottom: end };
            if (this.maps.layers[this.index].dataLabelSettings.smartLabelMode === "Hide") {
              if (scale > 1) {
                text = this.maps.dataLabelShape[index] * scale >= zoomtextSize["width"] ? zoomtext : "";
                element.textContent = text;
              } else {
                text = this.maps.dataLabelShape[index] >= zoomtextSize["width"] ? zoomtext : "";
                element.textContent = text;
              }
            }
            var widthList = [];
            if (this.maps.layers[this.index].dataLabelSettings.smartLabelMode === "Trim") {
              if (scale > 1) {
                zoomtrimLabel = textTrim(this.maps.dataLabelShape[index] * scale, zoomtext, style, zoomtextSize.width, true, widthList);
                text = zoomtrimLabel;
                element.textContent = text;
              } else {
                zoomtrimLabel = textTrim(this.maps.dataLabelShape[index], zoomtext, style, zoomtextSize.width, true, widthList);
                text = zoomtrimLabel;
                element.textContent = text;
              }
            }
            if (this.maps.layers[this.index].dataLabelSettings.intersectionAction === "Hide") {
              for (var m = 0; m < intersect.length; m++) {
                if (!isNullOrUndefined(intersect[m])) {
                  if (textLocations["leftWidth"] > intersect[m]["rightWidth"] || textLocations["rightWidth"] < intersect[m]["leftWidth"] || textLocations["heightTop"] > intersect[m]["heightBottom"] || textLocations["heightBottom"] < intersect[m]["heightTop"]) {
                    text = !isNullOrUndefined(text) ? text : zoomtext;
                    element.textContent = text;
                  } else {
                    text = "";
                    element.textContent = text;
                    break;
                  }
                }
              }
              intersect.push(textLocations);
            }
            if (this.maps.layers[this.index].dataLabelSettings.intersectionAction === "Trim") {
              for (var j = 0; j < intersect.length; j++) {
                if (!isNullOrUndefined(intersect[j])) {
                  if (textLocations["rightWidth"] < intersect[j]["leftWidth"] || textLocations["leftWidth"] > intersect[j]["rightWidth"] || textLocations["heightBottom"] < intersect[j]["heightTop"] || textLocations["heightTop"] > intersect[j]["heightBottom"]) {
                    trimmedLable = !isNullOrUndefined(text) ? text : zoomtext;
                    if (scale > 1) {
                      var trimmedWidth = widthList.length > 0 ? widthList[0] : zoomtextSize.width;
                      trimmedLable = textTrim(this.maps.dataLabelShape[index] * scale, trimmedLable, style, trimmedWidth, true);
                    }
                    element.textContent = trimmedLable;
                  } else {
                    if (textLocations["leftWidth"] > intersect[j]["leftWidth"]) {
                      var width = intersect[j]["rightWidth"] - textLocations["leftWidth"];
                      var difference = width - (textLocations["rightWidth"] - textLocations["leftWidth"]);
                      text = !isNullOrUndefined(text) ? text : zoomtext;
                      var trimmedWidth = widthList.length > 0 ? widthList[0] : zoomtextSize.width;
                      trimmedLable = textTrim(difference, text, style, trimmedWidth, true);
                      element.textContent = trimmedLable;
                      break;
                    }
                    if (textLocations["leftWidth"] < intersect[j]["leftWidth"]) {
                      var width = textLocations["rightWidth"] - intersect[j]["leftWidth"];
                      var difference = Math.abs(width - (textLocations["rightWidth"] - textLocations["leftWidth"]));
                      text = !isNullOrUndefined(text) ? text : zoomtext;
                      var trimmedWidth = widthList.length > 0 ? widthList[0] : zoomtextSize.width;
                      trimmedLable = textTrim(difference, text, style, trimmedWidth, true);
                      element.textContent = trimmedLable;
                      break;
                    }
                  }
                }
              }
              intersect.push(textLocations);
              if (isNullOrUndefined(trimmedLable)) {
                trimmedLable = textTrim(this.maps.dataLabelShape[index] * scale, zoomtext, style, zoomtextSize.width, true);
                element.textContent = trimmedLable;
              }
            }
          }
          if (animate2 || duration > 0) {
            smoothTranslate(element, 0, duration, new MapLocation(labelX, labelY));
          }
        }
      }
    };
    Zoom2.prototype.markerTranslate = function(element, factor, x, y, scale, type, animate2) {
      if (animate2 === void 0) {
        animate2 = false;
      }
      var layerIndex = parseInt(element.id.split("_LayerIndex_")[1].split("_")[0], 10);
      var markerIndex = parseInt(element.id.split("_MarkerIndex_")[1].split("_")[0], 10);
      var dataIndex = parseInt(element.id.split("_dataIndex_")[1].split("_")[0], 10);
      var layer = this.maps.layersCollection[layerIndex];
      var marker2 = layer.markerSettings[markerIndex];
      if (!isNullOrUndefined(marker2) && !isNullOrUndefined(marker2.dataSource) && !isNullOrUndefined(marker2.dataSource[dataIndex])) {
        var lng = !isNullOrUndefined(marker2.longitudeValuePath) ? Number(getValueFromObject(marker2.dataSource[dataIndex], marker2.longitudeValuePath)) : !isNullOrUndefined(marker2.dataSource[dataIndex]["longitude"]) ? parseFloat(marker2.dataSource[dataIndex]["longitude"]) : !isNullOrUndefined(marker2.dataSource[dataIndex]["Longitude"]) ? parseFloat(marker2.dataSource[dataIndex]["Longitude"]) : 0;
        var lat = !isNullOrUndefined(marker2.latitudeValuePath) ? Number(getValueFromObject(marker2.dataSource[dataIndex], marker2.latitudeValuePath)) : !isNullOrUndefined(marker2.dataSource[dataIndex]["latitude"]) ? parseFloat(marker2.dataSource[dataIndex]["latitude"]) : !isNullOrUndefined(marker2.dataSource[dataIndex]["Latitude"]) ? parseFloat(marker2.dataSource[dataIndex]["Latitude"]) : 0;
        var duration = this.currentLayer.animationDuration === 0 && animationMode === "Enable" ? 1e3 : this.currentLayer.animationDuration;
        var location_2 = this.maps.isTileMap ? convertTileLatLongToPoint(new Point(lng, lat), this.isPinchZooming ? this.pinchZoomScale : this.maps.tileZoomLevel, this.maps.tileTranslatePoint, true) : convertGeoToPoint(lat, lng, factor, layer, this.maps);
        if (this.maps.isTileMap) {
          if (type === "Template") {
            element.style.left = location_2.x + marker2.offset.x + "px";
            element.style.top = location_2.y + marker2.offset.y + "px";
          } else {
            location_2.x += marker2.offset.x;
            location_2.y += marker2.offset.y;
            element.setAttribute("transform", "translate( " + location_2.x + " " + location_2.y + " )");
          }
        } else {
          if (type === "Template") {
            if (duration > 0) {
              location_2.x = Math.abs(this.maps.baseMapRectBounds["min"]["x"] - location_2.x) * scale;
              location_2.y = Math.abs(this.maps.baseMapRectBounds["min"]["y"] - location_2.y) * scale;
              var layerOffset = getElementByID(this.maps.element.id + "_Layer_Collections").getBoundingClientRect();
              var elementOffset = element.parentElement.getBoundingClientRect();
              element.style.left = location_2.x + (layerOffset.left - elementOffset.left) + marker2.offset.x + "px";
              element.style.top = location_2.y + (layerOffset.top - elementOffset.top) + marker2.offset.y + "px";
              element.style.transform = "translate(-50%, -50%)";
            } else {
              element.style.left = (location_2.x + x) * scale + marker2.offset.x - this.maps.mapAreaRect.x + "px";
              element.style.top = (location_2.y + y) * scale + marker2.offset.y - this.maps.mapAreaRect.y + "px";
            }
          } else {
            location_2.x = (location_2.x + x) * scale + marker2.offset.x;
            location_2.y = (location_2.y + y) * scale + marker2.offset.y;
            if (!animate2 || duration === 0) {
              element.setAttribute("transform", "translate( " + location_2.x + " " + location_2.y + " )");
            } else {
              smoothTranslate(element, 0, duration, location_2);
            }
          }
        }
      }
    };
    Zoom2.prototype.markerLineAnimation = function(map) {
      if (map.isTileMap) {
        for (var i = 0; i < map.layersCollection.length; i++) {
          var markerTemplateElement = getElementByID(this.maps.element.id + "_LayerIndex_" + i + "_Markers_Template_Group");
          var lineElement = getElementByID(this.maps.element.id + "_LayerIndex_" + i + "_line_Group");
          var polygonElement = getElementByID(this.maps.element.id + "_LayerIndex_" + i + "_Polygons_Group");
          if (!isNullOrUndefined(markerTemplateElement)) {
            markerTemplateElement.style.visibility = "hidden";
          }
          if (!isNullOrUndefined(lineElement)) {
            lineElement.style.visibility = "hidden";
          }
          if (!isNullOrUndefined(polygonElement)) {
            polygonElement.style.visibility = "hidden";
          }
        }
      }
    };
    Zoom2.prototype.panning = function(direction, xDifference, yDifference, event) {
      var map = this.maps;
      var panArgs;
      var down = this.mouseDownPoints;
      var move = this.mouseMovePoints;
      var scale = map.scale;
      map.markerZoomedState = false;
      map.zoomPersistence = map.enablePersistence;
      map.defaultState = false;
      map.initialCheck = false;
      var translatePoint = map.translatePoint;
      var prevTilePoint = map.tileTranslatePoint;
      var x;
      var y;
      xDifference = !isNullOrUndefined(xDifference) ? xDifference : down.x - move.x;
      yDifference = !isNullOrUndefined(yDifference) ? yDifference : down.y - move.y;
      var layerX = event.type.indexOf("mouse") > -1 || event.type.indexOf("key") > -1 ? event["layerX"] : event.touches[0].pageX;
      var layerY = event.type.indexOf("mouse") > -1 || event.type.indexOf("key") > -1 ? event["layerY"] : event.touches[0].pageY;
      this.maps.mergeCluster();
      if (!map.isTileMap) {
        var marginTop = getProcessedMarginValue(map.margin.top);
        var legendElement = document.getElementById(map.element.id + "_Legend_Group");
        var legendHeight = !isNullOrUndefined(legendElement) ? legendElement.getClientRects()[0].height : 0;
        x = translatePoint.x - xDifference / scale;
        y = translatePoint.y - yDifference / scale;
        var layerRect = getElementByID(map.element.id + "_Layer_Collections").getBoundingClientRect();
        var elementRect = getElementByID(map.element.id + "_svg").getBoundingClientRect();
        var panningXDirection = xDifference < 0 ? layerRect.left <= elementRect.left + map.mapAreaRect.x : layerRect.left + layerRect.width + map.mapAreaRect.x >= elementRect.width;
        var panningYDirection = yDifference < 0 ? layerRect.top <= elementRect.top + map.mapAreaRect.y : layerRect.top + layerRect.height + legendHeight + marginTop >= elementRect.top + elementRect.height;
        var location_3 = this.maps.getGeoLocation(this.maps.layersCollection.length - 1, layerX, layerY);
        var minMaxLatitudeLongitude = this.maps.getMinMaxLatitudeLongitude();
        panArgs = {
          cancel: false,
          name: pan,
          maps: map,
          tileTranslatePoint: {},
          translatePoint: { previous: translatePoint, current: new Point(x, y) },
          scale: map.scale,
          tileZoomLevel: map.tileZoomLevel,
          latitude: location_3["latitude"],
          longitude: location_3["longitude"],
          minLatitude: minMaxLatitudeLongitude.minLatitude,
          maxLatitude: minMaxLatitudeLongitude.maxLatitude,
          minLongitude: minMaxLatitudeLongitude.minLongitude,
          maxLongitude: minMaxLatitudeLongitude.maxLongitude
        };
        map.trigger(pan, panArgs);
        if (!panArgs.cancel) {
          if (panningXDirection && panningYDirection) {
            map.translatePoint = new Point(x, y);
            this.applyTransform(map, false, false, true);
          } else if (panningXDirection) {
            map.translatePoint = new Point(x, map.translatePoint.y);
            this.applyTransform(map, false, false, true);
          } else if (panningYDirection) {
            map.translatePoint = new Point(map.translatePoint.x, y);
            this.applyTransform(map, false, false, true);
          }
        }
        this.maps.zoomNotApplied = false;
      } else if (this.maps.tileZoomLevel > 1) {
        x = map.tileTranslatePoint.x - xDifference;
        y = map.tileTranslatePoint.y - yDifference;
        map.tileTranslatePoint.x = x;
        map.tileTranslatePoint.y = y;
        if (map.tileTranslatePoint.y > -10 && yDifference < 0 || map.tileTranslatePoint.y < -((Math.pow(2, this.maps.tileZoomLevel) - 2) * 256) && yDifference > 0) {
          map.tileTranslatePoint.x = x + xDifference;
          map.tileTranslatePoint.y = y + yDifference;
        }
        map.translatePoint.x = map.tileTranslatePoint.x / map.scale;
        map.translatePoint.y = map.tileTranslatePoint.y / map.scale;
        var location_4 = this.maps.getTileGeoLocation(layerX, layerY);
        var minMaxLatitudeLongitude = this.maps.getMinMaxLatitudeLongitude();
        panArgs = {
          cancel: false,
          name: pan,
          maps: map,
          tileTranslatePoint: { previous: prevTilePoint, current: map.tileTranslatePoint },
          translatePoint: { previous: translatePoint, current: map.translatePoint },
          scale: map.scale,
          tileZoomLevel: map.tileZoomLevel,
          latitude: location_4["latitude"],
          longitude: location_4["longitude"],
          minLatitude: minMaxLatitudeLongitude.minLatitude,
          maxLatitude: minMaxLatitudeLongitude.maxLatitude,
          minLongitude: minMaxLatitudeLongitude.minLongitude,
          maxLongitude: minMaxLatitudeLongitude.maxLongitude
        };
        map.trigger(pan, panArgs);
        map.mapLayerPanel.generateTiles(map.tileZoomLevel, map.tileTranslatePoint, "Pan");
        this.applyTransform(map, false, false, true);
        map.translatePoint.x = (map.tileTranslatePoint.x - xDifference) / map.scale;
        map.translatePoint.y = (map.tileTranslatePoint.y - yDifference) / map.scale;
      }
      map.zoomTranslatePoint = map.translatePoint;
      this.mouseDownPoints = this.mouseMovePoints;
      this.isSingleClick = false;
    };
    Zoom2.prototype.toolBarZooming = function(zoomFactor, type) {
      var _this = this;
      var map = this.maps;
      map.initialCheck = map.isMarkerZoomCompleted = false;
      map.defaultState = type === "Reset" && zoomFactor === 1 && !(map.zoomSettings.resetToInitial && map.applyZoomReset) || type === "ZoomOut" && zoomFactor === 1;
      var prevLevel = map.tileZoomLevel;
      var scale = map.previousScale = map.scale;
      map.markerZoomedState = false;
      map.zoomPersistence = map.enablePersistence;
      map.mapScaleValue = zoomFactor;
      var maxZoom = map.zoomSettings.maxZoom;
      var minZoom = map.zoomSettings.minZoom;
      var size = map.mapAreaRect;
      var translatePoint = map.previousPoint = map.translatePoint;
      var prevTilePoint = map.tileTranslatePoint;
      this.maps.mergeCluster();
      map.previousProjection = type === "Reset" ? void 0 : map.projectionType;
      zoomFactor = type === "ZoomOut" ? Math.round(zoomFactor) === 1 ? 1 : zoomFactor : zoomFactor;
      zoomFactor = type === "Reset" ? minZoom : Math.round(zoomFactor) === 0 ? 1 : zoomFactor;
      zoomFactor = minZoom > zoomFactor && type === "ZoomIn" ? minZoom + 1 : zoomFactor;
      if (!map.isTileMap && (type === "ZoomIn" ? zoomFactor >= minZoom && Math.round(zoomFactor) <= maxZoom : zoomFactor >= minZoom || map.isReset)) {
        var min = map.baseMapRectBounds["min"];
        var max = map.baseMapRectBounds["max"];
        var mapWidth = Math.abs(max["x"] - min["x"]);
        var mapHeight = Math.abs(min["y"] - max["y"]);
        var translatePointX = void 0;
        var translatePointY = void 0;
        if (zoomFactor < 1.2 && map.projectionType !== "Eckert5") {
          if (mapHeight === 0 || mapWidth === 0 || mapHeight === mapWidth) {
            mapWidth = size.width / 2;
            mapHeight = size.height;
          }
          zoomFactor = parseFloat(Math.min(size.width / mapWidth, size.height / mapHeight).toFixed(2));
          zoomFactor = zoomFactor > 1.05 ? 1 : zoomFactor;
          map.translatePoint = this.calculateInitalZoomTranslatePoint(zoomFactor, mapWidth, mapHeight, size, min, map);
        } else {
          translatePointX = translatePoint.x - (size.width / scale - size.width / zoomFactor) / 2;
          translatePointY = translatePoint.y - (size.height / scale - size.height / zoomFactor) / 2;
          var currentHeight = Math.abs(map.baseMapRectBounds["max"]["y"] - map.baseMapRectBounds["min"]["y"]) * zoomFactor;
          translatePointX = currentHeight < map.mapAreaRect.height ? size.x + (-min["x"] + (size.width / 2 - mapWidth / 2)) : translatePointX;
          translatePointY = currentHeight < map.mapAreaRect.height ? size.y + (-min["y"] + (size.height / 2 - mapHeight / 2)) : translatePointY;
          map.translatePoint = new Point(translatePointX, translatePointY);
        }
        map.zoomTranslatePoint = map.translatePoint;
        map.scale = zoomFactor;
        if (this.triggerZoomEvent(prevTilePoint, prevLevel, type)) {
          map.translatePoint = map.zoomTranslatePoint = map.previousPoint;
          map.scale = map.previousScale;
        } else {
          this.applyTransform(map, false, true);
        }
      } else if (map.isTileMap && (zoomFactor >= minZoom && zoomFactor <= maxZoom || map.isReset)) {
        var tileZoomFactor = prevLevel < minZoom && !map.isReset ? minZoom : zoomFactor;
        map.scale = Math.pow(2, tileZoomFactor - 1);
        map.tileZoomLevel = tileZoomFactor;
        if (map.previousScale !== map.scale || map.isReset) {
          map.zoomSettings.zoomFactor = zoomFactor;
          var position = { x: map.availableSize.width / 2, y: map.availableSize.height / 2 };
          this.getTileTranslatePosition(prevLevel, tileZoomFactor, position, type);
          if (map.zoomSettings.resetToInitial && map.applyZoomReset && type === "Reset" || type === "ZoomOut" && map.zoomSettings.resetToInitial && map.applyZoomReset && tileZoomFactor <= map.initialZoomLevel) {
            map.initialCheck = true;
            map.zoomPersistence = false;
            map.tileTranslatePoint.x = map.initialTileTranslate.x;
            map.tileTranslatePoint.y = map.initialTileTranslate.y;
            tileZoomFactor = map.tileZoomLevel = map.mapScaleValue = map.initialZoomLevel;
          }
          if (this.triggerZoomEvent(prevTilePoint, prevLevel, type)) {
            map.translatePoint = map.tileTranslatePoint = new Point(0, 0);
            map.scale = map.previousScale;
            map.tileZoomLevel = prevLevel;
            map.zoomSettings.zoomFactor = map.previousScale;
          } else {
            map.translatePoint.y = (map.tileTranslatePoint.y - 0.01 * map.mapScaleValue) / map.scale;
            map.translatePoint.x = (map.tileTranslatePoint.x - 0.01 * map.mapScaleValue) / map.scale;
            if (document.getElementById(this.maps.element.id + "_LayerIndex_1")) {
              document.getElementById(this.maps.element.id + "_LayerIndex_1").style.display = "none";
            }
            if (document.querySelector(".GroupElement")) {
              document.querySelector(".GroupElement").style.display = "none";
            }
            this.markerLineAnimation(map);
            map.mapLayerPanel.generateTiles(tileZoomFactor, map.tileTranslatePoint, type);
            var animationDuration = this.maps.layersCollection[0].animationDuration === 0 && animationMode === "Enable" ? 1e3 : this.maps.layersCollection[0].animationDuration;
            setTimeout(function() {
              if (type === "ZoomOut" || type === "Reset") {
              }
              _this.applyTransform(_this.maps, false, true);
              if (document.getElementById(_this.maps.element.id + "_LayerIndex_1")) {
                document.getElementById(_this.maps.element.id + "_LayerIndex_1").style.display = "block";
              }
              _this.maps.isAddLayer = false;
            }, animationDuration);
          }
        }
        this.maps.zoomNotApplied = false;
      }
      this.triggerZoomComplete(map, prevLevel, type);
    };
    Zoom2.prototype.createZoomingToolbars = function() {
      var map = this.maps;
      this.toolBarGroup = map.renderer.createGroup({
        id: map.element.id + "_Zooming_KitCollection",
        opacity: map.theme.toLowerCase() === "fluentdark" ? 0.6 : 0.3
      });
      var xSpacing = 15;
      var ySpacing = 15;
      var toolbar = map.zoomSettings.toolbarSettings;
      var button = map.zoomSettings.toolbarSettings.buttonSettings;
      this.maps.toolbarProperties = {
        toolBarOrientation: toolbar.orientation,
        highlightColor: button.highlightColor,
        selectionColor: button.selectionColor,
        horizontalAlignment: toolbar.horizontalAlignment,
        verticalAlignment: toolbar.verticalAlignment,
        color: button.color,
        shapeOpacity: button.opacity,
        borderOpacity: button.borderOpacity
      };
      var buttonRadius = button.radius || map.themeStyle.zoomButtonRadius;
      var cx = buttonRadius / 4;
      var cy = buttonRadius / 4;
      var radius = buttonRadius / 2;
      var padding = button.padding;
      var orientation = this.maps.toolbarProperties.toolBarOrientation;
      var toolbarCollection = map.zoomSettings.toolbarSettings.buttonSettings.toolbarItems.map(function(value) {
        return value;
      });
      xSpacing = buttonRadius / 4 + button.borderWidth / 2 + padding;
      ySpacing = buttonRadius / 4 + button.borderWidth / 2 + padding;
      var shadowElement = '<filter id="chart_shadow" height="130%"><feGaussianBlur in="SourceAlpha" stdDeviation="5"/>';
      shadowElement += '<feOffset dx="-3" dy="4" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="1"/>';
      shadowElement += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
      var toolBarLength = toolbarCollection.length;
      var toolWidth = orientation === "Horizontal" ? toolBarLength * buttonRadius + toolBarLength * padding + padding + toolBarLength * button.borderWidth : buttonRadius + button.borderWidth + 2 * padding;
      var toolHeight = orientation === "Horizontal" ? buttonRadius + button.borderWidth + 2 * padding : toolBarLength * buttonRadius + toolBarLength * padding + padding + toolBarLength * button.borderWidth;
      var defElement = map.renderer.createDefs();
      defElement.innerHTML = shadowElement;
      this.toolBarGroup.appendChild(defElement);
      var outerElement = map.renderer.drawRectangle(new RectOption(map.element.id + "_Zooming_Rect", toolbar.backgroundColor, { color: toolbar.borderColor, width: toolbar.borderWidth, opacity: toolbar.borderOpacity }, toolbar.borderOpacity, new Rect2(toolbar.borderWidth / 2, toolbar.borderWidth / 2, toolWidth - toolbar.borderWidth, toolHeight - toolbar.borderWidth), 0, 0));
      this.toolBarGroup.appendChild(outerElement);
      var scaleX = (buttonRadius - button.borderWidth / 2) / 30;
      for (var i = 0; i < toolbarCollection.length; i++) {
        if (i !== 0) {
          xSpacing = map.toolbarProperties.toolBarOrientation === "Horizontal" ? xSpacing + (buttonRadius + padding) + button.borderWidth : xSpacing;
          ySpacing = map.toolbarProperties.toolBarOrientation === "Horizontal" ? ySpacing : ySpacing + (buttonRadius + padding) + button.borderWidth;
        }
        var toolbar_1 = toolbarCollection[i];
        var pathStroke = !isNullOrUndefined(this.maps.toolbarProperties.color) ? this.maps.toolbarProperties.color : this.maps.themeStyle.zoomFillColor;
        var borderColor = button.borderColor || (this.maps.themeStyle.zoomBorderColor || this.maps.themeStyle.zoomFillColor);
        this.currentToolbarEle = map.renderer.createGroup({
          id: map.element.id + "_Zooming_ToolBar_" + toolbar_1 + "_Group",
          transform: "translate( " + xSpacing + " " + ySpacing + " ) "
        });
        this.currentToolbarEle.setAttribute("class", "e-maps-toolbar");
        this.currentToolbarEle.appendChild(map.renderer.drawCircle(new CircleOption(map.element.id + "_Zooming_ToolBar_" + toolbar_1 + "_Rect", button.fill, { color: borderColor, width: button.borderWidth, opacity: button.borderOpacity }, button.opacity, cx, cy, radius, "")));
        var opacity = 1;
        var direction = "";
        var fill = button.fill;
        this.selectionColor = this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor;
        switch (toolbar_1.toLowerCase()) {
          case "zoom": {
            var fillColor = void 0;
            var strokeColor = void 0;
            direction = "M0.001,14.629L1.372,16l4.571-4.571v-0.685l0.228-0.274c1.051,0.868,2.423,1.417,3.885,1.417c3.291,0,";
            direction += "5.943-2.651,5.943-5.943S13.395,0,10.103,0S4.16,2.651,4.16,5.943c0,1.508,0.503,2.834,1.417,3.885l-0.274,0.228H4.571";
            direction = direction + "L0.001,14.629L0.001,14.629z M5.943,5.943c0-2.285,1.828-4.114,4.114-4.114s4.114,1.828,4.114,";
            this.currentToolbarEle.setAttribute("class", this.maps.zoomSettings.enableSelectionZooming ? "e-maps-toolbar" : "");
            if (this.maps.zoomSettings.enablePanning && !this.maps.zoomSettings.enableSelectionZooming) {
              fillColor = fill;
              strokeColor = pathStroke;
            } else if (this.maps.zoomSettings.enablePanning && this.maps.zoomSettings.enableSelectionZooming) {
              fillColor = fill;
              strokeColor = pathStroke;
            } else if (!this.maps.zoomSettings.enablePanning && !this.maps.zoomSettings.enableSelectionZooming) {
              fillColor = fill;
              strokeColor = pathStroke;
            } else if (!this.maps.zoomSettings.enablePanning && this.maps.zoomSettings.enableSelectionZooming) {
              fillColor = this.maps.themeStyle.zoomFillColor;
              strokeColor = pathStroke;
            } else {
              fillColor = this.selectionColor;
              strokeColor = this.selectionColor;
            }
            var zoomPath = map.renderer.drawPath(new PathOption2(map.element.id + "_Zooming_ToolBar_" + toolbar_1, fillColor, 1, strokeColor, opacity, opacity, null, direction + "4.114s-1.828,4.114-4.114,4.114S5.943,8.229,5.943,5.943z"));
            zoomPath.setAttribute("transform", "scale( " + scaleX + "," + scaleX + " )");
            this.currentToolbarEle.appendChild(zoomPath);
            this.zoomElements = this.currentToolbarEle;
            this.wireEvents(this.currentToolbarEle, this.performToolBarAction);
            break;
          }
          case "zoomin":
            direction = "M 8, 0 L 8, 16 M 0, 8 L 16, 8";
            var zoomInPath = map.renderer.drawPath(new PathOption2(map.element.id + "_Zooming_ToolBar_" + toolbar_1 + "_Path", fill, 3, pathStroke, 1, 1, null, direction));
            zoomInPath.setAttribute("transform", "scale( " + scaleX + "," + scaleX + " )");
            this.currentToolbarEle.appendChild(zoomInPath);
            this.wireEvents(this.currentToolbarEle, this.performToolBarAction);
            break;
          case "zoomout":
            direction = "M 0, 8 L 16, 8";
            var zoomOutPath = map.renderer.drawPath(new PathOption2(map.element.id + "_Zooming_ToolBar_" + toolbar_1, fill, 3, pathStroke, 1, 1, null, direction));
            zoomOutPath.setAttribute("transform", "scale( " + scaleX + "," + scaleX + " )");
            this.currentToolbarEle.appendChild(zoomOutPath);
            this.wireEvents(this.currentToolbarEle, this.performToolBarAction);
            break;
          case "pan": {
            var color = void 0;
            direction = "M5,3h2.3L7.275,5.875h1.4L8.65,3H11L8,0L5,3z M3,11V8.7l2.875,0.025v-1.4L3,7.35V5L0,8L3,";
            direction += "11z M11,13H8.7l0.025-2.875h-1.4L7.35,13H5l3,3L11,13z M13,5v2.3l-2.875-0.025v1.4L13,8.65V11l3-3L13,5z";
            this.currentToolbarEle.setAttribute("class", this.maps.zoomSettings.enablePanning ? "e-maps-toolbar" : "");
            if (this.maps.zoomSettings.enablePanning && this.maps.zoomModule.isDragZoom) {
              color = this.selectionColor || this.maps.themeStyle.zoomFillColor;
            } else if (!this.maps.zoomSettings.enablePanning) {
              color = this.selectionColor || this.maps.themeStyle.zoomFillColor;
              this.currentToolbarEle.setAttribute("class", "");
            } else {
              color = fill || this.maps.themeStyle.zoomFillColor;
            }
            var panPath = map.renderer.drawPath(new PathOption2(map.element.id + "_Zooming_ToolBar_" + toolbar_1, color, 1, pathStroke, opacity, opacity, null, direction));
            panPath.setAttribute("transform", "scale( " + scaleX + "," + scaleX + " )");
            this.currentToolbarEle.appendChild(panPath);
            this.panColor = color;
            this.panElements = this.currentToolbarEle;
            this.wireEvents(this.currentToolbarEle, this.performToolBarAction);
            break;
          }
          case "reset":
            direction = "M12.364,8h-2.182l2.909,3.25L16,8h-2.182c0-3.575-2.618-6.5-5.818-6.5c-1.128,0-2.218,0.366-3.091,";
            direction += "1.016l1.055,1.178C6.581,3.328,7.272,3.125,8,3.125C10.4,3.125,12.363,5.319,12.364,8L12.364,8z M11.091,";
            direction += "13.484l-1.055-1.178C9.419,12.672,8.728,12.875,8,12.875c-2.4,0-4.364-2.194-4.364-4.875h2.182L2.909,4.75L0,8h2.182c0,";
            var resetPath = map.renderer.drawPath(new PathOption2(map.element.id + "_Zooming_ToolBar_" + toolbar_1, fill, null, pathStroke, 1, 1, null, direction + "3.575,2.618,6.5,5.818,6.5C9.128,14.5,10.219,14.134,11.091,13.484L11.091,13.484z"));
            resetPath.setAttribute("transform", "scale( " + scaleX + "," + scaleX + " )");
            this.currentToolbarEle.appendChild(resetPath);
            this.wireEvents(this.currentToolbarEle, this.performToolBarAction);
            break;
        }
        this.toolBarGroup.appendChild(this.currentToolbarEle);
      }
    };
    Zoom2.prototype.performToolBarAction = function(e) {
      var target = e.target;
      e.stopImmediatePropagation();
      var isTouch = e.pointerType === "touch" || e.pointerType === "2" || e.type.indexOf("touch") > -1;
      var toolbar = target.id.split("_Zooming_ToolBar_")[1].split("_")[0];
      var isToolbarPerform = true;
      switch (toolbar.toLowerCase()) {
        case "zoomin":
          isToolbarPerform = (this.maps.isTileMap ? this.maps.tileZoomLevel : this.maps.scale) + 1 <= this.maps.zoomSettings.maxZoom;
          break;
        case "zoomout":
          var scaleValue = this.maps.isTileMap ? this.maps.tileZoomLevel : this.maps.scale;
          isToolbarPerform = this.maps.projectionType === "Miller" || this.maps.projectionType === "Winkel3" || this.maps.projectionType === "AitOff" ? Math.round(scaleValue) - 1 >= this.maps.zoomSettings.minZoom : scaleValue - 1 >= this.maps.zoomSettings.minZoom;
          break;
        case "reset":
          isToolbarPerform = Math.round(this.maps.isTileMap ? this.maps.tileZoomLevel : this.maps.scale) !== this.maps.zoomSettings.minZoom;
          break;
      }
      if (isTouch && isToolbarPerform) {
        this.handled = true;
        this.performZoomingByToolBar(toolbar);
      } else if ((e.type === "mousedown" || e.type === "pointerdown") && !this.handled && isToolbarPerform) {
        this.handled = false;
        this.performZoomingByToolBar(toolbar);
      } else {
        this.handled = false;
      }
    };
    Zoom2.prototype.performZoomingByToolBar = function(type) {
      var map = this.maps;
      map.isReset = false;
      var scale = 0;
      var stateColor = this.fillColor || this.maps.themeStyle.zoomFillColor;
      switch (type.toLowerCase()) {
        case "zoom":
          this.panColor = stateColor;
          this.zoomColor = this.maps.zoomSettings.enableSelectionZooming ? this.selectionColor : stateColor;
          this.applySelection(this.zoomElements, this.zoomColor);
          this.applySelection(this.panElements, this.panColor);
          this.isPan = false;
          this.isZoomSelection = this.maps.zoomSettings.enableSelectionZooming;
          break;
        case "pan":
          this.panColor = this.maps.zoomSettings.enablePanning ? this.selectionColor : stateColor;
          this.zoomColor = stateColor;
          if (!this.maps.zoomSettings.enablePanning) {
            this.applySelection(this.zoomElements, this.selectionColor);
            this.applySelection(this.panElements, this.panColor);
          } else {
            this.applySelection(this.zoomElements, this.fillColor || stateColor);
            this.applySelection(this.panElements, this.panColor);
          }
          this.isPan = this.maps.zoomSettings.enablePanning;
          this.isZoomSelection = false;
          break;
        case "zoomin":
          map.staticMapZoom = map.tileZoomLevel;
          if (map.staticMapZoom > 0 && map.staticMapZoom < map.zoomSettings.maxZoom) {
            map.staticMapZoom += 1;
          }
          if (map.isTileMap && map.tileZoomLevel >= map.zoomSettings.minZoom && map.tileZoomLevel < map.zoomSettings.maxZoom) {
            this.toolBarZooming(map.tileZoomLevel + 1, "ZoomIn");
          } else if (!map.isTileMap) {
            this.toolBarZooming(map.scale + 1, "ZoomIn");
          }
          scale = this.maps.isTileMap ? Math.round(this.maps.tileZoomLevel) : Math.round(this.maps.mapScaleValue);
          if (!this.isZoomSelection) {
            if (scale === map.zoomSettings.maxZoom || scale > 1 || scale === 1 && this.maps.isTileMap) {
              this.applySelection(this.zoomElements, stateColor);
              this.applySelection(this.panElements, map.zoomSettings.enablePanning ? this.selectionColor : stateColor);
            } else if (scale === 1 && !this.maps.isTileMap) {
              this.applySelection(this.zoomElements, stateColor);
              this.applySelection(this.panElements, stateColor);
            }
          }
          break;
        case "zoomout":
          map.staticMapZoom = map.tileZoomLevel;
          map.markerCenterLatitude = null;
          map.markerCenterLongitude = null;
          this.toolBarZooming((map.isTileMap ? map.tileZoomLevel : map.scale) - 1, "ZoomOut");
          scale = this.maps.isTileMap ? Math.round(this.maps.tileZoomLevel) : Math.round(this.maps.mapScaleValue);
          if (!this.isPan && this.isZoomSelection) {
            this.panColor = stateColor;
            this.zoomColor = this.selectionColor;
            this.applySelection(this.zoomElements, this.selectionColor);
            this.applySelection(this.panElements, this.panColor);
          } else {
            if (scale <= 1 && !map.isTileMap) {
              this.applySelection(this.panElements, stateColor);
            } else {
              this.applySelection(this.panElements, map.zoomSettings.enablePanning ? this.selectionColor : stateColor);
            }
          }
          break;
        case "reset":
          map.staticMapZoom = map.zoomSettings.enable ? map.zoomSettings.zoomFactor : 0;
          map.markerCenterLatitude = null;
          map.markerCenterLongitude = null;
          this.isZoomSelection = false;
          this.isPan = map.zoomSettings.enablePanning;
          this.toolBarZooming(map.zoomSettings.minZoom, "Reset");
          if (this.isPan && !this.isZoomSelection || !this.isPan && this.isZoomSelection) {
            if (!this.maps.zoomSettings.enablePanning) {
              this.applySelection(this.zoomElements, this.selectionColor);
              this.applySelection(this.panElements, stateColor);
            } else {
              this.applySelection(this.zoomElements, stateColor);
              this.applySelection(this.panElements, this.selectionColor);
            }
          } else if (!this.isPan && !this.isZoomSelection) {
            this.applySelection(this.zoomElements, stateColor);
            this.applySelection(this.panElements, stateColor);
          }
      }
      this.panningStyle(type.toLowerCase());
    };
    Zoom2.prototype.panningStyle = function(toolbar) {
      var svg = getElementByID(this.maps.element.id + "_svg");
      if (toolbar === "pan" || this.isPanModeEnabled && toolbar !== "reset") {
        svg.setAttribute("class", "e-maps-panning");
      } else {
        svg.setAttribute("class", "");
      }
    };
    Zoom2.prototype.applySelection = function(elements, color) {
      if (!elements) {
        return;
      }
      var childElement;
      for (var i = 0; i < elements.childElementCount; i++) {
        childElement = elements.childNodes[i];
        if (childElement.tagName !== "circle") {
          childElement.setAttribute("fill", elements.id.indexOf("Pan") > -1 ? color : "transparent");
          childElement.setAttribute("stroke", color);
        }
      }
    };
    Zoom2.prototype.showTooltip = function(e) {
      var text = e.target.id.split("_Zooming_ToolBar_")[1].split("_")[0];
      var tooltip = this.maps.zoomSettings.toolbarSettings.tooltipSettings;
      var tooltipSettings = {
        visible: tooltip.visible,
        fill: tooltip.fill,
        borderOpacity: tooltip.borderOpacity,
        borderWidth: tooltip.borderWidth,
        borderColor: tooltip.borderColor,
        fontColor: tooltip.fontColor,
        fontFamily: tooltip.fontFamily,
        fontStyle: tooltip.fontStyle,
        fontWeight: tooltip.fontWeight,
        fontSize: tooltip.fontSize || "10px",
        fontOpacity: tooltip.fontOpacity
      };
      tooltipSettings.fontFamily = this.maps.themeStyle.fontFamily;
      if (!this.isTouch) {
        createTooltip("EJ2_Map_Toolbar_Tip", this.maps.getLocalizedLabel(text), e.pageY + 10, e.pageX + 10, tooltipSettings);
        if (this.maps.isDevice) {
          clearTimeout(this.clearTimeout);
          this.clearTimeout = setTimeout(this.removeTooltip.bind(this), 2e3);
        }
      }
    };
    Zoom2.prototype.removeTooltip = function() {
      if (getElementByID("EJ2_Map_Toolbar_Tip")) {
        remove(getElementByID("EJ2_Map_Toolbar_Tip"));
      }
    };
    Zoom2.prototype.alignToolBar = function() {
      var map = this.maps;
      var padding = 10;
      var element = createElement("div", { id: map.element.id + "_ToolBar" });
      element.style.cssText = "position:absolute;z-index:2";
      var rectSVGObject = map.renderer.createSvg({
        id: map.element.id + "_Zooming_ToolBar",
        width: 10,
        height: 10
      });
      rectSVGObject.appendChild(this.toolBarGroup);
      element.appendChild(rectSVGObject);
      if (getElementByID(map.element.id + "_Secondary_Element")) {
        getElementByID(map.element.id + "_Secondary_Element").appendChild(element);
      }
      var toolBarSize = this.toolBarGroup.getBoundingClientRect();
      rectSVGObject.setAttribute("height", (toolBarSize.height + map.zoomSettings.toolbarSettings.borderWidth).toString());
      rectSVGObject.setAttribute("width", (toolBarSize.width + map.zoomSettings.toolbarSettings.borderWidth).toString());
      var size = !isNullOrUndefined(map.totalRect) ? map.totalRect : map.mapAreaRect;
      var x = 0;
      var y = 0;
      switch (map.toolbarProperties.verticalAlignment) {
        case "Near":
          y = size.y;
          break;
        case "Center":
          y = size.height / 2 - toolBarSize.height / 2;
          break;
        case "Far":
          y = size.height - toolBarSize.height - padding;
          break;
      }
      switch (map.toolbarProperties.horizontalAlignment) {
        case "Near":
          x = size.x;
          break;
        case "Center":
          x = size.width / 2 - toolBarSize.width / 2;
          break;
        case "Far":
          if (!isNullOrUndefined(map.legendModule) && map.legendSettings.position === "Left") {
            x = size.width + size.x - toolBarSize.width - padding;
          } else {
            x = size.width - toolBarSize.width - padding;
          }
          break;
      }
      element.style.left = x + "px";
      element.style.top = y + "px";
      var color = this.maps.toolbarProperties.highlightColor || this.maps.themeStyle.zoomSelectionColor;
      var css = " .e-maps-toolbar:hover > circle { stroke:" + color + "; } .e-maps-toolbar:hover > path { fill: " + color + " ;  stroke: " + color + "; }.e-maps-toolbar:hover { cursor: pointer; } .e-maps-cursor-disable:hover { cursor: not-allowed; } .e-maps-panning:hover { cursor: pointer; } .e-maps-popup-close { display: block; opacity: 0; }";
      var style = document.createElement("style");
      style.appendChild(document.createTextNode(css));
      element.appendChild(style);
    };
    Zoom2.prototype.removeToolbarOpacity = function(factor, id) {
      if (!isNullOrUndefined(this.maps) && this.maps.zoomModule && this.maps.zoomSettings.enable) {
        if (getElementByID(this.maps.element.id + "_Zooming_KitCollection") && id.indexOf(this.maps.element.id + "_Zooming_") > -1) {
          if (this.maps.isDevice) {
            getElementByID(this.maps.element.id + "_Zooming_KitCollection").setAttribute("opacity", "1");
            this.removeToolbarClass("", "", "", "", "");
          } else {
            this.removeToolbarClass(this.maps.zoomSettings.enableSelectionZooming ? "e-maps-toolbar" : "", "e-maps-toolbar", "e-maps-toolbar", this.maps.zoomSettings.enablePanning ? "e-maps-toolbar" : "", "e-maps-toolbar");
          }
          var toolbarShapeOpacity = this.maps.toolbarProperties.shapeOpacity;
          var toolbarButtonOpacity = this.maps.toolbarProperties.borderOpacity;
          if (this.maps.isTileMap && (factor <= 1.1 || this.maps.zoomSettings.minZoom === factor)) {
            if (!this.maps.isDevice) {
              this.removeToolbarClass(this.maps.zoomSettings.enableSelectionZooming ? "e-maps-toolbar" : "", "e-maps-toolbar", "", this.maps.zoomSettings.enablePanning ? "e-maps-toolbar" : "", "");
            }
            if (this.maps.zoomSettings.enablePanning) {
              this.removePanColor(this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor);
            }
            if (this.isZoomSelection && this.maps.zoomSettings.enableSelectionZooming && !this.maps.isReset) {
              this.removeZoomColor(this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor);
              this.removePanColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);
            }
            this.removeZoomOpacity(this.maps.zoomSettings.enableSelectionZooming ? toolbarShapeOpacity : 0.3, this.maps.zoomSettings.enableSelectionZooming ? toolbarButtonOpacity : 0.3, toolbarShapeOpacity, toolbarButtonOpacity, 0.3, 0.3, this.maps.zoomSettings.enablePanning ? toolbarShapeOpacity : 0.3, this.maps.zoomSettings.enablePanning ? toolbarButtonOpacity : 0.3, 0.3, 0.3);
          } else if (factor <= 1.1 || this.maps.zoomSettings.minZoom === factor) {
            if (!this.maps.isDevice) {
              this.removeToolbarClass(this.maps.zoomSettings.enableSelectionZooming ? "e-maps-toolbar" : "", "e-maps-toolbar", "", "", "");
            }
            if (!this.isZoomSelection && this.maps.zoomSettings.enablePanning) {
              this.removePanColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);
            }
            if (this.isZoomSelection && this.maps.zoomSettings.enableSelectionZooming && !this.maps.isReset) {
              this.removeZoomColor(this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor);
              this.removePanColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);
            }
            this.removeZoomOpacity(this.maps.zoomSettings.enableSelectionZooming ? toolbarShapeOpacity : 0.3, this.maps.zoomSettings.enableSelectionZooming ? toolbarButtonOpacity : 0.3, toolbarShapeOpacity, toolbarButtonOpacity, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3);
          } else if (factor < this.maps.zoomSettings.maxZoom) {
            if (!this.maps.isDevice) {
              this.removeToolbarClass(this.maps.zoomSettings.enableSelectionZooming ? "e-maps-toolbar" : "", "e-maps-toolbar", "e-maps-toolbar", this.maps.zoomSettings.enablePanning ? "e-maps-toolbar" : "", "e-maps-toolbar");
            }
            if (!this.maps.zoomModule.isZoomFinal) {
              this.removeZoomOpacity(this.maps.zoomSettings.enableSelectionZooming ? toolbarShapeOpacity : 0.3, this.maps.zoomSettings.enableSelectionZooming ? toolbarButtonOpacity : 0.3, toolbarShapeOpacity, toolbarButtonOpacity, toolbarShapeOpacity, toolbarButtonOpacity, this.maps.zoomSettings.enablePanning ? toolbarShapeOpacity : 0.3, this.maps.zoomSettings.enablePanning ? toolbarButtonOpacity : 0.3, toolbarShapeOpacity, toolbarButtonOpacity);
            } else {
              this.maps.zoomModule.isZoomFinal = false;
            }
            if (this.isZoomSelection && this.maps.zoomSettings.enableSelectionZooming) {
              this.removeZoomColor(this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor);
              if (this.maps.zoomModule.isPan && this.maps.zoomSettings.enablePanning) {
                this.removePanColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);
              }
            } else if (!this.isZoomSelection && this.maps.zoomSettings.enablePanning) {
              this.removePanColor(this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor);
              if (this.maps.zoomSettings.enableSelectionZooming) {
                this.removeZoomColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);
              }
            }
          } else {
            if (!this.maps.isDevice) {
              this.removeToolbarClass("", "", "e-maps-toolbar", this.maps.zoomSettings.enablePanning ? "e-maps-toolbar" : "", "e-maps-toolbar");
            }
            this.removeZoomOpacity(0.3, 0.3, 0.3, 0.3, toolbarShapeOpacity, toolbarButtonOpacity, this.maps.zoomSettings.enablePanning ? toolbarShapeOpacity : 0.3, this.maps.zoomSettings.enablePanning ? toolbarButtonOpacity : 0.3, toolbarShapeOpacity, toolbarButtonOpacity);
            if (this.maps.zoomSettings.enableSelectionZooming) {
              this.removeZoomColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);
            }
            if (!this.isZoomSelection && this.maps.zoomSettings.enablePanning) {
              this.removePanColor(this.maps.toolbarProperties.selectionColor || this.maps.themeStyle.zoomSelectionColor);
            }
          }
        } else {
          if (!this.maps.isDevice) {
            this.removePanColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);
            this.removeZoomColor(this.maps.toolbarProperties.color || this.maps.themeStyle.zoomFillColor);
            this.removeZoomOpacity(1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
          }
        }
      }
    };
    Zoom2.prototype.setOpacity = function(circleId, pathId, circleOpacity, pathOpacity) {
      if (getElementByID(this.maps.element.id + circleId)) {
        getElementByID(this.maps.element.id + circleId).setAttribute("stroke-opacity", circleOpacity.toString());
        getElementByID(this.maps.element.id + circleId).setAttribute("fill-opacity", circleOpacity.toString());
        getElementByID(this.maps.element.id + pathId).setAttribute("stroke-opacity", pathOpacity.toString());
        getElementByID(this.maps.element.id + pathId).setAttribute("fill-opacity", pathOpacity.toString());
      }
    };
    Zoom2.prototype.removeZoomOpacity = function(zoomOpacity, zoomStrokeOpacity, zoomInOpacity, zoomInStrokeOpacity, zoomOutOpacity, zoomOutStrokeOpacity, panOpacity, panStrokeOpacity, resetOpacity, resetStrokeOpacity) {
      this.setOpacity("_Zooming_ToolBar_Zoom_Rect", "_Zooming_ToolBar_Zoom", zoomStrokeOpacity, zoomOpacity);
      this.setOpacity("_Zooming_ToolBar_ZoomIn_Rect", "_Zooming_ToolBar_ZoomIn_Path", zoomInStrokeOpacity, zoomInOpacity);
      this.setOpacity("_Zooming_ToolBar_ZoomOut_Rect", "_Zooming_ToolBar_ZoomOut", zoomOutStrokeOpacity, zoomOutOpacity);
      this.setOpacity("_Zooming_ToolBar_Pan_Rect", "_Zooming_ToolBar_Pan", panStrokeOpacity, panOpacity);
      this.setOpacity("_Zooming_ToolBar_Reset_Rect", "_Zooming_ToolBar_Reset", resetStrokeOpacity, resetOpacity);
    };
    Zoom2.prototype.removeToolbarClass = function(zoomClassStyle, zoomInClassStyle, zoomOutClassStyle, panClassStyle, resetClassStyle) {
      if (getElementByID(this.maps.element.id + "_Zooming_KitCollection")) {
        if (document.getElementById(this.maps.element.id + "_Zooming_ToolBar_ZoomIn_Group")) {
          getElementByID(this.maps.element.id + "_Zooming_ToolBar_ZoomIn_Group").setAttribute("class", zoomInClassStyle);
        }
        if (document.getElementById(this.maps.element.id + "_Zooming_ToolBar_ZoomOut_Group")) {
          getElementByID(this.maps.element.id + "_Zooming_ToolBar_ZoomOut_Group").setAttribute("class", zoomOutClassStyle);
        }
        if (document.getElementById(this.maps.element.id + "_Zooming_ToolBar_Reset_Group")) {
          getElementByID(this.maps.element.id + "_Zooming_ToolBar_Reset_Group").setAttribute("class", resetClassStyle);
        }
        if (document.getElementById(this.maps.element.id + "_Zooming_ToolBar_Zoom_Group") && this.maps.zoomSettings.enableSelectionZooming) {
          getElementByID(this.maps.element.id + "_Zooming_ToolBar_Zoom_Group").setAttribute("class", zoomClassStyle);
        }
        if (document.getElementById(this.maps.element.id + "_Zooming_ToolBar_Pan_Group") && this.maps.zoomSettings.enablePanning) {
          getElementByID(this.maps.element.id + "_Zooming_ToolBar_Pan_Group").setAttribute("class", panClassStyle);
        }
      }
    };
    Zoom2.prototype.removePanColor = function(selectionColor) {
      if (getElementByID(this.maps.element.id + "_Zooming_ToolBar_Pan_Rect") && this.maps.zoomSettings.enablePanning) {
        getElementByID(this.maps.element.id + "_Zooming_ToolBar_Pan").setAttribute("fill", selectionColor);
        getElementByID(this.maps.element.id + "_Zooming_ToolBar_Pan").setAttribute("stroke", selectionColor);
      }
    };
    Zoom2.prototype.removeZoomColor = function(selectionColor) {
      if (getElementByID(this.maps.element.id + "_Zooming_ToolBar_Zoom_Rect") && this.maps.zoomSettings.enableSelectionZooming) {
        getElementByID(this.maps.element.id + "_Zooming_ToolBar_Zoom").setAttribute("fill", "transparent");
        getElementByID(this.maps.element.id + "_Zooming_ToolBar_Zoom").setAttribute("stroke", selectionColor);
      }
    };
    Zoom2.prototype.wireEvents = function(element, process) {
      EventHandler.add(element, Browser.touchStartEvent, process, this);
      EventHandler.add(element, "mouseover", this.showTooltip, this);
      EventHandler.add(element, "mouseout", this.removeTooltip, this);
    };
    Zoom2.prototype.mapMouseWheel = function(e) {
      if (this.maps.zoomSettings.enable && this.maps.zoomSettings.mouseWheelZoom) {
        var map = this.maps;
        map.markerZoomedState = false;
        map.zoomPersistence = map.enablePersistence;
        var position = this.getMousePosition(e.pageX, e.pageY);
        var prevLevel = map.tileZoomLevel;
        var prevScale = map.scale;
        var delta = 1;
        var staticMaxZoomLevel = map.zoomSettings.maxZoom;
        var value = map.isTileMap ? prevLevel : prevScale;
        this.maps.mergeCluster();
        if (position.x > map.mapAreaRect.x && position.x < map.mapAreaRect.x + map.mapAreaRect.width && position.y > map.mapAreaRect.y && position.y < map.mapAreaRect.y + map.mapAreaRect.height) {
          e.preventDefault();
          var direction = this.browserName === "mozilla" && !this.isPointer ? (
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            -e.detail / 3 > 0 ? "ZoomIn" : "ZoomOut"
          ) : e.wheelDelta / 120 > 0 ? "ZoomIn" : "ZoomOut";
          if (direction === "ZoomIn") {
            map.mapScaleValue = value + delta;
            if (map.isTileMap) {
              map.staticMapZoom = map.tileZoomLevel;
              if (map.staticMapZoom > 0 && map.staticMapZoom < staticMaxZoomLevel) {
                map.staticMapZoom += 1;
                this.performZooming(position, value + delta, direction, true);
              }
            } else {
              this.performZooming(position, value + delta, direction, true);
            }
          } else {
            map.mapScaleValue = value - delta;
            map.isReset = map.mapScaleValue < 1 ? true : false;
            map.staticMapZoom = map.tileZoomLevel;
            if (map.mapScaleValue === 1) {
              map.markerCenterLatitude = null;
              map.markerCenterLongitude = null;
            }
            if (map.staticMapZoom > 1 && map.staticMapZoom < staticMaxZoomLevel) {
              map.staticMapZoom -= 1;
            }
            this.performZooming(position, value - delta, direction, true);
          }
        }
        this.removeToolbarOpacity(map.mapScaleValue, !this.maps.isDevice ? !isNullOrUndefined(e.target) ? e.target["id"] : this.maps.element.id : this.maps.element.id + "_Zooming_");
      }
    };
    Zoom2.prototype.doubleClick = function(e) {
      var pageX = e.pageX;
      var pageY = e.pageY;
      var tooltipElement = e.target.closest("#" + this.maps.element.id + "_mapsTooltipparent_template");
      if (this.maps.zoomSettings.enable && this.maps.zoomSettings.doubleClickZoom && !(e.target["id"].indexOf("_Zooming_") > -1) && isNullOrUndefined(tooltipElement)) {
        var position = this.getMousePosition(pageX, pageY);
        var map = this.maps;
        var prevLevel = map.tileZoomLevel;
        var prevScale = map.scale;
        map.mapScaleValue = map.mapScaleValue + 1;
        var value = map.isTileMap ? prevLevel : prevScale;
        if (position.x > map.mapAreaRect.x && position.x < map.mapAreaRect.x + map.mapAreaRect.width && position.y > map.mapAreaRect.y && position.y < map.mapAreaRect.y + map.mapAreaRect.height) {
          this.performZooming(position, value + 1, "ZoomIn");
        }
      }
    };
    Zoom2.prototype.mouseDownHandler = function(e) {
      var pageX;
      var pageY;
      var target;
      var touches = null;
      this.isPinchZooming = false;
      var element = e.target;
      if (e.type === "touchstart") {
        this.isTouch = true;
        touches = e.touches;
        target = e.target;
        pageX = touches[0].pageX;
        pageY = touches[0].pageY;
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
        target = e.target;
      }
      if (!this.isTouch) {
        e.preventDefault();
      }
      if (!this.maps.zoomSettings.enablePanning) {
        this.isPan = this.isPanModeEnabled = this.panColor !== this.selectionColor ? this.maps.zoomSettings.enablePanning : this.zoomColor === this.selectionColor;
      } else {
        this.isPan = this.isPanModeEnabled = !this.isZoomSelection;
      }
      this.mouseDownLatLong = { x: pageX, y: pageY };
      var scale = this.maps.isTileMap ? Math.round(this.maps.tileZoomLevel) : Math.round(this.maps.mapScaleValue);
      this.rectZoomingStart = this.isZoomSelection && scale < this.maps.zoomSettings.maxZoom && this.maps.zoomSettings.enable;
      this.mouseDownPoints = this.getMousePosition(pageX, pageY);
      if (this.isTouch && touches !== null) {
        this.firstMove = true;
        this.pinchFactor = this.maps.scale;
        this.fingers = touches.length;
      }
      if (this.maps.isTileMap && this.isTouch && e["touches"].length > 1) {
        var startTouch = this.getMousePosition(e["touches"][0].pageX, e["touches"][0].pageY);
        var endTouch = this.getMousePosition(e["touches"][1].pageX, e["touches"][1].pageY);
        this.startDistance = Math.sqrt(Math.pow(startTouch.x - endTouch.x, 2) + Math.pow(startTouch.y - endTouch.y, 2));
        this.touchCenter = { x: (startTouch.x + endTouch.x) / 2, y: (startTouch.y + endTouch.y) / 2 };
        this.pinchStartLatLong = this.maps.pointToLatLong((startTouch.x + endTouch.x) / 2, (startTouch.y + endTouch.y) / 2);
        this.isCancellation = false;
        this.pinchTileZoomScale = this.maps.tileZoomLevel;
        this.pinchDistance = null;
      }
      this.isSingleClick = true;
    };
    Zoom2.prototype.mouseMoveHandler = function(e) {
      var pageX;
      var pageY;
      var map = this.maps;
      var touchArg;
      var target;
      var touches = null;
      var zoom = this.maps.zoomSettings;
      if (e.type === "touchmove") {
        this.isTouch = true;
        target = e.target;
        touches = e.touches;
        pageX = touches[0].pageX;
        pageY = touches[0].pageY;
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
        target = e.target;
      }
      if (getElementByID(map.element.id + "_Zooming_KitCollection")) {
        if (target.id.indexOf("_Zooming_") > -1) {
          getElementByID(map.element.id + "_Zooming_KitCollection").setAttribute("opacity", "1");
        } else if (!map.isDevice) {
          getElementByID(map.element.id + "_Zooming_KitCollection").setAttribute("opacity", map.theme.toLowerCase() === "fluentdark" ? "0.6" : "0.3");
        }
      }
      if (this.isTouch) {
        if (this.maps.zoomSettings.enable && this.maps.zoomSettings.pinchZooming && touches !== null) {
          if (this.firstMove && touches.length === 2) {
            this.rectZoomingStart = false;
            this.updateInteraction();
            this.touchStartList = targetTouches(e);
          } else if (touches.length === 2 && this.touchStartList.length === 2) {
            this.touchMoveList = targetTouches(e);
            if (e.cancelable) {
              e.preventDefault();
            }
            this.rectZoomingStart = false;
            this.performPinchZooming(e);
          }
          this.firstMove = false;
        }
      }
      this.mouseMovePoints = this.getMousePosition(pageX, pageY);
      if (!this.isPinchZooming && (zoom.enable && this.isPanModeEnabled && this.maps.markerDragId.indexOf("_MarkerIndex_") === -1 && (Browser.isDevice && touches.length >= 1 || !Browser.isDevice))) {
        e.preventDefault();
        this.maps.element.style.cursor = "pointer";
        this.mouseMoveLatLong = { x: pageX, y: pageY };
        if (this.mouseDownLatLong["x"] !== this.mouseMoveLatLong["x"] && this.mouseDownLatLong["y"] !== this.mouseMoveLatLong["y"]) {
          if (this.maps.zoomSettings.enablePanning) {
            this.panning("None", null, null, e);
          }
          this.mouseDownLatLong["x"] = pageX;
          this.mouseDownLatLong["y"] = pageY;
        }
      }
      if (!this.isPinchZooming && (this.isTouch ? touches !== null && touches.length === 1 && this.rectZoomingStart : this.rectZoomingStart)) {
        e.preventDefault();
        var scale = this.maps.isTileMap ? Math.round(this.maps.tileZoomLevel) : Math.round(this.maps.mapScaleValue);
        if (this.maps.zoomSettings.enableSelectionZooming && scale < this.maps.zoomSettings.maxZoom) {
          this.drawZoomRectangle();
        } else {
          this.rectZoomingStart = false;
          this.isPan = true;
        }
      }
    };
    Zoom2.prototype.mouseUpHandler = function(e) {
      this.rectZoomingStart = false;
      this.isSingleClick = this.isSingleClick ? true : false;
      this.isTouch = false;
      this.touchStartList = [];
      this.touchMoveList = [];
      this.lastScale = 1;
      this.isCancellation = false;
      this.maps.element.style.cursor = "auto";
      if (this.isPinchZooming && this.maps.isTileMap) {
        this.isPinchZooming = false;
        var tilesParent = document.getElementById(this.maps.element.id + "_tile_parent");
        var svgElement = document.getElementById(this.maps.element.id + "_Tile_SVG_Parent");
        tilesParent.style.transformOrigin = "";
        tilesParent.style.transform = "";
        svgElement.style.transformOrigin = "";
        svgElement.style.transform = "";
        this.maps.tileZoomLevel = this.maps.mapScaleValue = this.maps.zoomSettings.zoomFactor = this.pinchZoomScale;
        this.maps.scale = Math.pow(2, this.pinchZoomScale - 1);
        this.tileZoomLevel = Math.round(this.pinchZoomScale);
        this.getTileTranslate(this.tileZoomLevel);
        this.maps.mapLayerPanel.generateTiles(this.tileZoomLevel, this.maps.tileTranslatePoint);
        this.applyTransform(this.maps);
        if (document.getElementById(this.maps.element.id + "_animates_tiles")) {
          document.getElementById(this.maps.element.id + "_animates_tiles").remove();
        }
      }
      if (this.isPanModeEnabled && this.maps.zoomSettings.enablePanning && !isNullOrUndefined(this.maps.previousPoint) && (!this.maps.isTileMap ? this.maps.translatePoint.x !== this.maps.previousPoint.x && this.maps.translatePoint.y !== this.maps.previousPoint.y : this.isPanningInProgress)) {
        var pageX = void 0;
        var pageY = void 0;
        var layerX = 0;
        var layerY = 0;
        var target = void 0;
        var element = e.target;
        if (e.type.indexOf("touch") !== -1) {
          var touchArg = e;
          layerX = pageX = touchArg.changedTouches[0].pageX;
          pageY = touchArg.changedTouches[0].pageY;
          layerY = pageY - (this.maps.isTileMap ? 10 : 0);
          target = touchArg.target;
          this.maps.mouseClickEvent = { x: pageX, y: pageY };
        } else {
          pageX = e.pageX;
          pageY = e.pageY;
          layerX = e["layerX"];
          layerY = e["layerY"] - (this.maps.isTileMap ? 10 : 0);
          target = e.target;
        }
        var panCompleteEventArgs = void 0;
        var minMaxLatitudeLongitude = this.maps.getMinMaxLatitudeLongitude();
        if (!this.maps.isTileMap) {
          this.maps.mouseClickEvent["x"] = this.maps.mouseDownEvent["x"];
          this.maps.mouseClickEvent["y"] = this.maps.mouseDownEvent["y"];
          var location_5 = this.maps.getClickLocation(element.id, pageX, pageY, element, pageX, pageY);
          panCompleteEventArgs = {
            cancel: false,
            name: "panComplete",
            maps: this.maps,
            tileTranslatePoint: {},
            translatePoint: { previous: this.maps.previousPoint, current: this.maps.translatePoint },
            scale: this.maps.scale,
            tileZoomLevel: this.maps.tileZoomLevel,
            latitude: !isNullOrUndefined(location_5) ? location_5.latitude : 0,
            longitude: !isNullOrUndefined(location_5) ? location_5.longitude : 0,
            minLatitude: minMaxLatitudeLongitude.minLatitude,
            maxLatitude: minMaxLatitudeLongitude.maxLatitude,
            minLongitude: minMaxLatitudeLongitude.minLongitude,
            maxLongitude: minMaxLatitudeLongitude.maxLongitude
          };
        } else {
          var location_6 = this.maps.getTileGeoLocation(layerX, layerY);
          panCompleteEventArgs = {
            cancel: false,
            name: "panComplete",
            maps: this.maps,
            tileTranslatePoint: { previous: this.maps.tileTranslatePoint, current: this.maps.tileTranslatePoint },
            translatePoint: { previous: this.maps.previousPoint, current: this.maps.translatePoint },
            scale: this.maps.scale,
            tileZoomLevel: this.maps.tileZoomLevel,
            latitude: location_6.latitude,
            longitude: location_6.longitude,
            minLatitude: minMaxLatitudeLongitude.minLatitude,
            maxLatitude: minMaxLatitudeLongitude.maxLatitude,
            minLongitude: minMaxLatitudeLongitude.minLongitude,
            maxLongitude: minMaxLatitudeLongitude.maxLongitude
          };
        }
        this.maps.trigger("panComplete", panCompleteEventArgs);
      }
      this.isPanModeEnabled = false;
      this.isPanningInProgress = false;
      var zoomRectElement = getElementByID(this.maps.element.id + "_Selection_Rect_Zooming");
      if (zoomRectElement && this.maps.zoomSettings.enable && this.maps.zoomSettings.enableSelectionZooming) {
        remove(zoomRectElement);
        this.performRectZooming();
      }
      this.mouseMoveLatLong = { x: 0, y: 0 };
      this.mouseDownLatLong = { x: 0, y: 0 };
      this.pinchDistance = null;
    };
    Zoom2.prototype.mouseCancelHandler = function(e) {
      this.isPanModeEnabled = false;
      this.isTouch = false;
      this.rectZoomingStart = false;
      var zoomRectElement = getElementByID(this.maps.element.id + "_Selection_Rect_Zooming");
      if (zoomRectElement && this.maps.zoomSettings.enable) {
        remove(zoomRectElement);
        this.performRectZooming();
      }
    };
    Zoom2.prototype.click = function(e) {
      var map = this.maps;
      var tooltipElement = e.target.closest("#" + this.maps.element.id + "_mapsTooltipparent_template");
      if (map.markerModule && map.markerModule.sameMarkerData.length > 0 || e.target["id"].indexOf("MarkerIndex") > -1 && e.target["id"].indexOf("cluster") === -1 || !isNullOrUndefined(tooltipElement)) {
        return null;
      }
      if (this.isSingleClick && map.zoomSettings.zoomOnClick && !(e.target["id"].indexOf("_Zooming_") > -1) && !map.zoomSettings.doubleClickZoom && this.zoomColor !== this.selectionColor) {
        var pageX = e.pageX;
        var pageY = e.pageY;
        var position = this.getMousePosition(pageX, pageY);
        var prevLevel = map.tileZoomLevel;
        var prevScale = map.scale;
        map.mapScaleValue = map.mapScaleValue + 1;
        var value = map.isTileMap ? prevLevel : prevScale;
        if (position.x > map.mapAreaRect.x && position.x < map.mapAreaRect.x + map.mapAreaRect.width && position.y > map.mapAreaRect.y && position.y < map.mapAreaRect.y + map.mapAreaRect.height) {
          this.performZooming(position, value + 1, "ZoomIn");
        }
      }
    };
    Zoom2.prototype.getMousePosition = function(pageX, pageY) {
      var map = this.maps;
      var elementRect = map.element.getBoundingClientRect();
      var pageXOffset = map.element.ownerDocument.defaultView.pageXOffset;
      var pageYOffset = map.element.ownerDocument.defaultView.pageYOffset;
      var clientTop = map.element.ownerDocument.documentElement.clientTop;
      var clientLeft = map.element.ownerDocument.documentElement.clientLeft;
      var positionX = elementRect.left + pageXOffset - clientLeft;
      var positionY = elementRect.top + pageYOffset - clientTop;
      return new Point(Math.abs(pageX - positionX), Math.abs(pageY - positionY));
    };
    Zoom2.prototype.addEventListener = function() {
      if (this.maps.isDestroyed) {
        return;
      }
      EventHandler.add(this.maps.element, this.wheelEvent, this.mapMouseWheel, this);
      EventHandler.add(this.maps.element, "click", this.click, this);
      EventHandler.add(this.maps.element, "dblclick", this.doubleClick, this);
      this.maps.on(Browser.touchMoveEvent, this.mouseMoveHandler, this);
      this.maps.on(Browser.touchStartEvent, this.mouseDownHandler, this);
      this.maps.on(Browser.touchEndEvent, this.mouseUpHandler, this);
      EventHandler.add(this.maps.element, this.cancelEvent, this.mouseCancelHandler, this);
    };
    Zoom2.prototype.removeEventListener = function() {
      if (this.maps.isDestroyed) {
        return;
      }
      EventHandler.remove(this.maps.element, this.wheelEvent, this.mapMouseWheel);
      EventHandler.remove(this.maps.element, "click", this.click);
      EventHandler.remove(this.maps.element, "dblclick", this.doubleClick);
      this.maps.off(Browser.touchMoveEvent, this.mouseMoveHandler);
      this.maps.off(Browser.touchStartEvent, this.mouseDownHandler);
      this.maps.off(Browser.touchEndEvent, this.mouseUpHandler);
      EventHandler.remove(this.maps.element, this.cancelEvent, this.mouseCancelHandler);
      var toolbarElement = document.getElementById(this.maps.element.id + "_Zooming_KitCollection");
      if (toolbarElement) {
        for (var i = 0; i < toolbarElement.childNodes.length; i++) {
          if (toolbarElement.childNodes[i].tagName === "g") {
            EventHandler.add(toolbarElement.childNodes[i], Browser.touchStartEvent, this.performToolBarAction);
            EventHandler.add(toolbarElement.childNodes[i], "mouseover", this.showTooltip);
            EventHandler.add(toolbarElement.childNodes[i], "mouseout", this.removeTooltip);
          }
        }
      }
    };
    Zoom2.prototype.getModuleName = function() {
      return "Zoom";
    };
    Zoom2.prototype.destroy = function() {
      this.toolBarGroup = null;
      this.currentToolbarEle = null;
      this.zoomingRect = null;
      this.zoomElements = null;
      this.panElements = null;
      this.baseTranslatePoint = null;
      this.touchStartList = null;
      this.touchMoveList = null;
      this.previousTouchMoveList = null;
      this.mouseDownPoints = null;
      this.mouseMovePoints = null;
      this.startTouches = [];
      this.mouseDownLatLong = null;
      this.mouseMoveLatLong = null;
      this.layerCollectionEle = null;
      this.currentLayer = null;
      this.pinchDistance = null;
      if (!this.maps.refreshing) {
        this.maps = null;
      }
    };
    return Zoom2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/model/print.js
var Print = (
  /** @class */
  (function() {
    function Print2(control) {
    }
    Print2.prototype.print = function(maps, elements) {
      var printWindow = window.open("", "print", "height=" + window.outerHeight + ",width=" + window.outerWidth + ",tabbar=no");
      printWindow.moveTo(0, 0);
      printWindow.resizeTo(screen.availWidth, screen.availHeight);
      var argsData = {
        cancel: false,
        htmlContent: this.getHTMLContent(maps, elements),
        name: beforePrint
      };
      maps.trigger("beforePrint", argsData, function(beforePrintArgs) {
        if (!argsData.cancel) {
          print(argsData.htmlContent, printWindow);
        }
      });
    };
    Print2.prototype.getHTMLContent = function(maps, elements) {
      var div = createElement("div");
      var divElement = maps.element.cloneNode(true);
      var backgroundElement = !maps.isTileMap ? divElement.getElementsByTagName("svg")[0] : divElement.getElementsByTagName("svg")[1];
      if (!isNullOrUndefined(backgroundElement)) {
        backgroundElement = backgroundElement.childNodes[0];
        if (!isNullOrUndefined(backgroundElement)) {
          var backgroundColor = backgroundElement.getAttribute("fill");
          if ((maps.theme === "Tailwind" || maps.theme === "Tailwind3" || maps.theme === "Bootstrap5" || maps.theme === "Fluent" || maps.theme === "Material3" || maps.theme === "Fluent2") && (backgroundColor === "rgba(255,255,255, 0.0)" || backgroundColor === "transparent")) {
            backgroundElement.setAttribute("fill", "rgba(255,255,255, 1)");
          } else if ((maps.theme === "TailwindDark" || maps.theme === "Tailwind3Dark" || maps.theme === "Bootstrap5Dark" || maps.theme === "FluentDark" || maps.theme === "Material3Dark" || maps.theme === "Fluent2Dark" || maps.theme === "Fluent2HighContrast") && (backgroundColor === "rgba(255,255,255, 0.0)" || backgroundColor === "transparent")) {
            backgroundElement.setAttribute("fill", "rgba(0, 0, 0, 1)");
          }
        }
      }
      if (maps.isTileMap) {
        for (var i = 0; i < divElement.childElementCount; i++) {
          if (divElement.children[i].id === maps.element.id + "_tile_parent") {
            divElement.children[i].style.removeProperty("height");
            divElement.children[i].style.removeProperty("width");
            divElement.children[i].style.removeProperty("top");
            divElement.children[i].style.removeProperty("left");
            divElement.children[i].style.removeProperty("right");
            divElement.children[i].style.removeProperty("overflow");
            var svgElement = document.getElementById(maps.element.id + "_Tile_SVG_Parent");
            divElement.children[i].children[0].style.overflow = "hidden";
            divElement.children[i].children[0].style.position = "absolute";
            divElement.children[i].children[0].style.height = svgElement.style.height;
            divElement.children[i].children[0].style.width = svgElement.style.width;
            divElement.children[i].children[0].style.left = svgElement.style.left;
            divElement.children[i].children[0].style.top = svgElement.style.top;
            break;
          }
        }
      }
      if (elements) {
        if (elements instanceof Array) {
          Array.prototype.forEach.call(elements, function(value) {
            div.appendChild(getElement2(value).cloneNode(true));
          });
        } else if (elements instanceof Element) {
          div.appendChild(elements.cloneNode(true));
        } else {
          div.appendChild(getElement2(elements).cloneNode(true));
        }
      } else {
        div.appendChild(divElement);
      }
      return div;
    };
    Print2.prototype.getModuleName = function() {
      return "Print";
    };
    Print2.prototype.destroy = function() {
    };
    return Print2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/model/export-image.js
var ImageExport = (
  /** @class */
  (function() {
    function ImageExport2(control) {
    }
    ImageExport2.prototype.export = function(maps, type, fileName, allowDownload) {
      var promise = new Promise(function(resolve, reject) {
        var imageCanvasElement = createElement("canvas", {
          id: "ej2-canvas",
          attrs: {
            "width": maps.availableSize.width.toString(),
            "height": maps.availableSize.height.toString()
          }
        });
        var isDownload = !(Browser.userAgent.toString().indexOf("HeadlessChrome") > -1);
        var svgParent = document.getElementById(maps.element.id + "_Tile_SVG_Parent");
        var svgDataElement;
        var tileSvg;
        var svgObject = getElementByID(maps.element.id + "_svg").cloneNode(true);
        var backgroundElement = svgObject.childNodes[0];
        var backgroundColor = backgroundElement.getAttribute("fill");
        if ((maps.theme === "Tailwind" || maps.theme === "Tailwind3" || maps.theme === "Bootstrap5" || maps.theme === "Fluent" || maps.theme === "Material3" || maps.theme === "Fluent2") && (backgroundColor === "rgba(255,255,255, 0.0)" || backgroundColor === "transparent")) {
          svgObject.childNodes[0].setAttribute("fill", "rgba(255,255,255, 1)");
        } else if ((maps.theme === "TailwindDark" || maps.theme === "Tailwind3Dark" || maps.theme === "Bootstrap5Dark" || maps.theme === "FluentDark" || maps.theme === "Material3Dark" || maps.theme === "Fluent2Dark" || maps.theme === "Fluent2HighContrast") && (backgroundColor === "rgba(255,255,255, 0.0)" || backgroundColor === "transparent")) {
          svgObject.childNodes[0].setAttribute("fill", "rgba(0, 0, 0, 1)");
        }
        if (!maps.isTileMap) {
          svgDataElement = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + svgObject.outerHTML + "</svg>";
        } else {
          tileSvg = getElementByID(maps.element.id + "_Tile_SVG").cloneNode(true);
          svgDataElement = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + svgObject.outerHTML + tileSvg.outerHTML + "</svg>";
        }
        var url = window.URL.createObjectURL(new Blob(type === "SVG" ? [svgDataElement] : [new XMLSerializer().serializeToString(svgObject)], { type: "image/svg+xml" }));
        if (type === "SVG") {
          if (allowDownload) {
            triggerDownload(fileName, type, url, isDownload);
          } else {
            resolve(null);
          }
        } else {
          var image_1 = new Image();
          var ctxt_1 = imageCanvasElement.getContext("2d");
          if (!maps.isTileMap) {
            image_1.onload = (function() {
              ctxt_1.drawImage(image_1, 0, 0);
              window.URL.revokeObjectURL(url);
              if (allowDownload) {
                triggerDownload(fileName, type, imageCanvasElement.toDataURL("image/png").replace("image/png", "image/octet-stream"), isDownload);
              } else {
                if (type === "PNG") {
                  resolve(imageCanvasElement.toDataURL("image/png"));
                } else if (type === "JPEG") {
                  resolve(imageCanvasElement.toDataURL("image/jpeg"));
                }
              }
            });
            image_1.src = url;
          } else {
            maps.isExportInitialTileMap = true;
            var svgParentElement = document.getElementById(maps.element.id + "_MapAreaBorder");
            var top_1 = parseFloat(svgParentElement.getAttribute("y"));
            var left_1 = parseFloat(svgParentElement.getAttribute("x"));
            var imgxHttp = new XMLHttpRequest();
            var imgTileLength_1 = maps.mapLayerPanel.tiles.length;
            var _loop_1 = function(i2) {
              var tile = document.getElementById(maps.element.id + "_tile_" + (i2 - 1));
              var exportTileImg = new Image();
              exportTileImg.crossOrigin = "Anonymous";
              var background = maps.background ? maps.background : (maps.theme === "Tailwind" || maps.theme === "Tailwind3" || maps.theme === "Bootstrap5" || maps.theme === "Fluent" || maps.theme === "Material3") && (backgroundColor === "rgba(255,255,255, 0.0)" || backgroundColor === "transparent") ? "#ffffff" : (maps.theme === "TailwindDark" || maps.theme === "Tailwind3Dark" || maps.theme === "Bootstrap5Dark" || maps.theme === "FluentDark" || maps.theme === "Material3Dark") && (backgroundColor === "rgba(255,255,255, 0.0)" || backgroundColor === "transparent") ? "#000000" : "#ffffff";
              ctxt_1.fillStyle = background;
              ctxt_1.fillRect(0, 0, maps.availableSize.width, maps.availableSize.height);
              ctxt_1.font = maps.titleSettings.textStyle.size + " Arial";
              var titleElement = document.getElementById(maps.element.id + "_Map_title");
              if (!isNullOrUndefined(titleElement)) {
                ctxt_1.fillStyle = titleElement.getAttribute("fill");
                ctxt_1.fillText(maps.titleSettings.text, parseFloat(titleElement.getAttribute("x")), parseFloat(titleElement.getAttribute("y")));
              }
              exportTileImg.onload = (function() {
                if (i2 === 0 || i2 === imgTileLength_1 + 1) {
                  if (i2 === 0) {
                    ctxt_1.setTransform(1, 0, 0, 1, 0, 0);
                    ctxt_1.rect(0, top_1, parseFloat(svgParent.style.width), parseFloat(svgParent.style.height));
                    ctxt_1.clip();
                  } else {
                    ctxt_1.setTransform(1, 0, 0, 1, left_1, top_1);
                  }
                } else {
                  ctxt_1.setTransform(1, 0, 0, 1, parseFloat(tile.style.left) + left_1, parseFloat(tile.style.top) + top_1);
                }
                ctxt_1.drawImage(exportTileImg, 0, 0);
                if (i2 === imgTileLength_1 + 1) {
                  localStorage.setItem("local-canvasImage", imageCanvasElement.toDataURL("image/png"));
                  var localBase64 = localStorage.getItem("local-canvasImage");
                  if (allowDownload) {
                    triggerDownload(fileName, type, localBase64, isDownload);
                    localStorage.removeItem("local-canvasImage");
                    maps.isExportInitialTileMap = false;
                  } else {
                    maps.isExportInitialTileMap = false;
                    if (type === "PNG") {
                      resolve(localBase64);
                    } else if (type === "JPEG") {
                      resolve(imageCanvasElement.toDataURL("image/jpeg"));
                    }
                  }
                }
              });
              if (i2 === 0 || i2 === imgTileLength_1 + 1) {
                if (i2 === 0) {
                  exportTileImg.src = url;
                } else {
                  setTimeout(function() {
                    exportTileImg.src = window.URL.createObjectURL(new Blob([new XMLSerializer().serializeToString(tileSvg)], { type: "image/svg+xml" }));
                  }, 300);
                }
              } else {
                imgxHttp.open("GET", tile.children[0].getAttribute("src"), true);
                imgxHttp.send();
                exportTileImg.src = tile.children[0].getAttribute("src");
              }
            };
            for (var i = 0; i <= imgTileLength_1 + 1; i++) {
              _loop_1(i);
            }
          }
        }
      });
      return promise;
    };
    ImageExport2.prototype.getModuleName = function() {
      return "ImageExport";
    };
    ImageExport2.prototype.destroy = function() {
    };
    return ImageExport2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/collections/utils.js
function defaultToString(item) {
  if (Object.prototype.toString.call(item) === "[object String]") {
    return "$s" + item;
  } else {
    return "$o" + item.toString();
  }
}

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/collections/dictionary.js
var Dictionary = (
  /** @class */
  (function() {
    function Dictionary2(toStringFunction) {
      this.table = {};
      this.nElements = 0;
      this.toStr = toStringFunction || defaultToString;
    }
    Dictionary2.prototype.getValue = function(key) {
      var pair = this.table["$" + this.toStr(key)];
      if (typeof pair === "undefined") {
        return void 0;
      }
      return pair.value;
    };
    Dictionary2.prototype.setValue = function(key, value) {
      var ret;
      var k = "$" + this.toStr(key);
      var previousElement = this.table[k];
      this.nElements++;
      ret = void 0;
      this.table[k] = {
        key,
        value
      };
      return ret;
    };
    Dictionary2.prototype.remove = function(key) {
      var k = "$" + this.toStr(key);
      var previousElement = this.table[k];
      delete this.table[k];
      this.nElements--;
      return previousElement.value;
    };
    Dictionary2.prototype.keys = function() {
      var keysArray = [];
      var namesOfKeys = Object.keys(this.table);
      for (var index1 = 0; index1 < namesOfKeys.length; index1++) {
        var pair1 = this.table[namesOfKeys[index1]];
        keysArray.push(pair1.key);
      }
      return keysArray;
    };
    Dictionary2.prototype.values = function() {
      var valuesArray = [];
      var namesOfValues = Object.keys(this.table);
      for (var index2 = 0; index2 < namesOfValues.length; index2++) {
        var pair2 = this.table[namesOfValues[index2]];
        valuesArray.push(pair2.value);
      }
      return valuesArray;
    };
    Dictionary2.prototype.containsKey = function(key) {
      var retutnValue = true;
      if (typeof this.getValue(key) === "undefined") {
        retutnValue = true;
      } else {
        retutnValue = false;
      }
      return !retutnValue;
    };
    Dictionary2.prototype.clear = function() {
      this.table = {};
      this.nElements = 0;
    };
    Dictionary2.prototype.size = function() {
      return this.nElements;
    };
    return Dictionary2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-name.js
var PdfName = (
  /** @class */
  (function() {
    function PdfName2(value) {
      this.stringStartMark = "/";
      this.internalValue = "";
      this.isSaving6 = false;
      this.position6 = -1;
      this.internalValue = this.normalizeValue(value);
    }
    Object.defineProperty(PdfName2.prototype, "status", {
      //property
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status6;
      },
      set: function(value) {
        this.status6 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfName2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving6;
      },
      set: function(value) {
        this.isSaving6 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfName2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index6;
      },
      set: function(value) {
        this.index6 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfName2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position6;
      },
      set: function(value) {
        this.position6 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfName2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfName2.prototype, "value", {
      /**
       * Gets or sets the `value` of the object.
       * @private
       */
      get: function() {
        return this.internalValue;
      },
      set: function(value) {
        var val = value;
        if (value !== null && value.length > 0) {
          val = value;
          this.internalValue = this.normalizeValue(val);
        } else {
          this.internalValue = val;
        }
      },
      enumerable: true,
      configurable: true
    });
    PdfName2.prototype.save = function(writer) {
      writer.write(this.toString());
    };
    PdfName2.prototype.toString = function() {
      return this.stringStartMark + this.escapeString(this.value);
    };
    PdfName2.prototype.clone = function(crossTable) {
      var newName = new PdfName2();
      newName.value = this.internalValue;
      return newName;
    };
    PdfName2.prototype.escapeString = function(stringValue) {
      var result = "";
      var len = 0;
      for (var i = 0, len_1 = stringValue.length; i < len_1; i++) {
        var ch = stringValue[i];
        var index = PdfName2.delimiters.indexOf(ch);
        result = result + ch;
      }
      return result;
    };
    PdfName2.prototype.normalizeValue = function(value, c) {
      var strFormat = "#{0:X}";
      return value;
    };
    PdfName2.delimiters = "()<>[]{}/%}";
    PdfName2.replacements = [" ", "	", "\n", "\r"];
    return PdfName2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/pdf-operators.js
var Operators = (
  /** @class */
  (function() {
    function Operators2() {
      this.forTest = "test";
      this.forTest = Operators2.obj;
    }
    Operators2.obj = "obj";
    Operators2.endObj = "endobj";
    Operators2.r = "R";
    Operators2.whiteSpace = " ";
    Operators2.slash = "/";
    Operators2.newLine = "\r\n";
    Operators2.stream = "stream";
    Operators2.endStream = "endstream";
    Operators2.xref = "xref";
    Operators2.f = "f";
    Operators2.n = "n";
    Operators2.trailer = "trailer";
    Operators2.startxref = "startxref";
    Operators2.eof = "%%EOF";
    Operators2.header = "%PDF-1.5";
    Operators2.beginText = "BT";
    Operators2.endText = "ET";
    Operators2.beginPath = "m";
    Operators2.appendLineSegment = "l";
    Operators2.stroke = "S";
    Operators2.fill = "f";
    Operators2.fillEvenOdd = "f*";
    Operators2.fillStroke = "B";
    Operators2.fillStrokeEvenOdd = "B*";
    Operators2.appendbeziercurve = "c";
    Operators2.appendRectangle = "re";
    Operators2.saveState = "q";
    Operators2.restoreState = "Q";
    Operators2.paintXObject = "Do";
    Operators2.modifyCtm = "cm";
    Operators2.modifyTM = "Tm";
    Operators2.setLineWidth = "w";
    Operators2.setLineCapStyle = "J";
    Operators2.setLineJoinStyle = "j";
    Operators2.setDashPattern = "d";
    Operators2.setFlatnessTolerance = "i";
    Operators2.closePath = "h";
    Operators2.closeStrokePath = "s";
    Operators2.closeFillStrokePath = "b";
    Operators2.setCharacterSpace = "Tc";
    Operators2.setWordSpace = "Tw";
    Operators2.setHorizontalScaling = "Tz";
    Operators2.setTextLeading = "TL";
    Operators2.setFont = "Tf";
    Operators2.setRenderingMode = "Tr";
    Operators2.setTextRise = "Ts";
    Operators2.setTextScaling = "Tz";
    Operators2.setCoords = "Td";
    Operators2.goToNextLine = "T*";
    Operators2.setText = "Tj";
    Operators2.setTextWithFormatting = "TJ";
    Operators2.setTextOnNewLine = "'";
    Operators2.selectcolorspaceforstroking = "CS";
    Operators2.selectcolorspacefornonstroking = "cs";
    Operators2.setrbgcolorforstroking = "RG";
    Operators2.setrbgcolorfornonstroking = "rg";
    Operators2.setcmykcolorforstroking = "K";
    Operators2.setcmykcolorfornonstroking = "k";
    Operators2.setgraycolorforstroking = "G";
    Operators2.setgraycolorfornonstroking = "g";
    Operators2.clipPath = "W";
    Operators2.clipPathEvenOdd = "W*";
    Operators2.endPath = "n";
    Operators2.setGraphicsState = "gs";
    Operators2.comment = "%";
    Operators2.evenOdd = "*";
    Operators2.setMiterLimit = "M";
    Operators2.setColorAndPattern = "scn";
    Operators2.setColorAndPatternStroking = "SCN";
    return Operators2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/pdf-dictionary-properties.js
var DictionaryProperties = (
  /** @class */
  /* @__PURE__ */ (function() {
    function DictionaryProperties2() {
      this.pages = "Pages";
      this.kids = "Kids";
      this.count = "Count";
      this.resources = "Resources";
      this.type = "Type";
      this.size = "Size";
      this.mediaBox = "MediaBox";
      this.parent = "Parent";
      this.root = "Root";
      this.decodeParms = "DecodeParms";
      this.filter = "Filter";
      this.font = "Font";
      this.type1 = "Type1";
      this.baseFont = "BaseFont";
      this.encoding = "Encoding";
      this.subtype = "Subtype";
      this.contents = "Contents";
      this.procset = "ProcSet";
      this.colorSpace = "ColorSpace";
      this.extGState = "ExtGState";
      this.pattern = "Pattern";
      this.xObject = "XObject";
      this.length = "Length";
      this.width = "Width";
      this.height = "Height";
      this.bitsPerComponent = "BitsPerComponent";
      this.image = "Image";
      this.dctdecode = "DCTDecode";
      this.columns = "Columns";
      this.blackIs1 = "BlackIs1";
      this.k = "K";
      this.s = "S";
      this.predictor = "Predictor";
      this.deviceRgb = "DeviceRGB";
      this.next = "Next";
      this.action = "Action";
      this.link = "Link";
      this.a = "A";
      this.annot = "Annot";
      this.p = "P";
      this.c = "C";
      this.rect = "Rect";
      this.uri = "URI";
      this.annots = "Annots";
      this.ca = "ca";
      this.CA = "CA";
      this.xyz = "XYZ";
      this.fit = "Fit";
      this.dest = "Dest";
      this.BM = "BM";
      this.flatedecode = "FlateDecode";
      this.rotate = "Rotate";
      this.bBox = "BBox";
      this.form = "Form";
      this.w = "W";
      this.cIDFontType2 = "CIDFontType2";
      this.cIDToGIDMap = "CIDToGIDMap";
      this.cIDFontType0C = "CIDFontType0C";
      this.identity = "Identity";
      this.dw = "DW";
      this.fontDescriptor = "FontDescriptor";
      this.cIDSystemInfo = "CIDSystemInfo";
      this.cIDFontType0 = "CIDFontType0";
      this.fontName = "FontName";
      this.flags = "Flags";
      this.fontBBox = "FontBBox";
      this.missingWidth = "MissingWidth";
      this.stemV = "StemV";
      this.italicAngle = "ItalicAngle";
      this.capHeight = "CapHeight";
      this.ascent = "Ascent";
      this.descent = "Descent";
      this.leading = "Leading";
      this.avgWidth = "AvgWidth";
      this.fontFile2 = "FontFile2";
      this.fontFile3 = "FontFile3";
      this.maxWidth = "MaxWidth";
      this.xHeight = "XHeight";
      this.stemH = "StemH";
      this.registry = "Registry";
      this.ordering = "Ordering";
      this.supplement = "Supplement";
      this.type0 = "Type0";
      this.identityH = "Identity-H";
      this.toUnicode = "ToUnicode";
      this.descendantFonts = "DescendantFonts";
      this.background = "Background";
      this.shading = "Shading";
      this.matrix = "Matrix";
      this.antiAlias = "AntiAlias";
      this.function = "Function";
      this.extend = "Extend";
      this.shadingType = "ShadingType";
      this.coords = "Coords";
      this.domain = "Domain";
      this.range = "Range";
      this.functionType = "FunctionType";
      this.bitsPerSample = "BitsPerSample";
      this.patternType = "PatternType";
      this.paintType = "PaintType";
      this.tilingType = "TilingType";
      this.xStep = "XStep";
      this.yStep = "YStep";
      this.viewerPreferences = "ViewerPreferences";
      this.centerWindow = "CenterWindow";
      this.displayTitle = "DisplayTitle";
      this.fitWindow = "FitWindow";
      this.hideMenuBar = "HideMenubar";
      this.hideToolBar = "HideToolbar";
      this.hideWindowUI = "HideWindowUI";
      this.pageMode = "PageMode";
      this.pageLayout = "PageLayout";
      this.duplex = "Duplex";
      this.printScaling = "PrintScaling";
    }
    return DictionaryProperties2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-dictionary.js
var PdfDictionary = (
  /** @class */
  (function() {
    function PdfDictionary2(dictionary) {
      this.position7 = -1;
      this.primitiveItems = new Dictionary();
      this.prefix = "<<";
      this.suffix = ">>";
      this.resources = [];
      this.object = null;
      this.archive = true;
      this.isResource = false;
      if (typeof dictionary === "undefined") {
        this.primitiveItems = new Dictionary();
        this.encrypt = true;
        this.dictionaryProperties = new DictionaryProperties();
      } else {
        this.primitiveItems = new Dictionary();
        var keys2 = dictionary.items.keys();
        var values = dictionary.items.values();
        for (var index = 0; index < dictionary.items.size(); index++) {
          this.primitiveItems.setValue(keys2[index], values[index]);
        }
        this.status = dictionary.status;
        this.freezeChanges(this);
        this.encrypt = true;
        this.dictionaryProperties = new DictionaryProperties();
      }
    }
    Object.defineProperty(PdfDictionary2.prototype, "items", {
      //Properties
      /**
       * Gets or sets the `IPdfSavable` with the specified key.
       * @private
       */
      get: function() {
        return this.primitiveItems;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "status", {
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status7;
      },
      set: function(value) {
        this.status7 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving7;
      },
      set: function(value) {
        this.isSaving7 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index7;
      },
      set: function(value) {
        this.index7 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        return this.object;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position7;
      },
      set: function(value) {
        this.position7 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "Count", {
      /**
       * Gets the `count`.
       * @private
       */
      get: function() {
        return this.primitiveItems.size();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDictionary2.prototype, "Dictionary", {
      /**
       * Collection of `items` in the object.
       * @private
       */
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    PdfDictionary2.prototype.getArchive = function() {
      return this.archive;
    };
    PdfDictionary2.prototype.setArchive = function(value) {
      this.archive = value;
    };
    PdfDictionary2.prototype.setEncrypt = function(value) {
      this.encrypt = value;
      this.modify();
    };
    PdfDictionary2.prototype.getEncrypt = function() {
      return this.encrypt;
    };
    PdfDictionary2.prototype.freezeChanges = function(freezer) {
      this.bChanged = false;
    };
    PdfDictionary2.prototype.clone = function(crossTable) {
      var newDict = new PdfDictionary2();
      return newDict;
    };
    PdfDictionary2.prototype.modify = function() {
      this.bChanged = true;
    };
    PdfDictionary2.prototype.remove = function(key) {
      if (typeof key !== "string") {
        this.primitiveItems.remove(key.value);
        this.modify();
      } else {
        this.remove(new PdfName(key));
      }
    };
    PdfDictionary2.prototype.containsKey = function(key) {
      var returnValue = false;
      returnValue = this.primitiveItems.containsKey(key.toString());
      return returnValue;
    };
    PdfDictionary2.prototype.onBeginSave = function() {
      this.beginSave.sender.beginSave();
    };
    PdfDictionary2.prototype.onFontDictionaryBeginSave = function() {
      this.fontDictionaryBeginSave.sender.fontDictionaryBeginSave();
    };
    PdfDictionary2.prototype.onDescendantFontBeginSave = function() {
      this.descendantFontBeginSave.sender.descendantFontBeginSave();
    };
    PdfDictionary2.prototype.onTemplateBeginSave = function() {
      this.pageBeginDrawTemplate.sender.pageBeginSave();
    };
    PdfDictionary2.prototype.onBeginAnnotationSave = function() {
      this.annotationBeginSave.sender.beginSave();
    };
    PdfDictionary2.prototype.onSectionBeginSave = function(writer) {
      var saveEvent = this.sectionBeginSave;
      saveEvent.sender.beginSave(saveEvent.state, writer);
    };
    PdfDictionary2.prototype.save = function(writer, bRaiseEvent) {
      if (typeof bRaiseEvent === "undefined") {
        this.save(writer, true);
      } else {
        writer.write(this.prefix);
        if (typeof this.beginSave !== "undefined") {
          this.onBeginSave();
        }
        if (typeof this.descendantFontBeginSave !== "undefined") {
          this.onDescendantFontBeginSave();
        }
        if (typeof this.fontDictionaryBeginSave !== "undefined") {
          this.onFontDictionaryBeginSave();
        }
        if (typeof this.annotationBeginSave !== "undefined") {
          this.onBeginAnnotationSave();
        }
        if (typeof this.sectionBeginSave !== "undefined") {
          this.onSectionBeginSave(writer);
        }
        if (typeof this.pageBeginDrawTemplate !== "undefined") {
          this.onTemplateBeginSave();
        }
        if (this.Count > 0) {
          this.saveItems(writer);
        }
        writer.write(this.suffix);
        writer.write(Operators.newLine);
      }
    };
    PdfDictionary2.prototype.saveItems = function(writer) {
      writer.write(Operators.newLine);
      var keys2 = this.primitiveItems.keys();
      var values = this.primitiveItems.values();
      for (var index = 0; index < keys2.length; index++) {
        var key = keys2[index];
        var name_1 = new PdfName(key);
        name_1.save(writer);
        writer.write(Operators.whiteSpace);
        var resources = values[index];
        resources.save(writer);
        writer.write(Operators.newLine);
      }
    };
    return PdfDictionary2;
  })()
);
var SaveSectionCollectionEventHandler = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SaveSectionCollectionEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveSectionCollectionEventHandler2;
  })()
);
var SaveDescendantFontEventHandler = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SaveDescendantFontEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveDescendantFontEventHandler2;
  })()
);
var SaveFontDictionaryEventHandler = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SaveFontDictionaryEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveFontDictionaryEventHandler2;
  })()
);
var SaveAnnotationEventHandler = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SaveAnnotationEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveAnnotationEventHandler2;
  })()
);
var SaveSectionEventHandler = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SaveSectionEventHandler2(sender, state) {
      this.sender = sender;
      this.state = state;
    }
    return SaveSectionEventHandler2;
  })()
);
var SaveTemplateEventHandler = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SaveTemplateEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveTemplateEventHandler2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-number.js
var PdfNumber = (
  /** @class */
  (function() {
    function PdfNumber2(value) {
      this.position5 = -1;
      this.value = value;
    }
    Object.defineProperty(PdfNumber2.prototype, "intValue", {
      /**
       * Gets or sets the `integer` value.
       * @private
       */
      get: function() {
        return this.value;
      },
      set: function(value) {
        this.value = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfNumber2.prototype, "isInteger", {
      /**
       * Gets or sets a value indicating whether this instance `is integer`.
       * @private
       */
      get: function() {
        return this.integer;
      },
      set: function(value) {
        this.integer = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfNumber2.prototype, "status", {
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status5;
      },
      set: function(value) {
        this.status5 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfNumber2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving5;
      },
      set: function(value) {
        this.isSaving5 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfNumber2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index5;
      },
      set: function(value) {
        this.index5 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfNumber2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position5;
      },
      set: function(value) {
        this.position5 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfNumber2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        var rValue = null;
        return rValue;
      },
      enumerable: true,
      configurable: true
    });
    PdfNumber2.prototype.save = function(writer) {
      writer.write(this.intValue.toString());
    };
    PdfNumber2.prototype.clone = function(crossTable) {
      var newNumber = new PdfNumber2(this.value);
      return newNumber;
    };
    PdfNumber2.floatToString = function(number) {
      var returnString = number.toFixed(2);
      if (returnString === "0.00") {
        returnString = ".00";
      }
      return returnString;
    };
    PdfNumber2.min = function(x, y, z) {
      var r = Math.min(x, y);
      return Math.min(z, r);
    };
    return PdfNumber2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-array.js
var PdfArray = (
  /** @class */
  (function() {
    function PdfArray2(array) {
      this.startMark = "[";
      this.endMark = "]";
      this.position9 = -1;
      this.clonedObject9 = null;
      this.isFont = false;
      if (typeof array === "undefined") {
        this.internalElements = [];
      } else {
        if (typeof array !== "undefined" && !(array instanceof PdfArray2)) {
          var tempNumberArray = array;
          for (var index = 0; index < tempNumberArray.length; index++) {
            var pdfNumber = new PdfNumber(tempNumberArray[index]);
            this.add(pdfNumber);
          }
        } else {
          var tempArray = array;
          this.internalElements = [];
          for (var index = 0; index < tempArray.elements.length; index++) {
            this.internalElements.push(tempArray.elements[index]);
          }
        }
      }
    }
    PdfArray2.prototype.items = function(index) {
      return this.internalElements[index];
    };
    Object.defineProperty(PdfArray2.prototype, "count", {
      /**
       * Gets the `count`.
       * @private
       */
      get: function() {
        return this.internalElements.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "status", {
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status9;
      },
      set: function(value) {
        this.status9 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving9;
      },
      set: function(value) {
        this.isSaving9 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        return this.clonedObject9;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position9;
      },
      set: function(value) {
        this.position9 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index9;
      },
      set: function(value) {
        this.index9 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "CrossTable", {
      /**
       * Returns `PdfCrossTable` associated with the object.
       * @private
       */
      get: function() {
        return this.pdfCrossTable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfArray2.prototype, "elements", {
      /**
       * Gets the `elements` of the Pdf Array.
       * @private
       */
      get: function() {
        return this.internalElements;
      },
      enumerable: true,
      configurable: true
    });
    PdfArray2.prototype.add = function(element) {
      if (typeof this.internalElements === "undefined") {
        this.internalElements = [];
      }
      this.internalElements.push(element);
      this.markedChange();
    };
    PdfArray2.prototype.markedChange = function() {
      this.bChanged = true;
    };
    PdfArray2.prototype.contains = function(element) {
      var returnValue = false;
      for (var index = 0; index < this.internalElements.length; index++) {
        var tempElement = this.internalElements[index];
        var inputElement = element;
        if (tempElement != null && typeof tempElement !== "undefined" && inputElement != null && typeof inputElement !== "undefined") {
          if (tempElement.value === inputElement.value) {
            return true;
          }
        }
      }
      return returnValue;
    };
    PdfArray2.prototype.getItems = function(index) {
      return this.internalElements[index];
    };
    PdfArray2.prototype.save = function(writer) {
      writer.write(this.startMark);
      for (var i = 0, len = this.count; i < len; i++) {
        this.getItems(i).save(writer);
        if (i + 1 !== len) {
          writer.write(Operators.whiteSpace);
        }
      }
      writer.write(this.endMark);
    };
    PdfArray2.prototype.clone = function(crossTable) {
      this.clonedObject9 = null;
      var newArray = new PdfArray2();
      for (var index = 0; index < this.internalElements.length; index++) {
        var obj = this.internalElements[index];
        newArray.add(obj.clone(crossTable));
      }
      newArray.pdfCrossTable = crossTable;
      this.clonedObject9 = newArray;
      return newArray;
    };
    PdfArray2.fromRectangle = function(bounds) {
      var values = [bounds.x, bounds.y, bounds.width, bounds.height];
      var array = new PdfArray2(values);
      return array;
    };
    PdfArray2.prototype.insert = function(index, element) {
      if (index < this.internalElements.length && index > 0) {
        var tempElements = [];
        for (var i = 0; i < index; i++) {
          tempElements.push(this.internalElements[i]);
        }
        tempElements.push(element);
        for (var i = index; i < this.internalElements.length; i++) {
          tempElements.push(this.internalElements[i]);
        }
        this.internalElements = tempElements;
      } else {
        this.internalElements.push(element);
      }
      this.markChanged();
    };
    PdfArray2.prototype.indexOf = function(element) {
      return this.internalElements.indexOf(element);
    };
    PdfArray2.prototype.remove = function(element) {
      var index = this.internalElements.indexOf(element);
      this.internalElements[index] = null;
      this.markChanged();
    };
    PdfArray2.prototype.removeAt = function(index) {
      if (this.internalElements.length > index) {
        var tempArray = [];
        for (var i = 0; i < index; i++) {
          tempArray.push(this.internalElements[i]);
        }
        for (var i = index + 1; i < this.internalElements.length; i++) {
          tempArray.push(this.internalElements[i]);
        }
        this.internalElements = tempArray;
      }
      this.markChanged();
    };
    PdfArray2.prototype.clear = function() {
      this.internalElements = [];
      this.markChanged();
    };
    PdfArray2.prototype.markChanged = function() {
      this.bChanged = true;
    };
    return PdfArray2;
  })()
);

// node_modules/@syncfusion/ej2-file-utils/src/save.js
var Save = (
  /** @class */
  (function() {
    function Save2() {
    }
    Save2.save = function(fileName, buffer) {
      if (fileName === null || fileName === void 0 || fileName === "") {
        throw new Error("ArgumentException: fileName cannot be undefined, null or empty");
      }
      var extension = fileName.substring(fileName.lastIndexOf(".") + 1, fileName.length);
      var mimeType = this.getMimeType(extension);
      if (mimeType !== "") {
        buffer = new Blob([buffer], { type: mimeType });
      }
      if (this.isMicrosoftBrowser) {
        navigator.msSaveBlob(buffer, fileName);
      } else {
        var downloadLink = document.createElementNS("http://www.w3.org/1999/xhtml", "a");
        this.saveInternal(fileName, extension, buffer, downloadLink, "download" in downloadLink);
      }
    };
    Save2.saveInternal = function(fileName, extension, buffer, downloadLink, hasDownloadAttribute) {
      if (hasDownloadAttribute) {
        downloadLink.download = fileName;
        var dataUrl_1 = window.URL.createObjectURL(buffer);
        downloadLink.href = dataUrl_1;
        var event_1 = document.createEvent("MouseEvent");
        event_1.initEvent("click", true, true);
        downloadLink.dispatchEvent(event_1);
        setTimeout(function() {
          window.URL.revokeObjectURL(dataUrl_1);
          dataUrl_1 = void 0;
        });
      } else {
        if (extension !== "docx" && extension !== "xlsx") {
          var url = window.URL.createObjectURL(buffer);
          var isPopupBlocked = window.open(url, "_blank");
          if (!isPopupBlocked) {
            window.location.href = url;
          }
        } else {
          var reader_1 = new FileReader();
          reader_1.onloadend = function() {
            var isPopupBlocked2 = window.open(reader_1.result, "_blank");
            if (!isPopupBlocked2) {
              window.location.href = reader_1.result;
            }
          };
          reader_1.readAsDataURL(buffer);
        }
      }
    };
    Save2.getMimeType = function(extension) {
      var mimeType = "";
      switch (extension) {
        case "html":
          mimeType = "text/html";
          break;
        case "pdf":
          mimeType = "application/pdf";
          break;
        case "docx":
          mimeType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
          break;
        case "xlsx":
          mimeType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
          break;
        case "txt":
          mimeType = "text/plain";
          break;
      }
      return mimeType;
    };
    return Save2;
  })()
);

// node_modules/@syncfusion/ej2-file-utils/src/xml-writer.js
var XmlWriter = (
  /** @class */
  (function() {
    function XmlWriter2() {
      this.contentPos = 0;
      this.bufferText = "";
      this.bufferBlob = new Blob([""], { type: "text/plain" });
      this.currentState = "Initial";
      this.namespaceStack = [];
      this.namespaceStack.push(new Namespace());
      this.namespaceStack[0].set("xmlns", "http://www.w3.org/2000/xmlns/", "Special");
      this.namespaceStack.push(new Namespace());
      this.namespaceStack[1].set("xml", "http://www.w3.org/XML/1998/namespace", "Special");
      this.namespaceStack.push(new Namespace());
      this.namespaceStack[2].set("", "", "Implied");
      this.elementStack = [];
      this.elementStack.push(new XmlElement());
      this.elementStack[0].set("", "", "", this.namespaceStack.length - 1);
      this.attributeStack = [];
      Save.isMicrosoftBrowser = !!navigator.msSaveBlob;
    }
    Object.defineProperty(XmlWriter2.prototype, "buffer", {
      /**
       * Gets the content written to the {XmlWriter} as Blob.
       * @returns {Blob}
       */
      get: function() {
        this.flush();
        return this.bufferBlob;
      },
      enumerable: true,
      configurable: true
    });
    XmlWriter2.prototype.writeProcessingInstruction = function(name, text) {
      if (name === void 0 || name === null || name.length === 0) {
        throw new Error("ArgumentException: name should not be undefined, null or empty");
      }
      this.checkName(name);
      if (text === void 0 || text === null) {
        text = "";
      }
      if (name.length === 3 && name === "xml") {
        if (this.currentState !== "Initial") {
          throw new Error("InvalidArgumentException: Cannot write XML declaration.WriteStartDocument method has already written it");
        }
      }
      if (this.currentState !== "Initial" || this.bufferBlob === void 0) {
        throw new Error("InvalidOperationException: Wrong Token");
      } else {
        this.writeStartDocument();
        this.writeProcessingInstructionInternal(name, text);
      }
    };
    XmlWriter2.prototype.writeStartDocument = function(standalone3) {
      if (this.currentState !== "Initial" || this.bufferBlob === void 0) {
        throw new Error("InvalidOperationException: Wrong Token");
      }
      this.currentState = "StartDocument";
      this.rawText('<?xml version="1.0" encoding="utf-8');
      if (standalone3 !== null && standalone3 !== void 0) {
        this.rawText('" standalone="');
        this.rawText(standalone3 ? "yes" : "no");
      }
      this.rawText('"?>');
    };
    XmlWriter2.prototype.writeEndDocument = function() {
      while (this.elementStack.length - 1 > 0) {
        this.writeEndElement();
      }
      this.currentState = "EndDocument";
      this.flush();
    };
    XmlWriter2.prototype.writeStartElement = function(prefix, localName, namespace) {
      if (this.bufferBlob === void 0) {
        throw new Error("InvalidOperationException: Wrong Token");
      }
      if (localName === void 0 || localName === null || localName.length === 0) {
        throw new Error("ArgumentException: localName cannot be undefined, null or empty");
      }
      this.checkName(localName);
      if (this.currentState === "Initial") {
        this.writeStartDocument();
      }
      if (this.currentState === "StartElement") {
        this.startElementContent();
      }
      this.currentState = "StartElement";
      if (prefix === void 0 || prefix === null) {
        if (namespace !== void 0 && namespace !== null) {
          prefix = this.lookupPrefix(namespace);
        }
        if (prefix === void 0 || prefix === null) {
          prefix = "";
        }
      } else if (prefix.length > 0) {
        if (namespace === void 0 || namespace === null) {
          namespace = this.lookupNamespace(prefix);
        }
        if (namespace === void 0 || namespace === null || namespace !== void 0 && namespace.length === 0) {
          throw new Error("ArgumentException: Cannot use a prefix with an empty namespace");
        }
      }
      if (namespace === void 0 || namespace === null) {
        namespace = this.lookupNamespace(prefix);
      }
      this.writeStartElementInternal(prefix, localName, namespace);
    };
    XmlWriter2.prototype.writeEndElement = function() {
      if (this.currentState === "StartElement") {
        this.startElementContent();
        this.currentState = "ElementContent";
      } else if (this.currentState === "ElementContent") {
        this.currentState = "ElementContent";
      }
      this.currentState = "EndElement";
      var top = this.elementStack.length - 1;
      this.writeEndElementInternal(this.elementStack[top].prefix, this.elementStack[top].localName);
      this.namespaceStack.splice(this.elementStack[top].previousTop + 1);
      this.elementStack.splice(top);
      if (this.bufferText.length > 10240) {
        this.flush();
      }
    };
    XmlWriter2.prototype.writeElementString = function(prefix, localName, namespace, value) {
      this.writeStartElement(prefix, localName, namespace);
      if (value !== void 0 && value !== null && value.length !== 0) {
        this.writeString(value);
      }
      this.writeEndElement();
    };
    XmlWriter2.prototype.writeAttributeString = function(prefix, localName, namespace, value) {
      this.writeStartAttribute(prefix, localName, namespace, value);
      this.writeStringInternal(value, true);
      this.writeEndAttribute();
    };
    XmlWriter2.prototype.writeString = function(text) {
      this.writeInternal(text, false);
    };
    XmlWriter2.prototype.writeRaw = function(text) {
      this.writeInternal(text, true);
    };
    XmlWriter2.prototype.writeInternal = function(text, isRawString) {
      if (text === void 0 || text === null) {
        return;
      } else {
        if (this.currentState !== "StartElement" && this.currentState !== "ElementContent") {
          throw new Error("InvalidOperationException: Wrong Token");
        }
        if (this.currentState === "StartElement") {
          this.startElementContent();
        }
        this.currentState = "ElementContent";
        if (isRawString) {
          this.rawText(text);
        } else {
          this.writeStringInternal(text, false);
        }
      }
    };
    XmlWriter2.prototype.save = function(fileName) {
      while (this.elementStack.length - 1 > 0) {
        this.writeEndElement();
      }
      if (this.bufferText !== "") {
        this.flush();
      }
      Save.save(fileName, this.buffer);
    };
    XmlWriter2.prototype.destroy = function() {
      this.bufferBlob = void 0;
      for (var i = 0; i < this.namespaceStack.length; i++) {
        this.namespaceStack[i].destroy();
      }
      this.namespaceStack = [];
      for (var i = 0; i < this.elementStack.length; i++) {
        this.elementStack[i].destroy();
      }
      this.elementStack = [];
      this.bufferText = "";
      this.contentPos = 0;
    };
    XmlWriter2.prototype.flush = function() {
      if (this.bufferBlob === void 0) {
        return;
      }
      this.bufferBlob = new Blob([this.bufferBlob, this.bufferText], { type: "text/plain" });
      this.bufferText = "";
    };
    XmlWriter2.prototype.writeProcessingInstructionInternal = function(name, text) {
      this.bufferText += "<?";
      this.rawText(name);
      if (text.length > 0) {
        this.bufferText += " ";
        text = text.replace(/\?\>/g, "? >");
        this.bufferText += text;
      }
      this.bufferText += "?";
      this.bufferText += ">";
    };
    XmlWriter2.prototype.writeStartAttribute = function(prefix, localName, namespace, value) {
      if (localName === void 0 || localName === null || localName.length === 0) {
        if (prefix === "xmlns") {
          localName = "xmlns";
          prefix = "";
        } else {
          throw new Error("ArgumentException: localName cannot be undefined, null or empty");
        }
      }
      if (this.currentState !== "StartElement") {
        throw new Error("InvalidOperationException: Wrong Token");
      }
      this.checkName(localName);
      this.writeStartAttributePrefixAndNameSpace(prefix, localName, namespace, value);
    };
    XmlWriter2.prototype.writeStartAttributePrefixAndNameSpace = function(prefix, localName, namespace, value) {
      if (prefix === void 0 || prefix === null) {
        if (namespace !== void 0 && namespace !== null) {
          if (!(localName === "xmlns" && namespace === "http://www.w3.org/2000/xmlns/")) {
            prefix = this.lookupPrefix(namespace);
          }
        }
        if (prefix === void 0 || prefix === null) {
          prefix = "";
        }
      }
      if (namespace === void 0 || namespace === null) {
        if (prefix !== void 0 && prefix !== null && prefix.length > 0) {
          namespace = this.lookupNamespace(prefix);
        }
        if (namespace === void 0 || namespace === null) {
          namespace = "";
        }
      }
      this.writeStartAttributeSpecialAttribute(prefix, localName, namespace, value);
    };
    XmlWriter2.prototype.writeStartAttributeSpecialAttribute = function(prefix, localName, namespace, value) {
      if (prefix.length === 0) {
        if (localName[0] === "x" && localName === "xmlns") {
          this.skipPushAndWrite(prefix, localName, namespace);
          this.pushNamespaceExplicit("", value);
          return;
        } else if (namespace.length > 0) {
          prefix = this.lookupPrefix(namespace);
        }
      } else {
        if (prefix[0] === "x") {
          if (prefix === "xmlns") {
            this.skipPushAndWrite(prefix, localName, namespace);
            this.pushNamespaceExplicit(localName, value);
            return;
          } else if (prefix === "xml") {
            if (localName === "space" || localName === "lang") {
              this.skipPushAndWrite(prefix, localName, namespace);
              return;
            }
          }
        }
        if (namespace.length === 0) {
          prefix = "";
        }
      }
      if (prefix !== void 0 && prefix !== null && prefix.length !== 0) {
        this.pushNamespaceImplicit(prefix, namespace);
      }
      this.skipPushAndWrite(prefix, localName, namespace);
    };
    XmlWriter2.prototype.writeEndAttribute = function() {
      this.currentState = "StartElement";
      this.bufferText += '"';
    };
    XmlWriter2.prototype.writeStartElementInternal = function(prefix, localName, namespace) {
      this.bufferText += "<";
      if (prefix.length > 0) {
        this.rawText(prefix);
        this.bufferText += ":";
      }
      this.rawText(localName);
      var top = this.elementStack.length;
      this.elementStack.push(new XmlElement());
      this.elementStack[top].set(prefix, localName, namespace, this.namespaceStack.length - 1);
      this.pushNamespaceImplicit(prefix, namespace);
      for (var i = 0; i < this.attributeStack.length; i++) {
        this.attributeStack[i].destroy();
      }
      this.attributeStack = [];
    };
    XmlWriter2.prototype.writeEndElementInternal = function(prefix, localName) {
      if (this.contentPos !== this.bufferText.length + 1) {
        this.bufferText += "</";
        if (prefix !== void 0 && prefix !== null && prefix.length !== 0) {
          this.rawText(prefix);
          this.bufferText += ":";
        }
        this.rawText(localName);
        this.bufferText += ">";
      } else {
        this.bufferText = this.bufferText.substring(0, this.bufferText.length - 1);
        this.bufferText += " />";
      }
    };
    XmlWriter2.prototype.writeStartAttributeInternal = function(prefix, localName, namespaceName) {
      this.bufferText += " ";
      if (prefix !== void 0 && prefix !== null && prefix.length > 0) {
        this.rawText(prefix);
        this.bufferText += ":";
      }
      this.rawText(localName);
      this.bufferText += "=";
      this.bufferText += '"';
    };
    XmlWriter2.prototype.writeNamespaceDeclaration = function(prefix, namespaceUri) {
      this.writeStartNamespaceDeclaration(prefix);
      this.writeStringInternal(namespaceUri, true);
      this.bufferText += '"';
    };
    XmlWriter2.prototype.writeStartNamespaceDeclaration = function(prefix) {
      if (prefix === void 0 || prefix === null || prefix.length === 0) {
        this.rawText(' xmlns="');
      } else {
        this.rawText(" xmlns:");
        this.rawText(prefix);
        this.bufferText += "=";
        this.bufferText += '"';
      }
    };
    XmlWriter2.prototype.writeStringInternal = function(text, inAttributeValue) {
      if (text === null || text === void 0) {
        text = "";
      }
      var tempText = "";
      text = text.replace(/\&/g, "&amp;");
      text = text.replace(/\</g, "&lt;");
      text = text.replace(/\>/g, "&gt;");
      if (inAttributeValue) {
        text = text.replace(/\"/g, "&quot;");
      }
      this.bufferText += text;
      if (!inAttributeValue) {
        this.contentPos = 0;
      }
    };
    XmlWriter2.prototype.startElementContent = function() {
      var start = this.elementStack[this.elementStack.length - 1].previousTop;
      for (var i = this.namespaceStack.length - 1; i > start; i--) {
        if (this.namespaceStack[i].kind === "NeedToWrite") {
          this.writeNamespaceDeclaration(this.namespaceStack[i].prefix, this.namespaceStack[i].namespaceUri);
        }
      }
      this.bufferText += ">";
      this.contentPos = this.bufferText.length + 1;
    };
    XmlWriter2.prototype.rawText = function(text) {
      this.bufferText += text;
    };
    XmlWriter2.prototype.addNamespace = function(prefix, ns, kind) {
      var top = this.namespaceStack.length;
      this.namespaceStack.push(new Namespace());
      this.namespaceStack[top].set(prefix, ns, kind);
    };
    XmlWriter2.prototype.lookupPrefix = function(namespace) {
      for (var i = this.namespaceStack.length - 1; i >= 0; i--) {
        if (this.namespaceStack[i].namespaceUri === namespace) {
          return this.namespaceStack[i].prefix;
        }
      }
      return void 0;
    };
    XmlWriter2.prototype.lookupNamespace = function(prefix) {
      for (var i = this.namespaceStack.length - 1; i >= 0; i--) {
        if (this.namespaceStack[i].prefix === prefix) {
          return this.namespaceStack[i].namespaceUri;
        }
      }
      return void 0;
    };
    XmlWriter2.prototype.lookupNamespaceIndex = function(prefix) {
      for (var i = this.namespaceStack.length - 1; i >= 0; i--) {
        if (this.namespaceStack[i].prefix === prefix) {
          return i;
        }
      }
      return -1;
    };
    XmlWriter2.prototype.pushNamespaceImplicit = function(prefix, ns) {
      var kind;
      var existingNsIndex = this.lookupNamespaceIndex(prefix);
      if (existingNsIndex !== -1) {
        if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {
          if (this.namespaceStack[existingNsIndex].namespaceUri !== ns) {
            throw new Error("XmlException namespace Uri needs to be the same as the one that is already declared");
          }
          return;
        } else {
          if (this.namespaceStack[existingNsIndex].kind === "Special") {
            if (prefix === "xml") {
              if (ns !== this.namespaceStack[existingNsIndex].namespaceUri) {
                throw new Error("InvalidArgumentException: Xml String");
              } else {
                kind = "Implied";
              }
            } else {
              throw new Error('InvalidArgumentException: Prefix "xmlns" is reserved for use by XML.');
            }
          } else {
            kind = this.namespaceStack[existingNsIndex].namespaceUri === ns ? "Implied" : "NeedToWrite";
          }
        }
      } else {
        if (ns === "http://www.w3.org/XML/1998/namespace" && prefix !== "xml" || ns === "http://www.w3.org/2000/xmlns/" && prefix !== "xmlns") {
          throw new Error("InvalidArgumentException");
        }
        kind = "NeedToWrite";
      }
      this.addNamespace(prefix, ns, kind);
    };
    XmlWriter2.prototype.pushNamespaceExplicit = function(prefix, ns) {
      var existingNsIndex = this.lookupNamespaceIndex(prefix);
      if (existingNsIndex !== -1) {
        if (existingNsIndex > this.elementStack[this.elementStack.length - 1].previousTop) {
          this.namespaceStack[existingNsIndex].kind = "Written";
          return;
        }
      }
      this.addNamespace(prefix, ns, "Written");
      return;
    };
    XmlWriter2.prototype.addAttribute = function(prefix, localName, namespaceName) {
      var top = this.attributeStack.length;
      this.attributeStack.push(new XmlAttribute());
      this.attributeStack[top].set(prefix, localName, namespaceName);
      for (var i = 0; i < top; i++) {
        if (this.attributeStack[i].isDuplicate(prefix, localName, namespaceName)) {
          throw new Error("XmlException: duplicate attribute name");
        }
      }
    };
    XmlWriter2.prototype.skipPushAndWrite = function(prefix, localName, namespace) {
      this.addAttribute(prefix, localName, namespace);
      this.writeStartAttributeInternal(prefix, localName, namespace);
    };
    XmlWriter2.prototype.checkName = function(text) {
      var format = /[ !@#$%^&*()+\=\[\]{};':"\\|,<>\/?]/;
      if (format.test(text)) {
        throw new Error("InvalidArgumentException: invalid name character");
      }
    };
    return XmlWriter2;
  })()
);
var Namespace = (
  /** @class */
  (function() {
    function Namespace2() {
    }
    Namespace2.prototype.set = function(prefix, namespaceUri, kind) {
      this.prefix = prefix;
      this.namespaceUri = namespaceUri;
      this.kind = kind;
    };
    Namespace2.prototype.destroy = function() {
      this.prefix = void 0;
      this.namespaceUri = void 0;
      this.kind = void 0;
    };
    return Namespace2;
  })()
);
var XmlElement = (
  /** @class */
  (function() {
    function XmlElement2() {
    }
    XmlElement2.prototype.set = function(prefix, localName, namespaceUri, previousTop) {
      this.previousTop = previousTop;
      this.prefix = prefix;
      this.namespaceUri = namespaceUri;
      this.localName = localName;
    };
    XmlElement2.prototype.destroy = function() {
      this.previousTop = void 0;
      this.prefix = void 0;
      this.localName = void 0;
      this.namespaceUri = void 0;
    };
    return XmlElement2;
  })()
);
var XmlAttribute = (
  /** @class */
  (function() {
    function XmlAttribute2() {
    }
    XmlAttribute2.prototype.set = function(prefix, localName, namespaceUri) {
      this.prefix = prefix;
      this.namespaceUri = namespaceUri;
      this.localName = localName;
    };
    XmlAttribute2.prototype.isDuplicate = function(prefix, localName, namespaceUri) {
      return this.localName === localName && (this.prefix === prefix || this.namespaceUri === namespaceUri);
    };
    XmlAttribute2.prototype.destroy = function() {
      this.prefix = void 0;
      this.namespaceUri = void 0;
      this.localName = void 0;
    };
    return XmlAttribute2;
  })()
);

// node_modules/@syncfusion/ej2-file-utils/src/encoding.js
var Encoding = (
  /** @class */
  (function() {
    function Encoding2(includeBom) {
      this.emitBOM = true;
      this.encodingType = "Ansi";
      this.initBOM(includeBom);
    }
    Object.defineProperty(Encoding2.prototype, "includeBom", {
      /**
       * Gets a value indicating whether to write a Unicode byte order mark
       * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false
       */
      get: function() {
        return this.emitBOM;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Encoding2.prototype, "type", {
      /**
       * Gets the encoding type.
       * @returns EncodingType
       */
      get: function() {
        return this.encodingType;
      },
      /**
       * Sets the encoding type.
       * @param  {EncodingType} value
       */
      set: function(value) {
        this.encodingType = value;
      },
      enumerable: true,
      configurable: true
    });
    Encoding2.prototype.initBOM = function(includeBom) {
      if (includeBom === void 0 || includeBom === null) {
        this.emitBOM = true;
      } else {
        this.emitBOM = includeBom;
      }
    };
    Encoding2.prototype.getByteCount = function(chars) {
      var byteCount = 0;
      validateNullOrUndefined(chars, "string");
      if (chars === "") {
        var byte = this.utf8Len(chars.charCodeAt(0));
        return byte;
      }
      if (this.type === null || this.type === void 0) {
        this.type = "Ansi";
      }
      return this.getByteCountInternal(chars, 0, chars.length);
    };
    Encoding2.prototype.utf8Len = function(codePoint) {
      var bytes = codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : codePoint <= 2097151 ? 4 : 0;
      return bytes;
    };
    Encoding2.prototype.isHighSurrogate = function(codeUnit) {
      return codeUnit >= 55296 && codeUnit <= 56319;
    };
    Encoding2.prototype.toCodepoint = function(highCodeUnit, lowCodeUnit) {
      highCodeUnit = (1023 & highCodeUnit) << 10;
      var u = highCodeUnit | 1023 & lowCodeUnit;
      return u + 65536;
    };
    Encoding2.prototype.getByteCountInternal = function(chars, charIndex, charCount) {
      var byteCount = 0;
      if (this.encodingType === "Utf8" || this.encodingType === "Unicode") {
        var isUtf8 = this.encodingType === "Utf8";
        for (var i = 0; i < charCount; i++) {
          var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);
          if (this.isHighSurrogate(charCode)) {
            if (isUtf8) {
              var high = charCode;
              var low = chars.charCodeAt(++charIndex);
              byteCount += this.utf8Len(this.toCodepoint(high, low));
            } else {
              byteCount += 4;
              ++i;
            }
          } else {
            if (isUtf8) {
              byteCount += this.utf8Len(charCode);
            } else {
              byteCount += 2;
            }
          }
          if (isUtf8) {
            charIndex++;
          }
        }
        return byteCount;
      } else {
        byteCount = charCount;
        return byteCount;
      }
    };
    Encoding2.prototype.getBytes = function(s, charIndex, charCount) {
      validateNullOrUndefined(s, "string");
      validateNullOrUndefined(charIndex, "charIndex");
      validateNullOrUndefined(charCount, "charCount");
      if (charIndex < 0 || charCount < 0) {
        throw new RangeError("Argument Out Of Range Exception: charIndex or charCount is less than zero");
      }
      if (s.length - charIndex < charCount) {
        throw new RangeError("Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string");
      }
      var bytes;
      if (s === "") {
        bytes = new ArrayBuffer(0);
        return bytes;
      }
      if (this.type === null || this.type === void 0) {
        this.type = "Ansi";
      }
      var byteCount = this.getByteCountInternal(s, charIndex, charCount);
      switch (this.type) {
        case "Utf8":
          bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);
          return bytes;
        case "Unicode":
          bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);
          return bytes;
        default:
          bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);
          return bytes;
      }
    };
    Encoding2.prototype.getString = function(bytes, index, count) {
      validateNullOrUndefined(bytes, "bytes");
      validateNullOrUndefined(index, "index");
      validateNullOrUndefined(count, "count");
      if (index < 0 || count < 0) {
        throw new RangeError("Argument Out Of Range Exception: index or count is less than zero");
      }
      if (bytes.byteLength - index < count) {
        throw new RangeError("Argument Out Of Range Exception: index and count do not denote a valid range in bytes");
      }
      if (bytes.byteLength === 0 || count === 0) {
        return "";
      }
      if (this.type === null || this.type === void 0) {
        this.type = "Ansi";
      }
      var out = "";
      var byteCal = new Uint8Array(bytes);
      switch (this.type) {
        case "Utf8":
          var s = this.getStringOfUtf8Encoding(byteCal, index, count);
          return s;
        case "Unicode":
          var byteUnicode = new Uint16Array(bytes);
          out = this.getStringofUnicodeEncoding(byteUnicode, index, count);
          return out;
        default:
          var j = index;
          for (var i = 0; i < count; i++) {
            var c = byteCal[j];
            out += String.fromCharCode(c);
            j++;
          }
          return out;
      }
    };
    Encoding2.prototype.getBytesOfAnsiEncoding = function(byteCount, s, charIndex, charCount) {
      var bytes = new ArrayBuffer(byteCount);
      var bufview = new Uint8Array(bytes);
      var k = 0;
      for (var i = 0; i < charCount; i++) {
        var charcode = s.charCodeAt(charIndex++);
        if (charcode < 2048) {
          bufview[k] = charcode;
        } else {
          bufview[k] = 63;
        }
        k++;
      }
      return bytes;
    };
    Encoding2.prototype.getBytesOfUtf8Encoding = function(byteCount, s, charIndex, charCount) {
      var bytes = new ArrayBuffer(byteCount);
      var uint = new Uint8Array(bytes);
      var index = charIndex;
      var j = 0;
      for (var i = 0; i < charCount; i++) {
        var charcode = s.charCodeAt(index);
        if (charcode <= 127) {
          uint[j] = charcode;
        } else if (charcode < 2048) {
          uint[j] = 192 | charcode >> 6;
          uint[++j] = 128 | charcode & 63;
        } else if (charcode < 55296 || charcode >= 57344) {
          uint[j] = 224 | charcode >> 12;
          uint[++j] = 128 | charcode >> 6 & 63;
          uint[++j] = 128 | charcode & 63;
        } else {
          uint[j] = 239;
          uint[++j] = 191;
          uint[++j] = 189;
        }
        ++j;
        ++index;
      }
      return bytes;
    };
    Encoding2.prototype.getBytesOfUnicodeEncoding = function(byteCount, s, charIndex, charCount) {
      var bytes = new ArrayBuffer(byteCount);
      var uint16 = new Uint16Array(bytes);
      for (var i = 0; i < charCount; i++) {
        var charcode = s.charCodeAt(i);
        uint16[i] = charcode;
      }
      return bytes;
    };
    Encoding2.prototype.getStringOfUtf8Encoding = function(byteCal, index, count) {
      var j = 0;
      var i = index;
      var s = "";
      for (j; j < count; j++) {
        var c = byteCal[i++];
        while (i > byteCal.length) {
          return s;
        }
        if (c > 127) {
          if (c > 191 && c < 224 && i < count) {
            c = (c & 31) << 6 | byteCal[i] & 63;
          } else if (c > 223 && c < 240 && i < byteCal.byteLength) {
            c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;
          } else if (c > 239 && c < 248 && i < byteCal.byteLength) {
            c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;
          }
          ++i;
        }
        s += String.fromCharCode(c);
      }
      return s;
    };
    Encoding2.prototype.getStringofUnicodeEncoding = function(byteUni, index, count) {
      if (count > byteUni.length) {
        throw new RangeError("ArgumentOutOfRange_Count");
      }
      var byte16 = new Uint16Array(count);
      var out = "";
      for (var i = 0; i < count && i < byteUni.length; i++) {
        byte16[i] = byteUni[index++];
      }
      out = String.fromCharCode.apply(null, byte16);
      return out;
    };
    Encoding2.prototype.destroy = function() {
      this.emitBOM = void 0;
      this.encodingType = void 0;
    };
    return Encoding2;
  })()
);
function validateNullOrUndefined(value, message) {
  if (value === null || value === void 0) {
    throw new Error("ArgumentException: " + message + " cannot be null or undefined");
  }
}

// node_modules/@syncfusion/ej2-file-utils/src/stream-writer.js
var StreamWriter = (
  /** @class */
  (function() {
    function StreamWriter2(encoding) {
      this.bufferBlob = new Blob([""]);
      this.bufferText = "";
      this.init(encoding);
      Save.isMicrosoftBrowser = !!navigator.msSaveBlob;
    }
    Object.defineProperty(StreamWriter2.prototype, "buffer", {
      /**
       * Gets the content written to the StreamWriter as Blob.
       * @returns Blob
       */
      get: function() {
        this.flush();
        return this.bufferBlob;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(StreamWriter2.prototype, "encoding", {
      /**
       * Gets the encoding.
       * @returns Encoding
       */
      get: function() {
        return this.enc;
      },
      enumerable: true,
      configurable: true
    });
    StreamWriter2.prototype.init = function(encoding) {
      if (encoding === null || encoding === void 0) {
        this.enc = new Encoding(false);
        this.enc.type = "Utf8";
      } else {
        this.enc = encoding;
        this.setBomByte();
      }
    };
    StreamWriter2.prototype.setBomByte = function() {
      if (this.encoding.includeBom) {
        switch (this.encoding.type) {
          case "Unicode":
            var arrayUnicode = new ArrayBuffer(2);
            var uint8 = new Uint8Array(arrayUnicode);
            uint8[0] = 255;
            uint8[1] = 254;
            this.bufferBlob = new Blob([arrayUnicode]);
            break;
          case "Utf8":
            var arrayUtf8 = new ArrayBuffer(3);
            var utf8 = new Uint8Array(arrayUtf8);
            utf8[0] = 239;
            utf8[1] = 187;
            utf8[2] = 191;
            this.bufferBlob = new Blob([arrayUtf8]);
            break;
          default:
            this.bufferBlob = new Blob([""]);
            break;
        }
      }
    };
    StreamWriter2.prototype.save = function(fileName) {
      if (this.bufferText !== "") {
        this.flush();
      }
      Save.save(fileName, this.buffer);
    };
    StreamWriter2.prototype.write = function(value) {
      if (this.encoding === void 0) {
        throw new Error("Object Disposed Exception: current writer is disposed");
      }
      validateNullOrUndefined(value, "string");
      this.bufferText += value;
      if (this.bufferText.length >= 10240) {
        this.flush();
      }
    };
    StreamWriter2.prototype.flush = function() {
      if (this.bufferText === void 0 || this.bufferText === null || this.bufferText.length === 0) {
        return;
      }
      var bufferArray = this.encoding.getBytes(this.bufferText, 0, this.bufferText.length);
      this.bufferText = "";
      this.bufferBlob = new Blob([this.bufferBlob, bufferArray]);
    };
    StreamWriter2.prototype.writeLine = function(value) {
      if (this.encoding === void 0) {
        throw new Error("Object Disposed Exception: current writer is disposed");
      }
      validateNullOrUndefined(value, "string");
      this.bufferText = this.bufferText + value + "\r\n";
      if (this.bufferText.length >= 10240) {
        this.flush();
      }
    };
    StreamWriter2.prototype.destroy = function() {
      this.bufferBlob = void 0;
      this.bufferText = void 0;
      if (this.enc instanceof Encoding) {
        this.enc.destroy();
      }
      this.enc = void 0;
    };
    return StreamWriter2;
  })()
);

// node_modules/@syncfusion/ej2-compression/src/utils.js
var Utils = (
  /** @class */
  (function() {
    function Utils2() {
    }
    Utils2.bitReverse = function(value) {
      return Utils2.reverseBits[value & 15] << 12 | Utils2.reverseBits[value >> 4 & 15] << 8 | Utils2.reverseBits[value >> 8 & 15] << 4 | Utils2.reverseBits[value >> 12];
    };
    Utils2.bitConverterToInt32 = function(value, index) {
      return value[index] | value[index + 1] << 8 | value[index + 2] << 16 | value[index + 3] << 24;
    };
    Utils2.bitConverterToInt16 = function(value, index) {
      return value[index] | value[index + 1] << 8;
    };
    Utils2.bitConverterToUInt32 = function(value) {
      var uint = new Uint32Array(1);
      uint[0] = value;
      return uint[0];
    };
    Utils2.bitConverterToUInt16 = function(value, index) {
      var uint = new Uint16Array(1);
      uint[0] = value[index] | value[index + 1] << 8;
      return uint[0];
    };
    Utils2.bitConverterUintToInt32 = function(value) {
      var uint = new Int32Array(1);
      uint[0] = value;
      return uint[0];
    };
    Utils2.bitConverterInt32ToUint = function(value) {
      var uint = new Uint32Array(1);
      uint[0] = value;
      return uint[0];
    };
    Utils2.bitConverterInt32ToInt16 = function(value) {
      var uint = new Int16Array(1);
      uint[0] = value;
      return uint[0];
    };
    Utils2.byteToString = function(value) {
      var str = "";
      for (var i = 0; i < value.length; i++) {
        str += String.fromCharCode(value[i]);
      }
      return str;
    };
    Utils2.byteIntToString = function(value) {
      var str = "";
      for (var i = 0; i < value.length; i++) {
        str += String.fromCharCode(value[i]);
      }
      return str;
    };
    Utils2.arrayCopy = function(source, sourceIndex, destination, destinationIndex, dataToCopy) {
      var temp = new Uint8Array(source.buffer, sourceIndex);
      var data = temp.subarray(0, dataToCopy);
      destination.set(data, destinationIndex);
    };
    Utils2.mergeArray = function(arrayOne, arrayTwo) {
      var mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);
      mergedArray.set(arrayOne);
      mergedArray.set(arrayTwo, arrayOne.length);
      return mergedArray;
    };
    Utils2.encodedString = function(input) {
      var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var chr1;
      var chr2;
      var chr3;
      var encode1;
      var encode2;
      var encode3;
      var encode4;
      var count = 0;
      var resultIndex = 0;
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var totalLength = input.length * 3 / 4;
      if (input.charAt(input.length - 1) === keyStr.charAt(64)) {
        totalLength--;
      }
      if (input.charAt(input.length - 2) === keyStr.charAt(64)) {
        totalLength--;
      }
      if (totalLength % 1 !== 0) {
        throw new Error("Invalid base64 input, bad content length.");
      }
      var output = new Uint8Array(totalLength | 0);
      while (count < input.length) {
        encode1 = keyStr.indexOf(input.charAt(count++));
        encode2 = keyStr.indexOf(input.charAt(count++));
        encode3 = keyStr.indexOf(input.charAt(count++));
        encode4 = keyStr.indexOf(input.charAt(count++));
        chr1 = encode1 << 2 | encode2 >> 4;
        chr2 = (encode2 & 15) << 4 | encode3 >> 2;
        chr3 = (encode3 & 3) << 6 | encode4;
        output[resultIndex++] = chr1;
        if (encode3 !== 64) {
          output[resultIndex++] = chr2;
        }
        if (encode4 !== 64) {
          output[resultIndex++] = chr3;
        }
      }
      return output;
    };
    Utils2.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];
    Utils2.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    return Utils2;
  })()
);

// node_modules/@syncfusion/ej2-compression/src/zip-archive.js
var CRC32TABLE = [];
var INT_SIZE = 4;
var SHORT_SIZE = 2;
var CentralDirectoryEndSignature = 101010256;
var CentralDirSizeOffset = 12;
var CentralHeaderSignature = 33639248;
var BufferSize = 4096;
var ZipArchive = (
  /** @class */
  (function() {
    function ZipArchive2() {
      if (CRC32TABLE.length === 0) {
        ZipArchive2.initCrc32Table();
      }
      this.files = [];
      this.level = "Normal";
      Save.isMicrosoftBrowser = !!navigator.msSaveBlob;
    }
    Object.defineProperty(ZipArchive2.prototype, "items", {
      get: function() {
        return this.files;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ZipArchive2.prototype, "compressionLevel", {
      /**
       * gets compression level
       */
      get: function() {
        return this.level;
      },
      /**
       * sets compression level
       */
      set: function(level) {
        this.level = level;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ZipArchive2.prototype, "length", {
      /**
       * gets items count
       */
      get: function() {
        if (this.files === void 0) {
          return 0;
        }
        return this.files.length;
      },
      enumerable: true,
      configurable: true
    });
    ZipArchive2.prototype.addItem = function(item) {
      if (item === null || item === void 0) {
        throw new Error("ArgumentException: item cannot be null or undefined");
      }
      for (var i = 0; i < this.files.length; i++) {
        var file = this.files[i];
        if (file instanceof ZipArchiveItem) {
          if (file.name === item.name) {
            throw new Error("item with same name already exist");
          }
        }
      }
      this.files.push(item);
    };
    ZipArchive2.prototype.addDirectory = function(directoryName) {
      if (directoryName === null || directoryName === void 0) {
        throw new Error("ArgumentException: string cannot be null or undefined");
      }
      if (directoryName.length === 0) {
        throw new Error("ArgumentException: string cannot be empty");
      }
      if (directoryName.slice(-1) !== "/") {
        directoryName += "/";
      }
      if (this.files.indexOf(directoryName) !== -1) {
        throw new Error("item with same name already exist");
      }
      this.files.push(directoryName);
    };
    ZipArchive2.prototype.getItem = function(index) {
      if (index >= 0 && index < this.files.length) {
        return this.files[index];
      }
      return void 0;
    };
    ZipArchive2.prototype.contains = function(item) {
      return this.files.indexOf(item) !== -1 ? true : false;
    };
    ZipArchive2.prototype.open = function(base64String) {
      var zipArchive = this;
      var zipByteArray = Utils.encodedString(base64String);
      if (zipByteArray.length == 0)
        throw new DOMException("stream");
      var stream = new Stream(zipByteArray);
      var lCentralDirEndPosition = ZipArchive2.findValueFromEnd(stream, CentralDirectoryEndSignature, 65557);
      if (lCentralDirEndPosition < 0)
        throw new DOMException("Can't locate end of central directory record. Possible wrong file format or archive is corrupt.");
      stream.position = lCentralDirEndPosition + CentralDirSizeOffset;
      var iCentralDirSize = ZipArchive2.ReadInt32(stream);
      var lCentralDirPosition = lCentralDirEndPosition - iCentralDirSize;
      stream.position = lCentralDirPosition;
      this.readCentralDirectoryDataAndExtractItems(stream);
    };
    ZipArchive2.prototype.readCentralDirectoryDataAndExtractItems = function(stream) {
      if (stream == null)
        throw new DOMException("stream");
      var itemHelper;
      while (ZipArchive2.ReadInt32(stream) == CentralHeaderSignature) {
        itemHelper = new ZipArchiveItemHelper();
        itemHelper.readCentralDirectoryData(stream);
        itemHelper;
      }
      itemHelper.readData(stream, itemHelper.checkCrc);
      itemHelper.decompressData();
      this.files.push(new ZipArchiveItem(itemHelper.unCompressedStream.buffer, itemHelper.name));
    };
    ZipArchive2.prototype.save = function(fileName) {
      if (fileName === null || fileName === void 0 || fileName.length === 0) {
        throw new Error("ArgumentException: fileName cannot be null or undefined");
      }
      if (this.files.length === 0) {
        throw new Error("InvalidOperation");
      }
      var zipArchive = this;
      var promise;
      return promise = new Promise(function(resolve, reject) {
        zipArchive.saveInternal(fileName, false).then(function() {
          resolve(zipArchive);
        });
      });
    };
    ZipArchive2.prototype.saveAsBlob = function() {
      var zipArchive = this;
      var promise;
      return promise = new Promise(function(resolve, reject) {
        zipArchive.saveInternal("", true).then(function(blob) {
          resolve(blob);
        });
      });
    };
    ZipArchive2.prototype.saveInternal = function(fileName, skipFileSave) {
      var _this = this;
      var zipArchive = this;
      var promise;
      return promise = new Promise(function(resolve, reject) {
        var zipData = [];
        var dirLength = 0;
        for (var i = 0; i < zipArchive.files.length; i++) {
          var compressedObject = _this.getCompressedData(_this.files[i]);
          compressedObject.then(function(data) {
            dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);
            if (zipData.length === zipArchive.files.length) {
              var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);
              resolve(blob);
            }
          });
        }
      });
    };
    ZipArchive2.prototype.destroy = function() {
      if (this.files !== void 0 && this.files.length > 0) {
        for (var i = 0; i < this.files.length; i++) {
          var file = this.files[i];
          if (file instanceof ZipArchiveItem) {
            file.destroy();
          }
          file = void 0;
        }
        this.files = [];
      }
      this.files = void 0;
      this.level = void 0;
    };
    ZipArchive2.prototype.getCompressedData = function(item) {
      var zipArchive = this;
      var promise = new Promise(function(resolve, reject) {
        if (item instanceof ZipArchiveItem) {
          var reader_1 = new FileReader();
          reader_1.onload = function() {
            var input = new Uint8Array(reader_1.result);
            var data2 = {
              fileName: item.name,
              crc32Value: 0,
              compressedData: [],
              compressedSize: void 0,
              uncompressedDataSize: input.length,
              compressionType: void 0,
              isDirectory: false
            };
            if (zipArchive.level === "Normal") {
              zipArchive.compressData(input, data2, CRC32TABLE);
              var length_1 = 0;
              for (var i = 0; i < data2.compressedData.length; i++) {
                length_1 += data2.compressedData[i].length;
              }
              data2.compressedSize = length_1;
              data2.compressionType = "\b\0";
            } else {
              data2.compressedSize = input.length;
              data2.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);
              data2.compressionType = "\0\0";
              data2.compressedData.push(input);
            }
            resolve(data2);
          };
          reader_1.readAsArrayBuffer(item.data);
        } else {
          var data = {
            fileName: item,
            crc32Value: 0,
            compressedData: "",
            compressedSize: 0,
            uncompressedDataSize: 0,
            compressionType: "\0\0",
            isDirectory: true
          };
          resolve(data);
        }
      });
      return promise;
    };
    ZipArchive2.prototype.compressData = function(input, data, crc32Table) {
      var compressor = new CompressedStreamWriter(true);
      var currentIndex = 0;
      var nextIndex = 0;
      do {
        if (currentIndex >= input.length) {
          compressor.close();
          break;
        }
        nextIndex = Math.min(input.length, currentIndex + 16384);
        var subArray = input.subarray(currentIndex, nextIndex);
        data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);
        compressor.write(subArray, 0, nextIndex - currentIndex);
        currentIndex = nextIndex;
      } while (currentIndex <= input.length);
      data.compressedData = compressor.compressedData;
      compressor.destroy();
    };
    ZipArchive2.prototype.constructZippedObject = function(zipParts, data, dirLength, isDirectory) {
      var extFileAttr = 0;
      var date = /* @__PURE__ */ new Date();
      if (isDirectory) {
        extFileAttr = extFileAttr | 16;
      }
      extFileAttr = extFileAttr | 0 & 63;
      var header = this.writeHeader(data, date);
      var localHeader = "PK" + header + data.fileName;
      var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);
      zipParts.push({ localHeader, centralDir, compressedData: data });
      return dirLength + localHeader.length + data.compressedSize;
    };
    ZipArchive2.prototype.writeHeader = function(data, date) {
      var zipHeader = "";
      zipHeader += "\n\0\0\0";
      zipHeader += data.compressionType;
      zipHeader += this.getBytes(this.getModifiedTime(date), 2);
      zipHeader += this.getBytes(this.getModifiedDate(date), 2);
      zipHeader += this.getBytes(data.crc32Value, 4);
      zipHeader += this.getBytes(data.compressedSize, 4);
      zipHeader += this.getBytes(data.uncompressedDataSize, 4);
      zipHeader += this.getBytes(data.fileName.length, 2);
      zipHeader += this.getBytes(0, 2);
      return zipHeader;
    };
    ZipArchive2.prototype.writeZippedContent = function(fileName, zipData, localDirLen, skipFileSave) {
      var cenDirLen = 0;
      var buffer = [];
      for (var i = 0; i < zipData.length; i++) {
        var item = zipData[i];
        cenDirLen += item.centralDir.length;
        buffer.push(this.getArrayBuffer(item.localHeader));
        while (item.compressedData.compressedData.length) {
          buffer.push(item.compressedData.compressedData.shift().buffer);
        }
      }
      for (var i = 0; i < zipData.length; i++) {
        buffer.push(this.getArrayBuffer(zipData[i].centralDir));
      }
      buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));
      var blob = new Blob(buffer, { type: "application/zip" });
      if (!skipFileSave) {
        Save.save(fileName, blob);
      }
      return blob;
    };
    ZipArchive2.prototype.writeCentralDirectory = function(data, localHeader, offset, externalFileAttribute) {
      var directoryHeader = "PK" + this.getBytes(20, 2) + localHeader + // inherit from file header
      this.getBytes(0, 2) + // comment length
      "\0\0\0\0" + // internal file attributes 
      this.getBytes(externalFileAttribute, 4) + // external file attributes
      this.getBytes(offset, 4) + // local fileHeader relative offset
      data.fileName;
      return directoryHeader;
    };
    ZipArchive2.prototype.writeFooter = function(zipData, centralLength, localLength) {
      var dirEnd = "PK\0\0\0\0" + this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) + this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) + this.getBytes(0, 2);
      return dirEnd;
    };
    ZipArchive2.prototype.getArrayBuffer = function(input) {
      var a = new Uint8Array(input.length);
      for (var j = 0; j < input.length; ++j) {
        a[j] = input.charCodeAt(j) & 255;
      }
      return a.buffer;
    };
    ZipArchive2.prototype.getBytes = function(value, offset) {
      var bytes = "";
      for (var i = 0; i < offset; i++) {
        bytes += String.fromCharCode(value & 255);
        value = value >>> 8;
      }
      return bytes;
    };
    ZipArchive2.prototype.getModifiedTime = function(date) {
      var modTime = date.getHours();
      modTime = modTime << 6;
      modTime = modTime | date.getMinutes();
      modTime = modTime << 5;
      return modTime = modTime | date.getSeconds() / 2;
    };
    ZipArchive2.prototype.getModifiedDate = function(date) {
      var modiDate = date.getFullYear() - 1980;
      modiDate = modiDate << 4;
      modiDate = modiDate | date.getMonth() + 1;
      modiDate = modiDate << 5;
      return modiDate = modiDate | date.getDate();
    };
    ZipArchive2.prototype.calculateCrc32Value = function(crc32Value, input, crc32Table) {
      crc32Value ^= -1;
      for (var i = 0; i < input.length; i++) {
        crc32Value = crc32Value >>> 8 ^ crc32Table[(crc32Value ^ input[i]) & 255];
      }
      return crc32Value ^ -1;
    };
    ZipArchive2.initCrc32Table = function() {
      var i;
      for (var j = 0; j < 256; j++) {
        i = j;
        for (var k = 0; k < 8; k++) {
          i = i & 1 ? 3988292384 ^ i >>> 1 : i >>> 1;
        }
        CRC32TABLE[j] = i;
      }
    };
    ZipArchive2.findValueFromEnd = function(stream, value, maxCount) {
      if (stream == null)
        throw new DOMException("stream");
      var lStreamSize = stream.inputStream.buffer.byteLength;
      if (lStreamSize < 4)
        return -1;
      var arrBuffer = new Uint8Array(4);
      var lLastPos = Math.max(0, lStreamSize - maxCount);
      var lCurrentPosition = lStreamSize - 1 - INT_SIZE;
      stream.position = lCurrentPosition;
      stream.read(arrBuffer, 0, INT_SIZE);
      var uiCurValue = arrBuffer[0];
      var bFound = uiCurValue == value;
      if (!bFound) {
        while (lCurrentPosition > lLastPos) {
          uiCurValue <<= 8;
          lCurrentPosition--;
          stream.position = lCurrentPosition;
          uiCurValue += stream.readByte();
          if (uiCurValue == value) {
            bFound = true;
            break;
          }
        }
      }
      return bFound ? lCurrentPosition : -1;
    };
    ZipArchive2.ReadInt32 = function(stream) {
      var buffer = new Uint8Array(INT_SIZE);
      if (stream.read(buffer, 0, INT_SIZE) != INT_SIZE) {
        throw new DOMException("Unable to read value at the specified position - end of stream was reached.");
      }
      return Utils.bitConverterToInt32(buffer, 0);
    };
    ZipArchive2.ReadInt16 = function(stream) {
      var buffer = new Uint8Array(SHORT_SIZE);
      if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {
        throw new DOMException("Unable to read value at the specified position - end of stream was reached.");
      }
      return Utils.bitConverterToInt16(buffer, 0);
    };
    ZipArchive2.ReadUInt16 = function(stream) {
      {
        var buffer = new Uint8Array(SHORT_SIZE);
        if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {
          throw new DOMException("Unable to read value at the specified position - end of stream was reached.");
        }
        return Utils.bitConverterToInt16(buffer, 0);
      }
    };
    return ZipArchive2;
  })()
);
var ZipArchiveItemHelper = (
  /** @class */
  (function() {
    function ZipArchiveItemHelper2() {
      this.headerSignature = 67324752;
      this.checkCrc = true;
      this.crc32 = 0;
    }
    ZipArchiveItemHelper2.prototype.readCentralDirectoryData = function(stream) {
      stream.position += 4;
      this.options = ZipArchive.ReadInt16(stream);
      this.compressionMethod = ZipArchive.ReadInt16(stream);
      this.checkCrc = this.compressionMethod != 99;
      var lastModified = ZipArchive.ReadInt32(stream);
      this.crc32 = Utils.bitConverterToUInt32(ZipArchive.ReadInt32(stream));
      this.compressedSize = ZipArchive.ReadInt32(stream);
      this.originalSize = ZipArchive.ReadInt32(stream);
      var iFileNameLength = ZipArchive.ReadInt16(stream);
      var iExtraFieldLenth = ZipArchive.ReadInt16(stream);
      var iCommentLength = ZipArchive.ReadInt16(stream);
      stream.position += 4;
      this.externalAttributes = ZipArchive.ReadInt32(stream);
      this.localHeaderOffset = ZipArchive.ReadInt32(stream);
      var arrBuffer = new Uint8Array(iFileNameLength);
      stream.read(arrBuffer, 0, iFileNameLength);
      var m_strItemName = Utils.byteToString(arrBuffer);
      m_strItemName = m_strItemName.replace("\\", "/");
      this.name = m_strItemName;
      stream.position += iExtraFieldLenth + iCommentLength;
      if (this.options != 0)
        this.options = 0;
    };
    ZipArchiveItemHelper2.prototype.readData = function(stream, checkCrc) {
      if (stream.length == 0)
        throw new DOMException("stream");
      stream.position = this.localHeaderOffset;
      this.checkCrc = checkCrc;
      this.readLocalHeader(stream);
      this.readCompressedData(stream);
    };
    ZipArchiveItemHelper2.prototype.decompressData = function() {
      if (this.compressionMethod == 8) {
        if (this.originalSize > 0) {
          this.decompressDataOld();
        }
      }
    };
    ZipArchiveItemHelper2.prototype.decompressDataOld = function() {
      var reader = new CompressedStreamReader(this.compressedStream, true);
      var decompressedData;
      if (this.originalSize > 0)
        decompressedData = new Stream(new Uint8Array(this.originalSize));
      var arrBuffer = new Uint8Array(BufferSize);
      var iReadBytes;
      var past = new Uint8Array(0);
      while ((iReadBytes = reader.read(arrBuffer, 0, BufferSize)) > 0) {
        decompressedData.write(arrBuffer.subarray(0, iReadBytes), 0, iReadBytes);
      }
      this.unCompressedStream = decompressedData.toByteArray();
      if (this.checkCrc) {
      }
    };
    ZipArchiveItemHelper2.prototype.readLocalHeader = function(stream) {
      if (stream.length == 0)
        throw new DOMException("stream");
      if (ZipArchive.ReadInt32(stream) != this.headerSignature)
        throw new DOMException("Can't find local header signature - wrong file format or file is corrupt.");
      stream.position += 22;
      var iNameLength = ZipArchive.ReadInt16(stream);
      var iExtraLength = ZipArchive.ReadUInt16(stream);
      if (this.compressionMethod == 99) {
      } else if (iExtraLength > 2) {
        stream.position += iNameLength;
        var headerVal = ZipArchive.ReadInt16(stream);
        if (headerVal == 23)
          throw new DOMException("UnSupported");
        else
          stream.position += iExtraLength - 2;
      } else
        stream.position += iNameLength + iExtraLength;
    };
    ZipArchiveItemHelper2.prototype.readCompressedData = function(stream) {
      var dataStream;
      if (this.compressedSize > 0) {
        var iBytesLeft = this.compressedSize;
        dataStream = new Stream(new Uint8Array(iBytesLeft));
        var arrBuffer = new Uint8Array(BufferSize);
        while (iBytesLeft > 0) {
          var iBytesToRead = Math.min(iBytesLeft, BufferSize);
          if (stream.read(arrBuffer, 0, iBytesToRead) != iBytesToRead)
            throw new DOMException("End of file reached - wrong file format or file is corrupt.");
          dataStream.write(arrBuffer.subarray(0, iBytesToRead), 0, iBytesToRead);
          iBytesLeft -= iBytesToRead;
        }
        this.compressedStream = new Uint8Array(dataStream.inputStream);
      } else if (this.compressedSize < 0) {
      } else if (this.compressedSize == 0) {
      }
    };
    return ZipArchiveItemHelper2;
  })()
);
var ZipArchiveItem = (
  /** @class */
  (function() {
    function ZipArchiveItem2(data, itemName) {
      if (data === null || data === void 0) {
        throw new Error("ArgumentException: data cannot be null or undefined");
      }
      if (itemName === null || itemName === void 0) {
        throw new Error("ArgumentException: string cannot be null or undefined");
      }
      if (itemName.length === 0) {
        throw new Error("string cannot be empty");
      }
      this.data = data;
      this.name = itemName;
    }
    Object.defineProperty(ZipArchiveItem2.prototype, "dataStream", {
      get: function() {
        return this.decompressedStream;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ZipArchiveItem2.prototype, "name", {
      /**
       * Get the name of archive item
       * @returns string
       */
      get: function() {
        return this.fileName;
      },
      /**
       * Set the name of archive item
       * @param  {string} value
       */
      set: function(value) {
        this.fileName = value;
      },
      enumerable: true,
      configurable: true
    });
    ZipArchiveItem2.prototype.destroy = function() {
      this.fileName = void 0;
      this.data = void 0;
    };
    return ZipArchiveItem2;
  })()
);

// node_modules/@syncfusion/ej2-compression/src/compression-writer.js
var ARR_LITERAL_CODES = new Int16Array(286);
var ARR_LITERAL_LENGTHS = new Uint8Array(286);
var ARR_DISTANCE_CODES = new Int16Array(30);
var ARR_DISTANCE_LENGTHS = new Uint8Array(30);
var CompressedStreamWriter = (
  /** @class */
  (function() {
    function CompressedStreamWriter2(noWrap) {
      this.pendingBuffer = new Uint8Array(1 << 16);
      this.pendingBufLength = 0;
      this.pendingBufCache = 0;
      this.pendingBufBitsInCache = 0;
      this.bufferPosition = 0;
      this.extraBits = 0;
      this.currentHash = 0;
      this.matchStart = 0;
      this.matchLength = 0;
      this.matchPrevAvail = false;
      this.blockStart = 0;
      this.stringStart = 0;
      this.lookAhead = 0;
      this.totalBytesIn = 0;
      this.inputOffset = 0;
      this.inputEnd = 0;
      this.windowSize = 1 << 15;
      this.windowMask = this.windowSize - 1;
      this.hashSize = 1 << 15;
      this.hashMask = this.hashSize - 1;
      this.hashShift = Math.floor((15 + 3 - 1) / 3);
      this.maxDist = this.windowSize - 262;
      this.checkSum = 1;
      this.noWrap = false;
      if (!CompressedStreamWriter2.isHuffmanTreeInitiated) {
        CompressedStreamWriter2.initHuffmanTree();
        CompressedStreamWriter2.isHuffmanTreeInitiated = true;
      }
      this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);
      this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);
      this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);
      this.arrDistances = new Uint16Array(1 << 14);
      this.arrLiterals = new Uint8Array(1 << 14);
      this.stream = [];
      this.dataWindow = new Uint8Array(2 * this.windowSize);
      this.hashHead = new Int16Array(this.hashSize);
      this.hashPrevious = new Int16Array(this.windowSize);
      this.blockStart = this.stringStart = 1;
      this.noWrap = noWrap;
      if (!noWrap) {
        this.writeZLibHeader();
      }
    }
    Object.defineProperty(CompressedStreamWriter2.prototype, "compressedData", {
      /**
       * get compressed data
       */
      get: function() {
        return this.stream;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompressedStreamWriter2.prototype, "getCompressedString", {
      get: function() {
        var compressedString = "";
        if (this.stream !== void 0) {
          for (var i = 0; i < this.stream.length; i++) {
            compressedString += String.fromCharCode.apply(null, this.stream[i]);
          }
        }
        return compressedString;
      },
      enumerable: true,
      configurable: true
    });
    CompressedStreamWriter2.prototype.write = function(data, offset, length) {
      if (data === void 0 || data === null) {
        throw new Error("ArgumentException: data cannot null or undefined");
      }
      var end = offset + length;
      if (0 > offset || offset > end || end > data.length) {
        throw new Error("ArgumentOutOfRangeException: Offset or length is incorrect");
      }
      if (typeof data === "string") {
        var encode = new Encoding(false);
        encode.type = "Utf8";
        data = new Uint8Array(encode.getBytes(data, 0, data.length));
        end = offset + data.length;
      }
      this.inputBuffer = data;
      this.inputOffset = offset;
      this.inputEnd = end;
      if (!this.noWrap) {
        this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);
      }
      while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {
        this.pendingBufferFlush();
        this.compressData(false);
      }
    };
    CompressedStreamWriter2.prototype.writeZLibHeader = function() {
      var headerDate = 8 + (7 << 4) << 8;
      headerDate |= (5 >> 2 & 3) << 6;
      headerDate += 31 - headerDate % 31;
      this.pendingBufferWriteShortBytes(headerDate);
    };
    CompressedStreamWriter2.prototype.pendingBufferWriteShortBytes = function(s) {
      this.pendingBuffer[this.pendingBufLength++] = s >> 8;
      this.pendingBuffer[this.pendingBufLength++] = s;
    };
    CompressedStreamWriter2.prototype.compressData = function(finish) {
      var success;
      do {
        this.fillWindow();
        var canFlush = finish && this.inputEnd === this.inputOffset;
        success = this.compressSlow(canFlush, finish);
      } while (this.pendingBufLength === 0 && success);
      return success;
    };
    CompressedStreamWriter2.prototype.compressSlow = function(flush, finish) {
      if (this.lookAhead < 262 && !flush) {
        return false;
      }
      while (this.lookAhead >= 262 || flush) {
        if (this.lookAhead === 0) {
          return this.lookAheadCompleted(finish);
        }
        if (this.stringStart >= 2 * this.windowSize - 262) {
          this.slideWindow();
        }
        var prevMatch = this.matchStart;
        var prevLen = this.matchLength;
        if (this.lookAhead >= 3) {
          this.discardMatch();
        }
        if (prevLen >= 3 && this.matchLength <= prevLen) {
          prevLen = this.matchPreviousBest(prevMatch, prevLen);
        } else {
          this.matchPreviousAvailable();
        }
        if (this.bufferPosition >= 1 << 14) {
          return this.huffmanIsFull(finish);
        }
      }
      return true;
    };
    CompressedStreamWriter2.prototype.discardMatch = function() {
      var hashHead = this.insertString();
      if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {
        if (this.matchLength <= 5 && (this.matchLength === 3 && this.stringStart - this.matchStart > 4096)) {
          this.matchLength = 3 - 1;
        }
      }
    };
    CompressedStreamWriter2.prototype.matchPreviousAvailable = function() {
      if (this.matchPrevAvail) {
        this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 255);
      }
      this.matchPrevAvail = true;
      this.stringStart++;
      this.lookAhead--;
    };
    CompressedStreamWriter2.prototype.matchPreviousBest = function(prevMatch, prevLen) {
      this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);
      prevLen -= 2;
      do {
        this.stringStart++;
        this.lookAhead--;
        if (this.lookAhead >= 3) {
          this.insertString();
        }
      } while (--prevLen > 0);
      this.stringStart++;
      this.lookAhead--;
      this.matchPrevAvail = false;
      this.matchLength = 3 - 1;
      return prevLen;
    };
    CompressedStreamWriter2.prototype.lookAheadCompleted = function(finish) {
      if (this.matchPrevAvail) {
        this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 255);
      }
      this.matchPrevAvail = false;
      this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);
      this.blockStart = this.stringStart;
      return false;
    };
    CompressedStreamWriter2.prototype.huffmanIsFull = function(finish) {
      var len = this.stringStart - this.blockStart;
      if (this.matchPrevAvail) {
        len--;
      }
      var lastBlock = finish && this.lookAhead === 0 && !this.matchPrevAvail;
      this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);
      this.blockStart += len;
      return !lastBlock;
    };
    CompressedStreamWriter2.prototype.fillWindow = function() {
      if (this.stringStart >= this.windowSize + this.maxDist) {
        this.slideWindow();
      }
      while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {
        var more = 2 * this.windowSize - this.lookAhead - this.stringStart;
        if (more > this.inputEnd - this.inputOffset) {
          more = this.inputEnd - this.inputOffset;
        }
        this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);
        this.inputOffset += more;
        this.totalBytesIn += more;
        this.lookAhead += more;
      }
      if (this.lookAhead >= 3) {
        this.updateHash();
      }
    };
    CompressedStreamWriter2.prototype.slideWindow = function() {
      this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);
      this.matchStart -= this.windowSize;
      this.stringStart -= this.windowSize;
      this.blockStart -= this.windowSize;
      for (var i = 0; i < this.hashSize; ++i) {
        var m = this.hashHead[i] & 65535;
        this.hashHead[i] = m >= this.windowSize ? m - this.windowSize : 0;
      }
      for (var i = 0; i < this.windowSize; i++) {
        var m = this.hashPrevious[i] & 65535;
        this.hashPrevious[i] = m >= this.windowSize ? m - this.windowSize : 0;
      }
    };
    CompressedStreamWriter2.prototype.insertString = function() {
      var match;
      var hash = (this.currentHash << this.hashShift ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;
      this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];
      this.hashHead[hash] = this.stringStart;
      this.currentHash = hash;
      return match & 65535;
    };
    CompressedStreamWriter2.prototype.findLongestMatch = function(curMatch) {
      var chainLen = 4096;
      var niceLen = 258;
      var scan = this.stringStart;
      var match;
      var bestEnd = this.stringStart + this.matchLength;
      var bestLength = Math.max(this.matchLength, 3 - 1);
      var limit = Math.max(this.stringStart - this.maxDist, 0);
      var stringEnd = this.stringStart + 258 - 1;
      var scanEnd1 = this.dataWindow[bestEnd - 1];
      var scanEnd = this.dataWindow[bestEnd];
      var data = this.dataWindow;
      if (bestLength >= 32) {
        chainLen >>= 2;
      }
      if (niceLen > this.lookAhead) {
        niceLen = this.lookAhead;
      }
      do {
        if (data[curMatch + bestLength] !== scanEnd || data[curMatch + bestLength - 1] !== scanEnd1 || data[curMatch] !== data[scan] || data[curMatch + 1] !== data[scan + 1]) {
          continue;
        }
        match = curMatch + 2;
        scan += 2;
        while (data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {
        }
        if (scan > bestEnd) {
          this.matchStart = curMatch;
          bestEnd = scan;
          bestLength = scan - this.stringStart;
          if (bestLength >= niceLen) {
            break;
          }
          scanEnd1 = data[bestEnd - 1];
          scanEnd = data[bestEnd];
        }
        scan = this.stringStart;
      } while ((curMatch = this.hashPrevious[curMatch & this.windowMask] & 65535) > limit && --chainLen !== 0);
      this.matchLength = Math.min(bestLength, this.lookAhead);
      return this.matchLength >= 3;
    };
    CompressedStreamWriter2.prototype.updateHash = function() {
      this.currentHash = this.dataWindow[this.stringStart] << this.hashShift ^ this.dataWindow[this.stringStart + 1];
    };
    CompressedStreamWriter2.prototype.huffmanTallyLit = function(literal) {
      this.arrDistances[this.bufferPosition] = 0;
      this.arrLiterals[this.bufferPosition++] = literal;
      this.treeLiteral.codeFrequencies[literal]++;
      return this.bufferPosition >= 1 << 14;
    };
    CompressedStreamWriter2.prototype.huffmanTallyDist = function(dist, len) {
      this.arrDistances[this.bufferPosition] = dist;
      this.arrLiterals[this.bufferPosition++] = len - 3;
      var lc = this.huffmanLengthCode(len - 3);
      this.treeLiteral.codeFrequencies[lc]++;
      if (lc >= 265 && lc < 285) {
        this.extraBits += Math.floor((lc - 261) / 4);
      }
      var dc = this.huffmanDistanceCode(dist - 1);
      this.treeDistances.codeFrequencies[dc]++;
      if (dc >= 4) {
        this.extraBits += Math.floor(dc / 2 - 1);
      }
      return this.bufferPosition >= 1 << 14;
    };
    CompressedStreamWriter2.prototype.huffmanFlushBlock = function(stored, storedOffset, storedLength, lastBlock) {
      this.treeLiteral.codeFrequencies[256]++;
      this.treeLiteral.buildTree();
      this.treeDistances.buildTree();
      this.treeLiteral.calculateBLFreq(this.treeCodeLengths);
      this.treeDistances.calculateBLFreq(this.treeCodeLengths);
      this.treeCodeLengths.buildTree();
      var blTreeCodes = 4;
      for (var i = 18; i > blTreeCodes; i--) {
        if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {
          blTreeCodes = i + 1;
        }
      }
      var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() + this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;
      var static_len = this.extraBits;
      for (var i = 0; i < 286; i++) {
        static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];
      }
      for (var i = 0; i < 30; i++) {
        static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];
      }
      if (opt_len >= static_len) {
        opt_len = static_len;
      }
      if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {
        this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);
      } else if (opt_len == static_len) {
        this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);
        this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);
        this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);
        this.huffmanCompressBlock();
        this.huffmanReset();
      } else {
        this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);
        this.huffmanSendAllTrees(blTreeCodes);
        this.huffmanCompressBlock();
        this.huffmanReset();
      }
    };
    CompressedStreamWriter2.prototype.huffmanFlushStoredBlock = function(stored, storedOffset, storedLength, lastBlock) {
      this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);
      this.pendingBufferAlignToByte();
      this.pendingBufferWriteShort(storedLength);
      this.pendingBufferWriteShort(~storedLength);
      this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);
      this.huffmanReset();
    };
    CompressedStreamWriter2.prototype.huffmanLengthCode = function(len) {
      if (len === 255) {
        return 285;
      }
      var code = 257;
      while (len >= 8) {
        code += 4;
        len >>= 1;
      }
      return code + len;
    };
    CompressedStreamWriter2.prototype.huffmanDistanceCode = function(distance) {
      var code = 0;
      while (distance >= 4) {
        code += 2;
        distance >>= 1;
      }
      return code + distance;
    };
    CompressedStreamWriter2.prototype.huffmanSendAllTrees = function(blTreeCodes) {
      this.treeCodeLengths.buildCodes();
      this.treeLiteral.buildCodes();
      this.treeDistances.buildCodes();
      this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);
      this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);
      this.pendingBufferWriteBits(blTreeCodes - 4, 4);
      for (var rank = 0; rank < blTreeCodes; rank++) {
        this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);
      }
      this.treeLiteral.writeTree(this.treeCodeLengths);
      this.treeDistances.writeTree(this.treeCodeLengths);
    };
    CompressedStreamWriter2.prototype.huffmanReset = function() {
      this.bufferPosition = 0;
      this.extraBits = 0;
      this.treeLiteral.reset();
      this.treeDistances.reset();
      this.treeCodeLengths.reset();
    };
    CompressedStreamWriter2.prototype.huffmanCompressBlock = function() {
      for (var i = 0; i < this.bufferPosition; i++) {
        var literalLen = this.arrLiterals[i] & 255;
        var dist = this.arrDistances[i];
        if (dist-- !== 0) {
          var lc = this.huffmanLengthCode(literalLen);
          this.treeLiteral.writeCodeToStream(lc);
          var bits = Math.floor((lc - 261) / 4);
          if (bits > 0 && bits <= 5) {
            this.pendingBufferWriteBits(literalLen & (1 << bits) - 1, bits);
          }
          var dc = this.huffmanDistanceCode(dist);
          this.treeDistances.writeCodeToStream(dc);
          bits = Math.floor(dc / 2 - 1);
          if (bits > 0) {
            this.pendingBufferWriteBits(dist & (1 << bits) - 1, bits);
          }
        } else {
          this.treeLiteral.writeCodeToStream(literalLen);
        }
      }
      this.treeLiteral.writeCodeToStream(256);
    };
    CompressedStreamWriter2.prototype.pendingBufferWriteBits = function(b, count) {
      var uint = new Uint32Array(1);
      uint[0] = this.pendingBufCache | b << this.pendingBufBitsInCache;
      this.pendingBufCache = uint[0];
      this.pendingBufBitsInCache += count;
      this.pendingBufferFlushBits();
    };
    CompressedStreamWriter2.prototype.pendingBufferFlush = function(isClose) {
      this.pendingBufferFlushBits();
      if (this.pendingBufLength > 0) {
        var array = new Uint8Array(this.pendingBufLength);
        array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);
        this.stream.push(array);
      }
      this.pendingBufLength = 0;
    };
    CompressedStreamWriter2.prototype.pendingBufferFlushBits = function() {
      var result = 0;
      while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < 1 << 16) {
        this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;
        this.pendingBufCache >>= 8;
        this.pendingBufBitsInCache -= 8;
        result++;
      }
      return result;
    };
    CompressedStreamWriter2.prototype.pendingBufferWriteByteBlock = function(data, offset, length) {
      var array = data.subarray(offset, offset + length);
      this.pendingBuffer.set(array, this.pendingBufLength);
      this.pendingBufLength += length;
    };
    CompressedStreamWriter2.prototype.pendingBufferWriteShort = function(s) {
      this.pendingBuffer[this.pendingBufLength++] = s;
      this.pendingBuffer[this.pendingBufLength++] = s >> 8;
    };
    CompressedStreamWriter2.prototype.pendingBufferAlignToByte = function() {
      if (this.pendingBufBitsInCache > 0) {
        this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;
      }
      this.pendingBufCache = 0;
      this.pendingBufBitsInCache = 0;
    };
    CompressedStreamWriter2.initHuffmanTree = function() {
      var i = 0;
      while (i < 144) {
        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(48 + i << 8);
        ARR_LITERAL_LENGTHS[i++] = 8;
      }
      while (i < 256) {
        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(400 - 144 + i << 7);
        ARR_LITERAL_LENGTHS[i++] = 9;
      }
      while (i < 280) {
        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0 - 256 + i << 9);
        ARR_LITERAL_LENGTHS[i++] = 7;
      }
      while (i < 286) {
        ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(192 - 280 + i << 8);
        ARR_LITERAL_LENGTHS[i++] = 8;
      }
      for (i = 0; i < 30; i++) {
        ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);
        ARR_DISTANCE_LENGTHS[i] = 5;
      }
    };
    CompressedStreamWriter2.prototype.close = function() {
      do {
        this.pendingBufferFlush(true);
        if (!this.compressData(true)) {
          this.pendingBufferFlush(true);
          this.pendingBufferAlignToByte();
          if (!this.noWrap) {
            this.pendingBufferWriteShortBytes(this.checkSum >> 16);
            this.pendingBufferWriteShortBytes(this.checkSum & 65535);
          }
          this.pendingBufferFlush(true);
        }
      } while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0));
    };
    CompressedStreamWriter2.prototype.destroy = function() {
      this.stream = [];
      this.stream = void 0;
      this.pendingBuffer = void 0;
      this.treeLiteral = void 0;
      this.treeDistances = void 0;
      this.treeCodeLengths = void 0;
      this.arrLiterals = void 0;
      this.arrDistances = void 0;
      this.hashHead = void 0;
      this.hashPrevious = void 0;
      this.dataWindow = void 0;
      this.inputBuffer = void 0;
      this.pendingBufLength = void 0;
      this.pendingBufCache = void 0;
      this.pendingBufBitsInCache = void 0;
      this.bufferPosition = void 0;
      this.extraBits = void 0;
      this.currentHash = void 0;
      this.matchStart = void 0;
      this.matchLength = void 0;
      this.matchPrevAvail = void 0;
      this.blockStart = void 0;
      this.stringStart = void 0;
      this.lookAhead = void 0;
      this.totalBytesIn = void 0;
      this.inputOffset = void 0;
      this.inputEnd = void 0;
      this.windowSize = void 0;
      this.windowMask = void 0;
      this.hashSize = void 0;
      this.hashMask = void 0;
      this.hashShift = void 0;
      this.maxDist = void 0;
      this.checkSum = void 0;
      this.noWrap = void 0;
    };
    CompressedStreamWriter2.isHuffmanTreeInitiated = false;
    return CompressedStreamWriter2;
  })()
);
var CompressorHuffmanTree = (
  /** @class */
  (function() {
    function CompressorHuffmanTree2(writer, elementCount, minCodes, maxLength) {
      this.writer = writer;
      this.codeMinCount = minCodes;
      this.maxLength = maxLength;
      this.codeFrequency = new Uint16Array(elementCount);
      this.lengthCount = new Int32Array(maxLength);
    }
    Object.defineProperty(CompressorHuffmanTree2.prototype, "treeLength", {
      get: function() {
        return this.codeCount;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompressorHuffmanTree2.prototype, "codeLengths", {
      get: function() {
        return this.codeLength;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(CompressorHuffmanTree2.prototype, "codeFrequencies", {
      get: function() {
        return this.codeFrequency;
      },
      enumerable: true,
      configurable: true
    });
    CompressorHuffmanTree2.prototype.setStaticCodes = function(codes, lengths) {
      var temp = new Int16Array(codes.length);
      temp.set(codes, 0);
      this.codes = temp;
      var lengthTemp = new Uint8Array(lengths.length);
      lengthTemp.set(lengths, 0);
      this.codeLength = lengthTemp;
    };
    CompressorHuffmanTree2.prototype.reset = function() {
      for (var i = 0; i < this.codeFrequency.length; i++) {
        this.codeFrequency[i] = 0;
      }
      this.codes = void 0;
      this.codeLength = void 0;
    };
    CompressorHuffmanTree2.prototype.writeCodeToStream = function(code) {
      this.writer.pendingBufferWriteBits(this.codes[code] & 65535, this.codeLength[code]);
    };
    CompressorHuffmanTree2.prototype.buildCodes = function() {
      var nextCode = new Int32Array(this.maxLength);
      this.codes = new Int16Array(this.codeCount);
      var code = 0;
      for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {
        nextCode[bitsCount] = code;
        code += this.lengthCount[bitsCount] << 15 - bitsCount;
      }
      for (var i = 0; i < this.codeCount; i++) {
        var bits = this.codeLength[i];
        if (bits > 0) {
          this.codes[i] = CompressorHuffmanTree2.bitReverse(nextCode[bits - 1]);
          nextCode[bits - 1] += 1 << 16 - bits;
        }
      }
    };
    CompressorHuffmanTree2.bitReverse = function(value) {
      return CompressorHuffmanTree2.reverseBits[value & 15] << 12 | CompressorHuffmanTree2.reverseBits[value >> 4 & 15] << 8 | CompressorHuffmanTree2.reverseBits[value >> 8 & 15] << 4 | CompressorHuffmanTree2.reverseBits[value >> 12];
    };
    CompressorHuffmanTree2.prototype.getEncodedLength = function() {
      var len = 0;
      for (var i = 0; i < this.codeFrequency.length; i++) {
        len += this.codeFrequency[i] * this.codeLength[i];
      }
      return len;
    };
    CompressorHuffmanTree2.prototype.calculateBLFreq = function(blTree) {
      var maxCount;
      var minCount;
      var count;
      var curLen = -1;
      var i = 0;
      while (i < this.codeCount) {
        count = 1;
        var nextLen = this.codeLength[i];
        if (nextLen === 0) {
          maxCount = 138;
          minCount = 3;
        } else {
          maxCount = 6;
          minCount = 3;
          if (curLen !== nextLen) {
            blTree.codeFrequency[nextLen]++;
            count = 0;
          }
        }
        curLen = nextLen;
        i++;
        while (i < this.codeCount && curLen === this.codeLength[i]) {
          i++;
          if (++count >= maxCount) {
            break;
          }
        }
        if (count < minCount) {
          blTree.codeFrequency[curLen] += count;
        } else if (curLen !== 0) {
          blTree.codeFrequency[16]++;
        } else if (count <= 10) {
          blTree.codeFrequency[17]++;
        } else {
          blTree.codeFrequency[18]++;
        }
      }
    };
    CompressorHuffmanTree2.prototype.writeTree = function(blTree) {
      var maxRepeatCount;
      var minRepeatCount;
      var currentRepeatCount;
      var currentCodeLength = -1;
      var i = 0;
      while (i < this.codeCount) {
        currentRepeatCount = 1;
        var nextLen = this.codeLength[i];
        if (nextLen === 0) {
          maxRepeatCount = 138;
          minRepeatCount = 3;
        } else {
          maxRepeatCount = 6;
          minRepeatCount = 3;
          if (currentCodeLength !== nextLen) {
            blTree.writeCodeToStream(nextLen);
            currentRepeatCount = 0;
          }
        }
        currentCodeLength = nextLen;
        i++;
        while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {
          i++;
          if (++currentRepeatCount >= maxRepeatCount) {
            break;
          }
        }
        if (currentRepeatCount < minRepeatCount) {
          while (currentRepeatCount-- > 0) {
            blTree.writeCodeToStream(currentCodeLength);
          }
        } else if (currentCodeLength !== 0) {
          blTree.writeCodeToStream(16);
          this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);
        } else if (currentRepeatCount <= 10) {
          blTree.writeCodeToStream(17);
          this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);
        } else {
          blTree.writeCodeToStream(18);
          this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);
        }
      }
    };
    CompressorHuffmanTree2.prototype.buildTree = function() {
      var codesCount = this.codeFrequency.length;
      var arrTree = new Int32Array(codesCount);
      var treeLength = 0;
      var maxCount = 0;
      for (var n = 0; n < codesCount; n++) {
        var freq = this.codeFrequency[n];
        if (freq !== 0) {
          var pos = treeLength++;
          var pPos = 0;
          while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {
            arrTree[pos] = arrTree[pPos];
            pos = pPos;
          }
          arrTree[pos] = n;
          maxCount = n;
        }
      }
      while (treeLength < 2) {
        arrTree[treeLength++] = maxCount < 2 ? ++maxCount : 0;
      }
      this.codeCount = Math.max(maxCount + 1, this.codeMinCount);
      var leafsCount = treeLength;
      var nodesCount = leafsCount;
      var child = new Int32Array(4 * treeLength - 2);
      var values = new Int32Array(2 * treeLength - 1);
      for (var i = 0; i < treeLength; i++) {
        var node = arrTree[i];
        var iIndex = 2 * i;
        child[iIndex] = node;
        child[iIndex + 1] = -1;
        values[i] = this.codeFrequency[node] << 8;
        arrTree[i] = i;
      }
      this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);
      this.buildLength(child);
    };
    CompressorHuffmanTree2.prototype.constructHuffmanTree = function(arrTree, treeLength, values, nodesCount, child) {
      do {
        var first = arrTree[0];
        var last = arrTree[--treeLength];
        var lastVal = values[last];
        var pPos = 0;
        var path = 1;
        while (path < treeLength) {
          if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {
            path++;
          }
          arrTree[pPos] = arrTree[path];
          pPos = path;
          path = pPos * 2 + 1;
        }
        while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {
          arrTree[path] = arrTree[pPos];
        }
        arrTree[path] = last;
        var second = arrTree[0];
        last = nodesCount++;
        child[2 * last] = first;
        child[2 * last + 1] = second;
        var minDepth = Math.min(values[first] & 255, values[second] & 255);
        values[last] = lastVal = values[first] + values[second] - minDepth + 1;
        pPos = 0;
        path = 1;
        while (path < treeLength) {
          if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {
            path++;
          }
          arrTree[pPos] = arrTree[path];
          pPos = path;
          path = pPos * 2 + 1;
        }
        while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {
          arrTree[path] = arrTree[pPos];
        }
        arrTree[path] = last;
      } while (treeLength > 1);
    };
    CompressorHuffmanTree2.prototype.buildLength = function(child) {
      this.codeLength = new Uint8Array(this.codeFrequency.length);
      var numNodes = Math.floor(child.length / 2);
      var numLeafs = Math.floor((numNodes + 1) / 2);
      var overflow = 0;
      for (var i = 0; i < this.maxLength; i++) {
        this.lengthCount[i] = 0;
      }
      overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);
      if (overflow === 0) {
        return;
      }
      var iIncreasableLength = this.maxLength - 1;
      do {
        while (this.lengthCount[--iIncreasableLength] === 0) {
        }
        do {
          this.lengthCount[iIncreasableLength]--;
          this.lengthCount[++iIncreasableLength]++;
          overflow -= 1 << this.maxLength - 1 - iIncreasableLength;
        } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);
      } while (overflow > 0);
      this.recreateTree(child, overflow, numLeafs);
    };
    CompressorHuffmanTree2.prototype.recreateTree = function(child, overflow, numLeafs) {
      this.lengthCount[this.maxLength - 1] += overflow;
      this.lengthCount[this.maxLength - 2] -= overflow;
      var nodePtr = 2 * numLeafs;
      for (var bits = this.maxLength; bits !== 0; bits--) {
        var n = this.lengthCount[bits - 1];
        while (n > 0) {
          var childPtr = 2 * child[nodePtr++];
          if (child[childPtr + 1] === -1) {
            this.codeLength[child[childPtr]] = bits;
            n--;
          }
        }
      }
    };
    CompressorHuffmanTree2.prototype.calculateOptimalCodeLength = function(child, overflow, numNodes) {
      var lengths = new Int32Array(numNodes);
      lengths[numNodes - 1] = 0;
      for (var i = numNodes - 1; i >= 0; i--) {
        var childIndex = 2 * i + 1;
        if (child[childIndex] !== -1) {
          var bitLength = lengths[i] + 1;
          if (bitLength > this.maxLength) {
            bitLength = this.maxLength;
            overflow++;
          }
          lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;
        } else {
          var bitLength = lengths[i];
          this.lengthCount[bitLength - 1]++;
          this.codeLength[child[childIndex - 1]] = lengths[i];
        }
      }
      return overflow;
    };
    CompressorHuffmanTree2.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];
    CompressorHuffmanTree2.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    return CompressorHuffmanTree2;
  })()
);
var ChecksumCalculator = (
  /** @class */
  (function() {
    function ChecksumCalculator3() {
    }
    ChecksumCalculator3.checksumUpdate = function(checksum, buffer, offset, length) {
      var uint = new Uint32Array(1);
      uint[0] = checksum;
      var checksum_uint = uint[0];
      var s1 = uint[0] = checksum_uint & 65535;
      var s2 = uint[0] = checksum_uint >> ChecksumCalculator3.checkSumBitOffset;
      while (length > 0) {
        var steps = Math.min(length, ChecksumCalculator3.checksumIterationCount);
        length -= steps;
        while (--steps >= 0) {
          s1 = s1 + (uint[0] = buffer[offset++] & 255);
          s2 = s2 + s1;
        }
        s1 %= ChecksumCalculator3.checksumBase;
        s2 %= ChecksumCalculator3.checksumBase;
      }
      checksum_uint = s2 << ChecksumCalculator3.checkSumBitOffset | s1;
      return checksum_uint;
    };
    ChecksumCalculator3.checkSumBitOffset = 16;
    ChecksumCalculator3.checksumBase = 65521;
    ChecksumCalculator3.checksumIterationCount = 3800;
    return ChecksumCalculator3;
  })()
);

// node_modules/@syncfusion/ej2-compression/src/decompressor-huffman-tree.js
var DecompressorHuffmanTree = (
  /** @class */
  (function() {
    function DecompressorHuffmanTree2(lengths) {
      this.buildTree(lengths);
    }
    DecompressorHuffmanTree2.init = function() {
      var lengths;
      var index;
      lengths = new Uint8Array(288);
      index = 0;
      while (index < 144) {
        lengths[index++] = 8;
      }
      while (index < 256) {
        lengths[index++] = 9;
      }
      while (index < 280) {
        lengths[index++] = 7;
      }
      while (index < 288) {
        lengths[index++] = 8;
      }
      DecompressorHuffmanTree2.m_LengthTree = new DecompressorHuffmanTree2(lengths);
      lengths = new Uint8Array(32);
      index = 0;
      while (index < 32) {
        lengths[index++] = 5;
      }
      DecompressorHuffmanTree2.m_DistanceTree = new DecompressorHuffmanTree2(lengths);
    };
    DecompressorHuffmanTree2.prototype.prepareData = function(blCount, nextCode, lengths) {
      var code = 0;
      var treeSize = 512;
      for (var i = 0; i < lengths.length; i++) {
        var length_1 = lengths[i];
        if (length_1 > 0) {
          blCount[length_1]++;
        }
      }
      for (var bits = 1; bits <= DecompressorHuffmanTree2.MAX_BITLEN; bits++) {
        nextCode[bits] = code;
        code += blCount[bits] << 16 - bits;
        if (bits >= 10) {
          var start = nextCode[bits] & 130944;
          var end = code & 130944;
          treeSize += end - start >> 16 - bits;
        }
      }
      return { "code": code, "treeSize": treeSize };
    };
    DecompressorHuffmanTree2.prototype.treeFromData = function(blCount, nextCode, lengths, code, treeSize) {
      var tree = new Int16Array(treeSize);
      var pointer = 512;
      var increment = 1 << 7;
      for (var bits = DecompressorHuffmanTree2.MAX_BITLEN; bits >= 10; bits--) {
        var end = code & 130944;
        code -= blCount[bits] << 16 - bits;
        var start = code & 130944;
        for (var i = start; i < end; i += increment) {
          tree[Utils.bitReverse(i)] = Utils.bitConverterInt32ToInt16(-pointer << 4 | bits);
          pointer += 1 << bits - 9;
        }
      }
      for (var i = 0; i < lengths.length; i++) {
        var bits = lengths[i];
        if (bits == 0) {
          continue;
        }
        code = nextCode[bits];
        var revcode = Utils.bitReverse(code);
        if (bits <= 9) {
          do {
            tree[revcode] = Utils.bitConverterInt32ToInt16(i << 4 | bits);
            revcode += 1 << bits;
          } while (revcode < 512);
        } else {
          var subTree = tree[revcode & 511];
          var treeLen = 1 << (subTree & 15);
          subTree = -(subTree >> 4);
          do {
            tree[subTree | revcode >> 9] = Utils.bitConverterInt32ToInt16(i << 4 | bits);
            revcode += 1 << bits;
          } while (revcode < treeLen);
        }
        nextCode[bits] = code + (1 << 16 - bits);
      }
      return tree;
    };
    DecompressorHuffmanTree2.prototype.buildTree = function(lengths) {
      var blCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      var nextCode = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      var prepareData = this.prepareData(blCount, nextCode, lengths);
      this.m_Tree = this.treeFromData(blCount, nextCode, lengths, prepareData.code, prepareData.treeSize);
    };
    DecompressorHuffmanTree2.prototype.unpackSymbol = function(input) {
      var lookahead;
      var symbol;
      if ((lookahead = input.peekBits(9)) >= 0) {
        if ((symbol = this.m_Tree[lookahead]) >= 0) {
          input.skipBits(symbol & 15);
          return symbol >> 4;
        }
        var subtree = -(symbol >> 4);
        var bitlen = symbol & 15;
        if ((lookahead = input.peekBits(bitlen)) >= 0) {
          symbol = this.m_Tree[subtree | lookahead >> 9];
          input.skipBits(symbol & 15);
          return symbol >> 4;
        } else {
          var bits = input.availableBits;
          lookahead = input.peekBits(bits);
          symbol = this.m_Tree[subtree | lookahead >> 9];
          if ((symbol & 15) <= bits) {
            input.skipBits(symbol & 15);
            return symbol >> 4;
          } else {
            return -1;
          }
        }
      } else {
        var bits = input.availableBits;
        lookahead = input.peekBits(bits);
        symbol = this.m_Tree[lookahead];
        if (symbol >= 0 && (symbol & 15) <= bits) {
          input.skipBits(symbol & 15);
          return symbol >> 4;
        } else {
          return -1;
        }
      }
    };
    Object.defineProperty(DecompressorHuffmanTree2, "lengthTree", {
      /// <summary>
      /// GET huffman tree for encoding and decoding lengths.
      /// </summary>
      get: function() {
        return this.m_LengthTree;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(DecompressorHuffmanTree2, "distanceTree", {
      /// <summary>
      /// GET huffman tree for encoding and decoding distances.
      /// </summary>
      get: function() {
        return this.m_DistanceTree;
      },
      enumerable: true,
      configurable: true
    });
    DecompressorHuffmanTree2.MAX_BITLEN = 15;
    return DecompressorHuffmanTree2;
  })()
);

// node_modules/@syncfusion/ej2-compression/src/checksum-calculator.js
var ChecksumCalculator2 = (
  /** @class */
  (function() {
    function ChecksumCalculator3() {
    }
    ChecksumCalculator3.ChecksumUpdate = function(checksum, buffer, offset, length) {
      var checkSumUInt = checksum;
      var s1 = checkSumUInt & 65535;
      var s2 = checkSumUInt >> this.DEF_CHECKSUM_BIT_OFFSET;
      while (length > 0) {
        var steps = Math.min(length, this.DEF_CHECKSUM_ITERATIONSCOUNT);
        length -= steps;
        while (--steps >= 0) {
          s1 = s1 + (buffer[offset++] & 255);
          s2 = s2 + s1;
        }
        s1 %= this.DEF_CHECKSUM_BASE;
        s2 %= this.DEF_CHECKSUM_BASE;
      }
      checkSumUInt = s2 << this.DEF_CHECKSUM_BIT_OFFSET | s1;
      checksum = checkSumUInt;
    };
    ChecksumCalculator3.ChecksumGenerate = function(buffer, offset, length) {
      var result = 1;
      ChecksumCalculator3.ChecksumUpdate(result, buffer, offset, length);
      return result;
    };
    ChecksumCalculator3.DEF_CHECKSUM_BIT_OFFSET = 16;
    ChecksumCalculator3.DEF_CHECKSUM_BASE = 65521;
    ChecksumCalculator3.DEF_CHECKSUM_ITERATIONSCOUNT = 3800;
    return ChecksumCalculator3;
  })()
);

// node_modules/@syncfusion/ej2-compression/src/compression-reader.js
var CompressedStreamReader = (
  /** @class */
  (function() {
    function CompressedStreamReader2(stream, bNoWrap) {
      this.defaultHuffmanDynamicTree = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      this.DEF_HEADER_METHOD_MASK = 15 << 8;
      this.DEF_HEADER_INFO_MASK = 240 << 8;
      this.DEF_HEADER_FLAGS_FCHECK = 31;
      this.DEF_HEADER_FLAGS_FDICT = 32;
      this.DEF_HEADER_FLAGS_FLEVEL = 192;
      this.DEF_MAX_WINDOW_SIZE = 65535;
      this.DEF_HUFFMAN_REPEATE_MAX = 258;
      this.DEF_HUFFMAN_END_BLOCK = 256;
      this.DEF_HUFFMAN_LENGTH_MINIMUMCODE = 257;
      this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE = 285;
      this.DEF_HUFFMAN_DISTANCE_MAXIMUMCODE = 29;
      this.mCheckSum = 1;
      this.tBuffer = 0;
      this.mBufferedBits = 0;
      this.mTempBuffer = new Uint8Array(4);
      this.mBlockBuffer = new Uint8Array(this.DEF_MAX_WINDOW_SIZE);
      this.mbNoWrap = false;
      this.mWindowSize = 0;
      this.mCurrentPosition = 0;
      this.mDataLength = 0;
      this.mbCanReadNextBlock = true;
      this.mbCanReadMoreData = true;
      this.mbCheckSumRead = false;
      if (stream == null) {
        throw new DOMException("stream");
      }
      if (stream.length === 0) {
        throw new DOMException("stream - string can not be empty");
      }
      DecompressorHuffmanTree.init();
      this.mInputStream = new Stream(stream);
      this.mbNoWrap = bNoWrap;
      if (!this.mbNoWrap) {
        this.readZLibHeader();
      }
      this.decodeBlockHeader();
    }
    Object.defineProperty(CompressedStreamReader2.prototype, "mBuffer", {
      get: function() {
        return this.tBuffer;
      },
      set: function(value) {
        this.tBuffer = value;
      },
      enumerable: true,
      configurable: true
    });
    CompressedStreamReader2.prototype.peekBits = function(count) {
      if (count < 0) {
        throw new DOMException("count", "Bits count can not be less than zero.");
      }
      if (count > 32) {
        throw new DOMException("count", "Count of bits is too large.");
      }
      if (this.mBufferedBits < count) {
        this.fillBuffer();
      }
      if (this.mBufferedBits < count) {
        return -1;
      }
      var bitMask = ~(4294967295 << count);
      var result = Utils.bitConverterUintToInt32(this.mBuffer & bitMask);
      return result;
    };
    CompressedStreamReader2.prototype.fillBuffer = function() {
      var length = 4 - (this.mBufferedBits >> 3) - ((this.mBufferedBits & 7) !== 0 ? 1 : 0);
      if (length === 0) {
        return;
      }
      var bytesRead = this.mInputStream.read(this.mTempBuffer, 0, length);
      for (var i = 0; i < bytesRead; i++) {
        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer | Utils.bitConverterInt32ToUint(this.mTempBuffer[i] << this.mBufferedBits));
        this.mBufferedBits += 8;
      }
    };
    CompressedStreamReader2.prototype.skipBits = function(count) {
      if (count < 0) {
        throw new DOMException("count", "Bits count can not be less than zero.");
      }
      if (count === 0) {
        return;
      }
      if (count >= this.mBufferedBits) {
        count -= this.mBufferedBits;
        this.mBufferedBits = 0;
        this.mBuffer = 0;
        if (count > 0) {
          this.mInputStream.position += count >> 3;
          count &= 7;
          if (count > 0) {
            this.fillBuffer();
            this.mBufferedBits -= count;
            this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);
          }
        }
      } else {
        this.mBufferedBits -= count;
        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);
      }
    };
    Object.defineProperty(CompressedStreamReader2.prototype, "availableBits", {
      get: function() {
        return this.mBufferedBits;
      },
      enumerable: true,
      configurable: true
    });
    CompressedStreamReader2.prototype.readZLibHeader = function() {
      var header = this.readInt16();
      if (header === -1) {
        throw new DOMException("Header of the stream can not be read.");
      }
      if (header % 31 !== 0) {
        throw new DOMException("Header checksum illegal");
      }
      if ((header & this.DEF_HEADER_METHOD_MASK) !== 8 << 8) {
        throw new DOMException("Unsupported compression method.");
      }
      this.mWindowSize = Math.pow(2, ((header & this.DEF_HEADER_INFO_MASK) >> 12) + 8);
      if (this.mWindowSize > 65535) {
        throw new DOMException("Unsupported window size for deflate compression method.");
      }
      if ((header & this.DEF_HEADER_FLAGS_FDICT) >> 5 === 1) {
        throw new DOMException("Custom dictionary is not supported at the moment.");
      }
    };
    CompressedStreamReader2.prototype.readInt16 = function() {
      var result = this.readBits(8) << 8;
      result |= this.readBits(8);
      return result;
    };
    CompressedStreamReader2.prototype.readBits = function(count) {
      var result = this.peekBits(count);
      if (result === -1) {
        return -1;
      }
      this.mBufferedBits -= count;
      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);
      return result;
    };
    CompressedStreamReader2.prototype.decodeBlockHeader = function() {
      if (!this.mbCanReadNextBlock) {
        return false;
      }
      var bFinalBlock = this.readBits(1);
      if (bFinalBlock === -1) {
        return false;
      }
      var blockType = this.readBits(2);
      if (blockType === -1) {
        return false;
      }
      this.mbCanReadNextBlock = bFinalBlock === 0;
      switch (blockType) {
        case 0:
          this.mbReadingUncompressed = true;
          this.skipToBoundary();
          var length_1 = this.readInt16Inverted();
          var lengthComplement = this.readInt16Inverted();
          if (length_1 !== (lengthComplement ^ 65535)) {
            throw new DOMException("Wrong block length.");
          }
          if (length_1 > 65535) {
            throw new DOMException("Uncompressed block length can not be more than 65535.");
          }
          this.mUncompressedDataLength = length_1;
          this.mCurrentLengthTree = null;
          this.mCurrentDistanceTree = null;
          break;
        case 1:
          this.mbReadingUncompressed = false;
          this.mUncompressedDataLength = -1;
          this.mCurrentLengthTree = DecompressorHuffmanTree.lengthTree;
          this.mCurrentDistanceTree = DecompressorHuffmanTree.distanceTree;
          break;
        case 2:
          this.mbReadingUncompressed = false;
          this.mUncompressedDataLength = -1;
          var trees = this.decodeDynamicHeader(this.mCurrentLengthTree, this.mCurrentDistanceTree);
          this.mCurrentLengthTree = trees.lengthTree;
          this.mCurrentDistanceTree = trees.distanceTree;
          break;
        default:
          throw new DOMException("Wrong block type.");
      }
      return true;
    };
    CompressedStreamReader2.prototype.skipToBoundary = function() {
      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> (this.mBufferedBits & 7));
      this.mBufferedBits &= ~7;
    };
    CompressedStreamReader2.prototype.readInt16Inverted = function() {
      var result = this.readBits(8);
      result |= this.readBits(8) << 8;
      return result;
    };
    CompressedStreamReader2.prototype.decodeDynamicHeader = function(lengthTree, distanceTree) {
      var bLastSymbol = 0;
      var iLengthsCount = this.readBits(5);
      var iDistancesCount = this.readBits(5);
      var iCodeLengthsCount = this.readBits(4);
      if (iLengthsCount < 0 || iDistancesCount < 0 || iCodeLengthsCount < 0) {
        throw new DOMException("Wrong dynamic huffman codes.");
      }
      iLengthsCount += 257;
      iDistancesCount += 1;
      var iResultingCodeLengthsCount = iLengthsCount + iDistancesCount;
      var arrResultingCodeLengths = new Uint8Array(iResultingCodeLengthsCount);
      var arrDecoderCodeLengths = new Uint8Array(19);
      iCodeLengthsCount += 4;
      var iCurrentCode = 0;
      while (iCurrentCode < iCodeLengthsCount) {
        var len = this.readBits(3);
        if (len < 0) {
          throw new DOMException("Wrong dynamic huffman codes.");
        }
        arrDecoderCodeLengths[this.defaultHuffmanDynamicTree[iCurrentCode++]] = len;
      }
      var treeInternalDecoder = new DecompressorHuffmanTree(arrDecoderCodeLengths);
      iCurrentCode = 0;
      for (; ; ) {
        var symbol = void 0;
        var bNeedBreak = false;
        symbol = treeInternalDecoder.unpackSymbol(this);
        while ((symbol & ~15) === 0) {
          arrResultingCodeLengths[iCurrentCode++] = bLastSymbol = symbol;
          if (iCurrentCode === iResultingCodeLengthsCount) {
            bNeedBreak = true;
            break;
          }
          symbol = treeInternalDecoder.unpackSymbol(this);
        }
        if (bNeedBreak) {
          break;
        }
        if (symbol < 0) {
          throw new DOMException("Wrong dynamic huffman codes.");
        }
        if (symbol >= 17) {
          bLastSymbol = 0;
        } else if (iCurrentCode === 0) {
          throw new DOMException("Wrong dynamic huffman codes.");
        }
        var miRepSymbol = symbol - 16;
        var bits = CompressedStreamReader2.DEF_HUFFMAN_DYNTREE_REPEAT_BITS[miRepSymbol];
        var count = this.readBits(bits);
        if (count < 0) {
          throw new DOMException("Wrong dynamic huffman codes.");
        }
        count += CompressedStreamReader2.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS[miRepSymbol];
        if (iCurrentCode + count > iResultingCodeLengthsCount) {
          throw new DOMException("Wrong dynamic huffman codes.");
        }
        while (count-- > 0) {
          arrResultingCodeLengths[iCurrentCode++] = bLastSymbol;
        }
        if (iCurrentCode === iResultingCodeLengthsCount) {
          break;
        }
      }
      var tempArray = new Uint8Array(iLengthsCount);
      tempArray.set(arrResultingCodeLengths.subarray(0, iLengthsCount), 0);
      lengthTree = new DecompressorHuffmanTree(tempArray);
      tempArray = arrResultingCodeLengths.slice(iLengthsCount, iLengthsCount + iDistancesCount);
      distanceTree = new DecompressorHuffmanTree(tempArray);
      return { "lengthTree": lengthTree, "distanceTree": distanceTree };
    };
    CompressedStreamReader2.prototype.readHuffman = function() {
      var free = this.DEF_MAX_WINDOW_SIZE - (this.mDataLength - this.mCurrentPosition);
      var dataRead = false;
      var readdata = {};
      while (free >= this.DEF_HUFFMAN_REPEATE_MAX) {
        var symbol = void 0;
        symbol = this.mCurrentLengthTree.unpackSymbol(this);
        while ((symbol & ~255) === 0) {
          readdata[(this.mDataLength + 1) % this.DEF_MAX_WINDOW_SIZE] = symbol;
          this.mBlockBuffer[this.mDataLength++ % this.DEF_MAX_WINDOW_SIZE] = symbol;
          dataRead = true;
          if (--free < this.DEF_HUFFMAN_REPEATE_MAX) {
            return true;
          }
          symbol = this.mCurrentLengthTree.unpackSymbol(this);
        }
        if (symbol < this.DEF_HUFFMAN_LENGTH_MINIMUMCODE) {
          if (symbol < this.DEF_HUFFMAN_END_BLOCK) {
            throw new DOMException("Illegal code.");
          }
          var numDataRead = dataRead ? 1 : 0;
          this.mbCanReadMoreData = this.decodeBlockHeader();
          var numReadMore = this.mbCanReadMoreData ? 1 : 0;
          return numDataRead | numReadMore ? true : false;
        }
        if (symbol > this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE) {
          throw new DOMException("Illegal repeat code length.");
        }
        var iRepeatLength = CompressedStreamReader2.DEF_HUFFMAN_REPEAT_LENGTH_BASE[symbol - this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];
        var iRepeatExtraBits = CompressedStreamReader2.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION[symbol - this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];
        if (iRepeatExtraBits > 0) {
          var extra = this.readBits(iRepeatExtraBits);
          if (extra < 0) {
            throw new DOMException("Wrong data.");
          }
          iRepeatLength += extra;
        }
        symbol = this.mCurrentDistanceTree.unpackSymbol(this);
        if (symbol < 0 || symbol > CompressedStreamReader2.DEF_HUFFMAN_REPEAT_DISTANCE_BASE.length) {
          throw new DOMException("Wrong distance code.");
        }
        var iRepeatDistance = CompressedStreamReader2.DEF_HUFFMAN_REPEAT_DISTANCE_BASE[symbol];
        iRepeatExtraBits = CompressedStreamReader2.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION[symbol];
        if (iRepeatExtraBits > 0) {
          var extra = this.readBits(iRepeatExtraBits);
          if (extra < 0) {
            throw new DOMException("Wrong data.");
          }
          iRepeatDistance += extra;
        }
        for (var i = 0; i < iRepeatLength; i++) {
          this.mBlockBuffer[this.mDataLength % this.DEF_MAX_WINDOW_SIZE] = this.mBlockBuffer[(this.mDataLength - iRepeatDistance) % this.DEF_MAX_WINDOW_SIZE];
          this.mDataLength++;
          free--;
        }
        dataRead = true;
      }
      return dataRead;
    };
    CompressedStreamReader2.prototype.read = function(buffer, offset, length) {
      if (buffer == null) {
        throw new DOMException("buffer");
      }
      if (offset < 0 || offset > buffer.length - 1) {
        throw new DOMException("offset", "Offset does not belong to specified buffer.");
      }
      if (length < 0 || length > buffer.length - offset) {
        throw new DOMException("length", "Length is illegal.");
      }
      var initialLength = length;
      while (length > 0) {
        if (this.mCurrentPosition < this.mDataLength) {
          var inBlockPosition = this.mCurrentPosition % this.DEF_MAX_WINDOW_SIZE;
          var dataToCopy = Math.min(this.DEF_MAX_WINDOW_SIZE - inBlockPosition, this.mDataLength - this.mCurrentPosition);
          dataToCopy = Math.min(dataToCopy, length);
          Utils.arrayCopy(this.mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy);
          this.mCurrentPosition += dataToCopy;
          offset += dataToCopy;
          length -= dataToCopy;
        } else {
          if (!this.mbCanReadMoreData) {
            break;
          }
          var oldDataLength = this.mDataLength;
          if (!this.mbReadingUncompressed) {
            if (!this.readHuffman()) {
              break;
            }
          } else {
            if (this.mUncompressedDataLength === 0) {
              this.mbCanReadMoreData = this.decodeBlockHeader();
              if (!this.mbCanReadMoreData) {
                break;
              }
            } else {
              var inBlockPosition = this.mDataLength % this.DEF_MAX_WINDOW_SIZE;
              var dataToRead = Math.min(this.mUncompressedDataLength, this.DEF_MAX_WINDOW_SIZE - inBlockPosition);
              var dataRead = this.readPackedBytes(this.mBlockBuffer, inBlockPosition, dataToRead);
              if (dataToRead !== dataRead) {
                throw new DOMException("Not enough data in stream.");
              }
              this.mUncompressedDataLength -= dataRead;
              this.mDataLength += dataRead;
            }
          }
          if (oldDataLength < this.mDataLength) {
            var start = oldDataLength % this.DEF_MAX_WINDOW_SIZE;
            var end = this.mDataLength % this.DEF_MAX_WINDOW_SIZE;
            if (start < end) {
              this.checksumUpdate(this.mBlockBuffer, start, end - start);
            } else {
              this.checksumUpdate(this.mBlockBuffer, start, this.DEF_MAX_WINDOW_SIZE - start);
              if (end > 0) {
                this.checksumUpdate(this.mBlockBuffer, 0, end);
              }
            }
          }
        }
      }
      if (!this.mbCanReadMoreData && !this.mbCheckSumRead && !this.mbNoWrap) {
        this.skipToBoundary();
        var checkSum = this.readInt32();
        if (checkSum !== this.mCheckSum) {
          throw new DOMException("Checksum check failed.");
        }
        this.mbCheckSumRead = true;
      }
      return initialLength - length;
    };
    CompressedStreamReader2.prototype.readPackedBytes = function(buffer, offset, length) {
      if (buffer == null) {
        throw new DOMException("buffer");
      }
      if (offset < 0 || offset > buffer.length - 1) {
        throw new DOMException('offset", "Offset can not be less than zero or greater than buffer length - 1.');
      }
      if (length < 0) {
        throw new DOMException('length", "Length can not be less than zero.');
      }
      if (length > buffer.length - offset) {
        throw new DOMException('length", "Length is too large.');
      }
      if ((this.mBufferedBits & 7) !== 0) {
        throw new DOMException("Reading of unalligned data is not supported.");
      }
      if (length === 0) {
        return 0;
      }
      var result = 0;
      while (this.mBufferedBits > 0 && length > 0) {
        buffer[offset++] = this.mBuffer;
        this.mBufferedBits -= 8;
        this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> 8);
        length--;
        result++;
      }
      if (length > 0) {
        result += this.mInputStream.read(buffer, offset, length);
      }
      return result;
    };
    CompressedStreamReader2.prototype.readInt32 = function() {
      var result = this.readBits(8) << 24;
      result |= this.readBits(8) << 16;
      result |= this.readBits(8) << 8;
      result |= this.readBits(8);
      return result;
    };
    CompressedStreamReader2.prototype.checksumUpdate = function(buffer, offset, length) {
      ChecksumCalculator2.ChecksumUpdate(this.mCheckSum, buffer, offset, length);
    };
    CompressedStreamReader2.DEF_REVERSE_BITS = new Uint8Array([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]);
    CompressedStreamReader2.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS = [3, 3, 11];
    CompressedStreamReader2.DEF_HUFFMAN_DYNTREE_REPEAT_BITS = [2, 3, 7];
    CompressedStreamReader2.DEF_HUFFMAN_REPEAT_LENGTH_BASE = [
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258
    ];
    CompressedStreamReader2.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0
    ];
    CompressedStreamReader2.DEF_HUFFMAN_REPEAT_DISTANCE_BASE = [
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577
    ];
    CompressedStreamReader2.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION = [
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13
    ];
    return CompressedStreamReader2;
  })()
);
var Stream = (
  /** @class */
  (function() {
    function Stream2(input) {
      this.position = 0;
      this.inputStream = new Uint8Array(input.buffer);
    }
    Object.defineProperty(Stream2.prototype, "length", {
      get: function() {
        return this.inputStream.buffer.byteLength;
      },
      enumerable: true,
      configurable: true
    });
    Stream2.prototype.read = function(buffer, start, length) {
      var temp = new Uint8Array(this.inputStream.buffer, this.position + start);
      var data = temp.subarray(0, length);
      buffer.set(data, 0);
      this.position += data.byteLength;
      return data.byteLength;
    };
    Stream2.prototype.readByte = function() {
      return this.inputStream[this.position++];
    };
    Stream2.prototype.write = function(inputBuffer, offset, count) {
      Utils.arrayCopy(inputBuffer, 0, this.inputStream, this.position + offset, count);
      this.position += count;
    };
    Stream2.prototype.toByteArray = function() {
      return new Uint8Array(this.inputStream.buffer);
    };
    return Stream2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-stream.js
var __extends23 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfStream = (
  /** @class */
  (function(_super) {
    __extends23(PdfStream2, _super);
    function PdfStream2(dictionary, data) {
      var _this = _super.call(this, dictionary) || this;
      _this.dicPrefix = "stream";
      _this.dicSuffix = "endstream";
      _this.clonedObject2 = null;
      _this.bCompress = true;
      if (typeof dictionary !== "undefined" || typeof data !== "undefined") {
        _this.dataStream2 = [];
        _this.dataStream2 = data;
        _this.bCompress2 = false;
      } else {
        _this.dataStream2 = [];
        _this.bCompress2 = true;
      }
      return _this;
    }
    Object.defineProperty(PdfStream2.prototype, "internalStream", {
      /**
       * Gets the `internal` stream.
       * @private
       */
      get: function() {
        return this.dataStream2;
      },
      set: function(value) {
        this.dataStream2 = [];
        this.dataStream2 = value;
        this.modify();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStream2.prototype, "compress", {
      /**
       * Gets or sets `compression` flag.
       * @private
       */
      get: function() {
        return this.bCompress;
      },
      set: function(value) {
        this.bCompress = value;
        this.modify();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStream2.prototype, "data", {
      /**
       * Gets or sets the `data`.
       * @private
       */
      get: function() {
        return this.dataStream2;
      },
      set: function(value) {
        this.dataStream2 = [];
        this.dataStream2 = value;
        this.modify();
      },
      enumerable: true,
      configurable: true
    });
    PdfStream2.prototype.clearStream = function() {
      this.internalStream = [];
      if (this.items.containsKey(this.dictionaryProperties.filter)) {
        this.remove(this.dictionaryProperties.filter);
      }
      this.bCompress = true;
      this.modify();
    };
    PdfStream2.prototype.write = function(text) {
      if (text == null) {
        throw new Error("ArgumentNullException:text");
      }
      if (text.length <= 0) {
        throw new Error("ArgumentException: Can not write an empty string, text");
      }
      this.dataStream2.push(text);
      this.modify();
    };
    PdfStream2.prototype.writeBytes = function(data) {
      if (data === null) {
        throw new Error("ArgumentNullException:data");
      }
      if (data.length <= 0) {
        throw new Error("ArgumentException: Can not write an empty bytes, data");
      }
      var text = "";
      for (var i = 0; i < data.length; i++) {
        text += String.fromCharCode(data[i]);
      }
      this.dataStream2.push(text);
      this.modify();
    };
    PdfStream2.prototype.onCmapBeginSave = function() {
      this.cmapBeginSave.sender.cmapBeginSave();
    };
    PdfStream2.prototype.onFontProgramBeginSave = function() {
      this.fontProgramBeginSave.sender.fontProgramBeginSave();
    };
    PdfStream2.prototype.compressContent = function(data, writer) {
      if (this.bCompress) {
        var byteArray = [];
        for (var i = 0; i < data.length; i++) {
          byteArray.push(data.charCodeAt(i));
        }
        var dataArray = new Uint8Array(byteArray);
        var sw = new CompressedStreamWriter();
        sw.write(dataArray, 0, dataArray.length);
        sw.close();
        data = sw.getCompressedString;
        this.addFilter(this.dictionaryProperties.flatedecode);
      }
      return data;
    };
    PdfStream2.prototype.addFilter = function(filterName) {
      var obj = this.items.getValue(this.dictionaryProperties.filter);
      if (obj instanceof PdfReferenceHolder) {
        var rh = obj;
        obj = rh.object;
      }
      var array = obj;
      var name = obj;
      if (name != null) {
        array = new PdfArray();
        array.insert(0, name);
        this.items.setValue(this.dictionaryProperties.filter, array);
      }
      name = new PdfName(filterName);
      if (array == null) {
        this.items.setValue(this.dictionaryProperties.filter, name);
      } else {
        array.insert(0, name);
      }
    };
    PdfStream2.prototype.save = function(writer) {
      if (typeof this.cmapBeginSave !== "undefined") {
        this.onCmapBeginSave();
      }
      if (typeof this.fontProgramBeginSave !== "undefined") {
        this.onFontProgramBeginSave();
      }
      var data = "";
      for (var i = 0; i < this.data.length; i++) {
        data = data + this.data[i];
      }
      if (data.length > 1 && !this.isResource) {
        data = "q\r\n" + data + "Q\r\n";
      }
      data = this.compressContent(data, writer);
      var length = data.length;
      this.items.setValue(this.dictionaryProperties.length, new PdfNumber(length));
      _super.prototype.save.call(this, writer, false);
      writer.write(this.dicPrefix);
      writer.write(Operators.newLine);
      if (data.length > 0) {
        writer.write(data);
      }
      writer.write(Operators.newLine);
      writer.write(this.dicSuffix);
      writer.write(Operators.newLine);
    };
    PdfStream2.bytesToString = function(byteArray) {
      var output = "";
      for (var i = 0; i < byteArray.length; i++) {
        output = output + String.fromCharCode(byteArray[i]);
      }
      return output;
    };
    return PdfStream2;
  })(PdfDictionary)
);
var SaveCmapEventHandler = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SaveCmapEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveCmapEventHandler2;
  })()
);
var SaveFontProgramEventHandler = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SaveFontProgramEventHandler2(sender) {
      this.sender = sender;
    }
    return SaveFontProgramEventHandler2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-string.js
var InternalEnum;
(function(InternalEnum2) {
  var ForceEncoding;
  (function(ForceEncoding2) {
    ForceEncoding2[ForceEncoding2["None"] = 0] = "None";
    ForceEncoding2[ForceEncoding2["Ascii"] = 1] = "Ascii";
    ForceEncoding2[ForceEncoding2["Unicode"] = 2] = "Unicode";
  })(ForceEncoding = InternalEnum2.ForceEncoding || (InternalEnum2.ForceEncoding = {}));
  var SourceType;
  (function(SourceType2) {
    SourceType2[SourceType2["StringValue"] = 0] = "StringValue";
    SourceType2[SourceType2["ByteBuffer"] = 1] = "ByteBuffer";
  })(SourceType || (SourceType = {}));
})(InternalEnum || (InternalEnum = {}));
var PdfString = (
  /** @class */
  (function() {
    function PdfString2(value) {
      this.bHex = false;
      this.position1 = -1;
      this.clonedObject1 = null;
      this.bDecrypted = false;
      this.isParentDecrypted = false;
      this.isPacked = false;
      this.isFormField = false;
      this.isColorSpace = false;
      this.isHexString = true;
      if (typeof value === "undefined") {
        this.bHex = false;
      } else {
        if (!(value.length > 0 && value[0] === "0xfeff")) {
          this.stringValue = value;
          this.data = [];
          for (var i = 0; i < value.length; ++i) {
            this.data.push(value.charCodeAt(i));
          }
        }
      }
    }
    Object.defineProperty(PdfString2.prototype, "hex", {
      //Property
      /**
       * Gets a value indicating whether string is in `hex`.
       * @private
       */
      get: function() {
        return this.bHex;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "value", {
      /**
       * Gets or sets string `value` of the object.
       * @private
       */
      get: function() {
        return this.stringValue;
      },
      set: function(value) {
        this.stringValue = value;
        this.data = null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "status", {
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status1;
      },
      set: function(value) {
        this.status1 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving1;
      },
      set: function(value) {
        this.isSaving1 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index1;
      },
      set: function(value) {
        this.index1 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        return this.clonedObject1;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position1;
      },
      set: function(value) {
        this.position1 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "CrossTable", {
      /**
       * Returns `PdfCrossTable` associated with the object.
       * @private
       */
      get: function() {
        return this.crossTable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "converted", {
      /**
       * Gets a value indicating whether to check if the value has unicode characters.
       * @private
       */
      get: function() {
        return this.bConverted;
      },
      /**
       * sets a value indicating whether to check if the value has unicode characters.
       * @private
       */
      set: function(value) {
        this.bConverted = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfString2.prototype, "encode", {
      /**
       * Gets value indicating whether we should convert data to Unicode.
       */
      get: function() {
        return this.bForceEncoding;
      },
      set: function(value) {
        this.bForceEncoding = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfString2.bytesToHex = function(bytes) {
      if (bytes == null) {
        return "";
      }
      var builder = "";
      return builder;
    };
    PdfString2.prototype.save = function(writer) {
      if (writer === null) {
        throw new Error("ArgumentNullException : writer");
      }
      if (this.encode !== void 0 && this.encode === InternalEnum.ForceEncoding.Ascii) {
        writer.write(this.pdfEncode());
      } else {
        writer.write(PdfString2.stringMark[0] + this.value + PdfString2.stringMark[1]);
      }
    };
    PdfString2.prototype.pdfEncode = function() {
      var result = "";
      if (this.encode !== void 0 && this.encode === InternalEnum.ForceEncoding.Ascii) {
        var data = this.escapeSymbols(this.value);
        for (var i = 0; i < data.length; i++) {
          result += String.fromCharCode(data[i]);
        }
        result = PdfString2.stringMark[0] + result + PdfString2.stringMark[1];
      } else {
        result = this.value;
      }
      return result;
    };
    PdfString2.prototype.escapeSymbols = function(value) {
      var data = [];
      for (var i = 0; i < value.length; i++) {
        var currentData = value.charCodeAt(i);
        switch (currentData) {
          case 40:
          case 41:
            data.push(92);
            data.push(currentData);
            break;
          case 13:
            data.push(92);
            data.push(114);
            break;
          case 92:
            data.push(92);
            data.push(currentData);
            break;
          default:
            data.push(currentData);
            break;
        }
      }
      return data;
    };
    PdfString2.prototype.clone = function(crossTable) {
      if (this.clonedObject1 !== null && this.clonedObject1.CrossTable === crossTable) {
        return this.clonedObject1;
      } else {
        this.clonedObject1 = null;
      }
      var newString = new PdfString2(this.stringValue);
      newString.bHex = this.bHex;
      newString.crossTable = crossTable;
      newString.isColorSpace = this.isColorSpace;
      this.clonedObject1 = newString;
      return newString;
    };
    PdfString2.toUnicodeArray = function(value, bAddPrefix) {
      if (value == null) {
        throw new Error("Argument Null Exception : value");
      }
      var startIndex = 0;
      var output = [];
      for (var i = 0; i < value.length; i++) {
        var code = value.charCodeAt(i);
        output.push(code / 256 >>> 0);
        output.push(code & 255);
      }
      return output;
    };
    PdfString2.byteToString = function(data) {
      if (data == null) {
        throw new Error("Argument Null Exception : stream");
      }
      var result = "";
      for (var i = 0; i < data.length; ++i) {
        result += String.fromCharCode(data[i]);
      }
      return result;
    };
    PdfString2.stringMark = "()";
    PdfString2.hexStringMark = "<>";
    PdfString2.hexFormatPattern = "{0:X2}";
    return PdfString2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-reference.js
var PdfReference = (
  /** @class */
  (function() {
    function PdfReference2(objNumber, genNumber) {
      this.index3 = -1;
      this.position3 = -1;
      this.objNumber = 0;
      this.genNumber = 0;
      if (typeof objNumber === "number" && typeof genNumber === "number") {
        this.objNumber = objNumber;
        this.genNumber = genNumber;
      } else {
        this.objNumber = Number(objNumber);
        this.genNumber = Number(genNumber);
      }
    }
    Object.defineProperty(PdfReference2.prototype, "status", {
      //Property
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status3;
      },
      set: function(value) {
        this.status3 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReference2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving3;
      },
      set: function(value) {
        this.isSaving3 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReference2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index3;
      },
      set: function(value) {
        this.index3 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReference2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position3;
      },
      set: function(value) {
        this.position3 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReference2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        var returnObject3 = null;
        return returnObject3;
      },
      enumerable: true,
      configurable: true
    });
    PdfReference2.prototype.save = function(writer) {
      writer.write(this.toString());
    };
    PdfReference2.prototype.toString = function() {
      return this.objNumber.toString() + " " + this.genNumber.toString() + " R";
    };
    PdfReference2.prototype.clone = function(crossTable) {
      return null;
    };
    return PdfReference2;
  })()
);
var PdfReferenceHolder = (
  /** @class */
  (function() {
    function PdfReferenceHolder2(obj1, obj2) {
      this.index4 = -1;
      this.position4 = -1;
      this.objectIndex = -1;
      this.dictionaryProperties = new DictionaryProperties();
      this.initialize(obj1);
    }
    Object.defineProperty(PdfReferenceHolder2.prototype, "status", {
      //Properties
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.status4;
      },
      set: function(value) {
        this.status4 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.isSaving4;
      },
      set: function(value) {
        this.isSaving4 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index4;
      },
      set: function(value) {
        this.index4 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.position4;
      },
      set: function(value) {
        this.position4 = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "object", {
      /**
       * Gets the `object` the reference is of.
       * @private
       */
      get: function() {
        return this.primitiveObject;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "reference", {
      /**
       * Gets the `reference`.
       * @private
       */
      get: function() {
        return this.pdfReference;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "index", {
      /**
       * Gets the `index` of the object.
       * @private
       */
      get: function() {
        return this.objectIndex;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfReferenceHolder2.prototype, "element", {
      /**
       * Gets the `element`.
       * @private
       */
      get: function() {
        return this.primitiveObject;
      },
      enumerable: true,
      configurable: true
    });
    PdfReferenceHolder2.prototype.initialize = function(obj1) {
      if (obj1 instanceof PdfArray || obj1 instanceof PdfDictionary || obj1 instanceof PdfName || obj1 instanceof PdfNumber || obj1 instanceof PdfStream || obj1 instanceof PdfReference || obj1 instanceof PdfString) {
        this.primitiveObject = obj1;
      } else {
        var tempObj = obj1;
        this.initialize(tempObj.element);
      }
    };
    PdfReferenceHolder2.prototype.save = function(writer) {
      var position = writer.position;
      var cTable = writer.document.crossTable;
      this.object.isSaving = true;
      var reference = null;
      reference = cTable.getReference(this.object);
      reference.save(writer);
    };
    PdfReferenceHolder2.prototype.clone = function(crossTable) {
      var refHolder = null;
      var temp = null;
      var refNum = "";
      var reference = null;
      return null;
    };
    return PdfReferenceHolder2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/actions/action.js
var PdfAction = (
  /** @class */
  (function() {
    function PdfAction2() {
      this.action = null;
      this.dictionaryProperties = new DictionaryProperties();
      this.initialize();
    }
    Object.defineProperty(PdfAction2.prototype, "next", {
      // Properties
      /**
       * Gets and Sets the `Next` action to perform.
       * @private
       */
      get: function() {
        return this.action;
      },
      set: function(value) {
        this.action = value;
        this.dictionary.items.setValue(this.dictionaryProperties.next, new PdfReferenceHolder(this.action));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAction2.prototype, "dictionary", {
      /**
       * Gets and Sets the instance of PdfDictionary class for `Dictionary`.
       * @private
       */
      get: function() {
        if (typeof this.pdfDictionary === "undefined") {
          this.pdfDictionary = new PdfDictionary();
        }
        return this.pdfDictionary;
      },
      enumerable: true,
      configurable: true
    });
    PdfAction2.prototype.initialize = function() {
      this.dictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.action));
    };
    Object.defineProperty(PdfAction2.prototype, "element", {
      // IPdfWrapper Members
      /**
       * Gets the `Element` as IPdfPrimitive class.
       * @private
       */
      get: function() {
        return this.dictionary;
      },
      enumerable: true,
      configurable: true
    });
    return PdfAction2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/actions/uri-action.js
var __extends24 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfUriAction = (
  /** @class */
  (function(_super) {
    __extends24(PdfUriAction2, _super);
    function PdfUriAction2(uri) {
      var _this = _super.call(this) || this;
      _this.uniformResourceIdentifier = "";
      return _this;
    }
    Object.defineProperty(PdfUriAction2.prototype, "uri", {
      // Properties
      /**
       * Gets and Sets the value of `Uri`.
       * @private
       */
      get: function() {
        return this.uniformResourceIdentifier;
      },
      set: function(value) {
        this.uniformResourceIdentifier = value;
        this.dictionary.items.setValue(this.dictionaryProperties.uri, new PdfString(this.uniformResourceIdentifier));
      },
      enumerable: true,
      configurable: true
    });
    PdfUriAction2.prototype.initialize = function() {
      _super.prototype.initialize.call(this);
      this.dictionary.items.setValue(this.dictionaryProperties.s, new PdfName(this.dictionaryProperties.uri));
    };
    return PdfUriAction2;
  })(PdfAction)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/enum.js
var PdfHorizontalAlignment;
(function(PdfHorizontalAlignment2) {
  PdfHorizontalAlignment2[PdfHorizontalAlignment2["Left"] = 0] = "Left";
  PdfHorizontalAlignment2[PdfHorizontalAlignment2["Center"] = 1] = "Center";
  PdfHorizontalAlignment2[PdfHorizontalAlignment2["Right"] = 2] = "Right";
})(PdfHorizontalAlignment || (PdfHorizontalAlignment = {}));
var PdfVerticalAlignment;
(function(PdfVerticalAlignment2) {
  PdfVerticalAlignment2[PdfVerticalAlignment2["Top"] = 0] = "Top";
  PdfVerticalAlignment2[PdfVerticalAlignment2["Middle"] = 1] = "Middle";
  PdfVerticalAlignment2[PdfVerticalAlignment2["Bottom"] = 2] = "Bottom";
})(PdfVerticalAlignment || (PdfVerticalAlignment = {}));
var PdfTextAlignment;
(function(PdfTextAlignment2) {
  PdfTextAlignment2[PdfTextAlignment2["Left"] = 0] = "Left";
  PdfTextAlignment2[PdfTextAlignment2["Center"] = 1] = "Center";
  PdfTextAlignment2[PdfTextAlignment2["Right"] = 2] = "Right";
  PdfTextAlignment2[PdfTextAlignment2["Justify"] = 3] = "Justify";
})(PdfTextAlignment || (PdfTextAlignment = {}));
var TextRenderingMode;
(function(TextRenderingMode2) {
  TextRenderingMode2[TextRenderingMode2["Fill"] = 0] = "Fill";
  TextRenderingMode2[TextRenderingMode2["Stroke"] = 1] = "Stroke";
  TextRenderingMode2[TextRenderingMode2["FillStroke"] = 2] = "FillStroke";
  TextRenderingMode2[TextRenderingMode2["None"] = 3] = "None";
  TextRenderingMode2[TextRenderingMode2["ClipFlag"] = 4] = "ClipFlag";
  TextRenderingMode2[TextRenderingMode2["ClipFill"] = 4] = "ClipFill";
  TextRenderingMode2[TextRenderingMode2["ClipStroke"] = 5] = "ClipStroke";
  TextRenderingMode2[TextRenderingMode2["ClipFillStroke"] = 6] = "ClipFillStroke";
  TextRenderingMode2[TextRenderingMode2["Clip"] = 7] = "Clip";
})(TextRenderingMode || (TextRenderingMode = {}));
var PdfLineJoin;
(function(PdfLineJoin2) {
  PdfLineJoin2[PdfLineJoin2["Miter"] = 0] = "Miter";
  PdfLineJoin2[PdfLineJoin2["Round"] = 1] = "Round";
  PdfLineJoin2[PdfLineJoin2["Bevel"] = 2] = "Bevel";
})(PdfLineJoin || (PdfLineJoin = {}));
var PdfLineCap;
(function(PdfLineCap2) {
  PdfLineCap2[PdfLineCap2["Flat"] = 0] = "Flat";
  PdfLineCap2[PdfLineCap2["Round"] = 1] = "Round";
  PdfLineCap2[PdfLineCap2["Square"] = 2] = "Square";
})(PdfLineCap || (PdfLineCap = {}));
var PdfDashStyle;
(function(PdfDashStyle2) {
  PdfDashStyle2[PdfDashStyle2["Solid"] = 0] = "Solid";
  PdfDashStyle2[PdfDashStyle2["Dash"] = 1] = "Dash";
  PdfDashStyle2[PdfDashStyle2["Dot"] = 2] = "Dot";
  PdfDashStyle2[PdfDashStyle2["DashDot"] = 3] = "DashDot";
  PdfDashStyle2[PdfDashStyle2["DashDotDot"] = 4] = "DashDotDot";
  PdfDashStyle2[PdfDashStyle2["Custom"] = 5] = "Custom";
})(PdfDashStyle || (PdfDashStyle = {}));
var PdfFillMode;
(function(PdfFillMode2) {
  PdfFillMode2[PdfFillMode2["Winding"] = 0] = "Winding";
  PdfFillMode2[PdfFillMode2["Alternate"] = 1] = "Alternate";
})(PdfFillMode || (PdfFillMode = {}));
var PdfColorSpace;
(function(PdfColorSpace2) {
  PdfColorSpace2[PdfColorSpace2["Rgb"] = 0] = "Rgb";
  PdfColorSpace2[PdfColorSpace2["Cmyk"] = 1] = "Cmyk";
  PdfColorSpace2[PdfColorSpace2["GrayScale"] = 2] = "GrayScale";
  PdfColorSpace2[PdfColorSpace2["Indexed"] = 3] = "Indexed";
})(PdfColorSpace || (PdfColorSpace = {}));
var PdfBlendMode;
(function(PdfBlendMode2) {
  PdfBlendMode2[PdfBlendMode2["Normal"] = 0] = "Normal";
  PdfBlendMode2[PdfBlendMode2["Multiply"] = 1] = "Multiply";
  PdfBlendMode2[PdfBlendMode2["Screen"] = 2] = "Screen";
  PdfBlendMode2[PdfBlendMode2["Overlay"] = 3] = "Overlay";
  PdfBlendMode2[PdfBlendMode2["Darken"] = 4] = "Darken";
  PdfBlendMode2[PdfBlendMode2["Lighten"] = 5] = "Lighten";
  PdfBlendMode2[PdfBlendMode2["ColorDodge"] = 6] = "ColorDodge";
  PdfBlendMode2[PdfBlendMode2["ColorBurn"] = 7] = "ColorBurn";
  PdfBlendMode2[PdfBlendMode2["HardLight"] = 8] = "HardLight";
  PdfBlendMode2[PdfBlendMode2["SoftLight"] = 9] = "SoftLight";
  PdfBlendMode2[PdfBlendMode2["Difference"] = 10] = "Difference";
  PdfBlendMode2[PdfBlendMode2["Exclusion"] = 11] = "Exclusion";
  PdfBlendMode2[PdfBlendMode2["Hue"] = 12] = "Hue";
  PdfBlendMode2[PdfBlendMode2["Saturation"] = 13] = "Saturation";
  PdfBlendMode2[PdfBlendMode2["Color"] = 14] = "Color";
  PdfBlendMode2[PdfBlendMode2["Luminosity"] = 15] = "Luminosity";
})(PdfBlendMode || (PdfBlendMode = {}));
var PdfGraphicsUnit;
(function(PdfGraphicsUnit2) {
  PdfGraphicsUnit2[PdfGraphicsUnit2["Centimeter"] = 0] = "Centimeter";
  PdfGraphicsUnit2[PdfGraphicsUnit2["Pica"] = 1] = "Pica";
  PdfGraphicsUnit2[PdfGraphicsUnit2["Pixel"] = 2] = "Pixel";
  PdfGraphicsUnit2[PdfGraphicsUnit2["Point"] = 3] = "Point";
  PdfGraphicsUnit2[PdfGraphicsUnit2["Inch"] = 4] = "Inch";
  PdfGraphicsUnit2[PdfGraphicsUnit2["Document"] = 5] = "Document";
  PdfGraphicsUnit2[PdfGraphicsUnit2["Millimeter"] = 6] = "Millimeter";
})(PdfGraphicsUnit || (PdfGraphicsUnit = {}));
var PdfGridImagePosition;
(function(PdfGridImagePosition2) {
  PdfGridImagePosition2[PdfGridImagePosition2["Fit"] = 0] = "Fit";
  PdfGridImagePosition2[PdfGridImagePosition2["Center"] = 1] = "Center";
  PdfGridImagePosition2[PdfGridImagePosition2["Stretch"] = 2] = "Stretch";
  PdfGridImagePosition2[PdfGridImagePosition2["Tile"] = 3] = "Tile";
})(PdfGridImagePosition || (PdfGridImagePosition = {}));
var PdfTextDirection;
(function(PdfTextDirection2) {
  PdfTextDirection2[PdfTextDirection2["None"] = 0] = "None";
  PdfTextDirection2[PdfTextDirection2["LeftToRight"] = 1] = "LeftToRight";
  PdfTextDirection2[PdfTextDirection2["RightToLeft"] = 2] = "RightToLeft";
})(PdfTextDirection || (PdfTextDirection = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-color.js
var PdfColor = (
  /** @class */
  (function() {
    function PdfColor2(color1, color2, color3, color4) {
      if (typeof color1 === "undefined") {
        if (typeof color2 !== "undefined" && typeof color3 !== "undefined" && typeof color4 !== "undefined") {
          this.assignRGB(color2, color3, color4);
        } else {
          this.filled = false;
        }
      } else if (color1 instanceof PdfColor2) {
        this.redColor = color1.r;
        this.greenColor = color1.g;
        this.blueColor = color1.b;
        this.grayColor = color1.gray;
        this.alpha = color1.alpha;
        this.filled = this.alpha !== 0;
      } else if (typeof color1 === "number" && typeof color2 === "undefined" && typeof color3 === "undefined" && typeof color4 === "undefined") {
        if (color1 < 0) {
          color1 = 0;
        }
        if (color1 > 1) {
          color1 = 1;
        }
        this.redColor = color1 * PdfColor2.maxColourChannelValue;
        this.greenColor = color1 * PdfColor2.maxColourChannelValue;
        this.blueColor = color1 * PdfColor2.maxColourChannelValue;
        this.cyanColor = color1;
        this.magentaColor = color1;
        this.yellowColor = color1;
        this.blackColor = color1;
        this.grayColor = color1;
        this.alpha = PdfColor2.maxColourChannelValue;
        this.filled = true;
      } else if (typeof color4 === "undefined") {
        this.assignRGB(color1, color2, color3);
      } else {
        this.assignRGB(color2, color3, color4, color1);
      }
    }
    PdfColor2.prototype.assignRGB = function(r, g, b, a) {
      if (typeof r === "undefined" || typeof g === "undefined" || typeof b === "undefined") {
        this.filled = false;
      } else {
        this.cyanColor = 0;
        this.magentaColor = 0;
        this.yellowColor = 0;
        this.blackColor = 0;
        this.grayColor = 0;
        this.redColor = r;
        this.greenColor = g;
        this.blueColor = b;
        if (typeof a === "undefined") {
          this.a = PdfColor2.maxColourChannelValue;
        } else {
          this.a = a;
          var isFractional = a >= 0 && a <= 1;
          var scaleFactor = isFractional ? a : a / 255;
          var inverseScale = 1 - scaleFactor;
          this.redColor = Math.max(0, Math.min(255, Math.round(r * scaleFactor + PdfColor2.maxColourChannelValue * inverseScale)));
          this.greenColor = Math.max(0, Math.min(255, Math.round(g * scaleFactor + PdfColor2.maxColourChannelValue * inverseScale)));
          this.blueColor = Math.max(0, Math.min(255, Math.round(b * scaleFactor + PdfColor2.maxColourChannelValue * inverseScale)));
        }
        this.filled = true;
        this.assignCMYK(r, g, b);
      }
    };
    PdfColor2.prototype.assignCMYK = function(r, g, b) {
      var red = r / PdfColor2.maxColourChannelValue;
      var green = g / PdfColor2.maxColourChannelValue;
      var blue = b / PdfColor2.maxColourChannelValue;
      var black = PdfNumber.min(1 - red, 1 - green, 1 - blue);
      var cyan = black === 1 ? 0 : (1 - red - black) / (1 - black);
      var magenta = black === 1 ? 0 : (1 - green - black) / (1 - black);
      var yellow = black === 1 ? 0 : (1 - blue - black) / (1 - black);
      this.blackColor = black;
      this.cyanColor = cyan;
      this.magentaColor = magenta;
      this.yellowColor = yellow;
    };
    Object.defineProperty(PdfColor2.prototype, "r", {
      //Properties
      // public static get Empty():PdfColor
      // {
      //     return this.s_emptyColor
      // }
      /**
       * Gets or sets `Red` channel value.
       * @private
       */
      get: function() {
        return this.redColor;
      },
      set: function(value) {
        this.redColor = value;
        this.assignCMYK(this.redColor, this.greenColor, this.blueColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "red", {
      /**
       * Gets the `Red` color
       * @private
       */
      get: function() {
        return this.r / PdfColor2.maxColourChannelValue;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "b", {
      /**
       * Gets or sets `Blue` channel value.
       * @private
       */
      get: function() {
        return this.blueColor;
      },
      set: function(value) {
        this.blueColor = value;
        this.assignCMYK(this.redColor, this.greenColor, this.blueColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "blue", {
      /**
       * Gets the `blue` color.
       * @private
       */
      get: function() {
        return this.b / PdfColor2.maxColourChannelValue;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "c", {
      /**
       * Gets or sets `Cyan` channel value.
       * @private
       */
      get: function() {
        return this.cyanColor;
      },
      set: function(value) {
        if (value < 0) {
          this.cyanColor = 0;
        } else if (value > 1) {
          this.cyanColor = 1;
        } else {
          this.cyanColor = value;
        }
        this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "k", {
      /**
       * Gets or sets `Black` channel value.
       * @private
       */
      get: function() {
        return this.blackColor;
      },
      set: function(value) {
        if (value < 0) {
          this.blackColor = 0;
        } else if (value > 1) {
          this.blackColor = 1;
        } else {
          this.blackColor = value;
        }
        this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "m", {
      /**
       * Gets or sets `Magenta` channel value.
       * @private
       */
      get: function() {
        return this.magentaColor;
      },
      set: function(value) {
        if (value < 0) {
          this.magentaColor = 0;
        } else if (value > 1) {
          this.magentaColor = 1;
        } else {
          this.magentaColor = value;
        }
        this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "y", {
      /**
       * Gets or sets `Yellow` channel value.
       * @private
       */
      get: function() {
        return this.yellowColor;
      },
      set: function(value) {
        if (value < 0) {
          this.yellowColor = 0;
        } else if (value > 1) {
          this.yellowColor = 1;
        } else {
          this.yellowColor = value;
        }
        this.assignRGB(this.cyanColor, this.magentaColor, this.yellowColor, this.blackColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "g", {
      /**
       *  Gets or sets `Green` channel value.
       * @private
       */
      get: function() {
        return this.greenColor;
      },
      set: function(value) {
        this.greenColor = value;
        this.assignCMYK(this.redColor, this.greenColor, this.blueColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "green", {
      /**
       * Gets the `Green` color.
       * @private
       */
      get: function() {
        return this.g / PdfColor2.maxColourChannelValue;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "gray", {
      /**
       * Gets or sets `Gray` channel value.
       * @private
       */
      get: function() {
        return (this.redColor + this.greenColor + this.blueColor) / (PdfColor2.maxColourChannelValue * 3);
      },
      set: function(value) {
        if (value < 0) {
          this.grayColor = 0;
        } else if (value > 1) {
          this.grayColor = 1;
        } else {
          this.grayColor = value;
        }
        this.r = this.grayColor * PdfColor2.maxColourChannelValue;
        this.g = this.grayColor * PdfColor2.maxColourChannelValue;
        this.b = this.grayColor * PdfColor2.maxColourChannelValue;
        this.assignCMYK(this.redColor, this.greenColor, this.blueColor);
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "isEmpty", {
      /**
       * Gets whether the PDFColor `is Empty` or not.
       * @private
       */
      get: function() {
        return !this.filled;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfColor2.prototype, "a", {
      /**
       * Gets or sets `Alpha` channel value.
       * @private
       */
      get: function() {
        return this.alpha;
      },
      set: function(value) {
        if (value < 0) {
          this.alpha = 0;
        } else {
          this.alpha = value;
        }
        this.filled = true;
      },
      enumerable: true,
      configurable: true
    });
    PdfColor2.prototype.toString = function(colorSpace, stroke) {
      if (this.isEmpty) {
        return "";
      }
      var str = "";
      switch (colorSpace) {
        case PdfColorSpace.Rgb:
          str = this.rgbToString(stroke);
          break;
        case PdfColorSpace.GrayScale:
          str = this.grayScaleToString(stroke);
          break;
        case PdfColorSpace.Cmyk:
          str = this.cmykToString(stroke);
          break;
      }
      return str;
    };
    PdfColor2.prototype.grayScaleToString = function(ifStroking) {
      var gray = this.gray;
      var colour = "";
      var obj = null;
      obj = ifStroking ? PdfColor2.grayStringsSroke.containsKey(gray) ? PdfColor2.grayStringsSroke.getValue(gray) : null : PdfColor2.grayStringsFill.containsKey(gray) ? PdfColor2.grayStringsFill.getValue(gray) : null;
      if (obj == null) {
        if (ifStroking) {
          colour = gray.toString() + " G";
          PdfColor2.grayStringsSroke.setValue(gray, colour);
        }
      } else {
        colour = obj.toString();
      }
      return colour + Operators.newLine;
    };
    PdfColor2.prototype.rgbToString = function(ifStroking) {
      var r = this.r;
      var g = this.g;
      var b = this.b;
      var key = (r << 16) + (g << 8) + b;
      if (ifStroking) {
        key += 1 << 24;
      }
      var colour = "";
      var obj = null;
      if (PdfColor2.rgbStrings.containsKey(key)) {
        obj = PdfColor2.rgbStrings.getValue(key);
      }
      if (obj == null) {
        var red = r / PdfColor2.maxColourChannelValue;
        var green = g / PdfColor2.maxColourChannelValue;
        var blue = b / PdfColor2.maxColourChannelValue;
        if (ifStroking) {
          colour = red.toString() + " " + green.toString() + " " + blue.toString() + " RG";
        } else {
          colour = red.toString() + " " + green.toString() + " " + blue.toString() + " rg";
        }
        PdfColor2.rgbStrings.setValue(key, colour);
      } else {
        colour = obj.toString();
      }
      return colour + Operators.newLine;
    };
    PdfColor2.prototype.cmykToString = function(ifStroking) {
      var cyan = this.c;
      var magenta = this.m;
      var yellow = this.y;
      var black = this.b;
      var colour = "";
      colour = cyan.toString() + " " + magenta.toString() + " " + yellow.toString() + " " + black.toString() + " K";
      return colour + Operators.newLine;
    };
    PdfColor2.prototype.toArray = function(colorSpace) {
      var array = new PdfArray();
      switch (colorSpace) {
        case PdfColorSpace.Rgb:
          array.add(new PdfNumber(this.red));
          array.add(new PdfNumber(this.green));
          array.add(new PdfNumber(this.blue));
          break;
      }
      return array;
    };
    PdfColor2.rgbStrings = new Dictionary();
    PdfColor2.grayStringsSroke = new Dictionary();
    PdfColor2.grayStringsFill = new Dictionary();
    PdfColor2.maxColourChannelValue = 255;
    return PdfColor2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/drawing/pdf-drawing.js
var PointF = (
  /** @class */
  /* @__PURE__ */ (function() {
    function PointF2(x, y) {
      if (typeof x === "undefined") {
        this.x = 0;
        this.y = 0;
      } else {
        if (x !== null) {
          this.x = x;
        } else {
          this.x = 0;
        }
        if (y !== null) {
          this.y = y;
        } else {
          this.y = 0;
        }
      }
    }
    return PointF2;
  })()
);
var SizeF = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SizeF2(width, height) {
      if (typeof height === "undefined") {
        this.height = 0;
        this.width = 0;
      } else {
        if (height !== null) {
          this.height = height;
        } else {
          this.height = 0;
        }
        if (width !== null) {
          this.width = width;
        } else {
          this.width = 0;
        }
      }
    }
    return SizeF2;
  })()
);
var RectangleF = (
  /** @class */
  /* @__PURE__ */ (function() {
    function RectangleF2(arg1, arg2, arg3, arg4) {
      if (typeof arg1 === typeof arg1 && typeof arg1 === "undefined") {
        this.x = 0;
        this.y = 0;
        this.height = 0;
        this.width = 0;
      } else {
        if (arg1 instanceof PointF && arg2 instanceof SizeF && typeof arg3 === "undefined") {
          var pointf = arg1;
          this.x = pointf.x;
          this.y = pointf.y;
          var sizef = arg2;
          this.height = sizef.height;
          this.width = sizef.width;
        } else {
          var x = arg1;
          var y = arg2;
          var width = arg3;
          var height = arg4;
          this.x = x;
          this.y = y;
          this.height = height;
          this.width = width;
        }
      }
    }
    return RectangleF2;
  })()
);
var Rectangle = (
  /** @class */
  (function() {
    function Rectangle2(left, top, right, bottom) {
      this.left = left;
      this.top = top;
      this.right = right;
      this.bottom = bottom;
    }
    Object.defineProperty(Rectangle2.prototype, "width", {
      /**
       * Gets a value of width
       */
      get: function() {
        return this.right - this.left;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "height", {
      /**
       * Gets a value of height
       */
      get: function() {
        return this.bottom - this.top;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "topLeft", {
      /**
       * Gets a value of Top and Left
       */
      get: function() {
        return new PointF(this.left, this.top);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "size", {
      /**
       * Gets a value of size
       */
      get: function() {
        return new SizeF(this.width, this.height);
      },
      enumerable: true,
      configurable: true
    });
    Rectangle2.prototype.toString = function() {
      return this.topLeft + "x" + this.size;
    };
    return Rectangle2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-brush.js
var PdfBrush = (
  /** @class */
  (function() {
    function PdfBrush2() {
    }
    PdfBrush2.prototype.clone = function() {
      return this;
    };
    return PdfBrush2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-solid-brush.js
var __extends25 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfSolidBrush = (
  /** @class */
  (function(_super) {
    __extends25(PdfSolidBrush2, _super);
    function PdfSolidBrush2(color) {
      var _this = _super.call(this) || this;
      _this.pdfColor = color;
      return _this;
    }
    Object.defineProperty(PdfSolidBrush2.prototype, "color", {
      //Properties
      /**
       * Gets or sets the `color` of the brush.
       * @private
       */
      get: function() {
        return this.pdfColor;
      },
      set: function(value) {
        this.pdfColor = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfSolidBrush2.prototype.monitorChanges = function(brush, streamWriter, getResources, saveChanges, currentColorSpace) {
      if (streamWriter == null) {
        throw new Error("ArgumentNullException:streamWriter");
      }
      var diff = false;
      if (brush == null) {
        diff = true;
        streamWriter.setColorAndSpace(this.pdfColor, currentColorSpace, false);
        return diff;
      } else {
        var sBrush = brush;
        diff = true;
        streamWriter.setColorAndSpace(this.pdfColor, currentColorSpace, false);
        return diff;
      }
    };
    PdfSolidBrush2.prototype.resetChanges = function(streamWriter) {
      streamWriter.setColorAndSpace(new PdfColor(0, 0, 0), PdfColorSpace.Rgb, false);
    };
    return PdfSolidBrush2;
  })(PdfBrush)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/enum.js
var PdfFontStyle;
(function(PdfFontStyle2) {
  PdfFontStyle2[PdfFontStyle2["Regular"] = 0] = "Regular";
  PdfFontStyle2[PdfFontStyle2["Bold"] = 1] = "Bold";
  PdfFontStyle2[PdfFontStyle2["Italic"] = 2] = "Italic";
  PdfFontStyle2[PdfFontStyle2["Underline"] = 4] = "Underline";
  PdfFontStyle2[PdfFontStyle2["Strikeout"] = 8] = "Strikeout";
})(PdfFontStyle || (PdfFontStyle = {}));
var PdfFontFamily;
(function(PdfFontFamily2) {
  PdfFontFamily2[PdfFontFamily2["Helvetica"] = 0] = "Helvetica";
  PdfFontFamily2[PdfFontFamily2["Courier"] = 1] = "Courier";
  PdfFontFamily2[PdfFontFamily2["TimesRoman"] = 2] = "TimesRoman";
  PdfFontFamily2[PdfFontFamily2["Symbol"] = 3] = "Symbol";
  PdfFontFamily2[PdfFontFamily2["ZapfDingbats"] = 4] = "ZapfDingbats";
})(PdfFontFamily || (PdfFontFamily = {}));
var PdfFontType;
(function(PdfFontType2) {
  PdfFontType2[PdfFontType2["Standard"] = 0] = "Standard";
  PdfFontType2[PdfFontType2["TrueType"] = 1] = "TrueType";
  PdfFontType2[PdfFontType2["TrueTypeEmbedded"] = 2] = "TrueTypeEmbedded";
})(PdfFontType || (PdfFontType = {}));
var PdfWordWrapType;
(function(PdfWordWrapType2) {
  PdfWordWrapType2[PdfWordWrapType2["None"] = 0] = "None";
  PdfWordWrapType2[PdfWordWrapType2["Word"] = 1] = "Word";
  PdfWordWrapType2[PdfWordWrapType2["WordOnly"] = 2] = "WordOnly";
  PdfWordWrapType2[PdfWordWrapType2["Character"] = 3] = "Character";
})(PdfWordWrapType || (PdfWordWrapType = {}));
var PdfSubSuperScript;
(function(PdfSubSuperScript2) {
  PdfSubSuperScript2[PdfSubSuperScript2["None"] = 0] = "None";
  PdfSubSuperScript2[PdfSubSuperScript2["SuperScript"] = 1] = "SuperScript";
  PdfSubSuperScript2[PdfSubSuperScript2["SubScript"] = 2] = "SubScript";
})(PdfSubSuperScript || (PdfSubSuperScript = {}));
var FontEncoding;
(function(FontEncoding2) {
  FontEncoding2[FontEncoding2["Unknown"] = 0] = "Unknown";
  FontEncoding2[FontEncoding2["StandardEncoding"] = 1] = "StandardEncoding";
  FontEncoding2[FontEncoding2["MacRomanEncoding"] = 2] = "MacRomanEncoding";
  FontEncoding2[FontEncoding2["MacExpertEncoding"] = 3] = "MacExpertEncoding";
  FontEncoding2[FontEncoding2["WinAnsiEncoding"] = 4] = "WinAnsiEncoding";
  FontEncoding2[FontEncoding2["PdfDocEncoding"] = 5] = "PdfDocEncoding";
  FontEncoding2[FontEncoding2["IdentityH"] = 6] = "IdentityH";
})(FontEncoding || (FontEncoding = {}));
var TtfCmapFormat;
(function(TtfCmapFormat2) {
  TtfCmapFormat2[TtfCmapFormat2["Apple"] = 0] = "Apple";
  TtfCmapFormat2[TtfCmapFormat2["Microsoft"] = 4] = "Microsoft";
  TtfCmapFormat2[TtfCmapFormat2["Trimmed"] = 6] = "Trimmed";
})(TtfCmapFormat || (TtfCmapFormat = {}));
var TtfCmapEncoding;
(function(TtfCmapEncoding2) {
  TtfCmapEncoding2[TtfCmapEncoding2["Unknown"] = 0] = "Unknown";
  TtfCmapEncoding2[TtfCmapEncoding2["Symbol"] = 1] = "Symbol";
  TtfCmapEncoding2[TtfCmapEncoding2["Unicode"] = 2] = "Unicode";
  TtfCmapEncoding2[TtfCmapEncoding2["Macintosh"] = 3] = "Macintosh";
})(TtfCmapEncoding || (TtfCmapEncoding = {}));
var TtfPlatformID;
(function(TtfPlatformID2) {
  TtfPlatformID2[TtfPlatformID2["AppleUnicode"] = 0] = "AppleUnicode";
  TtfPlatformID2[TtfPlatformID2["Macintosh"] = 1] = "Macintosh";
  TtfPlatformID2[TtfPlatformID2["Iso"] = 2] = "Iso";
  TtfPlatformID2[TtfPlatformID2["Microsoft"] = 3] = "Microsoft";
})(TtfPlatformID || (TtfPlatformID = {}));
var TtfMicrosoftEncodingID;
(function(TtfMicrosoftEncodingID2) {
  TtfMicrosoftEncodingID2[TtfMicrosoftEncodingID2["Undefined"] = 0] = "Undefined";
  TtfMicrosoftEncodingID2[TtfMicrosoftEncodingID2["Unicode"] = 1] = "Unicode";
})(TtfMicrosoftEncodingID || (TtfMicrosoftEncodingID = {}));
var TtfMacintoshEncodingID;
(function(TtfMacintoshEncodingID2) {
  TtfMacintoshEncodingID2[TtfMacintoshEncodingID2["Roman"] = 0] = "Roman";
  TtfMacintoshEncodingID2[TtfMacintoshEncodingID2["Japanese"] = 1] = "Japanese";
  TtfMacintoshEncodingID2[TtfMacintoshEncodingID2["Chinese"] = 2] = "Chinese";
})(TtfMacintoshEncodingID || (TtfMacintoshEncodingID = {}));
var FontDescriptorFlags;
(function(FontDescriptorFlags2) {
  FontDescriptorFlags2[FontDescriptorFlags2["FixedPitch"] = 1] = "FixedPitch";
  FontDescriptorFlags2[FontDescriptorFlags2["Serif"] = 2] = "Serif";
  FontDescriptorFlags2[FontDescriptorFlags2["Symbolic"] = 4] = "Symbolic";
  FontDescriptorFlags2[FontDescriptorFlags2["Script"] = 8] = "Script";
  FontDescriptorFlags2[FontDescriptorFlags2["Nonsymbolic"] = 32] = "Nonsymbolic";
  FontDescriptorFlags2[FontDescriptorFlags2["Italic"] = 64] = "Italic";
  FontDescriptorFlags2[FontDescriptorFlags2["ForceBold"] = 262144] = "ForceBold";
})(FontDescriptorFlags || (FontDescriptorFlags = {}));
var TtfCompositeGlyphFlags;
(function(TtfCompositeGlyphFlags2) {
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["Arg1And2AreWords"] = 1] = "Arg1And2AreWords";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["ArgsAreXyValues"] = 2] = "ArgsAreXyValues";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["RoundXyToGrid"] = 4] = "RoundXyToGrid";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["WeHaveScale"] = 8] = "WeHaveScale";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["Reserved"] = 16] = "Reserved";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["MoreComponents"] = 32] = "MoreComponents";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["WeHaveAnXyScale"] = 64] = "WeHaveAnXyScale";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["WeHaveTwoByTwo"] = 128] = "WeHaveTwoByTwo";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["WeHaveInstructions"] = 256] = "WeHaveInstructions";
  TtfCompositeGlyphFlags2[TtfCompositeGlyphFlags2["UseMyMetrics"] = 512] = "UseMyMetrics";
})(TtfCompositeGlyphFlags || (TtfCompositeGlyphFlags = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/pdf-string-format.js
var PdfStringFormat = (
  /** @class */
  (function() {
    function PdfStringFormat2(arg1, arg2) {
      this.scalingFactor = 100;
      this.wordWrapType = PdfWordWrapType.Word;
      this.internalLineLimit = true;
      this.wordWrapType = PdfWordWrapType.Word;
      if (typeof arg1 !== "undefined" && typeof arg1 !== "string") {
        this.textAlignment = arg1;
      }
      if (typeof arg2 !== "undefined") {
        this.verticalAlignment = arg2;
      }
    }
    Object.defineProperty(PdfStringFormat2.prototype, "alignment", {
      //Properties
      /**
       * Gets or sets the `horizontal` text alignment
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // add a pages to the document
       * let page1 : PdfPage = document.pages.add();
       * // set font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // set brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * //
       * // set the format for string
       * let stringFormat : PdfStringFormat = new PdfStringFormat();
       * // set the text alignment
       * stringFormat.alignment = PdfTextAlignment.Center;
       * //
       * // draw the text
       * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.textAlignment;
      },
      set: function(value) {
        this.textAlignment = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "textDirection", {
      get: function() {
        return this.direction;
      },
      set: function(value) {
        this.direction = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "lineAlignment", {
      /**
       * Gets or sets the `vertical` text alignment.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // add a pages to the document
       * let page1 : PdfPage = document.pages.add();
       * // set font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // set brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * //
       * // set the format for string
       * let stringFormat : PdfStringFormat = new PdfStringFormat();
       * // set the vertical alignment
       * stringFormat.lineAlignment = PdfVerticalAlignment.Middle;
       * //
       * // draw the text
       * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        if (typeof this.verticalAlignment === "undefined" || this.verticalAlignment == null) {
          return PdfVerticalAlignment.Top;
        } else {
          return this.verticalAlignment;
        }
      },
      set: function(value) {
        this.verticalAlignment = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "rightToLeft", {
      /**
       * Gets or sets the value that indicates text `direction` mode.
       * @private
       */
      get: function() {
        if (typeof this.isRightToLeft === "undefined" || this.isRightToLeft == null) {
          return false;
        } else {
          return this.isRightToLeft;
        }
      },
      set: function(value) {
        this.isRightToLeft = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "characterSpacing", {
      /**
       * Gets or sets value that indicates a `size` among the characters in the text.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // add a pages to the document
       * let page1 : PdfPage = document.pages.add();
       * // set font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // set brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * //
       * // set the format for string
       * let stringFormat : PdfStringFormat = new PdfStringFormat();
       * // set character spacing
       * stringFormat.characterSpacing = 10;
       * //
       * // draw the text
       * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        if (typeof this.internalCharacterSpacing === "undefined" || this.internalCharacterSpacing == null) {
          return 0;
        } else {
          return this.internalCharacterSpacing;
        }
      },
      set: function(value) {
        this.internalCharacterSpacing = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "wordSpacing", {
      /**
       * Gets or sets value that indicates a `size` among the words in the text.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // add a pages to the document
       * let page1 : PdfPage = document.pages.add();
       * // set font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // set brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * //
       * // set the format for string
       * let stringFormat : PdfStringFormat = new PdfStringFormat();
       * // set word spacing
       * stringFormat.wordSpacing = 10;
       * //
       * // draw the text
       * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        if (typeof this.internalWordSpacing === "undefined" || this.internalWordSpacing == null) {
          return 0;
        } else {
          return this.internalWordSpacing;
        }
      },
      set: function(value) {
        this.internalWordSpacing = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "lineSpacing", {
      /**
       * Gets or sets value that indicates the `vertical distance` between the baselines of adjacent lines of text.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // add a pages to the document
       * let page1 : PdfPage = document.pages.add();
       * // set font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // set brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * // set string
       * let text : string = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
       * incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitati';
       * // set rectangle bounds
       * let rectangle : RectangleF = new RectangleF({x : 0, y : 0}, {width : 300, height : 100})
       * //
       * // set the format for string
       * let stringFormat : PdfStringFormat = new PdfStringFormat();
       * // set line spacing
       * stringFormat.lineSpacing = 10;
       * //
       * // draw the text
       * page1.graphics.drawString(text, font, blackBrush, rectangle, stringFormat);
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        if (typeof this.leading === "undefined" || this.leading == null) {
          return 0;
        } else {
          return this.leading;
        }
      },
      set: function(value) {
        this.leading = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "clipPath", {
      /**
       * Gets or sets a value indicating whether the text is `clipped` or not.
       * @private
       */
      get: function() {
        if (typeof this.clip === "undefined" || this.clip == null) {
          return false;
        } else {
          return this.clip;
        }
      },
      set: function(value) {
        this.clip = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "subSuperScript", {
      /**
       * Gets or sets value indicating whether the text is in `subscript or superscript` mode.
       * @private
       */
      get: function() {
        if (typeof this.pdfSubSuperScript === "undefined" || this.pdfSubSuperScript == null) {
          return PdfSubSuperScript.None;
        } else {
          return this.pdfSubSuperScript;
        }
      },
      set: function(value) {
        this.pdfSubSuperScript = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "paragraphIndent", {
      /**
       * Gets or sets the `indent` of the first line in the paragraph.
       * @private
       */
      get: function() {
        if (typeof this.internalParagraphIndent === "undefined" || this.internalParagraphIndent == null) {
          return 0;
        } else {
          return this.internalParagraphIndent;
        }
      },
      set: function(value) {
        this.internalParagraphIndent = value;
        this.firstLineIndent = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "lineLimit", {
      /**
       * Gets or sets a value indicating whether [`line limit`].
       * @private
       */
      get: function() {
        return this.internalLineLimit;
      },
      set: function(value) {
        this.internalLineLimit = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "measureTrailingSpaces", {
      /**
       * Gets or sets a value indicating whether [`measure trailing spaces`].
       * @private
       */
      get: function() {
        if (typeof this.trailingSpaces === "undefined" || this.trailingSpaces == null) {
          return false;
        } else {
          return this.trailingSpaces;
        }
      },
      set: function(value) {
        this.trailingSpaces = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "noClip", {
      /**
       * Gets or sets a value indicating whether [`no clip`].
       * @private
       */
      get: function() {
        if (typeof this.isNoClip === "undefined" || this.isNoClip == null) {
          return false;
        } else {
          return this.isNoClip;
        }
      },
      set: function(value) {
        this.isNoClip = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "wordWrap", {
      /**
       * Gets or sets value indicating type of the text `wrapping`.
       * @private
       */
      get: function() {
        return this.wordWrapType;
      },
      set: function(value) {
        this.wordWrapType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "horizontalScalingFactor", {
      /**
       * Gets or sets the `scaling factor`.
       * @private
       */
      get: function() {
        return this.scalingFactor;
      },
      set: function(value) {
        if (value <= 0) {
          throw new Error("ArgumentOutOfRangeException:The scaling factor cant be less of equal to zero, ScalingFactor");
        }
        this.scalingFactor = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringFormat2.prototype, "firstLineIndent", {
      /**
       * Gets or sets the `indent` of the first line in the text.
       * @private
       */
      get: function() {
        if (typeof this.initialLineIndent === "undefined" || this.initialLineIndent == null) {
          return 0;
        } else {
          return this.initialLineIndent;
        }
      },
      set: function(value) {
        this.initialLineIndent = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfStringFormat2.prototype.clone = function() {
      var format = this;
      return format;
    };
    return PdfStringFormat2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/string-tokenizer.js
var StringTokenizer = (
  /** @class */
  (function() {
    function StringTokenizer2(textValue) {
      this.currentPosition = 0;
      if (textValue == null) {
        throw new Error("ArgumentNullException:text");
      }
      this.text = textValue;
    }
    Object.defineProperty(StringTokenizer2.prototype, "length", {
      // Properties
      /**
       * Gets text `length`.
       * @private
       */
      get: function() {
        return this.text.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(StringTokenizer2.prototype, "end", {
      get: function() {
        return this.currentPosition === this.text.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(StringTokenizer2.prototype, "position", {
      /**
       * Gets or sets the position.
       * @private
       */
      get: function() {
        return this.currentPosition;
      },
      set: function(value) {
        this.currentPosition = value;
      },
      enumerable: true,
      configurable: true
    });
    StringTokenizer2.getCharsCount = function(text, symbols) {
      if (typeof symbols === "string") {
        if (text == null) {
          throw new Error("ArgumentNullException:wholeText");
        }
        var numSymbols = 0;
        var curIndex = 0;
        for (; ; ) {
          curIndex = text.indexOf(symbols, curIndex);
          if (curIndex === -1) {
            break;
          } else {
            numSymbols++;
            curIndex++;
          }
        }
        return numSymbols;
      } else {
        if (text == null) {
          throw new Error("ArgumentNullException:text");
        }
        if (symbols == null) {
          throw new Error("ArgumentNullException:symbols");
        }
        var count = 0;
        for (var i = 0, len = text.length; i < len; i++) {
          var ch = text[i];
          if (this.contains(symbols, ch)) {
            count++;
          }
        }
        return count;
      }
    };
    StringTokenizer2.prototype.readLine = function() {
      var pos = this.currentPosition;
      while (pos < this.length) {
        var ch = this.text[pos];
        switch (ch) {
          case "\r":
          case "\n": {
            var text = this.text.substr(this.currentPosition, pos - this.currentPosition);
            this.currentPosition = pos + 1;
            if (ch === "\r" && this.currentPosition < this.length && this.text[this.currentPosition] === "\n") {
              this.currentPosition++;
            }
            return text;
          }
        }
        pos++;
      }
      if (pos > this.currentPosition) {
        var text2 = this.text.substr(this.currentPosition, pos - this.currentPosition);
        this.currentPosition = pos;
        return text2;
      }
      return null;
    };
    StringTokenizer2.prototype.peekLine = function() {
      var pos = this.currentPosition;
      var line = this.readLine();
      this.currentPosition = pos;
      return line;
    };
    StringTokenizer2.prototype.readWord = function() {
      var pos = this.currentPosition;
      while (pos < this.length) {
        var ch = this.text[pos];
        switch (ch) {
          case "\r":
          case "\n":
            var textValue = this.text.substr(this.currentPosition, pos - this.currentPosition);
            this.currentPosition = pos + 1;
            if (ch === "\r" && this.currentPosition < this.length && this.text[this.currentPosition] === "\n") {
              this.currentPosition++;
            }
            return textValue;
          case " ":
          case "	": {
            if (pos === this.currentPosition) {
              pos++;
            }
            var text = this.text.substr(this.currentPosition, pos - this.currentPosition);
            this.currentPosition = pos;
            return text;
          }
        }
        pos++;
      }
      if (pos > this.currentPosition) {
        var text2 = this.text.substr(this.currentPosition, pos - this.currentPosition);
        this.currentPosition = pos;
        return text2;
      }
      return null;
    };
    StringTokenizer2.prototype.peekWord = function() {
      var pos = this.currentPosition;
      var word = this.readWord();
      this.currentPosition = pos;
      return word;
    };
    StringTokenizer2.prototype.read = function(count) {
      if (typeof count === "undefined") {
        var ch = "0";
        if (!this.end) {
          ch = this.text[this.currentPosition];
          this.currentPosition++;
        }
        return ch;
      } else {
        var num = 0;
        var builder = "";
        while (!this.end && num < count) {
          var ch = this.read();
          builder = builder + ch;
          num++;
        }
        return builder;
      }
    };
    StringTokenizer2.prototype.peek = function() {
      var ch = "0";
      if (!this.end) {
        ch = this.text[this.currentPosition];
      }
      return ch;
    };
    StringTokenizer2.prototype.close = function() {
      this.text = null;
    };
    StringTokenizer2.prototype.readToEnd = function() {
      var text;
      if (this.currentPosition === 0) {
        text = this.text;
      } else {
        text = this.text.substr(this.currentPosition, this.length - this.currentPosition);
      }
      this.currentPosition = this.length;
      return text;
    };
    StringTokenizer2.contains = function(array, symbol) {
      var contains = false;
      for (var i = 0; i < array.length; i++) {
        if (array[i] === symbol) {
          contains = true;
          break;
        }
      }
      return contains;
    };
    StringTokenizer2.whiteSpace = " ";
    StringTokenizer2.tab = "	";
    StringTokenizer2.spaces = [StringTokenizer2.whiteSpace, StringTokenizer2.tab];
    StringTokenizer2.whiteSpacePattern = "^[ 	]+$";
    return StringTokenizer2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/string-layouter.js
var PdfStringLayouter = (
  /** @class */
  (function() {
    function PdfStringLayouter2() {
      this.isOverloadWithPosition = false;
    }
    PdfStringLayouter2.prototype.layout = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      if (arg4 instanceof RectangleF) {
        this.initialize(arg1, arg2, arg3, arg4, arg5);
        this.isOverloadWithPosition = arg6;
        this.clientSize = arg7;
        var result = this.doLayout();
        this.clear();
        return result;
      } else {
        this.initialize(arg1, arg2, arg3, arg4);
        this.isOverloadWithPosition = arg5;
        this.clientSize = arg6;
        var result = this.doLayout();
        this.clear();
        return result;
      }
    };
    PdfStringLayouter2.prototype.initialize = function(text, font, format, rectSize, pageHeight) {
      if (typeof pageHeight === "number") {
        if (text == null) {
          throw new Error("ArgumentNullException:text");
        }
        if (font == null) {
          throw new Error("ArgumentNullException:font");
        }
        this.text = text;
        this.font = font;
        this.format = format;
        this.size = new SizeF(rectSize.width, rectSize.height);
        this.rectangle = rectSize;
        this.pageHeight = pageHeight;
        this.reader = new StringTokenizer(text);
      } else {
        this.initialize(text, font, format, new RectangleF(new PointF(0, 0), rectSize), 0);
      }
    };
    PdfStringLayouter2.prototype.clear = function() {
      this.font = null;
      this.format = null;
      this.reader.close();
      this.reader = null;
      this.text = null;
    };
    PdfStringLayouter2.prototype.doLayout = function() {
      var result = new PdfStringLayoutResult();
      var lineResult = new PdfStringLayoutResult();
      var lines = [];
      var line = this.reader.peekLine();
      var lineIndent = this.getLineIndent(true);
      while (line != null) {
        lineResult = this.layoutLine(line, lineIndent);
        if (lineResult !== null || typeof lineResult !== "undefined") {
          var numSymbolsInserted = 0;
          var returnedValue = this.copyToResult(
            result,
            lineResult,
            lines,
            /*out*/
            numSymbolsInserted
          );
          var success = returnedValue.success;
          numSymbolsInserted = returnedValue.numInserted;
          if (!success) {
            this.reader.read(numSymbolsInserted);
            break;
          }
        }
        this.reader.readLine();
        line = this.reader.peekLine();
        lineIndent = this.getLineIndent(false);
      }
      this.finalizeResult(result, lines);
      return result;
    };
    PdfStringLayouter2.prototype.getLineIndent = function(firstLine) {
      var lineIndent = 0;
      if (this.format != null) {
        lineIndent = firstLine ? this.format.firstLineIndent : this.format.paragraphIndent;
        lineIndent = this.size.width > 0 ? Math.min(this.size.width, lineIndent) : lineIndent;
      }
      return lineIndent;
    };
    PdfStringLayouter2.prototype.getLineHeight = function() {
      var height = this.font.height;
      if (this.format != null && this.format.lineSpacing !== 0) {
        height = this.format.lineSpacing + this.font.height;
      }
      return height;
    };
    PdfStringLayouter2.prototype.getLineWidth = function(line) {
      var width = this.font.getLineWidth(line, this.format);
      return width;
    };
    PdfStringLayouter2.prototype.layoutLine = function(line, lineIndent) {
      var lineResult = new PdfStringLayoutResult();
      lineResult.layoutLineHeight = this.getLineHeight();
      var lines = [];
      var maxWidth = this.size.width;
      var lineWidth = this.getLineWidth(line) + lineIndent;
      var lineType = LineType.FirstParagraphLine;
      var readWord = true;
      if (maxWidth <= 0 || Math.round(lineWidth) <= Math.round(maxWidth)) {
        this.addToLineResult(lineResult, lines, line, lineWidth, LineType.NewLineBreak | lineType);
      } else {
        var builder = "";
        var curLine = "";
        lineWidth = lineIndent;
        var curIndent = lineIndent;
        var reader = new StringTokenizer(line);
        var word = reader.peekWord();
        var isSingleWord = false;
        if (word.length !== reader.length) {
          if (word === " ") {
            curLine = curLine + word;
            builder = builder + word;
            reader.position += 1;
            word = reader.peekWord();
          }
        }
        while (word != null) {
          curLine = curLine + word;
          var curLineWidth = this.getLineWidth(curLine.toString()) + curIndent;
          if (curLine.toString() === " ") {
            curLine = "";
            curLineWidth = 0;
          }
          if (curLineWidth > maxWidth) {
            if (this.getWrapType() === PdfWordWrapType.None) {
              break;
            }
            if (curLine.length === word.length) {
              if (this.getWrapType() === PdfWordWrapType.WordOnly) {
                lineResult.textRemainder = line.substring(reader.position);
                break;
              } else if (curLine.length === 1) {
                builder = builder + word;
                break;
              } else {
                readWord = false;
                curLine = "";
                word = reader.peek().toString();
                continue;
              }
            } else {
              if (this.getLineWidth(word.toString()) > maxWidth) {
                this.format.wordWrap = PdfWordWrapType.Character;
              } else {
                if (typeof this.format !== "undefined" && this.format !== null) {
                  this.format.wordWrap = PdfWordWrapType.Word;
                }
              }
              if (this.getWrapType() !== PdfWordWrapType.Character || !readWord) {
                var ln = builder.toString();
                if (ln !== " ") {
                  this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.LayoutBreak | lineType);
                }
                if (this.isOverloadWithPosition) {
                  maxWidth = this.clientSize.width;
                }
                curLine = "";
                builder = "";
                lineWidth = 0;
                curIndent = 0;
                curLineWidth = 0;
                lineType = LineType.None;
                word = readWord ? word : reader.peekWord();
                readWord = true;
              } else {
                readWord = false;
                curLine = "";
                curLine = curLine + builder.toString();
                word = reader.peek().toString();
              }
              continue;
            }
          }
          builder = builder + word;
          lineWidth = curLineWidth;
          if (readWord) {
            reader.readWord();
            word = reader.peekWord();
          } else {
            reader.read();
            word = reader.peek().toString();
          }
        }
        if (builder.length > 0) {
          var ln = builder.toString();
          this.addToLineResult(lineResult, lines, ln, lineWidth, LineType.NewLineBreak | LineType.LastParagraphLine);
        }
        reader.close();
      }
      lineResult.layoutLines = [];
      for (var index = 0; index < lines.length; index++) {
        lineResult.layoutLines.push(lines[index]);
      }
      lines = [];
      return lineResult;
    };
    PdfStringLayouter2.prototype.addToLineResult = function(lineResult, lines, line, lineWidth, breakType) {
      var info = new LineInfo();
      info.text = line;
      info.width = lineWidth;
      info.lineType = breakType;
      lines.push(info);
      var size = lineResult.actualSize;
      size.height += this.getLineHeight();
      size.width = Math.max(size.width, lineWidth);
      lineResult.size = size;
    };
    PdfStringLayouter2.prototype.copyToResult = function(result, lineResult, lines, numInserted) {
      var success = true;
      var allowPartialLines = this.format != null && !this.format.lineLimit;
      var height = result.actualSize.height;
      var maxHeight = this.size.height;
      if (this.pageHeight > 0 && maxHeight + this.rectangle.y > this.pageHeight) {
        maxHeight = this.rectangle.y - this.pageHeight;
        maxHeight = Math.max(maxHeight, -maxHeight);
      }
      numInserted = 0;
      if (lineResult.lines != null) {
        for (var i = 0, len = lineResult.lines.length; i < len; i++) {
          var expHeight = height + lineResult.lineHeight;
          if (expHeight <= maxHeight || maxHeight <= 0 || allowPartialLines) {
            var info = lineResult.lines[i];
            numInserted += info.text.length;
            info = this.trimLine(info, lines.length === 0);
            lines.push(info);
            var size = result.actualSize;
            size.width = Math.max(size.width, info.width);
            result.size = size;
            height = expHeight;
          } else {
            success = false;
            break;
          }
        }
      }
      if (height != result.size.height) {
        var size1 = result.actualSize;
        size1.height = height;
        result.size = size1;
      }
      return { success, numInserted };
    };
    PdfStringLayouter2.prototype.finalizeResult = function(result, lines) {
      result.layoutLines = [];
      for (var index = 0; index < lines.length; index++) {
        result.layoutLines.push(lines[index]);
      }
      result.layoutLineHeight = this.getLineHeight();
      if (!this.reader.end) {
        result.textRemainder = this.reader.readToEnd();
      }
      lines = [];
    };
    PdfStringLayouter2.prototype.trimLine = function(info, firstLine) {
      var line = info.text;
      var lineWidth = info.width;
      var trimStartSpaces = (info.lineType & LineType.FirstParagraphLine) === 0;
      var start = this.format == null || !this.format.rightToLeft;
      var spaces = StringTokenizer.spaces;
      line = start ? line.trim() : line.trim();
      if (line.length !== info.text.length) {
        lineWidth = this.getLineWidth(line);
        if ((info.lineType & LineType.FirstParagraphLine) > 0) {
          lineWidth += this.getLineIndent(firstLine);
        }
      }
      info.text = line;
      info.width = lineWidth;
      return info;
    };
    PdfStringLayouter2.prototype.getWrapType = function() {
      var wrapType = this.format != null ? this.format.wordWrap : PdfWordWrapType.Word;
      return wrapType;
    };
    return PdfStringLayouter2;
  })()
);
var PdfStringLayoutResult = (
  /** @class */
  (function() {
    function PdfStringLayoutResult2() {
    }
    Object.defineProperty(PdfStringLayoutResult2.prototype, "remainder", {
      // Properties
      /**
       * Gets the `text` which is not lay outed.
       * @private
       */
      get: function() {
        return this.textRemainder;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringLayoutResult2.prototype, "actualSize", {
      /**
       * Gets the actual layout text `bounds`.
       * @private
       */
      get: function() {
        if (typeof this.size === "undefined") {
          this.size = new SizeF(0, 0);
        }
        return this.size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringLayoutResult2.prototype, "lines", {
      /**
       * Gets layout `lines` information.
       * @private
       */
      get: function() {
        return this.layoutLines;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringLayoutResult2.prototype, "lineHeight", {
      /**
       * Gets the `height` of the line.
       * @private
       */
      get: function() {
        return this.layoutLineHeight;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringLayoutResult2.prototype, "empty", {
      /**
       * Gets value that indicates whether any layout text [`empty`].
       * @private
       */
      get: function() {
        return this.layoutLines == null || this.layoutLines.length === 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStringLayoutResult2.prototype, "lineCount", {
      /**
       * Gets `number of` the layout lines.
       * @private
       */
      get: function() {
        var count = !this.empty ? this.layoutLines.length : 0;
        return count;
      },
      enumerable: true,
      configurable: true
    });
    return PdfStringLayoutResult2;
  })()
);
var LineInfo = (
  /** @class */
  (function() {
    function LineInfo2() {
    }
    Object.defineProperty(LineInfo2.prototype, "lineType", {
      //Properties
      /**
       * Gets the `type` of the line text.
       * @private
       */
      get: function() {
        return this.type;
      },
      set: function(value) {
        this.type = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LineInfo2.prototype, "text", {
      /**
       * Gets the line `text`.
       * @private
       */
      get: function() {
        return this.content;
      },
      set: function(value) {
        this.content = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(LineInfo2.prototype, "width", {
      /**
       * Gets `width` of the line text.
       * @private
       */
      get: function() {
        return this.lineWidth;
      },
      set: function(value) {
        this.lineWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    return LineInfo2;
  })()
);
var LineType;
(function(LineType2) {
  LineType2[LineType2["None"] = 0] = "None";
  LineType2[LineType2["NewLineBreak"] = 1] = "NewLineBreak";
  LineType2[LineType2["LayoutBreak"] = 2] = "LayoutBreak";
  LineType2[LineType2["FirstParagraphLine"] = 4] = "FirstParagraphLine";
  LineType2[LineType2["LastParagraphLine"] = 8] = "LastParagraphLine";
})(LineType || (LineType = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/pdf-font.js
var PdfFont = (
  /** @class */
  (function() {
    function PdfFont2(size, style) {
      this.fontStyle = PdfFontStyle.Regular;
      if (typeof size === "number" && typeof style === "undefined") {
        this.fontSize = size;
      } else {
        this.fontSize = size;
        this.setStyle(style);
      }
    }
    Object.defineProperty(PdfFont2.prototype, "name", {
      //Properties
      /**
       * Gets the face name of this Font.
       * @private
       */
      get: function() {
        return this.metrics.name;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "size", {
      /**
       * Gets the size of this font.
       * @private
       */
      get: function() {
        return this.fontSize;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "height", {
      /**
       * Gets the height of the font in points.
       * @private
       */
      get: function() {
        return this.metrics.getHeight(null);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "style", {
      /**
       * Gets the style information for this font.
       * @private
       */
      get: function() {
        return this.fontStyle;
      },
      set: function(value) {
        this.fontStyle = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "bold", {
      /**
       * Gets a value indicating whether this `PdfFont` is `bold`.
       * @private
       */
      get: function() {
        return (this.style & PdfFontStyle.Bold) > 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "italic", {
      /**
       * Gets a value indicating whether this `PdfFont` has the `italic` style applied.
       * @private
       */
      get: function() {
        return (this.style & PdfFontStyle.Italic) > 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "strikeout", {
      /**
       * Gets a value indicating whether this `PdfFont` is `strikeout`.
       * @private
       */
      get: function() {
        return (this.style & PdfFontStyle.Strikeout) > 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "underline", {
      /**
       * Gets a value indicating whether this `PdfFont` is `underline`.
       * @private
       */
      get: function() {
        return (this.style & PdfFontStyle.Underline) > 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "metrics", {
      /**
       * Gets or sets the `metrics` for this font.
       * @private
       */
      get: function() {
        return this.fontMetrics;
      },
      set: function(value) {
        this.fontMetrics = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFont2.prototype, "element", {
      // /**
      //  * Gets and Sets the font `internals`.
      //  * @private
      //  */
      // public get fontInternal() : IPdfPrimitive {
      //     return this.pdfFontInternals;
      // }
      // public set fontInternal(value : IPdfPrimitive) {
      //     this.pdfFontInternals = value;
      // }
      //IPdfWrapper Members
      /**
       * Gets the `element` representing the font.
       * @private
       */
      get: function() {
        return this.pdfFontInternals;
      },
      enumerable: true,
      configurable: true
    });
    PdfFont2.prototype.measureString = function(text, arg2, arg3, arg4, arg5) {
      if (typeof text === "string" && typeof arg2 === "undefined") {
        return this.measureString(text, null);
      } else if (typeof text === "string" && (arg2 instanceof PdfStringFormat || arg2 == null) && typeof arg3 === "undefined" && typeof arg4 === "undefined") {
        var temparg2 = arg2;
        var charactersFitted = 0;
        var linesFilled = 0;
        return this.measureString(text, temparg2, charactersFitted, linesFilled);
      } else if (typeof text === "string" && (arg2 instanceof PdfStringFormat || arg2 == null) && typeof arg3 === "number" && typeof arg4 === "number") {
        var temparg2 = arg2;
        return this.measureString(text, 0, temparg2, arg3, arg4);
      } else if (typeof text === "string" && typeof arg2 === "number" && (arg3 instanceof PdfStringFormat || arg3 == null) && typeof arg4 === "number" && typeof arg5 === "number") {
        var layoutArea = new SizeF(arg2, 0);
        var temparg3 = arg3;
        return this.measureString(text, layoutArea, temparg3, arg4, arg5);
      } else {
        if (text == null) {
          throw Error('ArgumentNullException("text")');
        }
        var temparg2 = arg2;
        var temparg3 = arg3;
        var layouter = new PdfStringLayouter();
        var result = layouter.layout(text, this, temparg3, temparg2, false, new SizeF(0, 0));
        arg4 = text.length;
        arg5 = result.empty ? 0 : result.lines.length;
        return result.actualSize;
      }
    };
    PdfFont2.prototype.equalsTo = function(obj) {
      var result = this.equalsToFont(obj);
      return result;
    };
    PdfFont2.prototype.getInternals = function() {
      return this.pdfFontInternals;
    };
    PdfFont2.prototype.setInternals = function(internals) {
      if (internals == null) {
        throw new Error("ArgumentNullException:internals");
      }
      this.pdfFontInternals = internals;
    };
    PdfFont2.prototype.setStyle = function(style) {
      this.fontStyle = style;
    };
    PdfFont2.prototype.applyFormatSettings = function(line, format, width) {
      var realWidth = width;
      if (format != null && width > 0) {
        if (format.characterSpacing !== 0) {
          realWidth += (line.length - 1) * format.characterSpacing;
        }
        if (format.wordSpacing !== 0) {
          var symbols = StringTokenizer.spaces;
          var whitespacesCount = StringTokenizer.getCharsCount(line, symbols);
          realWidth += whitespacesCount * format.wordSpacing;
        }
      }
      return realWidth;
    };
    PdfFont2.charSizeMultiplier = 1e-3;
    PdfFont2.syncObject = new Object();
    return PdfFont2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/pdf-writer.js
var PdfWriter = (
  /** @class */
  (function() {
    function PdfWriter2(stream) {
      this.streamWriter = stream;
    }
    Object.defineProperty(PdfWriter2.prototype, "document", {
      //properties
      /**
       * Gets and Sets the `document`.
       * @private
       */
      get: function() {
        return this.pdfDocument;
      },
      set: function(value) {
        this.pdfDocument = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfWriter2.prototype, "position", {
      /**
       * Gets the `position`.
       * @private
       */
      get: function() {
        return this.streamWriter.buffer.size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfWriter2.prototype, "length", {
      /**
       * Gets  the `length` of the stream'.
       * @private
       */
      get: function() {
        return this.streamWriter.buffer.size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfWriter2.prototype, "stream", {
      /**
       * Gets the `stream`.
       * @private
       */
      get: function() {
        return this.streamWriter;
      },
      enumerable: true,
      configurable: true
    });
    PdfWriter2.prototype.write = function(overload) {
      var data = [];
      var tempOverload = overload;
      this.streamWriter.write(tempOverload);
    };
    return PdfWriter2;
  })()
);
var PdfWriterHelper = (
  /** @class */
  (function() {
    function PdfWriterHelper2() {
      this.buffer = new PdfArrayBuffer();
    }
    PdfWriterHelper2.prototype.write = function(data) {
      this.buffer.write(data);
    };
    PdfWriterHelper2.prototype.destroy = function() {
      if (this.buffer) {
        this.buffer.destroy();
        this.buffer = void 0;
      }
    };
    return PdfWriterHelper2;
  })()
);
var PdfArrayBuffer = (
  /** @class */
  (function() {
    function PdfArrayBuffer2() {
      this.buffer = [];
    }
    Object.defineProperty(PdfArrayBuffer2.prototype, "size", {
      /**
       * Gets the `size`.
       * @private
       */
      get: function() {
        return this.buffer.length;
      },
      enumerable: true,
      configurable: true
    });
    PdfArrayBuffer2.prototype.write = function(value) {
      for (var i = 0; i < value.length; i++) {
        this.buffer.push(value.charCodeAt(i) & 255);
      }
    };
    PdfArrayBuffer2.prototype.destroy = function() {
      if (this.buffer) {
        this.buffer = [];
        this.buffer = void 0;
      }
    };
    return PdfArrayBuffer2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/enum.js
var ObjectStatus;
(function(ObjectStatus2) {
  ObjectStatus2[ObjectStatus2["None"] = 0] = "None";
  ObjectStatus2[ObjectStatus2["Registered"] = 1] = "Registered";
})(ObjectStatus || (ObjectStatus = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/pdf-main-object-collection.js
var PdfMainObjectCollection = (
  /** @class */
  (function() {
    function PdfMainObjectCollection2() {
      this.objectCollections = [];
      this.mainObjectCollection = new Dictionary();
      this.primitiveObjectCollection = new Dictionary();
    }
    Object.defineProperty(PdfMainObjectCollection2.prototype, "count", {
      //Properties
      /**
       * Gets the `count`.
       * @private
       */
      get: function() {
        return this.objectCollections.length;
      },
      enumerable: true,
      configurable: true
    });
    PdfMainObjectCollection2.prototype.items = function(index) {
      return this.objectCollections[index];
    };
    Object.defineProperty(PdfMainObjectCollection2.prototype, "outIsNew", {
      //Methods
      /**
       * Specifies the value of `IsNew`.
       * @private
       */
      get: function() {
        return this.isNew;
      },
      enumerable: true,
      configurable: true
    });
    PdfMainObjectCollection2.prototype.add = function(element) {
      var objInfo = new ObjectInfo(element);
      this.objectCollections.push(objInfo);
      if (!this.primitiveObjectCollection.containsKey(element)) {
        this.primitiveObjectCollection.setValue(element, this.objectCollections.length - 1);
      }
      element.position = this.index = this.objectCollections.length - 1;
      element.status = ObjectStatus.Registered;
    };
    PdfMainObjectCollection2.prototype.lookFor = function(obj) {
      var index = -1;
      if (obj.position !== -1) {
        return obj.position;
      }
      if (this.primitiveObjectCollection.containsKey(obj) && this.count === this.primitiveObjectCollection.size()) {
        index = this.primitiveObjectCollection.getValue(obj);
      } else {
        for (var i = this.count - 1; i >= 0; i--) {
          var oi = this.objectCollections[i];
          if (oi.object === obj) {
            index = i;
            break;
          }
        }
      }
      return index;
    };
    PdfMainObjectCollection2.prototype.getReference = function(index, isNew) {
      this.index = this.lookFor(index);
      var reference;
      this.isNew = false;
      var oi = this.objectCollections[this.index];
      reference = oi.reference;
      var obj = { reference, wasNew: isNew };
      return obj;
    };
    PdfMainObjectCollection2.prototype.trySetReference = function(obj, reference, found) {
      var result = true;
      found = true;
      this.index = this.lookFor(obj);
      var oi = this.objectCollections[this.index];
      oi.setReference(reference);
      return result;
    };
    PdfMainObjectCollection2.prototype.destroy = function() {
      for (var _i = 0, _a = this.objectCollections; _i < _a.length; _i++) {
        var obj = _a[_i];
        if (obj !== void 0) {
          obj.pdfObject.position = -1;
          obj.pdfObject.isSaving = void 0;
          obj.pdfObject.objectCollectionIndex = void 0;
          obj.pdfObject.position = void 0;
        }
      }
      this.objectCollections = [];
      this.mainObjectCollection = new Dictionary();
      this.primitiveObjectCollection = new Dictionary();
    };
    return PdfMainObjectCollection2;
  })()
);
var ObjectInfo = (
  /** @class */
  (function() {
    function ObjectInfo2(obj, reference) {
      this.pdfObject = obj;
      this.pdfReference = reference;
    }
    Object.defineProperty(ObjectInfo2.prototype, "object", {
      //Properties
      /**
       * Gets the `object`.
       * @private
       */
      get: function() {
        return this.pdfObject;
      },
      set: function(value) {
        this.pdfObject = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ObjectInfo2.prototype, "reference", {
      /**
       * Gets the `reference`.
       * @private
       */
      get: function() {
        return this.pdfReference;
      },
      enumerable: true,
      configurable: true
    });
    ObjectInfo2.prototype.setReference = function(reference) {
      this.pdfReference = reference;
    };
    return ObjectInfo2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/pdf-document-base.js
var PdfDocumentBase = (
  /** @class */
  (function() {
    function PdfDocumentBase2(document2) {
      this.isStreamCopied = false;
      if (document2 instanceof PdfDocument) {
        this.document = document2;
      }
    }
    Object.defineProperty(PdfDocumentBase2.prototype, "pdfObjects", {
      //Prpperties
      /**
       * Gets the `PDF objects` collection, which stores all objects and references to it..
       * @private
       */
      get: function() {
        return this.objects;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentBase2.prototype, "crossTable", {
      /**
       * Gets the `cross-reference` table.
       * @private
       */
      get: function() {
        return this.pdfCrossTable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentBase2.prototype, "currentSavingObj", {
      /**
       * Gets or sets the current saving `object number`.
       * @private
       */
      get: function() {
        return this.currentSavingObject;
      },
      set: function(value) {
        this.currentSavingObject = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentBase2.prototype, "catalog", {
      /**
       * Gets the PDF document `catalog`.
       * @private
       */
      get: function() {
        return this.pdfCatalog;
      },
      set: function(value) {
        this.pdfCatalog = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentBase2.prototype, "viewerPreferences", {
      /**
       * Gets viewer preferences for presenting the PDF document in a viewer.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets viewer preferences
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.pdfCatalog.viewerPreferences;
      },
      enumerable: true,
      configurable: true
    });
    PdfDocumentBase2.prototype.setMainObjectCollection = function(mainObjectCollection) {
      this.objects = mainObjectCollection;
    };
    PdfDocumentBase2.prototype.setCrossTable = function(cTable) {
      this.pdfCrossTable = cTable;
    };
    PdfDocumentBase2.prototype.setCatalog = function(catalog) {
      this.pdfCatalog = catalog;
    };
    PdfDocumentBase2.prototype.save = function(filename) {
      var _this = this;
      var encoding = new Encoding(true);
      var SW = new StreamWriter(encoding);
      if (typeof filename === "undefined") {
        var encoding_1 = new Encoding(true);
        var SW_1 = new StreamWriter(encoding_1);
        return new Promise(function(resolve, reject) {
          var obj = {};
          obj.blobData = new Blob([_this.document.docSave(SW_1, true)], { type: "application/pdf" });
          resolve(obj);
        });
      } else {
        this.document.docSave(SW, filename, true);
      }
    };
    PdfDocumentBase2.prototype.clone = function() {
      return this.document;
    };
    PdfDocumentBase2.prototype._save = function() {
      return this.document._docSave();
    };
    return PdfDocumentBase2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/cross-table.js
var ObjectType;
(function(ObjectType2) {
  ObjectType2[ObjectType2["Free"] = 0] = "Free";
  ObjectType2[ObjectType2["Normal"] = 1] = "Normal";
  ObjectType2[ObjectType2["Packed"] = 2] = "Packed";
})(ObjectType || (ObjectType = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/primitives/pdf-boolean.js
var PdfBoolean = (
  /** @class */
  (function() {
    function PdfBoolean2(value) {
      this.currentPosition = -1;
      this.value = value;
    }
    Object.defineProperty(PdfBoolean2.prototype, "status", {
      //Properties
      /**
       * Gets or sets the `Status` of the specified object.
       * @private
       */
      get: function() {
        return this.objectStatus;
      },
      set: function(value) {
        this.objectStatus = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBoolean2.prototype, "isSaving", {
      /**
       * Gets or sets a value indicating whether this document `is saving` or not.
       * @private
       */
      get: function() {
        return this.saving;
      },
      set: function(value) {
        this.saving = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBoolean2.prototype, "objectCollectionIndex", {
      /**
       * Gets or sets the `index` value of the specified object.
       * @private
       */
      get: function() {
        return this.index;
      },
      set: function(value) {
        this.index = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBoolean2.prototype, "position", {
      /**
       * Gets or sets the `position` of the object.
       * @private
       */
      get: function() {
        return this.currentPosition;
      },
      set: function(value) {
        this.currentPosition = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBoolean2.prototype, "clonedObject", {
      /**
       * Returns `cloned object`.
       * @private
       */
      get: function() {
        var rValue = null;
        return rValue;
      },
      enumerable: true,
      configurable: true
    });
    PdfBoolean2.prototype.save = function(writer) {
      writer.write(this.boolToStr(this.value));
    };
    PdfBoolean2.prototype.clone = function(crossTable) {
      var newNumber = new PdfBoolean2(this.value);
      return newNumber;
    };
    PdfBoolean2.prototype.boolToStr = function(value) {
      return value ? "true" : "false";
    };
    return PdfBoolean2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/pdf-viewer-preferences.js
var PdfViewerPreferences = (
  /** @class */
  (function() {
    function PdfViewerPreferences2(catalog) {
      this._dictionaryProperties = new DictionaryProperties();
      this._centerWindow = false;
      this._fitWindow = false;
      this._displayTitle = false;
      this._splitWindow = false;
      this._hideMenuBar = false;
      this._hideToolBar = false;
      this._hideWindowUI = false;
      this._pageMode = PdfPageMode.UseNone;
      this._pageLayout = PdfPageLayout.SinglePage;
      this._dictionary = new PdfDictionary();
      this._duplex = DuplexMode.None;
      this._catalog = catalog;
    }
    Object.defineProperty(PdfViewerPreferences2.prototype, "centerWindow", {
      /**
       * A flag specifying whether to position the document’s window in the center of the screen.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Gets the center window
       * let centerWindow : boolean = viewerPreferences.centerWindow;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this._centerWindow;
      },
      /**
       * A flag specifying whether to position the document’s window in the center of the screen.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Sets the center window
       * viewerPreferences.centerWindow = true;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      set: function(value) {
        this._centerWindow = value;
        this._dictionary.items.setValue(this._dictionaryProperties.centerWindow, new PdfBoolean(this._centerWindow));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfViewerPreferences2.prototype, "displayTitle", {
      /**
       * A flag specifying whether the window’s title bar should display the document title taken
       * from the Title entry of the document information dictionary. If false, the title bar
       * should instead display the name of the PDF file containing the document.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Gets the display title
       * let displayTitle : boolean = viewerPreferences.displayTitle;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this._displayTitle;
      },
      /**
       * A flag specifying whether the window’s title bar should display the document title taken
       * from the Title entry of the document information dictionary. If false, the title bar
       * should instead display the name of the PDF file containing the document.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Sets the display title
       * viewerPreferences.displayTitle = true;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      set: function(value) {
        this._displayTitle = value;
        this._dictionary.items.setValue(this._dictionaryProperties.displayTitle, new PdfBoolean(this._displayTitle));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfViewerPreferences2.prototype, "fitWindow", {
      /**
       * A flag specifying whether to resize the document’s window to fit the size of the first
       * displayed page.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Gets the fit window
       * let fitWindow : boolean = viewerPreferences.fitWindow;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this._fitWindow;
      },
      /**
       * A flag specifying whether to resize the document’s window to fit the size of the first
       * displayed page.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Sets the fit window
       * viewerPreferences.fitWindow = true;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      set: function(value) {
        this._fitWindow = value;
        this._dictionary.items.setValue(this._dictionaryProperties.fitWindow, new PdfBoolean(this._fitWindow));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfViewerPreferences2.prototype, "hideMenuBar", {
      /**
       * A flag specifying whether to hide the viewer application’s menu bar when the
       * document is active.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Gets the hide menu bar
       * let hideMenuBar: boolean = viewerPreferences.hideMenuBar;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this._hideMenuBar;
      },
      /**
       * A flag specifying whether to hide the viewer application’s menu bar when the
       * document is active.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Sets the hide menu bar
       * viewerPreferences.hideMenuBar = true;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      set: function(value) {
        this._hideMenuBar = value;
        this._dictionary.items.setValue(this._dictionaryProperties.hideMenuBar, new PdfBoolean(this._hideMenuBar));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfViewerPreferences2.prototype, "hideToolBar", {
      /**
       * A flag specifying whether to hide the viewer application’s tool bar when the
       * document is active.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Gets the hide tool bar
       * let hideToolBar: boolean = viewerPreferences.hideToolBar;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this._hideToolBar;
      },
      /**
       * A flag specifying whether to hide the viewer application’s tool bar when the
       * document is active.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Sets the hide tool bar
       * viewerPreferences.hideToolbar = true;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      set: function(value) {
        this._hideToolBar = value;
        this._dictionary.items.setValue(this._dictionaryProperties.hideToolBar, new PdfBoolean(this._hideToolBar));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfViewerPreferences2.prototype, "hideWindowUI", {
      /**
       * A flag specifying whether to hide user interface elements in the document’s window
       * (such as scroll bars and navigation controls), leaving only the document’s contents displayed.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Gets the hide window UI
       * let hideWindowUI: boolean = viewerPreferences.hideWindowUI;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this._hideWindowUI;
      },
      /**
       * A flag specifying whether to hide user interface elements in the document’s window
       * (such as scroll bars and navigation controls), leaving only the document’s contents displayed.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Sets the hide window UI
       * viewerPreferences.hideWindowUI = true;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      set: function(value) {
        this._hideWindowUI = value;
        this._dictionary.items.setValue(this._dictionaryProperties.hideWindowUI, new PdfBoolean(this._hideWindowUI));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfViewerPreferences2.prototype, "pageMode", {
      /**
       * A name object specifying how the document should be displayed when opened.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Gets the page mode
       * let pageMode: PdfPageMode = viewerPreferences.pageMode;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this._pageMode;
      },
      /**
       * A name object specifying how the document should be displayed when opened.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Sets the page mode
       * viewerPreferences.pageMode = PdfPageMode.UseOutlines;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      set: function(value) {
        this._pageMode = value;
        this._catalog.items.setValue(this._dictionaryProperties.pageMode, new PdfName(this._mapPageMode(this._pageMode)));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfViewerPreferences2.prototype, "duplex", {
      /**
       * Gets print duplex mode handling option to use when printing the file from the print dialog.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Gets the duplex
       * let duplex : DuplexMode = viewerPreferences.duplex;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this._duplex;
      },
      /**
       * Sets print duplex mode handling option to use when printing the file from the print dialog.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Sets the duplex
       * viewerPreferences.duplex = DuplexMode.DuplexFlipLongEdge;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      set: function(value) {
        this._duplex = value;
        this._catalog.items.setValue(this._dictionaryProperties.duplex, new PdfName(this._mapDuplexMode(this._duplex)));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfViewerPreferences2.prototype, "pageLayout", {
      /**
       * A name object specifying the page layout to be used when the document is opened.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Gets the page layout
       * let pageLayout : PdfPageLayout = viewerPreferences.pageLayout;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this._pageLayout;
      },
      /**
       * A name object specifying the page layout to be used when the document is opened.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Sets the page layout
       * viewerPreferences.pageLayout = PdfPageLayout.TwoColumnLeft;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      set: function(value) {
        this._pageLayout = value;
        this._catalog.items.setValue(this._dictionaryProperties.pageLayout, new PdfName(this._mapPageLayout(this._pageLayout)));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfViewerPreferences2.prototype, "pageScaling", {
      /**
       * Gets the page scaling option to be selected
       * when a print dialog is displayed for this document.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Gets the page scaling
       * let pageScaling : PageScalingMode = viewerPreferences.pageScaling;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this._pageScaling;
      },
      /**
       * Sets the page scaling option to be selected
       * when a print dialog is displayed for this document.
       * ```typescript
       * // Create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // Gets the viewer preferences of the document
       * let viewerPreferences : PdfViewerPreferences = document.viewerPreferences;
       * // Sets the page scaling
       * viewerPreferences.pageScaling = PageScalingMode.None;
       * // Destroy the document
       * document.destroy();
       * ```
       */
      set: function(value) {
        this._pageScaling = value;
        if (this._pageScaling === PageScalingMode.AppDefault && this._dictionary.items.containsKey(this._dictionaryProperties.printScaling)) {
          this._dictionary.items.remove(this._dictionaryProperties.printScaling);
        } else if (this._pageScaling === PageScalingMode.None) {
          this._dictionary.items.setValue(this._dictionaryProperties.printScaling, new PdfName("None"));
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfViewerPreferences2.prototype, "element", {
      /**
       * Primivie element
       *
       * @private
       */
      get: function() {
        return this._dictionary;
      },
      enumerable: true,
      configurable: true
    });
    PdfViewerPreferences2.prototype._mapDuplexMode = function(mode) {
      switch (mode) {
        case DuplexMode.Simplex:
          return "Simplex";
        case DuplexMode.DuplexFlipShortEdge:
          return "DuplexFlipShortEdge";
        case DuplexMode.DuplexFlipLongEdge:
          return "DuplexFlipLongEdge";
        case DuplexMode.None:
          return "None";
      }
    };
    PdfViewerPreferences2.prototype._mapPageMode = function(mode) {
      switch (mode) {
        case PdfPageMode.UseNone:
          return "UseNone";
        case PdfPageMode.UseOutlines:
          return "UseOutlines";
        case PdfPageMode.UseThumbs:
          return "UseThumbs";
        case PdfPageMode.FullScreen:
          return "FullScreen";
        case PdfPageMode.UseOC:
          return "UseOC";
        case PdfPageMode.UseAttachments:
          return "UseAttachments";
      }
    };
    PdfViewerPreferences2.prototype._mapPageLayout = function(layout) {
      switch (layout) {
        case PdfPageLayout.SinglePage:
          return "SinglePage";
        case PdfPageLayout.OneColumn:
          return "OneColumn";
        case PdfPageLayout.TwoColumnLeft:
          return "TwoColumnLeft";
        case PdfPageLayout.TwoColumnRight:
          return "TwoColumnRight";
        case PdfPageLayout.TwoPageLeft:
          return "TwoPageLeft";
        case PdfPageLayout.TwoPageRight:
          return "TwoPageRight";
      }
    };
    return PdfViewerPreferences2;
  })()
);
var PdfPageMode;
(function(PdfPageMode2) {
  PdfPageMode2[PdfPageMode2["UseNone"] = 0] = "UseNone";
  PdfPageMode2[PdfPageMode2["UseOutlines"] = 1] = "UseOutlines";
  PdfPageMode2[PdfPageMode2["UseThumbs"] = 2] = "UseThumbs";
  PdfPageMode2[PdfPageMode2["FullScreen"] = 3] = "FullScreen";
  PdfPageMode2[PdfPageMode2["UseOC"] = 4] = "UseOC";
  PdfPageMode2[PdfPageMode2["UseAttachments"] = 5] = "UseAttachments";
})(PdfPageMode || (PdfPageMode = {}));
var PdfPageLayout;
(function(PdfPageLayout2) {
  PdfPageLayout2[PdfPageLayout2["SinglePage"] = 0] = "SinglePage";
  PdfPageLayout2[PdfPageLayout2["OneColumn"] = 1] = "OneColumn";
  PdfPageLayout2[PdfPageLayout2["TwoColumnLeft"] = 2] = "TwoColumnLeft";
  PdfPageLayout2[PdfPageLayout2["TwoColumnRight"] = 3] = "TwoColumnRight";
  PdfPageLayout2[PdfPageLayout2["TwoPageLeft"] = 4] = "TwoPageLeft";
  PdfPageLayout2[PdfPageLayout2["TwoPageRight"] = 5] = "TwoPageRight";
})(PdfPageLayout || (PdfPageLayout = {}));
var DuplexMode;
(function(DuplexMode2) {
  DuplexMode2[DuplexMode2["Simplex"] = 0] = "Simplex";
  DuplexMode2[DuplexMode2["DuplexFlipShortEdge"] = 1] = "DuplexFlipShortEdge";
  DuplexMode2[DuplexMode2["DuplexFlipLongEdge"] = 2] = "DuplexFlipLongEdge";
  DuplexMode2[DuplexMode2["None"] = 3] = "None";
})(DuplexMode || (DuplexMode = {}));
var PageScalingMode;
(function(PageScalingMode2) {
  PageScalingMode2[PageScalingMode2["AppDefault"] = 0] = "AppDefault";
  PageScalingMode2[PageScalingMode2["None"] = 1] = "None";
})(PageScalingMode || (PageScalingMode = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/pdf-catalog.js
var __extends26 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfCatalog = (
  /** @class */
  (function(_super) {
    __extends26(PdfCatalog2, _super);
    function PdfCatalog2() {
      var _this = _super.call(this) || this;
      _this.sections = null;
      _this.tempDictionaryProperties = new DictionaryProperties();
      _this.items.setValue(new DictionaryProperties().type, new PdfName("Catalog"));
      return _this;
    }
    Object.defineProperty(PdfCatalog2.prototype, "pages", {
      //Properties
      /**
       * Gets or sets the sections, which contain `pages`.
       * @private
       */
      get: function() {
        return this.sections;
      },
      set: function(value) {
        var dictionary = value.element;
        this.sections = value;
        this.items.setValue(this.tempDictionaryProperties.pages, new PdfReferenceHolder(value));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCatalog2.prototype, "viewerPreferences", {
      /**
       * Gets the viewer preferences of the PDF document.
       * @private
       */
      get: function() {
        if (this._viewerPreferences === null || typeof this._viewerPreferences === "undefined") {
          this._viewerPreferences = new PdfViewerPreferences(this);
          this.items.setValue(this.tempDictionaryProperties.viewerPreferences, new PdfReferenceHolder(this._viewerPreferences.element));
        }
        return this._viewerPreferences;
      },
      enumerable: true,
      configurable: true
    });
    return PdfCatalog2;
  })(PdfDictionary)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/pdf-cross-table.js
var PdfCrossTable = (
  /** @class */
  (function() {
    function PdfCrossTable2() {
      this.objects = new Dictionary();
      this.maxGenNumIndex = 0;
      this.objectCount = 0;
      this.dictionaryProperties = new DictionaryProperties();
    }
    Object.defineProperty(PdfCrossTable2.prototype, "isMerging", {
      //Properties
      /**
       * Gets or sets if the document `is merged`.
       * @private
       */
      get: function() {
        return this.merging;
      },
      set: function(value) {
        this.merging = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCrossTable2.prototype, "trailer", {
      /**
       * Gets the `trailer`.
       * @private
       */
      get: function() {
        if (this.internalTrailer == null) {
          this.internalTrailer = new PdfStream();
        }
        return this.internalTrailer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCrossTable2.prototype, "document", {
      /**
       * Gets or sets the main `PdfDocument` class instance.
       * @private
       */
      get: function() {
        return this.pdfDocument;
      },
      set: function(value) {
        this.pdfDocument = value;
        this.items = this.pdfDocument.pdfObjects;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCrossTable2.prototype, "pdfObjects", {
      /**
       * Gets the catched `PDF object` main collection.
       * @private
       */
      get: function() {
        return this.items;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCrossTable2.prototype, "objectCollection", {
      /**
       * Gets the `object collection`.
       * @private
       */
      get: function() {
        return this.pdfDocument.pdfObjects;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCrossTable2.prototype, "count", {
      /**
       * Gets or sets the `number of the objects` within the document.
       * @private
       */
      get: function() {
        return this.objectCount;
      },
      set: function(value) {
        this.objectCount = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCrossTable2.prototype, "nextObjNumber", {
      /**
       * Returns `next available object number`.
       * @private
       */
      get: function() {
        this.count = this.count + 1;
        return this.count;
      },
      enumerable: true,
      configurable: true
    });
    PdfCrossTable2.prototype.save = function(writer, filename) {
      this._saveProcess(writer);
      if (typeof filename === "undefined") {
        return writer.stream.buffer;
      } else {
        writer.stream.save(filename);
      }
    };
    PdfCrossTable2.prototype._saveProcess = function(writer) {
      this.saveHead(writer);
      this.mappedReferences = null;
      this.objects.clear();
      this.markTrailerReferences();
      this.saveObjects(writer);
      var saveCount = this.count;
      var xrefPos = writer.position;
      this.registerObject(0, new PdfReference(0, -1), true);
      var prevXRef = 0;
      writer.write(Operators.xref);
      writer.write(Operators.newLine);
      this.saveSections(writer);
      this.saveTrailer(writer, this.count, prevXRef);
      this.saveTheEndess(writer, xrefPos);
      this.count = saveCount;
      for (var i = 0; i < this.objectCollection.count; ++i) {
        var oi = this.objectCollection.items(i);
        oi.object.isSaving = false;
      }
    };
    PdfCrossTable2.prototype._save = function(writer) {
      this._saveProcess(writer);
      return new Uint8Array(writer.stream.buffer.buffer);
    };
    PdfCrossTable2.prototype.saveTheEndess = function(writer, xrefPos) {
      writer.write(Operators.newLine + Operators.startxref + Operators.newLine);
      writer.write(xrefPos.toString() + Operators.newLine);
      writer.write(Operators.eof + Operators.newLine);
    };
    PdfCrossTable2.prototype.saveTrailer = function(writer, count, prevXRef) {
      writer.write(Operators.trailer + Operators.newLine);
      var trailer = this.trailer;
      trailer.items.setValue(this.dictionaryProperties.size, new PdfNumber(this.objectCount + 1));
      trailer = new PdfDictionary(trailer);
      trailer.setEncrypt(false);
      trailer.save(writer);
    };
    PdfCrossTable2.prototype.saveSections = function(writer) {
      var objectNum = 0;
      var count = 0;
      do {
        count = this.prepareSubsection(objectNum);
        this.saveSubsection(writer, objectNum, count);
        objectNum += count;
      } while (count !== 0);
    };
    PdfCrossTable2.prototype.saveSubsection = function(writer, objectNum, count) {
      if (count <= 0 || objectNum >= this.count) {
        return;
      }
      var subsectionHead = "{0} {1}{2}";
      writer.write(objectNum + " " + (count + 1) + Operators.newLine);
      for (var i = objectNum; i <= objectNum + count; ++i) {
        var obj = this.objects.getValue(i);
        var str = "";
        if (obj.type === ObjectType.Free) {
          str = this.getItem(obj.offset, 65535, true);
        } else {
          str = this.getItem(obj.offset, obj.generation, false);
        }
        writer.write(str);
      }
    };
    PdfCrossTable2.prototype.getItem = function(offset, genNumber, isFree) {
      var returnString = "";
      var addOffsetLength = 10 - offset.toString().length;
      if (genNumber <= 0) {
        genNumber = 0;
      }
      var addGenNumberLength = 5 - genNumber.toString().length <= 0 ? 0 : 5 - genNumber.toString().length;
      for (var index = 0; index < addOffsetLength; index++) {
        returnString = returnString + "0";
      }
      returnString = returnString + offset.toString() + " ";
      for (var index = 0; index < addGenNumberLength; index++) {
        returnString = returnString + "0";
      }
      returnString = returnString + genNumber.toString() + " ";
      returnString = returnString + (isFree ? Operators.f : Operators.n) + Operators.newLine;
      return returnString;
    };
    PdfCrossTable2.prototype.prepareSubsection = function(objectNum) {
      var count = 0;
      var i;
      var total = this.count;
      for (var k = 0; k < this.document.pdfObjects.count; k++) {
        var reference = this.document.pdfObjects.items(k).reference;
        var refString = reference.toString();
        var refArray = refString.split(" ");
      }
      if (objectNum >= total) {
        return count;
      }
      for (i = objectNum; i < total; ++i) {
        break;
      }
      objectNum = i;
      for (; i < total; ++i) {
        ++count;
      }
      return count;
    };
    PdfCrossTable2.prototype.markTrailerReferences = function() {
      var tempArray;
      var keys2 = this.trailer.items.keys();
      var values = this.trailer.items.values();
    };
    PdfCrossTable2.prototype.saveHead = function(writer) {
      var version = this.generateFileVersion(writer.document);
      writer.write("%PDF-" + version);
      writer.write(Operators.newLine);
    };
    PdfCrossTable2.prototype.generateFileVersion = function(document2) {
      var iVersion = 4;
      var version = "1." + iVersion.toString();
      return version;
    };
    PdfCrossTable2.prototype.getReference = function(obj, bNew) {
      if (typeof bNew === "undefined") {
        var wasNew = false;
        return this.getReference(obj, wasNew);
      } else {
        return this.getSubReference(obj, bNew);
      }
    };
    PdfCrossTable2.prototype.getSubReference = function(obj, bNew) {
      var isNew = false;
      var wasNew;
      var reference = null;
      if (this.items.count > 0 && obj.objectCollectionIndex > 0 && this.items.count > obj.objectCollectionIndex - 1) {
        var tempObj = this.document.pdfObjects.getReference(obj, wasNew);
        reference = tempObj.reference;
        wasNew = tempObj.wasNew;
      }
      if (reference == null) {
        if (obj.status === ObjectStatus.Registered) {
          wasNew = false;
        } else {
          wasNew = true;
        }
      } else {
        wasNew = false;
      }
      if (reference == null) {
        var objnumber = this.nextObjNumber;
        reference = new PdfReference(objnumber, 0);
        var found = void 0;
        if (wasNew) {
          this.document.pdfObjects.add(obj);
          this.document.pdfObjects.trySetReference(obj, reference, found);
          var tempIndex = this.document.pdfObjects.count - 1;
          var tempkey = this.document.pdfObjects.objectCollections[tempIndex].reference.objNumber;
          var tempvalue = this.document.pdfObjects.objectCollections[this.document.pdfObjects.count - 1];
          this.document.pdfObjects.mainObjectCollection.setValue(tempkey, tempvalue);
          obj.position = -1;
        } else {
          this.document.pdfObjects.trySetReference(obj, reference, found);
        }
        obj.objectCollectionIndex = reference.objNumber;
        obj.status = ObjectStatus.None;
        isNew = true;
      }
      bNew = isNew || this.bForceNew;
      return reference;
    };
    PdfCrossTable2.prototype.saveObjects = function(writer) {
      var objectCollection = this.objectCollection;
      for (var i = 0; i < objectCollection.count; ++i) {
        var oi = objectCollection.items(i);
        var obj = oi.object;
        obj.isSaving = true;
        this.saveIndirectObject(obj, writer);
      }
    };
    PdfCrossTable2.prototype.saveIndirectObject = function(obj, writer) {
      var reference = this.getReference(obj);
      if (obj instanceof PdfCatalog) {
        this.trailer.items.setValue(this.dictionaryProperties.root, reference);
      }
      this.pdfDocument.currentSavingObj = reference;
      var tempArchive = false;
      tempArchive = obj.getArchive();
      var allowedType = !(obj instanceof PdfStream || !tempArchive || obj instanceof PdfCatalog);
      var sigFlag = false;
      this.registerObject(writer.position, reference);
      this.doSaveObject(obj, reference, writer);
    };
    PdfCrossTable2.prototype.doSaveObject = function(obj, reference, writer) {
      writer.write(reference.objNumber.toString());
      writer.write(Operators.whiteSpace);
      writer.write(reference.genNumber.toString());
      writer.write(Operators.whiteSpace);
      writer.write(Operators.obj);
      writer.write(Operators.newLine);
      obj.save(writer);
      writer.write(Operators.endObj);
      writer.write(Operators.newLine);
    };
    PdfCrossTable2.prototype.registerObject = function(offset, reference, free) {
      if (typeof free === "boolean") {
        this.objects.setValue(reference.objNumber, new RegisteredObject(offset, reference, free));
        this.maxGenNumIndex = Math.max(this.maxGenNumIndex, reference.genNumber);
      } else if (typeof free === "undefined") {
        this.objects.setValue(reference.objNumber, new RegisteredObject(offset, reference));
        this.maxGenNumIndex = Math.max(this.maxGenNumIndex, reference.genNumber);
      }
    };
    PdfCrossTable2.dereference = function(obj) {
      var rh = obj;
      if (rh != null) {
        obj = rh.object;
      }
      return obj;
    };
    return PdfCrossTable2;
  })()
);
var RegisteredObject = (
  /** @class */
  (function() {
    function RegisteredObject2(offset, reference, free) {
      var tempOffset = offset;
      this.offsetNumber = tempOffset;
      var tempReference = reference;
      this.generation = tempReference.genNumber;
      this.object = tempReference.objNumber;
      if (typeof free === "undefined") {
        this.type = ObjectType.Normal;
      } else {
        this.type = ObjectType.Free;
      }
    }
    Object.defineProperty(RegisteredObject2.prototype, "objectNumber", {
      //Properties
      /**
       * Gets the `object number`.
       * @private
       */
      get: function() {
        return this.object;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RegisteredObject2.prototype, "offset", {
      /**
       * Gets the `offset`.
       * @private
       */
      get: function() {
        var result;
        result = this.offsetNumber;
        return result;
      },
      enumerable: true,
      configurable: true
    });
    return RegisteredObject2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page-size.js
var PdfPageSize = (
  /** @class */
  (function() {
    function PdfPageSize2() {
    }
    PdfPageSize2.letter = new SizeF(612, 792);
    PdfPageSize2.note = new SizeF(540, 720);
    PdfPageSize2.legal = new SizeF(612, 1008);
    PdfPageSize2.a0 = new SizeF(2380, 3368);
    PdfPageSize2.a1 = new SizeF(1684, 2380);
    PdfPageSize2.a2 = new SizeF(1190, 1684);
    PdfPageSize2.a3 = new SizeF(842, 1190);
    PdfPageSize2.a4 = new SizeF(595, 842);
    PdfPageSize2.a5 = new SizeF(421, 595);
    PdfPageSize2.a6 = new SizeF(297, 421);
    PdfPageSize2.a7 = new SizeF(210, 297);
    PdfPageSize2.a8 = new SizeF(148, 210);
    PdfPageSize2.a9 = new SizeF(105, 148);
    PdfPageSize2.a10 = new SizeF(74, 105);
    PdfPageSize2.b0 = new SizeF(2836, 4008);
    PdfPageSize2.b1 = new SizeF(2004, 2836);
    PdfPageSize2.b2 = new SizeF(1418, 2004);
    PdfPageSize2.b3 = new SizeF(1002, 1418);
    PdfPageSize2.b4 = new SizeF(709, 1002);
    PdfPageSize2.b5 = new SizeF(501, 709);
    PdfPageSize2.archE = new SizeF(2592, 3456);
    PdfPageSize2.archD = new SizeF(1728, 2592);
    PdfPageSize2.archC = new SizeF(1296, 1728);
    PdfPageSize2.archB = new SizeF(864, 1296);
    PdfPageSize2.archA = new SizeF(648, 864);
    PdfPageSize2.flsa = new SizeF(612, 936);
    PdfPageSize2.halfLetter = new SizeF(396, 612);
    PdfPageSize2.letter11x17 = new SizeF(792, 1224);
    PdfPageSize2.ledger = new SizeF(1224, 792);
    return PdfPageSize2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/enum.js
var PdfPageOrientation;
(function(PdfPageOrientation2) {
  PdfPageOrientation2[PdfPageOrientation2["Portrait"] = 0] = "Portrait";
  PdfPageOrientation2[PdfPageOrientation2["Landscape"] = 1] = "Landscape";
})(PdfPageOrientation || (PdfPageOrientation = {}));
var PdfPageRotateAngle;
(function(PdfPageRotateAngle2) {
  PdfPageRotateAngle2[PdfPageRotateAngle2["RotateAngle0"] = 0] = "RotateAngle0";
  PdfPageRotateAngle2[PdfPageRotateAngle2["RotateAngle90"] = 1] = "RotateAngle90";
  PdfPageRotateAngle2[PdfPageRotateAngle2["RotateAngle180"] = 2] = "RotateAngle180";
  PdfPageRotateAngle2[PdfPageRotateAngle2["RotateAngle270"] = 3] = "RotateAngle270";
})(PdfPageRotateAngle || (PdfPageRotateAngle = {}));
var PdfNumberStyle;
(function(PdfNumberStyle2) {
  PdfNumberStyle2[PdfNumberStyle2["None"] = 0] = "None";
  PdfNumberStyle2[PdfNumberStyle2["Numeric"] = 1] = "Numeric";
  PdfNumberStyle2[PdfNumberStyle2["LowerLatin"] = 2] = "LowerLatin";
  PdfNumberStyle2[PdfNumberStyle2["LowerRoman"] = 3] = "LowerRoman";
  PdfNumberStyle2[PdfNumberStyle2["UpperLatin"] = 4] = "UpperLatin";
  PdfNumberStyle2[PdfNumberStyle2["UpperRoman"] = 5] = "UpperRoman";
})(PdfNumberStyle || (PdfNumberStyle = {}));
var PdfDockStyle;
(function(PdfDockStyle2) {
  PdfDockStyle2[PdfDockStyle2["None"] = 0] = "None";
  PdfDockStyle2[PdfDockStyle2["Bottom"] = 1] = "Bottom";
  PdfDockStyle2[PdfDockStyle2["Top"] = 2] = "Top";
  PdfDockStyle2[PdfDockStyle2["Left"] = 3] = "Left";
  PdfDockStyle2[PdfDockStyle2["Right"] = 4] = "Right";
  PdfDockStyle2[PdfDockStyle2["Fill"] = 5] = "Fill";
})(PdfDockStyle || (PdfDockStyle = {}));
var PdfAlignmentStyle;
(function(PdfAlignmentStyle2) {
  PdfAlignmentStyle2[PdfAlignmentStyle2["None"] = 0] = "None";
  PdfAlignmentStyle2[PdfAlignmentStyle2["TopLeft"] = 1] = "TopLeft";
  PdfAlignmentStyle2[PdfAlignmentStyle2["TopCenter"] = 2] = "TopCenter";
  PdfAlignmentStyle2[PdfAlignmentStyle2["TopRight"] = 3] = "TopRight";
  PdfAlignmentStyle2[PdfAlignmentStyle2["MiddleLeft"] = 4] = "MiddleLeft";
  PdfAlignmentStyle2[PdfAlignmentStyle2["MiddleCenter"] = 5] = "MiddleCenter";
  PdfAlignmentStyle2[PdfAlignmentStyle2["MiddleRight"] = 6] = "MiddleRight";
  PdfAlignmentStyle2[PdfAlignmentStyle2["BottomLeft"] = 7] = "BottomLeft";
  PdfAlignmentStyle2[PdfAlignmentStyle2["BottomCenter"] = 8] = "BottomCenter";
  PdfAlignmentStyle2[PdfAlignmentStyle2["BottomRight"] = 9] = "BottomRight";
})(PdfAlignmentStyle || (PdfAlignmentStyle = {}));
var TemplateType;
(function(TemplateType2) {
  TemplateType2[TemplateType2["None"] = 0] = "None";
  TemplateType2[TemplateType2["Top"] = 1] = "Top";
  TemplateType2[TemplateType2["Bottom"] = 2] = "Bottom";
  TemplateType2[TemplateType2["Left"] = 3] = "Left";
  TemplateType2[TemplateType2["Right"] = 4] = "Right";
})(TemplateType || (TemplateType = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-margins.js
var PdfMargins = (
  /** @class */
  (function() {
    function PdfMargins2() {
      this.pdfMargin = 40;
      this.setMargins(this.pdfMargin);
    }
    Object.defineProperty(PdfMargins2.prototype, "left", {
      //Properties
      /**
       * Gets or sets the `left margin` size.
       * @private
       */
      get: function() {
        return this.leftMargin;
      },
      set: function(value) {
        this.leftMargin = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfMargins2.prototype, "top", {
      /**
       * Gets or sets the `top margin` size.
       * @private
       */
      get: function() {
        return this.topMargin;
      },
      set: function(value) {
        this.topMargin = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfMargins2.prototype, "right", {
      /**
       * Gets or sets the `right margin` size.
       * @private
       */
      get: function() {
        return this.rightMargin;
      },
      set: function(value) {
        this.rightMargin = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfMargins2.prototype, "bottom", {
      /**
       * Gets or sets the `bottom margin` size.
       * @private
       */
      get: function() {
        return this.bottomMargin;
      },
      set: function(value) {
        this.bottomMargin = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfMargins2.prototype, "all", {
      /**
       * Sets the `margins`.
       * @private
       */
      set: function(value) {
        this.setMargins(value);
      },
      enumerable: true,
      configurable: true
    });
    PdfMargins2.prototype.setMargins = function(margin1, margin2, margin3, margin4) {
      if (typeof margin2 === "undefined") {
        this.leftMargin = this.topMargin = this.rightMargin = this.bottomMargin = margin1;
      } else {
        if (typeof margin3 === "undefined") {
          this.leftMargin = this.rightMargin = margin1;
          this.bottomMargin = this.topMargin = margin2;
        } else {
          this.leftMargin = margin1;
          this.topMargin = margin2;
          this.rightMargin = margin3;
          this.bottomMargin = margin4;
        }
      }
    };
    PdfMargins2.prototype.clone = function() {
      return this;
    };
    return PdfMargins2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page-settings.js
var PdfPageSettings = (
  /** @class */
  (function() {
    function PdfPageSettings2(margins) {
      this.pageMargins = new PdfMargins();
      this.pageSize = PdfPageSize.a4;
      this.rotateAngle = PdfPageRotateAngle.RotateAngle0;
      this.pageOrientation = PdfPageOrientation.Portrait;
      this.pageOrigin = new PointF(0, 0);
      this.isRotation = false;
      if (typeof margins === "number") {
        this.pageMargins.setMargins(margins);
      }
    }
    Object.defineProperty(PdfPageSettings2.prototype, "size", {
      //Properties
      /**
       * Gets or sets the `size` of the page.
       * @private
       */
      get: function() {
        return this.pageSize;
      },
      set: function(value) {
        this.setSize(value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageSettings2.prototype, "orientation", {
      /**
       * Gets or sets the page `orientation`.
       * @private
       */
      get: function() {
        return this.pageOrientation;
      },
      set: function(orientation) {
        if (this.pageOrientation !== orientation) {
          this.pageOrientation = orientation;
          this.updateSize(orientation);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageSettings2.prototype, "margins", {
      /**
       * Gets or sets the `margins` of the page.
       * @private
       */
      get: function() {
        return this.pageMargins;
      },
      set: function(value) {
        this.pageMargins = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageSettings2.prototype, "width", {
      /**
       * Gets or sets the `width` of the page.
       * @private
       */
      get: function() {
        return this.pageSize.width;
      },
      set: function(value) {
        this.pageSize.width = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageSettings2.prototype, "height", {
      /**
       * Gets or sets the `height` of the page.
       * @private
       */
      get: function() {
        return this.pageSize.height;
      },
      set: function(value) {
        this.pageSize.height = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageSettings2.prototype, "origin", {
      /**
       * Gets or sets the `origin` of the page.
       * @private
       */
      get: function() {
        return this.pageOrigin;
      },
      set: function(value) {
        this.pageOrigin = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageSettings2.prototype, "rotate", {
      /**
       * Gets or sets the number of degrees by which the page should be `rotated` clockwise when displayed or printed.
       * @private
       */
      get: function() {
        return this.rotateAngle;
      },
      set: function(value) {
        this.rotateAngle = value;
        this.isRotation = true;
      },
      enumerable: true,
      configurable: true
    });
    PdfPageSettings2.prototype.updateSize = function(orientation) {
      var min = Math.min(this.pageSize.width, this.pageSize.height);
      var max = Math.max(this.pageSize.width, this.pageSize.height);
      switch (orientation) {
        case PdfPageOrientation.Portrait:
          this.pageSize = new SizeF(min, max);
          break;
        case PdfPageOrientation.Landscape:
          this.pageSize = new SizeF(max, min);
          break;
      }
    };
    PdfPageSettings2.prototype.clone = function() {
      var settings = this;
      settings.pageMargins = this.pageMargins.clone();
      return settings;
    };
    PdfPageSettings2.prototype.getActualSize = function() {
      var width = this.width - (this.margins.left + this.margins.right);
      var height = this.height - (this.margins.top + this.margins.bottom);
      var size = new SizeF(width, height);
      return size;
    };
    PdfPageSettings2.prototype.setSize = function(size) {
      var min = Math.min(size.width, size.height);
      var max = Math.max(size.width, size.height);
      if (this.orientation === PdfPageOrientation.Portrait) {
        this.pageSize = new SizeF(min, max);
      } else {
        this.pageSize = new SizeF(max, min);
      }
    };
    return PdfPageSettings2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/pdf-stream-writer.js
var PdfStreamWriter = (
  /** @class */
  (function() {
    function PdfStreamWriter2(stream) {
      if (stream == null) {
        throw new Error("ArgumentNullException:stream");
      }
      this.stream = stream;
    }
    PdfStreamWriter2.prototype.clear = function() {
      this.stream.clearStream();
    };
    PdfStreamWriter2.prototype.setGraphicsState = function(dictionaryName) {
      if (dictionaryName instanceof PdfName) {
        this.stream.write(dictionaryName.toString());
        this.stream.write(Operators.whiteSpace);
        this.writeOperator(Operators.setGraphicsState);
      } else {
        this.stream.write(Operators.slash);
        this.stream.write(dictionaryName);
        this.stream.write(Operators.whiteSpace);
        this.writeOperator(Operators.setGraphicsState);
      }
    };
    PdfStreamWriter2.prototype.executeObject = function(name) {
      this.stream.write(name.toString());
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.paintXObject);
      this.stream.write(Operators.newLine);
    };
    PdfStreamWriter2.prototype.closePath = function() {
      this.writeOperator(Operators.closePath);
    };
    PdfStreamWriter2.prototype.clipPath = function(useEvenOddRule) {
      this.stream.write(Operators.clipPath);
      if (useEvenOddRule) {
        this.stream.write(Operators.evenOdd);
      }
      this.stream.write(Operators.whiteSpace);
      this.stream.write(Operators.endPath);
      this.stream.write(Operators.newLine);
    };
    PdfStreamWriter2.prototype.closeFillStrokePath = function(useEvenOddRule) {
      this.stream.write(Operators.closeFillStrokePath);
      if (useEvenOddRule) {
        this.stream.write(Operators.evenOdd);
        this.stream.write(Operators.newLine);
      } else {
        this.stream.write(Operators.newLine);
      }
    };
    PdfStreamWriter2.prototype.fillStrokePath = function(useEvenOddRule) {
      this.stream.write(Operators.fillStroke);
      if (useEvenOddRule) {
        this.stream.write(Operators.evenOdd);
        this.stream.write(Operators.newLine);
      } else {
        this.stream.write(Operators.newLine);
      }
    };
    PdfStreamWriter2.prototype.fillPath = function(useEvenOddRule) {
      this.stream.write(Operators.fill);
      if (useEvenOddRule) {
        this.stream.write(Operators.evenOdd);
        this.stream.write(Operators.newLine);
      } else {
        this.stream.write(Operators.newLine);
      }
    };
    PdfStreamWriter2.prototype.endPath = function() {
      this.writeOperator(Operators.n);
    };
    PdfStreamWriter2.prototype.closeFillPath = function(useEvenOddRule) {
      this.writeOperator(Operators.closePath);
      this.stream.write(Operators.fill);
      if (useEvenOddRule) {
        this.stream.write(Operators.evenOdd);
        this.stream.write(Operators.newLine);
      } else {
        this.stream.write(Operators.newLine);
      }
    };
    PdfStreamWriter2.prototype.closeStrokePath = function() {
      this.writeOperator(Operators.closeStrokePath);
    };
    PdfStreamWriter2.prototype.setTextScaling = function(textScaling) {
      this.stream.write(PdfNumber.floatToString(textScaling));
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setTextScaling);
    };
    PdfStreamWriter2.prototype.strokePath = function() {
      this.writeOperator(Operators.stroke);
    };
    PdfStreamWriter2.prototype.restoreGraphicsState = function() {
      this.writeOperator(Operators.restoreState);
    };
    PdfStreamWriter2.prototype.saveGraphicsState = function() {
      this.writeOperator(Operators.saveState);
    };
    PdfStreamWriter2.prototype.startNextLine = function(arg1, arg2) {
      if (typeof arg1 === "undefined") {
        this.writeOperator(Operators.goToNextLine);
      } else if (arg1 instanceof PointF) {
        this.writePoint(arg1);
        this.writeOperator(Operators.setCoords);
      } else {
        this.writePoint(arg1, arg2);
        this.writeOperator(Operators.setCoords);
      }
    };
    PdfStreamWriter2.prototype.showText = function(text) {
      this.checkTextParam(text);
      this.writeText(text);
      this.writeOperator(Operators.setText);
    };
    PdfStreamWriter2.prototype.setLeading = function(leading) {
      this.stream.write(PdfNumber.floatToString(leading));
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setTextLeading);
    };
    PdfStreamWriter2.prototype.beginPath = function(x, y) {
      this.writePoint(x, y);
      this.writeOperator(Operators.beginPath);
    };
    PdfStreamWriter2.prototype.beginText = function() {
      this.writeOperator(Operators.beginText);
    };
    PdfStreamWriter2.prototype.endText = function() {
      this.writeOperator(Operators.endText);
    };
    PdfStreamWriter2.prototype.appendRectangle = function(arg1, arg2, arg3, arg4) {
      if (arg1 instanceof RectangleF) {
        this.appendRectangle(arg1.x, arg1.y, arg1.width, arg1.height);
      } else {
        this.writePoint(arg1, arg2);
        this.writePoint(arg3, arg4);
        this.writeOperator(Operators.appendRectangle);
      }
    };
    PdfStreamWriter2.prototype.appendLineSegment = function(arg1, arg2) {
      if (arg1 instanceof PointF) {
        this.appendLineSegment(arg1.x, arg1.y);
      } else {
        this.writePoint(arg1, arg2);
        this.writeOperator(Operators.appendLineSegment);
      }
    };
    PdfStreamWriter2.prototype.setTextRenderingMode = function(renderingMode) {
      this.stream.write(renderingMode.toString());
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setRenderingMode);
    };
    PdfStreamWriter2.prototype.setCharacterSpacing = function(charSpacing) {
      this.stream.write(PdfNumber.floatToString(charSpacing));
      this.stream.write(Operators.whiteSpace);
      this.stream.write(Operators.setCharacterSpace);
      this.stream.write(Operators.newLine);
    };
    PdfStreamWriter2.prototype.setWordSpacing = function(wordSpacing) {
      this.stream.write(PdfNumber.floatToString(wordSpacing));
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setWordSpace);
    };
    PdfStreamWriter2.prototype.showNextLineText = function(arg1, arg2) {
      if (arg1 instanceof PdfString) {
        this.checkTextParam(arg1);
        this.writeText(arg1);
        this.writeOperator(Operators.setTextOnNewLine);
      } else {
        this.checkTextParam(arg1);
        this.writeText(arg1, arg2);
        this.writeOperator(Operators.setTextOnNewLine);
      }
    };
    PdfStreamWriter2.prototype.setColorSpace = function(arg1, arg2) {
      if (arg1 instanceof PdfName && typeof arg2 === "boolean") {
        var temparg1 = arg1;
        var temparg2 = arg2;
        var op = temparg2 ? Operators.selectcolorspaceforstroking : Operators.selectcolorspacefornonstroking;
        this.stream.write(temparg1.toString());
        this.stream.write(Operators.whiteSpace);
        this.stream.write(op);
        this.stream.write(Operators.newLine);
      } else {
        var temparg1 = arg1;
        var temparg2 = arg2;
        this.setColorSpace(new PdfName(temparg1), temparg2);
      }
    };
    PdfStreamWriter2.prototype.modifyCtm = function(matrix) {
      if (matrix == null) {
        throw new Error("ArgumentNullException:matrix");
      }
      this.stream.write(matrix.toString());
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.modifyCtm);
    };
    PdfStreamWriter2.prototype.setFont = function(font, name, size) {
      if (typeof name === "string") {
        this.setFont(font, new PdfName(name), size);
      } else {
        if (font == null) {
          throw new Error("ArgumentNullException:font");
        }
        this.stream.write(name.toString());
        this.stream.write(Operators.whiteSpace);
        this.stream.write(PdfNumber.floatToString(size));
        this.stream.write(Operators.whiteSpace);
        this.writeOperator(Operators.setFont);
      }
    };
    PdfStreamWriter2.prototype.writeOperator = function(opcode) {
      this.stream.write(opcode);
      this.stream.write(Operators.newLine);
    };
    PdfStreamWriter2.prototype.checkTextParam = function(text) {
      if (text == null) {
        throw new Error("ArgumentNullException:text");
      }
      if (typeof text === "string" && text === "") {
        throw new Error("ArgumentException:The text can not be an empty string, text");
      }
    };
    PdfStreamWriter2.prototype.writeText = function(arg1, arg2) {
      if (arg1 instanceof PdfString && typeof arg2 === "undefined") {
        this.stream.write(arg1.pdfEncode());
      } else {
        var start = void 0;
        var end = void 0;
        if (arg2) {
          start = PdfString.hexStringMark[0];
          end = PdfString.hexStringMark[1];
        } else {
          start = PdfString.stringMark[0];
          end = PdfString.stringMark[1];
        }
        this.stream.write(start);
        this.stream.write(arg1);
        this.stream.write(end);
      }
    };
    PdfStreamWriter2.prototype.writePoint = function(arg1, arg2) {
      if (arg1 instanceof PointF && typeof arg2 === "undefined") {
        this.writePoint(arg1.x, arg1.y);
      } else {
        var temparg1 = arg1;
        this.stream.write(PdfNumber.floatToString(temparg1));
        this.stream.write(Operators.whiteSpace);
        arg2 = this.updateY(arg2);
        this.stream.write(PdfNumber.floatToString(arg2));
        this.stream.write(Operators.whiteSpace);
      }
    };
    PdfStreamWriter2.prototype.updateY = function(arg) {
      return -arg;
    };
    PdfStreamWriter2.prototype.write = function(string) {
      var builder = "";
      builder += string;
      builder += Operators.newLine;
      this.writeOperator(builder);
    };
    PdfStreamWriter2.prototype.writeComment = function(comment) {
      if (comment != null && comment.length > 0) {
        var builder = "";
        builder += Operators.comment;
        builder += Operators.whiteSpace;
        builder += comment;
        this.writeOperator(builder);
      } else {
        throw new Error("Invalid comment");
      }
    };
    PdfStreamWriter2.prototype.setColorAndSpace = function(color, colorSpace, forStroking) {
      if (!color.isEmpty) {
        this.stream.write(color.toString(colorSpace, forStroking));
        this.stream.write(Operators.newLine);
      }
    };
    PdfStreamWriter2.prototype.setLineDashPattern = function(pattern, patternOffset) {
      this.setLineDashPatternHelper(pattern, patternOffset);
    };
    PdfStreamWriter2.prototype.setLineDashPatternHelper = function(pattern, patternOffset) {
      var tempPattern = "[";
      if (pattern.length > 1) {
        for (var index = 0; index < pattern.length; index++) {
          if (index === pattern.length - 1) {
            tempPattern += pattern[index].toString();
          } else {
            tempPattern += pattern[index].toString() + " ";
          }
        }
      }
      tempPattern += "] ";
      tempPattern += patternOffset.toString();
      tempPattern += " " + Operators.setDashPattern;
      this.stream.write(tempPattern);
      this.stream.write(Operators.newLine);
    };
    PdfStreamWriter2.prototype.setMiterLimit = function(miterLimit) {
      this.stream.write(PdfNumber.floatToString(miterLimit));
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setMiterLimit);
    };
    PdfStreamWriter2.prototype.setLineWidth = function(width) {
      this.stream.write(PdfNumber.floatToString(width));
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setLineWidth);
    };
    PdfStreamWriter2.prototype.setLineCap = function(lineCapStyle) {
      this.stream.write(lineCapStyle.toString());
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setLineCapStyle);
    };
    PdfStreamWriter2.prototype.setLineJoin = function(lineJoinStyle) {
      this.stream.write(lineJoinStyle.toString());
      this.stream.write(Operators.whiteSpace);
      this.writeOperator(Operators.setLineJoinStyle);
    };
    Object.defineProperty(PdfStreamWriter2.prototype, "position", {
      //IPdfWriter members
      /**
       * Gets or sets the current `position` within the stream.
       * @private
       */
      get: function() {
        return this.stream.position;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStreamWriter2.prototype, "length", {
      /**
       * Gets `stream length`.
       * @private
       */
      get: function() {
        var returnValue = 0;
        if (this.stream.data.length !== 0 && this.stream.data.length !== -1) {
          for (var index = 0; index < this.stream.data.length; index++) {
            returnValue += this.stream.data[index].length;
          }
        }
        return returnValue;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfStreamWriter2.prototype, "document", {
      /**
       * Gets and Sets the `current document`.
       * @private
       */
      get: function() {
        return null;
      },
      enumerable: true,
      configurable: true
    });
    PdfStreamWriter2.prototype.appendBezierSegment = function(arg1, arg2, arg3, arg4, arg5, arg6) {
      if (arg1 instanceof PointF && arg2 instanceof PointF && arg3 instanceof PointF) {
        this.writePoint(arg1.x, arg1.y);
        this.writePoint(arg2.x, arg2.y);
        this.writePoint(arg3.x, arg3.y);
      } else {
        this.writePoint(arg1, arg2);
        this.writePoint(arg3, arg4);
        this.writePoint(arg5, arg6);
      }
      this.writeOperator(Operators.appendbeziercurve);
    };
    PdfStreamWriter2.prototype.setColourWithPattern = function(colours, patternName, forStroking) {
      if (colours != null) {
        var count = colours.length;
        var i = 0;
        for (i = 0; i < count; ++i) {
          this.stream.write(colours[i].toString());
          this.stream.write(Operators.whiteSpace);
        }
      }
      if (patternName != null) {
        this.stream.write(patternName.toString());
        this.stream.write(Operators.whiteSpace);
      }
      if (forStroking) {
        this.writeOperator(Operators.setColorAndPatternStroking);
      } else {
        this.writeOperator(Operators.setColorAndPattern);
      }
    };
    return PdfStreamWriter2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-pen.js
var PdfPen = (
  /** @class */
  (function() {
    function PdfPen2(arg1, arg2) {
      this.pdfColor = new PdfColor(0, 0, 0);
      this.dashOffsetValue = 0;
      this.penDashPattern = [0];
      this.pdfDashStyle = PdfDashStyle.Solid;
      this.pdfLineCap = 0;
      this.pdfLineJoin = 0;
      this.penWidth = 1;
      this.internalMiterLimit = 0;
      this.colorSpace = PdfColorSpace.Rgb;
      if (arg1 instanceof PdfBrush) {
        this.setBrush(arg1);
      } else if (arg1 instanceof PdfColor) {
        this.color = arg1;
      }
      if (typeof arg2 === "number") {
        this.width = arg2;
      }
    }
    Object.defineProperty(PdfPen2.prototype, "color", {
      //Properties
      /**
       * Gets or sets the `color of the pen`.
       * @private
       */
      get: function() {
        return this.pdfColor;
      },
      set: function(value) {
        this.pdfColor = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "dashOffset", {
      /**
       * Gets or sets the `dash offset of the pen`.
       * @private
       */
      get: function() {
        if (typeof this.dashOffsetValue === "undefined" || this.dashOffsetValue == null) {
          return 0;
        } else {
          return this.dashOffsetValue;
        }
      },
      set: function(value) {
        this.dashOffsetValue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "dashPattern", {
      /**
       * Gets or sets the `dash pattern of the pen`.
       * @private
       */
      get: function() {
        return this.penDashPattern;
      },
      set: function(value) {
        this.penDashPattern = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "dashStyle", {
      /**
       * Gets or sets the `dash style of the pen`.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // create a new page
       * let page1 : PdfPage = document.pages.add();
       * // set pen
       * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
       * //
       * // set pen style
       * pen.dashStyle = PdfDashStyle.DashDot;
       * // get pen style
       * let style : PdfDashStyle = pen.dashStyle;
       * //
       * // draw rectangle
       * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
       * // save the document.
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.pdfDashStyle;
      },
      set: function(value) {
        if (this.pdfDashStyle !== value) {
          this.pdfDashStyle = value;
          switch (this.pdfDashStyle) {
            case PdfDashStyle.Custom:
              break;
            case PdfDashStyle.Dash:
              this.penDashPattern = [3, 1];
              break;
            case PdfDashStyle.Dot:
              this.penDashPattern = [1, 1];
              break;
            case PdfDashStyle.DashDot:
              this.penDashPattern = [3, 1, 1, 1];
              break;
            case PdfDashStyle.DashDotDot:
              this.penDashPattern = [3, 1, 1, 1, 1, 1];
              break;
            case PdfDashStyle.Solid:
              break;
            default:
              this.pdfDashStyle = PdfDashStyle.Solid;
              this.penDashPattern = [0];
              break;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "lineCap", {
      /**
       * Gets or sets the `line cap of the pen`.
       * @private
       */
      get: function() {
        return this.pdfLineCap;
      },
      set: function(value) {
        this.pdfLineCap = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "lineJoin", {
      /**
       * Gets or sets the `line join style of the pen`.
       * @private
       */
      get: function() {
        return this.pdfLineJoin;
      },
      set: function(value) {
        this.pdfLineJoin = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "miterLimit", {
      /**
       * Gets or sets the `miter limit`.
       * @private
       */
      get: function() {
        return this.internalMiterLimit;
      },
      set: function(value) {
        this.internalMiterLimit = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPen2.prototype, "width", {
      /**
       * Gets or sets the `width of the pen`.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // create a new page
       * let page1 : PdfPage = document.pages.add();
       * // set pen
       * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
       * //
       * // set pen width
       * pen.width = 2;
       * //
       * // draw rectangle
       * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
       * // save the document.
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.penWidth;
      },
      set: function(value) {
        this.penWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfPen2.prototype.clone = function() {
      var pen = this;
      return pen;
    };
    PdfPen2.prototype.setBrush = function(brush) {
      var sBrush = brush;
      if (sBrush != null && sBrush instanceof PdfSolidBrush) {
        this.color = sBrush.color;
        this.pdfBrush = sBrush;
      }
      this.color = sBrush.color;
      this.pdfBrush = sBrush;
    };
    PdfPen2.prototype.monitorChanges = function(currentPen, streamWriter, getResources, saveState, currentColorSpace, matrix) {
      var diff = false;
      saveState = true;
      if (currentPen == null) {
        diff = true;
      }
      diff = this.dashControl(currentPen, saveState, streamWriter);
      streamWriter.setLineWidth(this.width);
      streamWriter.setLineJoin(this.lineJoin);
      streamWriter.setLineCap(this.lineCap);
      var miterLimit = this.miterLimit;
      if (miterLimit > 0) {
        streamWriter.setMiterLimit(miterLimit);
        diff = true;
      }
      var brush = this.pdfBrush;
      streamWriter.setColorAndSpace(this.color, currentColorSpace, true);
      diff = true;
      return diff;
    };
    PdfPen2.prototype.dashControl = function(pen, saveState, streamWriter) {
      saveState = true;
      var lineWidth = this.width;
      var pattern = this.getPattern();
      streamWriter.setLineDashPattern(pattern, this.dashOffset * lineWidth);
      return saveState;
    };
    PdfPen2.prototype.getPattern = function() {
      var pattern = this.dashPattern;
      for (var i = 0; i < pattern.length; ++i) {
        pattern[i] *= this.width;
      }
      return pattern;
    };
    return PdfPen2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-transformation-matrix.js
var PdfTransformationMatrix = (
  /** @class */
  (function() {
    function PdfTransformationMatrix2(value) {
      this.radDegFactor = 180 / Math.PI;
      if (typeof value === "undefined") {
        this.transformationMatrix = new Matrix(1, 0, 0, 1, 0, 0);
      } else {
        this.transformationMatrix = new Matrix(1, 0, 0, -1, 0, 0);
      }
    }
    Object.defineProperty(PdfTransformationMatrix2.prototype, "matrix", {
      // Properties
      /**
       * Gets or sets the `internal matrix object`.
       * @private
       */
      get: function() {
        return this.transformationMatrix;
      },
      set: function(value) {
        this.transformationMatrix = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfTransformationMatrix2.prototype.translate = function(offsetX, offsetY) {
      this.transformationMatrix.translate(offsetX, offsetY);
    };
    PdfTransformationMatrix2.prototype.scale = function(scaleX, scaleY) {
      this.transformationMatrix.elements[0] = scaleX;
      this.transformationMatrix.elements[3] = scaleY;
    };
    PdfTransformationMatrix2.prototype.rotate = function(angle) {
      angle = angle * Math.PI / 180;
      this.transformationMatrix.elements[0] = Math.cos(angle);
      this.transformationMatrix.elements[1] = Math.sin(angle);
      this.transformationMatrix.elements[2] = -Math.sin(angle);
      this.transformationMatrix.elements[3] = Math.cos(angle);
    };
    PdfTransformationMatrix2.prototype.toString = function() {
      var builder = "";
      var whitespace = " ";
      for (var i = 0, len = this.transformationMatrix.elements.length; i < len; i++) {
        var temp = this.matrix.elements[i];
        builder += PdfNumber.floatToString(this.transformationMatrix.elements[i]);
        builder += whitespace;
      }
      return builder;
    };
    PdfTransformationMatrix2.prototype.multiply = function(matrix) {
      this.transformationMatrix.multiply(matrix.matrix);
    };
    PdfTransformationMatrix2.degreesToRadians = function(degreesX) {
      return this.degRadFactor * degreesX;
    };
    PdfTransformationMatrix2.prototype.radiansToDegrees = function(radians) {
      return this.radDegFactor * radians;
    };
    PdfTransformationMatrix2.prototype.clone = function() {
      return this;
    };
    PdfTransformationMatrix2.degRadFactor = Math.PI / 180;
    return PdfTransformationMatrix2;
  })()
);
var Matrix = (
  /** @class */
  (function() {
    function Matrix2(arg1, arg2, arg3, arg4, arg5, arg6) {
      if (typeof arg1 === "undefined") {
        this.metrixElements = [];
      } else if (typeof arg1 === "number") {
        this.metrixElements = [];
        this.metrixElements.push(arg1);
        this.metrixElements.push(arg2);
        this.metrixElements.push(arg3);
        this.metrixElements.push(arg4);
        this.metrixElements.push(arg5);
        this.metrixElements.push(arg6);
      } else {
        this.metrixElements = arg1;
      }
    }
    Object.defineProperty(Matrix2.prototype, "elements", {
      // Properties
      /**
       * Gets the `elements`.
       * @private
       */
      get: function() {
        return this.metrixElements;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Matrix2.prototype, "offsetX", {
      /**
       * Gets the off set `X`.
       * @private
       */
      get: function() {
        return this.metrixElements[4];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Matrix2.prototype, "offsetY", {
      /**
       * Gets the off set `Y`.
       * @private
       */
      get: function() {
        return this.metrixElements[5];
      },
      enumerable: true,
      configurable: true
    });
    Matrix2.prototype.translate = function(offsetX, offsetY) {
      this.metrixElements[4] = offsetX;
      this.metrixElements[5] = offsetY;
    };
    Matrix2.prototype.transform = function(point) {
      var x = point.x;
      var y = point.y;
      var x2 = x * this.elements[0] + y * this.elements[2] + this.offsetX;
      var y2 = x * this.elements[1] + y * this.elements[3] + this.offsetY;
      return new PointF(x2, y2);
    };
    Matrix2.prototype.multiply = function(matrix) {
      var tempMatrix = [];
      tempMatrix.push(this.elements[0] * matrix.elements[0] + this.elements[1] * matrix.elements[2]);
      tempMatrix[1] = this.elements[0] * matrix.elements[1] + this.elements[1] * matrix.elements[3];
      tempMatrix[2] = this.elements[2] * matrix.elements[0] + this.elements[3] * matrix.elements[2];
      tempMatrix[3] = this.elements[2] * matrix.elements[1] + this.elements[3] * matrix.elements[3];
      tempMatrix[4] = this.offsetX * matrix.elements[0] + this.offsetY * matrix.elements[2] + matrix.offsetX;
      tempMatrix[5] = this.offsetX * matrix.elements[1] + this.offsetY * matrix.elements[3] + matrix.offsetY;
      for (var i = 0; i < tempMatrix.length; i++) {
        this.elements[i] = tempMatrix[i];
      }
    };
    Matrix2.prototype.dispose = function() {
      this.metrixElements = null;
    };
    Matrix2.prototype.clone = function() {
      var m = new Matrix2(this.metrixElements);
      return m;
    };
    return Matrix2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/constants.js
var ProcedureSets = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ProcedureSets2() {
      this.pdf = "PDF";
      this.text = "Text";
      this.imageB = "ImageB";
      this.imageC = "ImageC";
      this.imageI = "ImageI";
    }
    return ProcedureSets2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/collections/object-object-pair/dictionary.js
var TemporaryDictionary = (
  /** @class */
  (function() {
    function TemporaryDictionary2() {
      this.mKeys = [];
      this.mValues = [];
    }
    TemporaryDictionary2.prototype.size = function() {
      return this.mKeys.length;
    };
    TemporaryDictionary2.prototype.add = function(key, value) {
      if (key === void 0 || key === null || value === void 0 || value === null) {
        throw new ReferenceError("Provided key or value is not valid.");
      }
      var index = this.mKeys.indexOf(key);
      if (index < 0) {
        this.mKeys.push(key);
        this.mValues.push(value);
        return 1;
      } else {
        throw new RangeError("An item with the same key has already been added.");
      }
    };
    TemporaryDictionary2.prototype.keys = function() {
      return this.mKeys;
    };
    TemporaryDictionary2.prototype.values = function() {
      return this.mValues;
    };
    TemporaryDictionary2.prototype.getValue = function(key) {
      if (key === void 0 || key === null) {
        throw new ReferenceError("Provided key is not valid.");
      }
      var index = this.mKeys.indexOf(key);
      if (index < 0) {
        throw new RangeError("No item with the specified key has been added.");
      } else {
        return this.mValues[index];
      }
    };
    TemporaryDictionary2.prototype.setValue = function(key, value) {
      if (key === void 0 || key === null) {
        throw new ReferenceError("Provided key is not valid.");
      }
      var index = this.mKeys.indexOf(key);
      if (index < 0) {
        this.mKeys.push(key);
        this.mValues.push(value);
      } else {
        this.mValues[index] = value;
      }
    };
    TemporaryDictionary2.prototype.remove = function(key) {
      if (key === void 0 || key === null) {
        throw new ReferenceError("Provided key is not valid.");
      }
      var index = this.mKeys.indexOf(key);
      if (index < 0) {
        throw new RangeError("No item with the specified key has been added.");
      } else {
        this.mKeys.splice(index, 1);
        this.mValues.splice(index, 1);
        return true;
      }
    };
    TemporaryDictionary2.prototype.containsKey = function(key) {
      if (key === void 0 || key === null) {
        throw new ReferenceError("Provided key is not valid.");
      }
      var index = this.mKeys.indexOf(key);
      if (index < 0) {
        return false;
      }
      return true;
    };
    TemporaryDictionary2.prototype.clear = function() {
      this.mKeys = [];
      this.mValues = [];
    };
    return TemporaryDictionary2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-transparency.js
var PdfTransparency = (
  /** @class */
  (function() {
    function PdfTransparency2(stroke, fill, mode) {
      this.dictionary = new PdfDictionary();
      this.dictionaryProperties = new DictionaryProperties();
      this.dictionary.items.setValue(this.dictionaryProperties.CA, new PdfNumber(stroke));
      this.dictionary.items.setValue(this.dictionaryProperties.ca, new PdfNumber(fill));
      this.dictionary.items.setValue(this.dictionaryProperties.BM, new PdfName(mode.toString()));
    }
    Object.defineProperty(PdfTransparency2.prototype, "element", {
      // // Implementation
      // /**
      //  * Gets the `number value`.
      //  * @private
      //  */
      // private getNumber(keyName : string) : number {
      //     let result : number = 0.0;
      //     let numb : PdfNumber = this.dictionary.items.getValue(keyName) as PdfNumber;
      //     result = numb.intValue;
      //     return result;
      // }
      // /**
      //  * Gets the `name value`.
      //  * @private
      //  */
      // private getName(keyName : string) : string {
      //     let result : string = null;
      //     let name : PdfName = this.dictionary.items.getValue(keyName) as PdfName;
      //     result = name.value;
      //     return result;
      // }
      // IPdfWrapper Members
      /**
       * Gets the `element`.
       * @private
       */
      get: function() {
        return this.dictionary;
      },
      enumerable: true,
      configurable: true
    });
    return PdfTransparency2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/automatic-field-info-collection.js
var PdfAutomaticFieldInfoCollection = (
  /** @class */
  (function() {
    function PdfAutomaticFieldInfoCollection2() {
      this.automaticFieldsInformation = [];
    }
    Object.defineProperty(PdfAutomaticFieldInfoCollection2.prototype, "automaticFields", {
      /**
       * Gets the `page number fields collection`.
       * @private
       */
      get: function() {
        return this.automaticFieldsInformation;
      },
      enumerable: true,
      configurable: true
    });
    PdfAutomaticFieldInfoCollection2.prototype.add = function(fieldInfo) {
      return this.automaticFields.push(fieldInfo);
    };
    return PdfAutomaticFieldInfoCollection2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/graphics-element.js
var PdfGraphicsElement = (
  /** @class */
  (function() {
    function PdfGraphicsElement2() {
    }
    PdfGraphicsElement2.prototype.drawHelper = function(graphics, x, y) {
      var bNeedSave = x !== 0 || y !== 0;
      var gState = null;
      if (bNeedSave) {
        gState = graphics.save();
        graphics.translateTransform(x, y);
      }
      this.drawInternal(graphics);
      if (bNeedSave) {
        graphics.restore(gState);
      }
    };
    return PdfGraphicsElement2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/automatic-field.js
var __extends27 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfAutomaticField = (
  /** @class */
  (function(_super) {
    __extends27(PdfAutomaticField2, _super);
    function PdfAutomaticField2() {
      var _this = _super.call(this) || this;
      _this.internalBounds = new RectangleF(0, 0, 0, 0);
      _this.internalTemplateSize = new SizeF(0, 0);
      return _this;
    }
    Object.defineProperty(PdfAutomaticField2.prototype, "bounds", {
      // Properties
      get: function() {
        return this.internalBounds;
      },
      set: function(value) {
        this.internalBounds = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticField2.prototype, "size", {
      get: function() {
        return new SizeF(this.bounds.width, this.bounds.height);
      },
      set: function(value) {
        this.bounds.width = value.width;
        this.bounds.height = value.height;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticField2.prototype, "location", {
      get: function() {
        return new PointF(this.bounds.x, this.bounds.y);
      },
      set: function(value) {
        this.bounds.x = value.x;
        this.bounds.y = value.y;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticField2.prototype, "font", {
      get: function() {
        return this.internalFont;
      },
      set: function(value) {
        this.internalFont = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticField2.prototype, "brush", {
      get: function() {
        return this.internalBrush;
      },
      set: function(value) {
        this.internalBrush = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticField2.prototype, "pen", {
      get: function() {
        return this.internalPen;
      },
      set: function(value) {
        this.internalPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticField2.prototype, "stringFormat", {
      get: function() {
        return this.internalStringFormat;
      },
      set: function(value) {
        this.internalStringFormat = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfAutomaticField2.prototype.performDrawHelper = function(graphics, location2, scalingX, scalingY) {
      if (this.bounds.height === 0 || this.bounds.width === 0) {
        var text = this.getValue(graphics);
        this.internalTemplateSize = this.getFont().measureString(text, this.size, this.stringFormat);
      }
    };
    PdfAutomaticField2.prototype.draw = function(arg1, arg2, arg3) {
      if (typeof arg2 === "undefined") {
        var location_1 = new PointF(0, 0);
        this.draw(arg1, location_1);
      } else if (arg2 instanceof PointF) {
        this.draw(arg1, arg2.x, arg2.y);
      } else {
        this.drawHelper(arg1, arg2, arg3);
        var info = new PdfAutomaticFieldInfo(this, new PointF(arg2, arg3));
        arg1.automaticFields.add(info);
      }
    };
    PdfAutomaticField2.prototype.getSize = function() {
      if (this.bounds.height === 0 || this.bounds.width === 0) {
        return this.internalTemplateSize;
      } else {
        return this.size;
      }
    };
    PdfAutomaticField2.prototype.drawInternal = function(graphics) {
    };
    PdfAutomaticField2.prototype.getBrush = function() {
      return typeof this.internalBrush === "undefined" || this.internalBrush == null ? new PdfSolidBrush(new PdfColor(0, 0, 0)) : this.internalBrush;
    };
    PdfAutomaticField2.prototype.getFont = function() {
      return typeof this.internalFont === "undefined" || this.internalFont == null ? PdfDocument.defaultFont : this.internalFont;
    };
    PdfAutomaticField2.prototype.getPageFromGraphics = function(graphics) {
      if (typeof graphics.page !== "undefined" && graphics.page !== null) {
        var page = graphics.page;
        return page;
      } else {
        var page = graphics.currentPage;
        return page;
      }
    };
    return PdfAutomaticField2;
  })(PdfGraphicsElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/automatic-field-info.js
var PdfAutomaticFieldInfo = (
  /** @class */
  (function() {
    function PdfAutomaticFieldInfo2(field, location2, scaleX, scaleY) {
      this.pageNumberFieldLocation = new PointF();
      this.pageNumberField = null;
      this.scaleX = 1;
      this.scaleY = 1;
      if (typeof location2 === "undefined" && field instanceof PdfAutomaticFieldInfo2) {
        this.pageNumberField = field.field;
        this.pageNumberFieldLocation = field.location;
        this.scaleX = field.scalingX;
        this.scaleY = field.scalingY;
      } else if (typeof scaleX === "undefined" && location2 instanceof PointF && field instanceof PdfAutomaticField) {
        this.pageNumberField = field;
        this.pageNumberFieldLocation = location2;
      } else {
        this.pageNumberField = field;
        this.pageNumberFieldLocation = location2;
        this.scaleX = scaleX;
        this.scaleY = scaleY;
      }
    }
    Object.defineProperty(PdfAutomaticFieldInfo2.prototype, "location", {
      /* tslint:enable */
      // Properties
      /**
       * Gets or sets the location.
       * @private
       */
      get: function() {
        return this.pageNumberFieldLocation;
      },
      set: function(value) {
        this.pageNumberFieldLocation = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticFieldInfo2.prototype, "field", {
      /**
       * Gets or sets the field.
       * @private
       */
      get: function() {
        return this.pageNumberField;
      },
      set: function(value) {
        this.pageNumberField = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticFieldInfo2.prototype, "scalingX", {
      /**
       * Gets or sets the scaling X factor.
       * @private
       */
      get: function() {
        return this.scaleX;
      },
      set: function(value) {
        this.scaleX = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAutomaticFieldInfo2.prototype, "scalingY", {
      /**
       * Gets or sets the scaling Y factor.
       * @private
       */
      get: function() {
        return this.scaleY;
      },
      set: function(value) {
        this.scaleY = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfAutomaticFieldInfo2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/images/byte-array.js
var ByteArray = (
  /** @class */
  (function() {
    function ByteArray2(length) {
      this.mPosition = 0;
      this.buffer = new Uint8Array(length);
      this.dataView = new DataView(this.buffer.buffer);
    }
    Object.defineProperty(ByteArray2.prototype, "position", {
      /**
       * Gets and Sets a current `position` of byte array.
       * @hidden
       * @private
       */
      get: function() {
        return this.mPosition;
      },
      set: function(value) {
        this.mPosition = value;
      },
      enumerable: true,
      configurable: true
    });
    ByteArray2.prototype.read = function(buffer, offset, count) {
      for (var index = offset; index < count; index++) {
        var position = this.position;
        buffer.buffer[index] = this.readByte(position);
        this.position++;
      }
    };
    ByteArray2.prototype.getBuffer = function(index) {
      return this.buffer[index];
    };
    ByteArray2.prototype.writeFromBase64String = function(base64) {
      var arr = this.encodedString(base64);
      this.buffer = arr;
    };
    ByteArray2.prototype.encodedString = function(input) {
      var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var chr1;
      var chr2;
      var chr3;
      var enc1;
      var enc2;
      var enc3;
      var enc4;
      var i = 0;
      var resultIndex = 0;
      var dataUrlPrefix = "data:";
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var totalLength = input.length * 3 / 4;
      if (input.charAt(input.length - 1) === keyStr.charAt(64)) {
        totalLength--;
      }
      var output = new Uint8Array(totalLength | 0);
      while (i < input.length) {
        enc1 = keyStr.indexOf(input.charAt(i++));
        enc2 = keyStr.indexOf(input.charAt(i++));
        enc3 = keyStr.indexOf(input.charAt(i++));
        enc4 = keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output[resultIndex++] = chr1;
        output[resultIndex++] = chr2;
        output[resultIndex++] = chr3;
      }
      return output;
    };
    ByteArray2.prototype.readByte = function(offset) {
      return this.buffer[offset];
    };
    Object.defineProperty(ByteArray2.prototype, "internalBuffer", {
      /**
       * @hidden
       */
      get: function() {
        return this.buffer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ByteArray2.prototype, "count", {
      /**
       * @hidden
       */
      get: function() {
        return this.buffer.byteLength;
      },
      enumerable: true,
      configurable: true
    });
    ByteArray2.prototype.readNextTwoBytes = function(stream) {
      var data = stream.readByte(this.position);
      this.position++;
      data <<= 8;
      data |= stream.readByte(this.position);
      this.position++;
      return data;
    };
    return ByteArray2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/images/image-decoder.js
var ImageFormat;
(function(ImageFormat2) {
  ImageFormat2[ImageFormat2["Unknown"] = 0] = "Unknown";
  ImageFormat2[ImageFormat2["Bmp"] = 1] = "Bmp";
  ImageFormat2[ImageFormat2["Emf"] = 2] = "Emf";
  ImageFormat2[ImageFormat2["Gif"] = 3] = "Gif";
  ImageFormat2[ImageFormat2["Jpeg"] = 4] = "Jpeg";
  ImageFormat2[ImageFormat2["Png"] = 5] = "Png";
  ImageFormat2[ImageFormat2["Wmf"] = 6] = "Wmf";
  ImageFormat2[ImageFormat2["Icon"] = 7] = "Icon";
})(ImageFormat || (ImageFormat = {}));
var ImageDecoder = (
  /** @class */
  (function() {
    function ImageDecoder2(stream) {
      this.sof1Marker = 193;
      this.sof2Marker = 194;
      this.sof3Marker = 195;
      this.sof5Marker = 197;
      this.sof6Marker = 198;
      this.sof7Marker = 199;
      this.sof9Marker = 201;
      this.sof10Marker = 202;
      this.sof11Marker = 203;
      this.sof13Marker = 205;
      this.sof14Marker = 206;
      this.sof15Marker = 207;
      this.mFormat = ImageFormat.Unknown;
      this.mbitsPerComponent = 8;
      this.dictionaryProperties = new DictionaryProperties();
      this.mStream = stream;
      this.initialize();
    }
    Object.defineProperty(ImageDecoder2.prototype, "height", {
      /**
       * Gets the `height` of image.
       * @hidden
       * @private
       */
      get: function() {
        return this.mHeight;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ImageDecoder2.prototype, "width", {
      /**
       * Gets the `width` of image.
       * @hidden
       * @private
       */
      get: function() {
        return this.mWidth;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ImageDecoder2.prototype, "bitsPerComponent", {
      /**
       * Gets `bits per component`.
       * @hidden
       * @private
       */
      get: function() {
        return this.mbitsPerComponent;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ImageDecoder2.prototype, "size", {
      /**
       * Gets the `size` of an image data.
       * @hidden
       * @private
       */
      get: function() {
        return this.mImageData.count;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ImageDecoder2.prototype, "imageData", {
      /**
       * Gets the value of an `image data`.
       * @hidden
       * @private
       */
      get: function() {
        return this.mImageData;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ImageDecoder2.prototype, "imageDataAsNumberArray", {
      /**
       * Gets the value of an `image data as number array`.
       * @hidden
       * @private
       */
      get: function() {
        return this.mImageData.internalBuffer.buffer;
      },
      enumerable: true,
      configurable: true
    });
    ImageDecoder2.prototype.initialize = function() {
      if (this.mFormat === ImageFormat.Unknown && this.checkIfJpeg()) {
        this.mFormat = ImageFormat.Jpeg;
        this.parseJpegImage();
      } else {
        throw new TypeError("Only the JPEG format is supported");
      }
      this.reset();
      this.mImageData = new ByteArray(this.mStream.count);
      this.mStream.read(this.mImageData, 0, this.mImageData.count);
    };
    ImageDecoder2.prototype.reset = function() {
      this.mStream.position = 0;
    };
    ImageDecoder2.prototype.parseJpegImage = function() {
      this.reset();
      var imgData = new ByteArray(this.mStream.count);
      this.mStream.read(imgData, 0, imgData.count);
      var i = 4;
      var isLengthExceed = false;
      var length = imgData.getBuffer(i) * 256 + imgData.getBuffer(i + 1);
      while (i < imgData.count) {
        i += length;
        if (i < imgData.count) {
          if (imgData.getBuffer(i + 1) === 192) {
            this.mHeight = imgData.getBuffer(i + 5) * 256 + imgData.getBuffer(i + 6);
            this.mWidth = imgData.getBuffer(i + 7) * 256 + imgData.getBuffer(i + 8);
            return;
          } else {
            i += 2;
            length = imgData.getBuffer(i) * 256 + imgData.getBuffer(i + 1);
          }
        } else {
          isLengthExceed = true;
          break;
        }
      }
      if (isLengthExceed) {
        this.mStream.position = 0;
        this.skip(this.mStream, 2);
        this.readExceededJPGImage(this.mStream);
      }
    };
    Object.defineProperty(ImageDecoder2.prototype, "format", {
      /**
       * Gets the image `format`.
       * @private
       * @hidden
       */
      get: function() {
        return this.mFormat;
      },
      enumerable: true,
      configurable: true
    });
    ImageDecoder2.prototype.checkIfJpeg = function() {
      this.reset();
      for (var i = 0; i < ImageDecoder2.mJpegHeader.length; i++) {
        if (ImageDecoder2.mJpegHeader[i] !== this.mStream.readByte(i)) {
          return false;
        }
        this.mStream.position++;
      }
      return true;
    };
    ImageDecoder2.prototype.getImageDictionary = function() {
      if (this.mFormat === ImageFormat.Jpeg) {
        var tempArrayBuffer = this.imageData.internalBuffer.length;
        this.imageStream = new PdfStream();
        this.imageStream.isResource = true;
        var tempString = "";
        var decodedString = "";
        for (var i = 0; i < this.imageDataAsNumberArray.byteLength; i++) {
          tempString += String.fromCharCode(null, this.mStream.readByte(i));
        }
        for (var i = 0; i < tempString.length; i++) {
          if (i % 2 !== 0) {
            decodedString += tempString[i];
          }
        }
        this.imageStream.data = [decodedString];
        this.imageStream.compress = false;
        this.imageStream.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.xObject));
        this.imageStream.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.image));
        this.imageStream.items.setValue(this.dictionaryProperties.width, new PdfNumber(this.width));
        this.imageStream.items.setValue(this.dictionaryProperties.height, new PdfNumber(this.height));
        this.imageStream.items.setValue(this.dictionaryProperties.bitsPerComponent, new PdfNumber(this.bitsPerComponent));
        this.imageStream.items.setValue(this.dictionaryProperties.filter, new PdfName(this.dictionaryProperties.dctdecode));
        this.imageStream.items.setValue(this.dictionaryProperties.colorSpace, new PdfName(this.getColorSpace()));
        this.imageStream.items.setValue(this.dictionaryProperties.decodeParms, this.getDecodeParams());
        return this.imageStream;
      } else {
        return this.imageStream;
      }
    };
    ImageDecoder2.prototype.getColorSpace = function() {
      return this.dictionaryProperties.deviceRgb;
    };
    ImageDecoder2.prototype.getDecodeParams = function() {
      var decodeParams = new PdfDictionary();
      decodeParams.items.setValue(this.dictionaryProperties.columns, new PdfNumber(this.width));
      decodeParams.items.setValue(this.dictionaryProperties.blackIs1, new PdfBoolean(true));
      decodeParams.items.setValue(this.dictionaryProperties.k, new PdfNumber(-1));
      decodeParams.items.setValue(this.dictionaryProperties.predictor, new PdfNumber(15));
      decodeParams.items.setValue(this.dictionaryProperties.bitsPerComponent, new PdfNumber(this.bitsPerComponent));
      return decodeParams;
    };
    ImageDecoder2.prototype.readExceededJPGImage = function(stream) {
      this.mStream = stream;
      var isContinueReading = true;
      while (isContinueReading) {
        var marker2 = this.getMarker(stream);
        switch (marker2) {
          case this.sof1Marker:
          case this.sof2Marker:
          case this.sof3Marker:
          case this.sof5Marker:
          case this.sof6Marker:
          case this.sof7Marker:
          case this.sof9Marker:
          case this.sof10Marker:
          case this.sof11Marker:
          case this.sof13Marker:
          case this.sof14Marker:
          case this.sof15Marker:
            stream.position += 3;
            this.mHeight = this.mStream.readNextTwoBytes(stream);
            this.mWidth = this.mStream.readNextTwoBytes(stream);
            isContinueReading = false;
            break;
          default:
            this.skipStream(stream);
            break;
        }
      }
    };
    ImageDecoder2.prototype.skip = function(stream, noOfBytes) {
      this.mStream = stream;
      var temp = new ByteArray(noOfBytes);
      this.mStream.read(temp, 0, temp.count);
    };
    ImageDecoder2.prototype.getMarker = function(stream) {
      var skippedByte = 0;
      var marker2 = 32;
      marker2 = stream.readByte(this.mStream.position);
      stream.position++;
      while (marker2 !== 255) {
        skippedByte++;
        marker2 = stream.readByte(this.mStream.position);
        stream.position++;
      }
      do {
        marker2 = stream.readByte(this.mStream.position);
        stream.position++;
      } while (marker2 === 255);
      return marker2;
    };
    ImageDecoder2.prototype.skipStream = function(stream) {
      var markerLength = this.mStream.readNextTwoBytes(stream) - 2;
      if (markerLength > 0) {
        stream.position += markerLength;
      }
    };
    ImageDecoder2.mPngHeader = [137, 80, 78, 71, 13, 10, 26, 10];
    ImageDecoder2.mJpegHeader = [255, 216];
    ImageDecoder2.GIF_HEADER = "G,I,F,8";
    ImageDecoder2.BMP_HEADER = "B,M";
    return ImageDecoder2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/unit-convertor.js
var PdfUnitConverter = (
  /** @class */
  (function() {
    function PdfUnitConverter2(dpi) {
      this.updateProportionsHelper(dpi);
    }
    PdfUnitConverter2.prototype.convertUnits = function(value, from, to) {
      return this.convertFromPixels(this.convertToPixels(value, from), to);
    };
    PdfUnitConverter2.prototype.convertToPixels = function(value, from) {
      var index = from;
      var result = value * this.proportions[index];
      return result;
    };
    PdfUnitConverter2.prototype.convertFromPixels = function(value, to) {
      var index = to;
      var result = value / this.proportions[index];
      return result;
    };
    PdfUnitConverter2.prototype.updateProportionsHelper = function(pixelPerInch) {
      this.proportions = [
        pixelPerInch / 2.54,
        pixelPerInch / 6,
        1,
        pixelPerInch / 72,
        pixelPerInch,
        pixelPerInch / 300,
        pixelPerInch / 25.4
        // Millimeter
      ];
    };
    PdfUnitConverter2.horizontalResolution = 96;
    PdfUnitConverter2.verticalResolution = 96;
    return PdfUnitConverter2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/images/pdf-image.js
var PdfImage = (
  /** @class */
  (function() {
    function PdfImage2() {
    }
    Object.defineProperty(PdfImage2.prototype, "width", {
      /**
       * Gets and Sets the `width` of an image.
       * @private
       */
      get: function() {
        return this.imageWidth;
      },
      set: function(value) {
        this.imageWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfImage2.prototype, "height", {
      /**
       * Gets and Sets the `height` of an image.
       * @private
       */
      get: function() {
        return this.imageHeight;
      },
      set: function(value) {
        this.imageHeight = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfImage2.prototype, "size", {
      /**
       * Gets or sets the size of the image.
       * @private
       */
      set: function(value) {
        this.width = value.width;
        this.height = value.height;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfImage2.prototype, "physicalDimension", {
      /**
       * Gets the `physical dimension` of an image.
       * @private
       */
      get: function() {
        this.imagePhysicalDimension = this.getPointSize(this.width, this.height, this.horizontalResolution, this.verticalResolution);
        return new SizeF(this.width, this.height);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfImage2.prototype, "element", {
      // /**
      //  * Gets the `image stream as string`.
      //  * @private
      //  */
      // public static fromString(string : string) : PdfImage {
      //     let image : PdfImage = new PdfBitmap(string);
      //     return image;
      // }
      /**
       * Gets the `element` image stream.
       * @private
       */
      get: function() {
        return this.imageStream;
      },
      enumerable: true,
      configurable: true
    });
    PdfImage2.prototype.getPointSize = function(width, height, horizontalResolution, verticalResolution) {
      if (typeof horizontalResolution === "undefined") {
        var dpiX = PdfUnitConverter.horizontalResolution;
        var dpiY = PdfUnitConverter.verticalResolution;
        var size = this.getPointSize(width, height, dpiX, dpiY);
        return size;
      } else {
        var ucX = new PdfUnitConverter(horizontalResolution);
        var ucY = new PdfUnitConverter(verticalResolution);
        var ptWidth = ucX.convertUnits(width, PdfGraphicsUnit.Pixel, PdfGraphicsUnit.Point);
        var ptHeight = ucY.convertUnits(height, PdfGraphicsUnit.Pixel, PdfGraphicsUnit.Point);
        var size = new SizeF(ptWidth, ptHeight);
        return size;
      }
    };
    return PdfImage2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/images/pdf-bitmap.js
var __extends28 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfBitmap = (
  /** @class */
  (function(_super) {
    __extends28(PdfBitmap2, _super);
    function PdfBitmap2(encodedString) {
      var _this = _super.call(this) || this;
      _this.imageStatus = true;
      _this.dictionaryProperties = new DictionaryProperties();
      _this.loadImage(encodedString);
      return _this;
    }
    PdfBitmap2.prototype.loadImage = function(encodedString) {
      var task = this.initializeAsync(encodedString);
    };
    PdfBitmap2.prototype.initializeAsync = function(encodedString) {
      var byteArray = new ByteArray(encodedString.length);
      byteArray.writeFromBase64String(encodedString);
      this.decoder = new ImageDecoder(byteArray);
      this.height = this.decoder.height;
      this.width = this.decoder.width;
      this.bitsPerComponent = this.decoder.bitsPerComponent;
    };
    PdfBitmap2.prototype.save = function() {
      this.imageStatus = true;
      this.imageStream = this.decoder.getImageDictionary();
    };
    return PdfBitmap2;
  })(PdfImage)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-table-info.js
var TtfTableInfo = (
  /** @class */
  (function() {
    function TtfTableInfo2() {
    }
    Object.defineProperty(TtfTableInfo2.prototype, "empty", {
      //Properties
      /**
       * Gets a value indicating whether this table is empty.
       * @private
       */
      get: function() {
        var empty = this.offset === this.length && this.length === this.checksum && this.checksum === 0;
        return empty;
      },
      enumerable: true,
      configurable: true
    });
    return TtfTableInfo2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-name-table.js
var TtfNameTable = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfNameTable2() {
    }
    return TtfNameTable2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-name-record.js
var TtfNameRecord = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfNameRecord2() {
    }
    return TtfNameRecord2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-head-table.js
var TtfHeadTable = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfHeadTable2() {
    }
    return TtfHeadTable2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-metrics.js
var TtfMetrics = (
  /** @class */
  (function() {
    function TtfMetrics2() {
    }
    Object.defineProperty(TtfMetrics2.prototype, "isItalic", {
      //Properties
      /**
       * Gets a value indicating whether this instance is italic.
       */
      get: function() {
        return (this.macStyle & 2) !== 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TtfMetrics2.prototype, "isBold", {
      /**
       * Gets a value indicating whether this instance is bold.
       */
      get: function() {
        return (this.macStyle & 1) !== 0;
      },
      enumerable: true,
      configurable: true
    });
    return TtfMetrics2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-horizontal-header-table.js
var TtfHorizontalHeaderTable = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfHorizontalHeaderTable2() {
    }
    return TtfHorizontalHeaderTable2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-OS2-Table.js
var TtfOS2Table = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfOS2Table2() {
    }
    return TtfOS2Table2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-post-table.js
var TtfPostTable = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfPostTable2() {
    }
    return TtfPostTable2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-long-hor-metric.js
var TtfLongHorMetric = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfLongHorMetric2() {
    }
    return TtfLongHorMetric2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-cmap-sub-table.js
var TtfCmapSubTable = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfCmapSubTable2() {
    }
    return TtfCmapSubTable2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-cmap-table.js
var TtfCmapTable = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfCmapTable2() {
    }
    return TtfCmapTable2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-glyph-info.js
var TtfGlyphInfo = (
  /** @class */
  (function() {
    function TtfGlyphInfo2() {
    }
    Object.defineProperty(TtfGlyphInfo2.prototype, "empty", {
      //Properties
      /**
       * Gets a value indicating whether this TtfGlyphInfo is empty.
       */
      get: function() {
        var empty = this.index === this.width && this.width === this.charCode && this.charCode === 0;
        return empty;
      },
      enumerable: true,
      configurable: true
    });
    TtfGlyphInfo2.prototype.compareTo = function(obj) {
      var glyph = obj;
      return this.index - glyph.index;
    };
    return TtfGlyphInfo2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-loca-table.js
var TtfLocaTable = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfLocaTable2() {
    }
    return TtfLocaTable2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-apple-cmap-sub-table.js
var TtfAppleCmapSubTable = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfAppleCmapSubTable2() {
    }
    return TtfAppleCmapSubTable2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-microsoft-cmap-sub-table.js
var TtfMicrosoftCmapSubTable = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfMicrosoftCmapSubTable2() {
    }
    return TtfMicrosoftCmapSubTable2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-trimmed-cmap-sub-table.js
var TtfTrimmedCmapSubTable = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfTrimmedCmapSubTable2() {
    }
    return TtfTrimmedCmapSubTable2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-glyph-header.js
var TtfGlyphHeader = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TtfGlyphHeader2() {
    }
    return TtfGlyphHeader2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/input-output/big-endian-writer.js
var BigEndianWriter = (
  /** @class */
  (function() {
    function BigEndianWriter2(capacity) {
      this.int32Size = 4;
      this.int16Size = 2;
      this.int64Size = 8;
      this.bufferLength = capacity;
      this.buffer = [];
    }
    Object.defineProperty(BigEndianWriter2.prototype, "data", {
      //Properties
      /**
       * Gets data written to the writer.
       */
      get: function() {
        if (this.buffer.length < this.bufferLength) {
          var length_1 = this.bufferLength - this.buffer.length;
          for (var i = 0; i < length_1; i++) {
            this.buffer.push(0);
          }
        }
        return this.buffer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BigEndianWriter2.prototype, "position", {
      /// <summary>
      /// Gets position of the internal buffer.
      /// </summary>
      get: function() {
        if (this.internalPosition === void 0 || this.internalPosition === null) {
          this.internalPosition = 0;
        }
        return this.internalPosition;
      },
      enumerable: true,
      configurable: true
    });
    BigEndianWriter2.prototype.writeShort = function(value) {
      var bytes = [(value & 65280) >> 8, value & 255];
      this.flush(bytes);
    };
    BigEndianWriter2.prototype.writeInt = function(value) {
      var i1 = (value & 4278190080) >> 24;
      i1 = i1 < 0 ? 256 + i1 : i1;
      var i2 = (value & 16711680) >> 16;
      i2 = i2 < 0 ? 256 + i2 : i2;
      var i3 = (value & 65280) >> 8;
      i3 = i3 < 0 ? 256 + i3 : i3;
      var i4 = value & 255;
      i4 = i4 < 0 ? 256 + i4 : i4;
      var bytes = [(value & 4278190080) >> 24, (value & 16711680) >> 16, (value & 65280) >> 8, value & 255];
      this.flush(bytes);
    };
    BigEndianWriter2.prototype.writeUInt = function(value) {
      var buff = [(value & 4278190080) >> 24, (value & 16711680) >> 16, (value & 65280) >> 8, value & 255];
      this.flush(buff);
    };
    BigEndianWriter2.prototype.writeString = function(value) {
      if (value == null) {
        throw new Error("Argument Null Exception : value");
      }
      var bytes = [];
      for (var i = 0; i < value.length; i++) {
        bytes.push(value.charCodeAt(i));
      }
      this.flush(bytes);
    };
    BigEndianWriter2.prototype.writeBytes = function(value) {
      this.flush(value);
    };
    BigEndianWriter2.prototype.flush = function(buff) {
      if (buff === null) {
        throw new Error("Argument Null Exception : buff");
      }
      var position = this.position;
      for (var i = 0; i < buff.length; i++) {
        this.buffer[position] = buff[i];
        position++;
      }
      this.internalPosition += buff.length;
    };
    return BigEndianWriter2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/ttf-reader.js
var TtfReader = (
  /** @class */
  (function() {
    function TtfReader2(fontData) {
      this.int32Size = 4;
      this.isTtcFont = false;
      this.isMacTtf = false;
      this.metricsName = "";
      this.isMacTTF = false;
      this.missedGlyphs = 0;
      this.tableNames = ["cvt ", "fpgm", "glyf", "head", "hhea", "hmtx", "loca", "maxp", "prep"];
      this.entrySelectors = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4];
      this._isOpenTypeFont = false;
      this.fontData = fontData;
      this.initialize();
    }
    Object.defineProperty(TtfReader2.prototype, "macintosh", {
      //Properties
      /**
       * Gets glyphs for Macintosh or Symbol fonts (char - key, glyph - value).
       */
      get: function() {
        if (this.macintoshDictionary === null || this.macintoshDictionary === void 0) {
          this.macintoshDictionary = new Dictionary();
        }
        return this.macintoshDictionary;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TtfReader2.prototype, "microsoft", {
      /**
       * Gets glyphs for Microsoft or Symbol fonts (char - key, glyph - value).
       */
      get: function() {
        if (this.microsoftDictionary === null || this.microsoftDictionary === void 0) {
          this.microsoftDictionary = new Dictionary();
        }
        return this.microsoftDictionary;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TtfReader2.prototype, "macintoshGlyphs", {
      /**
       * Gets glyphs for Macintosh or Symbol fonts (glyph index - key, glyph - value).
       */
      get: function() {
        if (this.internalMacintoshGlyphs === null || this.internalMacintoshGlyphs === void 0) {
          this.internalMacintoshGlyphs = new Dictionary();
        }
        return this.internalMacintoshGlyphs;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(TtfReader2.prototype, "microsoftGlyphs", {
      /**
       * Gets glyphs for Microsoft Unicode fonts (glyph index - key, glyph - value).
       */
      get: function() {
        if (this.internalMicrosoftGlyphs === null || this.internalMicrosoftGlyphs === void 0) {
          this.internalMicrosoftGlyphs = new Dictionary();
        }
        return this.internalMicrosoftGlyphs;
      },
      enumerable: true,
      configurable: true
    });
    TtfReader2.prototype.initialize = function() {
      if (this.metrics === void 0) {
        this.metrics = new TtfMetrics();
      }
      this.readFontDictionary();
      var nameTable = this.readNameTable();
      var headTable = this.readHeadTable();
      this.initializeFontName(nameTable);
      this.metrics.macStyle = headTable.macStyle;
    };
    TtfReader2.prototype.readFontDictionary = function() {
      this.offset = 0;
      var version = this.checkPreambula();
      var numTables = this.readInt16(this.offset);
      var searchRange = this.readInt16(this.offset);
      var entrySelector = this.readInt16(this.offset);
      var rangeShift = this.readInt16(this.offset);
      if (this.tableDirectory === void 0) {
        this.tableDirectory = new Dictionary();
      }
      for (var i = 0; i < numTables; ++i) {
        var table = new TtfTableInfo();
        var tableKey = this.readString(this.int32Size);
        table.checksum = this.readInt32(this.offset);
        table.offset = this.readInt32(this.offset);
        table.length = this.readInt32(this.offset);
        this.tableDirectory.setValue(tableKey, table);
      }
      this.lowestPosition = this.offset;
      if (!this.isTtcFont) {
        this.fixOffsets();
      }
    };
    TtfReader2.prototype.fixOffsets = function() {
      var minOffset = Number.MAX_VALUE;
      var tableKeys = this.tableDirectory.keys();
      for (var i = 0; i < tableKeys.length; i++) {
        var value = this.tableDirectory.getValue(tableKeys[i]);
        var offset = value.offset;
        if (minOffset > offset) {
          minOffset = offset;
          if (minOffset <= this.lowestPosition) {
            break;
          }
        }
      }
      var shift = minOffset - this.lowestPosition;
      if (shift !== 0) {
        var table = new Dictionary();
        for (var i = 0; i < tableKeys.length; i++) {
          var value = this.tableDirectory.getValue(tableKeys[i]);
          value.offset -= shift;
          table.setValue(tableKeys[i], value);
        }
        this.tableDirectory = table;
      }
    };
    TtfReader2.prototype.checkPreambula = function() {
      var version = this.readInt32(this.offset);
      this.isMacTtf = version === 1953658213 ? true : false;
      if (version !== 65536 && version !== 1953658213 && version !== 1330926671) {
        this.isTtcFont = true;
        this.offset = 0;
        var fontTag = this.readString(4);
        if (fontTag !== "ttcf") {
          throw new Error("Can not read TTF font data");
        }
        this.offset += 4;
        var ttcIdentificationNumber = this.readInt32(this.offset);
        if (ttcIdentificationNumber < 0) {
          throw new Error("Can not read TTF font data");
        }
        this.offset = this.readInt32(this.offset);
        version = this.readInt32(this.offset);
      }
      if (version === 1330926671) {
        this._isOpenTypeFont = true;
      }
      return version;
    };
    TtfReader2.prototype.readNameTable = function() {
      var tableInfo = this.getTable("name");
      this.offset = tableInfo.offset;
      var table = new TtfNameTable();
      table.formatSelector = this.readUInt16(this.offset);
      table.recordsCount = this.readUInt16(this.offset);
      table.offset = this.readUInt16(this.offset);
      table.nameRecords = [];
      var recordSize = 12;
      var position = this.offset;
      for (var i = 0; i < table.recordsCount; i++) {
        this.offset = position;
        var record = new TtfNameRecord();
        record.platformID = this.readUInt16(this.offset);
        record.encodingID = this.readUInt16(this.offset);
        record.languageID = this.readUInt16(this.offset);
        record.nameID = this.readUInt16(this.offset);
        record.length = this.readUInt16(this.offset);
        record.offset = this.readUInt16(this.offset);
        this.offset = tableInfo.offset + table.offset + record.offset;
        var unicode = record.platformID === 0 || record.platformID === 3;
        record.name = this.readString(record.length, unicode);
        table.nameRecords[i] = record;
        position += recordSize;
      }
      return table;
    };
    TtfReader2.prototype.readHeadTable = function() {
      var tableInfo = this.getTable("head");
      this.offset = tableInfo.offset;
      var table = new TtfHeadTable();
      table.version = this.readFixed(this.offset);
      table.fontRevision = this.readFixed(this.offset);
      table.checkSumAdjustment = this.readUInt32(this.offset);
      table.magicNumber = this.readUInt32(this.offset);
      table.flags = this.readUInt16(this.offset);
      table.unitsPerEm = this.readUInt16(this.offset);
      table.created = this.readInt64(this.offset);
      table.modified = this.readInt64(this.offset);
      table.xMin = this.readInt16(this.offset);
      table.yMin = this.readInt16(this.offset);
      table.xMax = this.readInt16(this.offset);
      table.yMax = this.readInt16(this.offset);
      table.macStyle = this.readUInt16(this.offset);
      table.lowestReadableSize = this.readUInt16(this.offset);
      table.fontDirectionHint = this.readInt16(this.offset);
      table.indexToLocalFormat = this.readInt16(this.offset);
      table.glyphDataFormat = this.readInt16(this.offset);
      return table;
    };
    TtfReader2.prototype.readHorizontalHeaderTable = function() {
      var tableInfo = this.getTable("hhea");
      this.offset = tableInfo.offset;
      var table = new TtfHorizontalHeaderTable();
      table.version = this.readFixed(this.offset);
      table.ascender = this.readInt16(this.offset);
      table.descender = this.readInt16(this.offset);
      table.lineGap = this.readInt16(this.offset);
      table.advanceWidthMax = this.readUInt16(this.offset);
      table.minLeftSideBearing = this.readInt16(this.offset);
      table.minRightSideBearing = this.readInt16(this.offset);
      table.xMaxExtent = this.readInt16(this.offset);
      table.caretSlopeRise = this.readInt16(this.offset);
      table.caretSlopeRun = this.readInt16(this.offset);
      this.offset += 10;
      table.metricDataFormat = this.readInt16(this.offset);
      table.numberOfHMetrics = this.readUInt16(this.offset);
      return table;
    };
    TtfReader2.prototype.readOS2Table = function() {
      var tableInfo = this.getTable("OS/2");
      this.offset = tableInfo.offset;
      var table = new TtfOS2Table();
      table.version = this.readUInt16(this.offset);
      table.xAvgCharWidth = this.readInt16(this.offset);
      table.usWeightClass = this.readUInt16(this.offset);
      table.usWidthClass = this.readUInt16(this.offset);
      table.fsType = this.readInt16(this.offset);
      table.ySubscriptXSize = this.readInt16(this.offset);
      table.ySubscriptYSize = this.readInt16(this.offset);
      table.ySubscriptXOffset = this.readInt16(this.offset);
      table.ySubscriptYOffset = this.readInt16(this.offset);
      table.ySuperscriptXSize = this.readInt16(this.offset);
      table.ySuperscriptYSize = this.readInt16(this.offset);
      table.ySuperscriptXOffset = this.readInt16(this.offset);
      table.ySuperscriptYOffset = this.readInt16(this.offset);
      table.yStrikeoutSize = this.readInt16(this.offset);
      table.yStrikeoutPosition = this.readInt16(this.offset);
      table.sFamilyClass = this.readInt16(this.offset);
      table.panose = this.readBytes(10);
      table.ulUnicodeRange1 = this.readUInt32(this.offset);
      table.ulUnicodeRange2 = this.readUInt32(this.offset);
      table.ulUnicodeRange3 = this.readUInt32(this.offset);
      table.ulUnicodeRange4 = this.readUInt32(this.offset);
      table.vendorIdentifier = this.readBytes(4);
      table.fsSelection = this.readUInt16(this.offset);
      table.usFirstCharIndex = this.readUInt16(this.offset);
      table.usLastCharIndex = this.readUInt16(this.offset);
      table.sTypoAscender = this.readInt16(this.offset);
      table.sTypoDescender = this.readInt16(this.offset);
      table.sTypoLineGap = this.readInt16(this.offset);
      table.usWinAscent = this.readUInt16(this.offset);
      table.usWinDescent = this.readUInt16(this.offset);
      table.ulCodePageRange1 = this.readUInt32(this.offset);
      table.ulCodePageRange2 = this.readUInt32(this.offset);
      if (table.version > 1) {
        table.sxHeight = this.readInt16(this.offset);
        table.sCapHeight = this.readInt16(this.offset);
        table.usDefaultChar = this.readUInt16(this.offset);
        table.usBreakChar = this.readUInt16(this.offset);
        table.usMaxContext = this.readUInt16(this.offset);
      } else {
        table.sxHeight = 0;
        table.sCapHeight = 0;
        table.usDefaultChar = 0;
        table.usBreakChar = 0;
        table.usMaxContext = 0;
      }
      return table;
    };
    TtfReader2.prototype.readPostTable = function() {
      var tableInfo = this.getTable("post");
      this.offset = tableInfo.offset;
      var table = new TtfPostTable();
      table.formatType = this.readFixed(this.offset);
      table.italicAngle = this.readFixed(this.offset);
      table.underlinePosition = this.readInt16(this.offset);
      table.underlineThickness = this.readInt16(this.offset);
      table.isFixedPitch = this.readUInt32(this.offset);
      table.minType42 = this.readUInt32(this.offset);
      table.maxType42 = this.readUInt32(this.offset);
      table.minType1 = this.readUInt32(this.offset);
      table.maxType1 = this.readUInt32(this.offset);
      return table;
    };
    TtfReader2.prototype.readWidthTable = function(glyphCount, unitsPerEm) {
      var tableInfo = this.getTable("hmtx");
      this.offset = tableInfo.offset;
      var width = [];
      for (var i = 0; i < glyphCount; i++) {
        var glyph = new TtfLongHorMetric();
        glyph.advanceWidth = this.readUInt16(this.offset);
        glyph.lsb = this.readInt16(this.offset);
        var glyphWidth = glyph.advanceWidth * 1e3 / unitsPerEm;
        width.push(Math.floor(glyphWidth));
      }
      return width;
    };
    TtfReader2.prototype.readCmapTable = function() {
      var tableInfo = this.getTable("cmap");
      this.offset = tableInfo.offset;
      var table = new TtfCmapTable();
      table.version = this.readUInt16(this.offset);
      table.tablesCount = this.readUInt16(this.offset);
      var position = this.offset;
      var subTables = [];
      for (var i = 0; i < table.tablesCount; i++) {
        this.offset = position;
        var subTable = new TtfCmapSubTable();
        subTable.platformID = this.readUInt16(this.offset);
        subTable.encodingID = this.readUInt16(this.offset);
        subTable.offset = this.readUInt32(this.offset);
        position = this.offset;
        this.readCmapSubTable(subTable);
        subTables[i] = subTable;
      }
      return subTables;
    };
    TtfReader2.prototype.readCmapSubTable = function(subTable) {
      var tableInfo = this.getTable("cmap");
      this.offset = tableInfo.offset + subTable.offset;
      var format = this.readUInt16(this.offset);
      var encoding = this.getCmapEncoding(subTable.platformID, subTable.encodingID);
      var platform = encoding === TtfCmapEncoding.Macintosh ? TtfPlatformID.Macintosh : TtfPlatformID.Microsoft;
      if (encoding !== TtfCmapEncoding.Unknown) {
        switch (format) {
          case TtfCmapFormat.Apple:
            this.readAppleCmapTable(subTable, encoding);
            break;
          case TtfCmapFormat.Microsoft:
            this.readMicrosoftCmapTable(subTable, encoding);
            break;
          case TtfCmapFormat.Trimmed:
            this.readTrimmedCmapTable(subTable, encoding);
            break;
        }
      }
    };
    TtfReader2.prototype.readAppleCmapTable = function(subTable, encoding) {
      var tableInfo = this.getTable("cmap");
      this.offset = tableInfo.offset + subTable.offset;
      var table = new TtfAppleCmapSubTable();
      table.format = this.readUInt16(this.offset);
      table.length = this.readUInt16(this.offset);
      table.version = this.readUInt16(this.offset);
      if (this.maxMacIndex === null || this.maxMacIndex === void 0) {
        this.maxMacIndex = 0;
      }
      for (var i = 0; i < 256; ++i) {
        var glyphInfo = new TtfGlyphInfo();
        glyphInfo.index = this.readByte(this.offset);
        glyphInfo.width = this.getWidth(glyphInfo.index);
        glyphInfo.charCode = i;
        this.macintosh.setValue(i, glyphInfo);
        this.addGlyph(glyphInfo, encoding);
        this.maxMacIndex = Math.max(i, this.maxMacIndex);
      }
    };
    TtfReader2.prototype.readMicrosoftCmapTable = function(subTable, encoding) {
      var tableInfo = this.getTable("cmap");
      this.offset = tableInfo.offset + subTable.offset;
      var collection = encoding === TtfCmapEncoding.Unicode ? this.microsoft : this.macintosh;
      var table = new TtfMicrosoftCmapSubTable();
      table.format = this.readUInt16(this.offset);
      table.length = this.readUInt16(this.offset);
      table.version = this.readUInt16(this.offset);
      table.segCountX2 = this.readUInt16(this.offset);
      table.searchRange = this.readUInt16(this.offset);
      table.entrySelector = this.readUInt16(this.offset);
      table.rangeShift = this.readUInt16(this.offset);
      var segCount = table.segCountX2 / 2;
      table.endCount = this.readUshortArray(segCount);
      table.reservedPad = this.readUInt16(this.offset);
      table.startCount = this.readUshortArray(segCount);
      table.idDelta = this.readUshortArray(segCount);
      table.idRangeOffset = this.readUshortArray(segCount);
      var length = table.length / 2 - 8 - segCount * 4;
      table.glyphID = this.readUshortArray(length);
      var codeOffset = 0;
      var index = 0;
      for (var j = 0; j < segCount; j++) {
        for (var k = table.startCount[j]; k <= table.endCount[j] && k !== 65535; k++) {
          if (table.idRangeOffset[j] === 0) {
            codeOffset = k + table.idDelta[j] & 65535;
          } else {
            index = j + table.idRangeOffset[j] / 2 - segCount + k - table.startCount[j];
            if (index >= table.glyphID.length) {
              continue;
            }
            codeOffset = table.glyphID[index] + table.idDelta[j] & 65535;
          }
          var glyph = new TtfGlyphInfo();
          glyph.index = codeOffset;
          glyph.width = this.getWidth(glyph.index);
          var id = encoding === TtfCmapEncoding.Symbol ? (k & 65280) === 61440 ? k & 255 : k : k;
          glyph.charCode = id;
          collection.setValue(id, glyph);
          this.addGlyph(glyph, encoding);
        }
      }
    };
    TtfReader2.prototype.readTrimmedCmapTable = function(subTable, encoding) {
      var tableInfo = this.getTable("cmap");
      this.offset = tableInfo.offset + subTable.offset;
      var table = new TtfTrimmedCmapSubTable();
      table.format = this.readUInt16(this.offset);
      table.length = this.readUInt16(this.offset);
      table.version = this.readUInt16(this.offset);
      table.firstCode = this.readUInt16(this.offset);
      table.entryCount = this.readUInt16(this.offset);
      for (var i = 0; i < table.entryCount; ++i) {
        var glyphInfo = new TtfGlyphInfo();
        glyphInfo.index = this.readUInt16(this.offset);
        glyphInfo.width = this.getWidth(glyphInfo.index);
        glyphInfo.charCode = i + table.firstCode;
        this.macintosh.setValue(i, glyphInfo);
        this.addGlyph(glyphInfo, encoding);
        this.maxMacIndex = Math.max(i, this.maxMacIndex);
      }
    };
    TtfReader2.prototype.initializeFontName = function(nameTable) {
      for (var i = 0; i < nameTable.recordsCount; i++) {
        var record = nameTable.nameRecords[i];
        if (record.nameID === 1) {
          this.metrics.fontFamily = record.name;
        } else if (record.nameID === 6) {
          this.metrics.postScriptName = record.name;
        }
        if (this.metrics.fontFamily !== null && this.metrics.fontFamily !== void 0 && this.metrics.postScriptName !== null && this.metrics.postScriptName !== void 0) {
          break;
        }
      }
    };
    TtfReader2.prototype.getTable = function(name) {
      var table = new TtfTableInfo();
      var obj;
      if (this.tableDirectory.containsKey(name)) {
        obj = this.tableDirectory.getValue(name);
      }
      if (obj !== null && obj !== void 0) {
        table = obj;
      }
      return table;
    };
    TtfReader2.prototype.getWidth = function(glyphCode) {
      glyphCode = glyphCode < this.width.length ? glyphCode : this.width.length - 1;
      return this.width[glyphCode];
    };
    TtfReader2.prototype.getCmapEncoding = function(platformID, encodingID) {
      var format = TtfCmapEncoding.Unknown;
      if (platformID == TtfPlatformID.Microsoft && encodingID == TtfMicrosoftEncodingID.Undefined) {
        format = TtfCmapEncoding.Symbol;
      } else if (platformID == TtfPlatformID.Microsoft && encodingID == TtfMicrosoftEncodingID.Unicode) {
        format = TtfCmapEncoding.Unicode;
      } else if (platformID == TtfPlatformID.Macintosh && encodingID == TtfMacintoshEncodingID.Roman) {
        format = TtfCmapEncoding.Macintosh;
      }
      return format;
    };
    TtfReader2.prototype.addGlyph = function(glyph, encoding) {
      var collection = null;
      switch (encoding) {
        case TtfCmapEncoding.Unicode:
          collection = this.microsoftGlyphs;
          break;
        case TtfCmapEncoding.Macintosh:
        case TtfCmapEncoding.Symbol:
          collection = this.macintoshGlyphs;
          break;
      }
      collection.setValue(glyph.index, glyph);
    };
    TtfReader2.prototype.initializeMetrics = function(nameTable, headTable, horizontalHeadTable, os2Table, postTable, cmapTables) {
      this.initializeFontName(nameTable);
      var bSymbol = false;
      for (var i = 0; i < cmapTables.length; i++) {
        var subTable = cmapTables[i];
        var encoding = this.getCmapEncoding(subTable.platformID, subTable.encodingID);
        if (encoding === TtfCmapEncoding.Symbol) {
          bSymbol = true;
          break;
        }
      }
      this.metrics.isSymbol = bSymbol;
      this.metrics.macStyle = headTable.macStyle;
      this.metrics.isFixedPitch = postTable.isFixedPitch !== 0;
      this.metrics.italicAngle = postTable.italicAngle;
      var factor = 1e3 / headTable.unitsPerEm;
      this.metrics.winAscent = os2Table.sTypoAscender * factor;
      this.metrics.macAscent = horizontalHeadTable.ascender * factor;
      this.metrics.capHeight = os2Table.sCapHeight !== 0 ? os2Table.sCapHeight : 0.7 * headTable.unitsPerEm * factor;
      this.metrics.winDescent = os2Table.sTypoDescender * factor;
      this.metrics.macDescent = horizontalHeadTable.descender * factor;
      this.metrics.leading = (os2Table.sTypoAscender - os2Table.sTypoDescender + os2Table.sTypoLineGap) * factor;
      this.metrics.lineGap = Math.ceil(horizontalHeadTable.lineGap * factor);
      var left = headTable.xMin * factor;
      var top = Math.ceil(this.metrics.macAscent + this.metrics.lineGap);
      var right = headTable.xMax * factor;
      var bottom = this.metrics.macDescent;
      this.metrics.fontBox = new Rectangle(left, top, right, bottom);
      this.metrics.stemV = 80;
      this.metrics.widthTable = this.updateWidth();
      this.metrics.contains = this.tableDirectory.containsKey("CFF ");
      this.metrics.subScriptSizeFactor = headTable.unitsPerEm / os2Table.ySubscriptYSize;
      this.metrics.superscriptSizeFactor = headTable.unitsPerEm / os2Table.ySuperscriptYSize;
    };
    TtfReader2.prototype.updateWidth = function() {
      var count = 256;
      var bytes = [];
      if (this.metrics.isSymbol) {
        for (var i = 0; i < count; i++) {
          var glyphInfo = this.getGlyph(String.fromCharCode(i));
          bytes[i] = glyphInfo.empty ? 0 : glyphInfo.width;
        }
      } else {
        var byteToProcess = [];
        var unknown = "?";
        var space = String.fromCharCode(32);
        for (var i = 0; i < count; i++) {
          byteToProcess[0] = i;
          var text = this.getString(byteToProcess, 0, byteToProcess.length);
          var ch = text.length > 0 ? text[0] : unknown;
          var glyphInfo = this.getGlyph(ch);
          if (!glyphInfo.empty) {
            bytes[i] = glyphInfo.width;
          } else {
            glyphInfo = this.getGlyph(space);
            bytes[i] = glyphInfo.empty ? 0 : glyphInfo.width;
          }
        }
      }
      return bytes;
    };
    TtfReader2.prototype.getDefaultGlyph = function() {
      var glyph = this.getGlyph(StringTokenizer.whiteSpace);
      return glyph;
    };
    TtfReader2.prototype.getString = function(byteToProcess, start, length) {
      var result = "";
      for (var index = 0; index < length; index++) {
        result += String.fromCharCode(byteToProcess[index + start]);
      }
      return result;
    };
    TtfReader2.prototype.readLocaTable = function(bShort) {
      var tableInfo = this.getTable("loca");
      this.offset = tableInfo.offset;
      var table = new TtfLocaTable();
      var buffer = null;
      if (bShort) {
        var len = tableInfo.length / 2;
        buffer = [];
        for (var i = 0; i < len; i++) {
          buffer[i] = this.readUInt16(this.offset) * 2;
        }
      } else {
        var len = tableInfo.length / 4;
        buffer = [];
        for (var i = 0; i < len; i++) {
          buffer[i] = this.readUInt32(this.offset);
        }
      }
      table.offsets = buffer;
      return table;
    };
    TtfReader2.prototype.updateGlyphChars = function(glyphChars, locaTable) {
      if (!glyphChars.containsKey(0)) {
        glyphChars.setValue(0, 0);
      }
      var clone = new Dictionary();
      var glyphCharKeys = glyphChars.keys();
      for (var i = 0; i < glyphCharKeys.length; i++) {
        clone.setValue(glyphCharKeys[i], glyphChars.getValue(glyphCharKeys[i]));
      }
      for (var i = 0; i < glyphCharKeys.length; i++) {
        var nextKey = glyphCharKeys[i];
        this.processCompositeGlyph(glyphChars, nextKey, locaTable);
      }
    };
    TtfReader2.prototype.processCompositeGlyph = function(glyphChars, glyph, locaTable) {
      if (glyph < locaTable.offsets.length - 1) {
        var glyphOffset = locaTable.offsets[glyph];
        if (glyphOffset !== locaTable.offsets[glyph + 1]) {
          var tableInfo = this.getTable("glyf");
          this.offset = tableInfo.offset + glyphOffset;
          var glyphHeader = new TtfGlyphHeader();
          glyphHeader.numberOfContours = this.readInt16(this.offset);
          glyphHeader.xMin = this.readInt16(this.offset);
          glyphHeader.yMin = this.readInt16(this.offset);
          glyphHeader.xMax = this.readInt16(this.offset);
          glyphHeader.yMax = this.readInt16(this.offset);
          if (glyphHeader.numberOfContours < 0) {
            var skipBytes = 0;
            var entry = true;
            while (entry) {
              var flags = this.readUInt16(this.offset);
              var glyphIndex = this.readUInt16(this.offset);
              if (!glyphChars.containsKey(glyphIndex)) {
                glyphChars.setValue(glyphIndex, 0);
              }
              if ((flags & TtfCompositeGlyphFlags.MoreComponents) === 0) {
                break;
              }
              skipBytes = (flags & TtfCompositeGlyphFlags.Arg1And2AreWords) !== 0 ? 4 : 2;
              if ((flags & TtfCompositeGlyphFlags.WeHaveScale) !== 0) {
                skipBytes += 2;
              } else if ((flags & TtfCompositeGlyphFlags.WeHaveAnXyScale) !== 0) {
                skipBytes += 4;
              } else if ((flags & TtfCompositeGlyphFlags.WeHaveTwoByTwo) !== 0) {
                skipBytes += 2 * 4;
              }
              this.offset += skipBytes;
            }
          }
        }
      }
    };
    TtfReader2.prototype.generateGlyphTable = function(glyphChars, locaTable, newLocaTable, newGlyphTable) {
      newLocaTable = [];
      var activeGlyphs = glyphChars.keys();
      activeGlyphs.sort(function(a, b) {
        return a - b;
      });
      var glyphSize = 0;
      for (var i = 0; i < activeGlyphs.length; i++) {
        var glyphIndex = activeGlyphs[i];
        if (locaTable.offsets.length > 0) {
          glyphSize += locaTable.offsets[glyphIndex + 1] - locaTable.offsets[glyphIndex];
        }
      }
      var glyphSizeAligned = this.align(glyphSize);
      newGlyphTable = [];
      for (var i = 0; i < glyphSizeAligned; i++) {
        newGlyphTable.push(0);
      }
      var nextGlyphOffset = 0;
      var nextGlyphIndex = 0;
      var table = this.getTable("glyf");
      for (var i = 0; i < locaTable.offsets.length; i++) {
        newLocaTable.push(nextGlyphOffset);
        if (nextGlyphIndex < activeGlyphs.length && activeGlyphs[nextGlyphIndex] === i) {
          ++nextGlyphIndex;
          newLocaTable[i] = nextGlyphOffset;
          var oldGlyphOffset = locaTable.offsets[i];
          var oldNextGlyphOffset = locaTable.offsets[i + 1] - oldGlyphOffset;
          if (oldNextGlyphOffset > 0) {
            this.offset = table.offset + oldGlyphOffset;
            var result = this.read(newGlyphTable, nextGlyphOffset, oldNextGlyphOffset);
            newGlyphTable = result.buffer;
            nextGlyphOffset += oldNextGlyphOffset;
          }
        }
      }
      return { glyphTableSize: glyphSize, newLocaTable, newGlyphTable };
    };
    TtfReader2.prototype.updateLocaTable = function(newLocaTable, bLocaIsShort, newLocaTableOut) {
      if (newLocaTable === null) {
        throw new Error("Argument Null Exception : newLocaTable");
      }
      var size = bLocaIsShort ? newLocaTable.length * 2 : newLocaTable.length * 4;
      var count = this.align(size);
      var writer = new BigEndianWriter(count);
      for (var i = 0; i < newLocaTable.length; i++) {
        var value = newLocaTable[i];
        if (bLocaIsShort) {
          value /= 2;
          writer.writeShort(value);
        } else {
          writer.writeInt(value);
        }
      }
      return { newLocaUpdated: writer.data, newLocaSize: size };
    };
    TtfReader2.prototype.align = function(value) {
      return value + 3 & ~3;
    };
    TtfReader2.prototype.getFontProgram = function(newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {
      if (newLocaTableOut === null) {
        throw new Error("Argument Null Exception : newLocaTableOut");
      }
      if (newGlyphTable === null) {
        throw new Error("Argument Null Exception : newGlyphTable");
      }
      var tableNames = this.tableNames;
      var result = this.getFontProgramLength(newLocaTableOut, newGlyphTable, 0);
      var fontProgramLength = result.fontProgramLength;
      var numTables = result.numTables;
      var writer = new BigEndianWriter(fontProgramLength);
      writer.writeInt(65536);
      writer.writeShort(numTables);
      var entrySelector = this.entrySelectors[numTables];
      writer.writeShort((1 << (entrySelector & 31)) * 16);
      writer.writeShort(entrySelector);
      writer.writeShort((numTables - (1 << (entrySelector & 31))) * 16);
      this.writeCheckSums(writer, numTables, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize);
      this.writeGlyphs(writer, newLocaTableOut, newGlyphTable);
      return writer.data;
    };
    TtfReader2.prototype.getFontProgramLength = function(newLocaTableOut, newGlyphTable, numTables) {
      if (newLocaTableOut === null) {
        throw new Error("Argument Null Exception : newLocaTableOut");
      }
      if (newGlyphTable === null) {
        throw new Error("Argument Null Exception : newGlyphTable");
      }
      numTables = 2;
      var tableNames = this.tableNames;
      var fontProgramLength = 0;
      for (var i = 0; i < tableNames.length; i++) {
        var tableName = tableNames[i];
        if (tableName !== "glyf" && tableName !== "loca") {
          var table = this.getTable(tableName);
          if (!table.empty) {
            ++numTables;
            fontProgramLength += this.align(table.length);
          }
        }
      }
      fontProgramLength += newLocaTableOut.length;
      fontProgramLength += newGlyphTable.length;
      var usedTablesSize = numTables * 16 + 3 * 4;
      fontProgramLength += usedTablesSize;
      return { fontProgramLength, numTables };
    };
    TtfReader2.prototype.writeCheckSums = function(writer, numTables, newLocaTableOut, newGlyphTable, glyphTableSize, locaTableSize) {
      if (writer === null) {
        throw new Error("Argument Null Exception : writer");
      }
      if (newLocaTableOut === null) {
        throw new Error("Argument Null Exception : newLocaTableOut");
      }
      if (newGlyphTable === null) {
        throw new Error("Argument Null Exception : newGlyphTable");
      }
      var tableNames = this.tableNames;
      var usedTablesSize = numTables * 16 + 3 * 4;
      var nextTableSize = 0;
      for (var i = 0; i < tableNames.length; i++) {
        var tableName = tableNames[i];
        var tableInfo = this.getTable(tableName);
        if (tableInfo.empty) {
          continue;
        }
        writer.writeString(tableName);
        if (tableName === "glyf") {
          var checksum = this.calculateCheckSum(newGlyphTable);
          writer.writeInt(checksum);
          nextTableSize = glyphTableSize;
        } else if (tableName === "loca") {
          var checksum = this.calculateCheckSum(newLocaTableOut);
          writer.writeInt(checksum);
          nextTableSize = locaTableSize;
        } else {
          writer.writeInt(tableInfo.checksum);
          nextTableSize = tableInfo.length;
        }
        writer.writeUInt(usedTablesSize);
        writer.writeUInt(nextTableSize);
        usedTablesSize += this.align(nextTableSize);
      }
    };
    TtfReader2.prototype.calculateCheckSum = function(bytes) {
      if (bytes === null) {
        throw new Error("Argument Null Exception : bytes");
      }
      var pos = 0;
      var byte1 = 0;
      var byte2 = 0;
      var byte3 = 0;
      var byte4 = 0;
      for (var i = 0; i < (bytes.length + 1) / 4; i++) {
        byte4 += bytes[pos++] & 255;
        byte3 += bytes[pos++] & 255;
        byte2 += bytes[pos++] & 255;
        byte1 += bytes[pos++] & 255;
      }
      var result = byte1;
      result += byte2 << 8;
      result += byte3 << 16;
      result += byte4 << 24;
      return result;
    };
    TtfReader2.prototype.writeGlyphs = function(writer, newLocaTable, newGlyphTable) {
      if (writer === null) {
        throw new Error("Argument Null Exception : writer");
      }
      if (newLocaTable === null) {
        throw new Error("Argument Null Exception : newLocaTableOut");
      }
      if (newGlyphTable === null) {
        throw new Error("Argument Null Exception : newGlyphTable");
      }
      var tableNames = this.tableNames;
      for (var i = 0; i < tableNames.length; i++) {
        var tableName = tableNames[i];
        var tableInfo = this.getTable(tableName);
        if (tableInfo.empty) {
          continue;
        }
        if (tableName === "glyf") {
          writer.writeBytes(newGlyphTable);
        } else if (tableName === "loca") {
          writer.writeBytes(newLocaTable);
        } else {
          var count = this.align(tableInfo.length);
          var buff = [];
          for (var i_1 = 0; i_1 < count; i_1++) {
            buff.push(0);
          }
          this.offset = tableInfo.offset;
          var result = this.read(buff, 0, tableInfo.length);
          writer.writeBytes(result.buffer);
        }
      }
    };
    TtfReader2.prototype.setOffset = function(offset) {
      this.offset = offset;
    };
    TtfReader2.prototype.createInternals = function() {
      this.metrics = new TtfMetrics();
      var nameTable = this.readNameTable();
      var headTable = this.readHeadTable();
      this.bIsLocaShort = headTable.indexToLocalFormat === 0;
      var horizontalHeadTable = this.readHorizontalHeaderTable();
      var os2Table = this.readOS2Table();
      var postTable = this.readPostTable();
      this.width = this.readWidthTable(horizontalHeadTable.numberOfHMetrics, headTable.unitsPerEm);
      var subTables = this.readCmapTable();
      this.initializeMetrics(nameTable, headTable, horizontalHeadTable, os2Table, postTable, subTables);
    };
    TtfReader2.prototype.getGlyph = function(charCode) {
      if (typeof charCode === "number") {
        var obj1 = null;
        if (!this.metrics.isSymbol && this.microsoftGlyphs != null) {
          if (this.microsoftGlyphs.containsKey(charCode)) {
            obj1 = this.microsoftGlyphs.getValue(charCode);
          }
        } else if (this.metrics.isSymbol && this.macintoshGlyphs != null) {
          if (this.macintoshGlyphs.containsKey(charCode)) {
            obj1 = this.macintoshGlyphs.getValue(charCode);
          }
        }
        var glyph = obj1 != null ? obj1 : this.getDefaultGlyph();
        return glyph;
      } else {
        var obj = null;
        var code = charCode.charCodeAt(0);
        if (!this.metrics.isSymbol && this.microsoft !== null) {
          if (this.microsoft.containsKey(code)) {
            obj = this.microsoft.getValue(code);
            if (code !== StringTokenizer.whiteSpace.charCodeAt(0)) {
              this.isFontPresent = true;
            }
          } else if (code !== StringTokenizer.whiteSpace.charCodeAt(0)) {
            this.isFontPresent = false;
          }
        } else if (this.metrics.isSymbol && this.macintosh !== null || this.isMacTTF) {
          if (this.maxMacIndex !== 0) {
            code %= this.maxMacIndex + 1;
          } else {
            code = (code & 65280) === 61440 ? code & 255 : code;
          }
          if (this.macintosh.containsKey(code)) {
            obj = this.macintosh.getValue(code);
            this.isFontPresent = true;
          }
        }
        if (charCode === StringTokenizer.whiteSpace && obj === null) {
          obj = new TtfGlyphInfo();
        }
        var glyph = obj !== null ? obj : this.getDefaultGlyph();
        return glyph;
      }
    };
    TtfReader2.prototype.getGlyphChars = function(chars) {
      if (chars === null || chars === void 0) {
        throw new Error("Argument Null Exception : chars");
      }
      var dictionary = new Dictionary();
      var charKeys = chars.keys();
      for (var i = 0; i < charKeys.length; i++) {
        var ch = charKeys[i];
        var glyph = this.getGlyph(ch);
        if (!glyph.empty) {
          dictionary.setValue(glyph.index, ch.charCodeAt(0));
        }
      }
      return dictionary;
    };
    TtfReader2.prototype.getAllGlyphs = function() {
      var allGlyphInfo = [];
      var info = new TtfGlyphInfo();
      var index = 0;
      for (var i = 0; i < this.width.length; i++) {
        var width = this.width[i];
        info.index = index;
        info.width = width;
        allGlyphInfo.push(info);
        index++;
      }
      return allGlyphInfo;
    };
    TtfReader2.prototype.readFontProgram = function(chars) {
      var glyphChars = this.getGlyphChars(chars);
      var locaTable = this.readLocaTable(this.bIsLocaShort);
      if (glyphChars.size() < chars.size()) {
        this.missedGlyphs = chars.size() - glyphChars.size();
      }
      this.updateGlyphChars(glyphChars, locaTable);
      var result1 = this.generateGlyphTable(glyphChars, locaTable, null, null);
      var glyphTableSize = result1.glyphTableSize;
      var newLocaTable = result1.newLocaTable;
      var newGlyphTable = result1.newGlyphTable;
      var result2 = this.updateLocaTable(newLocaTable, this.bIsLocaShort, null);
      var newLocaSize = result2.newLocaSize;
      var newLocaUpdated = result2.newLocaUpdated;
      var fontProgram = this.getFontProgram(newLocaUpdated, newGlyphTable, glyphTableSize, newLocaSize);
      return fontProgram;
    };
    TtfReader2.prototype._readCompactFontFormatTable = function() {
      var tableInfo = this.getTable("CFF ");
      var length = tableInfo.length;
      var offset = tableInfo.offset;
      var cffData = new Array(length);
      this.setOffset(offset);
      var result = this.read(cffData, 0, length);
      return result.buffer;
    };
    TtfReader2.prototype.convertString = function(text) {
      if (text === null) {
        throw new Error("Argument Null Exception : text");
      }
      var glyph = "";
      var i = 0;
      for (var k = 0; k < text.length; k++) {
        var ch = text[k];
        var glyphInfo = this.getGlyph(ch);
        if (!glyphInfo.empty) {
          glyph += String.fromCharCode(glyphInfo.index);
          i++;
        }
      }
      return glyph;
    };
    TtfReader2.prototype.getCharWidth = function(code) {
      var glyphInfo = this.getGlyph(code);
      glyphInfo = !glyphInfo.empty ? glyphInfo : this.getDefaultGlyph();
      var codeWidth = !glyphInfo.empty ? glyphInfo.width : 0;
      return codeWidth;
    };
    TtfReader2.prototype.readString = function(length, isUnicode) {
      if (isUnicode === void 0) {
        return this.readString(length, false);
      } else {
        var result = "";
        if (isUnicode) {
          for (var i = 0; i < length; i++) {
            if (i % 2 !== 0) {
              result += String.fromCharCode(this.fontData[this.offset]);
            }
            this.offset += 1;
          }
        } else {
          for (var i = 0; i < length; i++) {
            result += String.fromCharCode(this.fontData[this.offset]);
            this.offset += 1;
          }
        }
        return result;
      }
    };
    TtfReader2.prototype.readFixed = function(offset) {
      var integer = this.readInt16(offset);
      var sFraction = this.readInt16(offset + 2);
      var fraction = sFraction / 16384;
      return integer + fraction;
    };
    TtfReader2.prototype.readInt32 = function(offset) {
      var i1 = this.fontData[offset + 3];
      var i2 = this.fontData[offset + 2];
      var i3 = this.fontData[offset + 1];
      var i4 = this.fontData[offset];
      this.offset += 4;
      return i1 + (i2 << 8) + (i3 << 16) + (i4 << 24);
    };
    TtfReader2.prototype.readUInt32 = function(offset) {
      var i1 = this.fontData[offset + 3];
      var i2 = this.fontData[offset + 2];
      var i3 = this.fontData[offset + 1];
      var i4 = this.fontData[offset];
      this.offset += 4;
      return i1 | i2 << 8 | i3 << 16 | i4 << 24;
    };
    TtfReader2.prototype.readInt16 = function(offset) {
      var result = (this.fontData[offset] << 8) + this.fontData[offset + 1];
      result = result & 1 << 15 ? result - 65536 : result;
      this.offset += 2;
      return result;
    };
    TtfReader2.prototype.readInt64 = function(offset) {
      var low = this.readInt32(offset + 4);
      var n = this.readInt32(offset) * 4294967296 + low;
      if (low < 0) {
        n += 4294967296;
      }
      return n;
    };
    TtfReader2.prototype.readUInt16 = function(offset) {
      var result = this.fontData[offset] << 8 | this.fontData[offset + 1];
      this.offset += 2;
      return result;
    };
    TtfReader2.prototype.readUshortArray = function(length) {
      var buffer = [];
      for (var i = 0; i < length; i++) {
        buffer[i] = this.readUInt16(this.offset);
      }
      return buffer;
    };
    TtfReader2.prototype.readBytes = function(length) {
      var result = [];
      for (var i = 0; i < length; i++) {
        result.push(this.fontData[this.offset]);
        this.offset += 1;
      }
      return result;
    };
    TtfReader2.prototype.readByte = function(offset) {
      var result = this.fontData[offset];
      this.offset += 1;
      return result;
    };
    TtfReader2.prototype.read = function(buffer, index, count) {
      if (buffer === null) {
        throw new Error("Argument Null Exception : buffer");
      }
      var written = 0;
      var read = 0;
      do {
        for (var i = 0; i < count - written && this.offset + i < this.fontData.length; i++) {
          buffer[index + i] = this.fontData[this.offset + i];
        }
        read = count - written;
        this.offset += read;
        written += read;
      } while (written < count);
      return { buffer, written };
    };
    return TtfReader2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/pdf-font-metrics.js
var __extends29 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfFontMetrics = (
  /** @class */
  (function() {
    function PdfFontMetrics2() {
      this.lineGap = 0;
    }
    PdfFontMetrics2.prototype.getAscent = function(format) {
      var returnValue = this.ascent * PdfFont.charSizeMultiplier * this.getSize(format);
      return returnValue;
    };
    PdfFontMetrics2.prototype.getDescent = function(format) {
      var returnValue = this.descent * PdfFont.charSizeMultiplier * this.getSize(format);
      return returnValue;
    };
    PdfFontMetrics2.prototype.getLineGap = function(format) {
      var returnValue = this.lineGap * PdfFont.charSizeMultiplier * this.getSize(format);
      return returnValue;
    };
    PdfFontMetrics2.prototype.getHeight = function(format) {
      var height;
      var clearTypeFonts = ["cambria", "candara", "constantia", "corbel", "cariadings"];
      var clearTypeFontCollection = [];
      for (var index = 0; index < clearTypeFonts.length; index++) {
        var font = clearTypeFonts[index];
        clearTypeFontCollection.push(font);
      }
      if (this.getDescent(format) < 0) {
        height = this.getAscent(format) - this.getDescent(format) + this.getLineGap(format);
      } else {
        height = this.getAscent(format) + this.getDescent(format) + this.getLineGap(format);
      }
      return height;
    };
    PdfFontMetrics2.prototype.getSize = function(format) {
      var size = this.size;
      if (format != null) {
        switch (format.subSuperScript) {
          case PdfSubSuperScript.SubScript:
            size /= this.subScriptSizeFactor;
            break;
          case PdfSubSuperScript.SuperScript:
            size /= this.superscriptSizeFactor;
            break;
        }
      }
      return size;
    };
    PdfFontMetrics2.prototype.clone = function() {
      var metrics = this;
      metrics.widthTable = WidthTable.clone();
      return metrics;
    };
    Object.defineProperty(PdfFontMetrics2.prototype, "widthTable", {
      //  Properies
      /**
       * Gets or sets the `width table`.
       * @private
       */
      get: function() {
        return this.internalWidthTable;
      },
      set: function(value) {
        this.internalWidthTable = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfFontMetrics2;
  })()
);
var WidthTable = (
  /** @class */
  (function() {
    function WidthTable2() {
    }
    WidthTable2.clone = function() {
      return null;
    };
    return WidthTable2;
  })()
);
var StandardWidthTable = (
  /** @class */
  (function(_super) {
    __extends29(StandardWidthTable2, _super);
    function StandardWidthTable2(widths) {
      var _this = _super.call(this) || this;
      if (widths == null) {
        throw new Error("ArgumentNullException:widths");
      }
      _this.widths = widths;
      return _this;
    }
    StandardWidthTable2.prototype.items = function(index) {
      if (index < 0 || index >= this.widths.length) {
        throw new Error("ArgumentOutOfRangeException:index, The character is not supported by the font.");
      }
      var result = this.widths[index];
      return result;
    };
    Object.defineProperty(StandardWidthTable2.prototype, "length", {
      /**
       * Gets the `length` of the internal array.
       * @private
       */
      get: function() {
        return this.widths.length;
      },
      enumerable: true,
      configurable: true
    });
    StandardWidthTable2.prototype.clone = function() {
      var swt = this;
      swt.widths = this.widths;
      return swt;
    };
    StandardWidthTable2.prototype.toArray = function() {
      var arr = new PdfArray(this.widths);
      return arr;
    };
    return StandardWidthTable2;
  })(WidthTable)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/unicode-true-type-font.js
var UnicodeTrueTypeFont = (
  /** @class */
  (function() {
    function UnicodeTrueTypeFont2(base64String, size) {
      this.nameString = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      this.dictionaryProperties = new DictionaryProperties();
      this.isCompress = false;
      this.isEmbedFont = false;
      this.cmapPrefix = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap" + Operators.newLine + "/CIDSystemInfo << /Registry (Adobe)/Ordering (UCS)/Supplement 0>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange" + Operators.newLine;
      this.cmapEndCodespaceRange = "endcodespacerange" + Operators.newLine;
      this.cmapBeginRange = "beginbfrange" + Operators.newLine;
      this.cmapEndRange = "endbfrange" + Operators.newLine;
      this.cmapSuffix = "endbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend end" + Operators.newLine;
      if (base64String === null || base64String === void 0) {
        throw new Error("ArgumentNullException:base64String");
      }
      this.fontSize = size;
      this.fontString = base64String;
      this.Initialize();
    }
    UnicodeTrueTypeFont2.prototype.getCharWidth = function(charCode) {
      var codeWidth = this.ttfReader.getCharWidth(charCode);
      return codeWidth;
    };
    UnicodeTrueTypeFont2.prototype.getLineWidth = function(line) {
      var width = 0;
      for (var i = 0, len = line.length; i < len; i++) {
        var ch = line[i];
        var charWidth = this.getCharWidth(ch);
        width += charWidth;
      }
      return width;
    };
    UnicodeTrueTypeFont2.prototype.Initialize = function() {
      var byteArray = new ByteArray(this.fontString.length);
      byteArray.writeFromBase64String(this.fontString);
      this.fontData = byteArray.internalBuffer;
      this.ttfReader = new TtfReader(this.fontData);
      this.ttfMetrics = this.ttfReader.metrics;
    };
    UnicodeTrueTypeFont2.prototype.createInternals = function() {
      this.fontDictionary = new PdfDictionary();
      this.fontProgram = new PdfStream();
      this.cmap = new PdfStream();
      this.descendantFont = new PdfDictionary();
      this.metrics = new PdfFontMetrics();
      this.ttfReader.createInternals();
      this.ttfMetrics = this.ttfReader.metrics;
      this.initializeMetrics();
      this.subsetName = this.getFontName();
      this.createDescendantFont();
      this.createCmap();
      this.createFontDictionary();
      this.createFontProgram();
    };
    UnicodeTrueTypeFont2.prototype.getInternals = function() {
      return this.fontDictionary;
    };
    UnicodeTrueTypeFont2.prototype.initializeMetrics = function() {
      var ttfMetrics = this.ttfReader.metrics;
      this.metrics.ascent = ttfMetrics.macAscent;
      this.metrics.descent = ttfMetrics.macDescent;
      this.metrics.height = ttfMetrics.macAscent - ttfMetrics.macDescent + ttfMetrics.lineGap;
      this.metrics.name = ttfMetrics.fontFamily;
      this.metrics.postScriptName = ttfMetrics.postScriptName;
      this.metrics.size = this.fontSize;
      this.metrics.widthTable = new StandardWidthTable(ttfMetrics.widthTable);
      this.metrics.lineGap = ttfMetrics.lineGap;
      this.metrics.subScriptSizeFactor = ttfMetrics.subScriptSizeFactor;
      this.metrics.superscriptSizeFactor = ttfMetrics.superscriptSizeFactor;
      this.metrics.isBold = ttfMetrics.isBold;
    };
    UnicodeTrueTypeFont2.prototype.getFontName = function() {
      var builder = "";
      var name;
      for (var i = 0; i < 6; i++) {
        var index = Math.floor(Math.random() * (25 - 0 + 1)) + 0;
        builder += this.nameString[index];
      }
      builder += "+";
      builder += this.ttfReader.metrics.postScriptName;
      name = builder.toString();
      name = this.formatName(name);
      return name;
    };
    UnicodeTrueTypeFont2.prototype.formatName = function(fontName) {
      var ret = fontName.replace("(", "#28");
      ret = ret.replace(")", "#29");
      ret = ret.replace("[", "#5B");
      ret = ret.replace("]", "#5D");
      ret = ret.replace("<", "#3C");
      ret = ret.replace(">", "#3E");
      ret = ret.replace("{", "#7B");
      ret = ret.replace("}", "#7D");
      ret = ret.replace("/", "#2F");
      ret = ret.replace("%", "#25");
      return ret.replace(" ", "#20");
    };
    UnicodeTrueTypeFont2.prototype.createDescendantFont = function() {
      this.descendantFont.isResource = true;
      this.descendantFont.descendantFontBeginSave = new SaveDescendantFontEventHandler(this);
      this.descendantFont.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));
      if (this.ttfReader && this.ttfReader._isOpenTypeFont) {
        this.descendantFont.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.cIDFontType0));
      } else {
        this.descendantFont.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.cIDFontType2));
      }
      this.descendantFont.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.subsetName));
      this.descendantFont.items.setValue(this.dictionaryProperties.cIDToGIDMap, new PdfName(this.dictionaryProperties.identity));
      this.descendantFont.items.setValue(this.dictionaryProperties.dw, new PdfNumber(1e3));
      this.fontDescriptor = this.createFontDescriptor();
      this.descendantFont.items.setValue(this.dictionaryProperties.fontDescriptor, new PdfReferenceHolder(this.fontDescriptor));
      var systemInfo = this.createSystemInfo();
      this.descendantFont.items.setValue(this.dictionaryProperties.cIDSystemInfo, systemInfo);
    };
    UnicodeTrueTypeFont2.prototype.createFontDescriptor = function() {
      var descriptor = new PdfDictionary();
      var metrics = this.ttfReader.metrics;
      descriptor.isResource = true;
      descriptor.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.fontDescriptor));
      descriptor.items.setValue(this.dictionaryProperties.fontName, new PdfName(this.subsetName));
      descriptor.items.setValue(this.dictionaryProperties.flags, new PdfNumber(this.getDescriptorFlags()));
      descriptor.items.setValue(this.dictionaryProperties.fontBBox, PdfArray.fromRectangle(this.getBoundBox()));
      descriptor.items.setValue(this.dictionaryProperties.missingWidth, new PdfNumber(metrics.widthTable[32]));
      descriptor.items.setValue(this.dictionaryProperties.stemV, new PdfNumber(metrics.stemV));
      descriptor.items.setValue(this.dictionaryProperties.italicAngle, new PdfNumber(metrics.italicAngle));
      descriptor.items.setValue(this.dictionaryProperties.capHeight, new PdfNumber(metrics.capHeight));
      descriptor.items.setValue(this.dictionaryProperties.ascent, new PdfNumber(metrics.winAscent));
      descriptor.items.setValue(this.dictionaryProperties.descent, new PdfNumber(metrics.winDescent));
      descriptor.items.setValue(this.dictionaryProperties.leading, new PdfNumber(metrics.leading));
      descriptor.items.setValue(this.dictionaryProperties.avgWidth, new PdfNumber(metrics.widthTable[32]));
      if (this.ttfReader.metrics.contains) {
        descriptor.items.setValue(this.dictionaryProperties.fontFile3, new PdfReferenceHolder(this.fontProgram));
        this.fontProgram.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.cIDFontType0C));
      } else {
        descriptor.items.setValue(this.dictionaryProperties.fontFile2, new PdfReferenceHolder(this.fontProgram));
      }
      descriptor.items.setValue(this.dictionaryProperties.maxWidth, new PdfNumber(metrics.widthTable[32]));
      descriptor.items.setValue(this.dictionaryProperties.xHeight, new PdfNumber(0));
      descriptor.items.setValue(this.dictionaryProperties.stemH, new PdfNumber(0));
      return descriptor;
    };
    UnicodeTrueTypeFont2.prototype.createCmap = function() {
      this.cmap.cmapBeginSave = new SaveCmapEventHandler(this);
    };
    UnicodeTrueTypeFont2.prototype.createFontDictionary = function() {
      this.fontDictionary.isResource = true;
      this.fontDictionary.fontDictionaryBeginSave = new SaveFontDictionaryEventHandler(this);
      this.fontDictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));
      this.fontDictionary.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.subsetName));
      this.fontDictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.type0));
      this.fontDictionary.items.setValue(this.dictionaryProperties.encoding, new PdfName(this.dictionaryProperties.identityH));
      var descFonts = new PdfArray();
      var reference = new PdfReferenceHolder(this.descendantFont);
      descFonts.isFont = true;
      descFonts.add(reference);
      this.fontDictionary.items.setValue(this.dictionaryProperties.descendantFonts, descFonts);
    };
    UnicodeTrueTypeFont2.prototype.createFontProgram = function() {
      this.fontProgram.fontProgramBeginSave = new SaveFontProgramEventHandler(this);
    };
    UnicodeTrueTypeFont2.prototype.createSystemInfo = function() {
      var systemInfo = new PdfDictionary();
      systemInfo.items.setValue(this.dictionaryProperties.registry, new PdfString("Adobe"));
      systemInfo.items.setValue(this.dictionaryProperties.ordering, new PdfString(this.dictionaryProperties.identity));
      systemInfo.items.setValue(this.dictionaryProperties.supplement, new PdfNumber(0));
      return systemInfo;
    };
    UnicodeTrueTypeFont2.prototype.descendantFontBeginSave = function() {
      if (this.usedChars !== null && this.usedChars !== void 0 && this.usedChars.size() > 0) {
        var width = this.getDescendantWidth();
        if (width !== null) {
          this.descendantFont.items.setValue(this.dictionaryProperties.w, width);
        }
      }
    };
    UnicodeTrueTypeFont2.prototype.cmapBeginSave = function() {
      this.generateCmap();
    };
    UnicodeTrueTypeFont2.prototype.fontDictionaryBeginSave = function() {
      if (this.usedChars !== null && this.usedChars !== void 0 && this.usedChars.size() > 0 && !this.fontDictionary.containsKey(this.dictionaryProperties.toUnicode)) {
        this.fontDictionary.items.setValue(this.dictionaryProperties.toUnicode, new PdfReferenceHolder(this.cmap));
      }
    };
    UnicodeTrueTypeFont2.prototype.fontProgramBeginSave = function() {
      this.isCompress = true;
      this.generateFontProgram();
    };
    UnicodeTrueTypeFont2.prototype.getDescendantWidth = function() {
      var array = new PdfArray();
      if (this.usedChars !== null && this.usedChars !== void 0 && this.usedChars.size() > 0) {
        var glyphInfo = [];
        var keys2 = this.usedChars.keys();
        for (var i = 0; i < keys2.length; i++) {
          var chLen = keys2[i];
          var glyph = this.ttfReader.getGlyph(chLen);
          if (glyph.empty) {
            continue;
          }
          glyphInfo.push(glyph);
        }
        glyphInfo.sort(function(a, b) {
          return a.index - b.index;
        });
        var firstGlyphIndex = 0;
        var lastGlyphIndex = 0;
        var firstGlyphIndexWasSet = false;
        var widthDetails = new PdfArray();
        for (var i = 0; i < glyphInfo.length; i++) {
          var glyph = glyphInfo[i];
          if (!firstGlyphIndexWasSet) {
            firstGlyphIndexWasSet = true;
            firstGlyphIndex = glyph.index;
            lastGlyphIndex = glyph.index - 1;
          }
          if ((lastGlyphIndex + 1 !== glyph.index || i + 1 === glyphInfo.length) && glyphInfo.length > 1) {
            array.add(new PdfNumber(firstGlyphIndex));
            if (i !== 0) {
              array.add(widthDetails);
            }
            firstGlyphIndex = glyph.index;
            widthDetails = new PdfArray();
          }
          widthDetails.add(new PdfNumber(glyph.width));
          if (i + 1 === glyphInfo.length) {
            array.add(new PdfNumber(firstGlyphIndex));
            array.add(widthDetails);
          }
          lastGlyphIndex = glyph.index;
        }
      }
      return array;
    };
    UnicodeTrueTypeFont2.prototype.generateCmap = function() {
      if (this.usedChars !== null && this.usedChars !== void 0 && this.usedChars.size() > 0) {
        var glyphChars = this.ttfReader.getGlyphChars(this.usedChars);
        if (glyphChars.size() > 0) {
          var keys2 = glyphChars.keys().sort();
          var first = keys2[0];
          var last = keys2[keys2.length - 1];
          var middlePart = this.toHexString(first, false) + this.toHexString(last, false) + Operators.newLine;
          var builder = "";
          builder += this.cmapPrefix;
          builder += middlePart;
          builder += this.cmapEndCodespaceRange;
          var nextRange = 0;
          for (var i = 0; i < keys2.length; i++) {
            if (nextRange === 0) {
              if (i !== 0) {
                builder += this.cmapEndRange;
              }
              nextRange = Math.min(100, keys2.length - i);
              builder += nextRange;
              builder += Operators.whiteSpace;
              builder += this.cmapBeginRange;
            }
            nextRange -= 1;
            var key = keys2[i];
            builder += this.toHexString(key, true) + this.toHexString(key, true) + this.toHexString(glyphChars.getValue(key), true) + "\n";
          }
          builder += this.cmapSuffix;
          this.cmap.clearStream();
          this.cmap.isResource = true;
          this.cmap.write(builder);
        }
      }
    };
    UnicodeTrueTypeFont2.prototype.generateFontProgram = function() {
      this.usedChars = this.usedChars === null || this.usedChars === void 0 ? new Dictionary() : this.usedChars;
      this.ttfReader.setOffset(0);
      if (this.ttfReader.metrics.contains && this.ttfReader._isOpenTypeFont) {
        var cffData = this.ttfReader._readCompactFontFormatTable();
        this.fontProgram.clearStream();
        this.fontProgram.isResource = true;
        this.fontProgram.writeBytes(cffData);
      } else {
        var fontProgram = this.ttfReader.readFontProgram(this.usedChars);
        this.fontProgram.clearStream();
        this.fontProgram.isResource = true;
        this.fontProgram.writeBytes(fontProgram);
      }
    };
    UnicodeTrueTypeFont2.prototype.getDescriptorFlags = function() {
      var flags = 0;
      var metrics = this.ttfReader.metrics;
      if (metrics.isFixedPitch) {
        flags |= FontDescriptorFlags.FixedPitch;
      }
      if (metrics.isSymbol) {
        flags |= FontDescriptorFlags.Symbolic;
      } else {
        flags |= FontDescriptorFlags.Nonsymbolic;
      }
      if (metrics.isItalic) {
        flags |= FontDescriptorFlags.Italic;
      }
      if (metrics.isBold) {
        flags |= FontDescriptorFlags.ForceBold;
      }
      return flags;
    };
    UnicodeTrueTypeFont2.prototype.getBoundBox = function() {
      var rect = this.ttfReader.metrics.fontBox;
      var width = Math.abs(rect.right - rect.left);
      var height = Math.abs(rect.top - rect.bottom);
      var rectangle = new RectangleF(rect.left, rect.bottom, width, height);
      return rectangle;
    };
    UnicodeTrueTypeFont2.prototype.toHexString = function(n, isCaseChange) {
      var s = n.toString(16);
      if (isCaseChange) {
        s = s.toUpperCase();
      }
      return "<0000".substring(0, 5 - s.length) + s + ">";
    };
    UnicodeTrueTypeFont2.prototype.setSymbols = function(text) {
      if (text === null) {
        throw new Error("Argument Null Exception : text");
      }
      if (this.usedChars === null || this.usedChars === void 0) {
        this.usedChars = new Dictionary();
      }
      for (var i = 0; i < text.length; i++) {
        var ch = text[i];
        this.usedChars.setValue(ch, String.fromCharCode(0));
      }
      if (this.isEmbedFont === false) {
        this.getDescendantWidth();
      }
    };
    return UnicodeTrueTypeFont2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/rtl/rtl-text-shape.js
var ArabicShapeRenderer = (
  /** @class */
  (function() {
    function ArabicShapeRenderer2() {
      this.arabicCharTable = [
        ["ء", "ﺀ"],
        ["آ", "ﺁ", "ﺂ"],
        ["أ", "ﺃ", "ﺄ"],
        ["ؤ", "ﺅ", "ﺆ"],
        ["إ", "ﺇ", "ﺈ"],
        ["ئ", "ﺉ", "ﺊ", "ﺋ", "ﺌ"],
        ["ا", "ﺍ", "ﺎ"],
        ["ب", "ﺏ", "ﺐ", "ﺑ", "ﺒ"],
        ["ة", "ﺓ", "ﺔ"],
        ["ت", "ﺕ", "ﺖ", "ﺗ", "ﺘ"],
        ["ث", "ﺙ", "ﺚ", "ﺛ", "ﺜ"],
        ["ج", "ﺝ", "ﺞ", "ﺟ", "ﺠ"],
        ["ح", "ﺡ", "ﺢ", "ﺣ", "ﺤ"],
        ["خ", "ﺥ", "ﺦ", "ﺧ", "ﺨ"],
        ["د", "ﺩ", "ﺪ"],
        ["ذ", "ﺫ", "ﺬ"],
        ["ر", "ﺭ", "ﺮ"],
        ["ز", "ﺯ", "ﺰ"],
        ["س", "ﺱ", "ﺲ", "ﺳ", "ﺴ"],
        ["ش", "ﺵ", "ﺶ", "ﺷ", "ﺸ"],
        ["ص", "ﺹ", "ﺺ", "ﺻ", "ﺼ"],
        ["ض", "ﺽ", "ﺾ", "ﺿ", "ﻀ"],
        ["ط", "ﻁ", "ﻂ", "ﻃ", "ﻄ"],
        ["ظ", "ﻅ", "ﻆ", "ﻇ", "ﻈ"],
        ["ع", "ﻉ", "ﻊ", "ﻋ", "ﻌ"],
        ["غ", "ﻍ", "ﻎ", "ﻏ", "ﻐ"],
        ["ـ", "ـ", "ـ", "ـ", "ـ"],
        ["ف", "ﻑ", "ﻒ", "ﻓ", "ﻔ"],
        ["ق", "ﻕ", "ﻖ", "ﻗ", "ﻘ"],
        ["ك", "ﻙ", "ﻚ", "ﻛ", "ﻜ"],
        ["ل", "ﻝ", "ﻞ", "ﻟ", "ﻠ"],
        ["م", "ﻡ", "ﻢ", "ﻣ", "ﻤ"],
        ["ن", "ﻥ", "ﻦ", "ﻧ", "ﻨ"],
        ["ه", "ﻩ", "ﻪ", "ﻫ", "ﻬ"],
        ["و", "ﻭ", "ﻮ"],
        ["ى", "ﻯ", "ﻰ", "ﯨ", "ﯩ"],
        ["ي", "ﻱ", "ﻲ", "ﻳ", "ﻴ"],
        ["ٱ", "ﭐ", "ﭑ"],
        ["ٹ", "ﭦ", "ﭧ", "ﭨ", "ﭩ"],
        ["ٺ", "ﭞ", "ﭟ", "ﭠ", "ﭡ"],
        ["ٻ", "ﭒ", "ﭓ", "ﭔ", "ﭕ"],
        ["پ", "ﭖ", "ﭗ", "ﭘ", "ﭙ"],
        ["ٿ", "ﭢ", "ﭣ", "ﭤ", "ﭥ"],
        ["ڀ", "ﭚ", "ﭛ", "ﭜ", "ﭝ"],
        ["ڃ", "ﭶ", "ﭷ", "ﭸ", "ﭹ"],
        ["ڄ", "ﭲ", "ﭳ", "ﭴ", "ﭵ"],
        ["چ", "ﭺ", "ﭻ", "ﭼ", "ﭽ"],
        ["ڇ", "ﭾ", "ﭿ", "ﮀ", "ﮁ"],
        ["ڈ", "ﮈ", "ﮉ"],
        ["ڌ", "ﮄ", "ﮅ"],
        ["ڍ", "ﮂ", "ﮃ"],
        ["ڎ", "ﮆ", "ﮇ"],
        ["ڑ", "ﮌ", "ﮍ"],
        ["ژ", "ﮊ", "ﮋ"],
        ["ڤ", "ﭪ", "ﭫ", "ﭬ", "ﭭ"],
        ["ڦ", "ﭮ", "ﭯ", "ﭰ", "ﭱ"],
        ["ک", "ﮎ", "ﮏ", "ﮐ", "ﮑ"],
        ["ڭ", "ﯓ", "ﯔ", "ﯕ", "ﯖ"],
        ["گ", "ﮒ", "ﮓ", "ﮔ", "ﮕ"],
        ["ڱ", "ﮚ", "ﮛ", "ﮜ", "ﮝ"],
        ["ڳ", "ﮖ", "ﮗ", "ﮘ", "ﮙ"],
        ["ں", "ﮞ", "ﮟ"],
        ["ڻ", "ﮠ", "ﮡ", "ﮢ", "ﮣ"],
        ["ھ", "ﮪ", "ﮫ", "ﮬ", "ﮭ"],
        ["ۀ", "ﮤ", "ﮥ"],
        ["ہ", "ﮦ", "ﮧ", "ﮨ", "ﮩ"],
        ["ۅ", "ﯠ", "ﯡ"],
        ["ۆ", "ﯙ", "ﯚ"],
        ["ۇ", "ﯗ", "ﯘ"],
        ["ۈ", "ﯛ", "ﯜ"],
        ["ۉ", "ﯢ", "ﯣ"],
        ["ۋ", "ﯞ", "ﯟ"],
        ["ی", "ﯼ", "ﯽ", "ﯾ", "ﯿ"],
        ["ې", "ﯤ", "ﯥ", "ﯦ", "ﯧ"],
        ["ے", "ﮮ", "ﮯ"],
        ["ۓ", "ﮰ", "ﮱ"]
      ];
      this.alef = "ا";
      this.alefHamza = "أ";
      this.alefHamzaBelow = "إ";
      this.alefMadda = "آ";
      this.lam = "ل";
      this.hamza = "ء";
      this.zeroWidthJoiner = "‍";
      this.hamzaAbove = "ٔ";
      this.hamzaBelow = "ٕ";
      this.wawHamza = "ؤ";
      this.yehHamza = "ئ";
      this.waw = "و";
      this.alefMaksura = "ى";
      this.yeh = "ي";
      this.farsiYeh = "ی";
      this.shadda = "ّ";
      this.madda = "ٓ";
      this.lwa = "ﻻ";
      this.lwawh = "ﻷ";
      this.lwawhb = "ﻹ";
      this.lwawm = "ﻵ";
      this.bwhb = "ۓ";
      this.fathatan = "ً";
      this.superScriptalef = "ٰ";
      this.vowel = 1;
      this.arabicMapTable = new Dictionary();
      for (var i = 0; i < this.arabicCharTable.length; i++) {
        this.arabicMapTable.setValue(this.arabicCharTable[i][0], this.arabicCharTable[i]);
      }
    }
    ArabicShapeRenderer2.prototype.getCharacterShape = function(input, index) {
      if (input >= this.hamza && input <= this.bwhb) {
        var value = [];
        if (this.arabicMapTable.getValue(input)) {
          value = this.arabicMapTable.getValue(input);
          return value[index + 1];
        }
      } else if (input >= this.lwawm && input <= this.lwa) {
        return input;
      }
      return input;
    };
    ArabicShapeRenderer2.prototype.shape = function(text, level) {
      var builder = "";
      var str2 = "";
      for (var i = 0; i < text.length; i++) {
        var c = text[i];
        if (c >= "؀" && c <= "ۿ") {
          str2 = str2 + c;
        } else {
          if (str2.length > 0) {
            var st = this.doShape(str2.toString(), 0);
            builder = builder + st;
            str2 = "";
          }
          builder = builder + c;
        }
      }
      if (str2.length > 0) {
        var st = this.doShape(str2.toString(), 0);
        builder = builder + st;
      }
      return builder.toString();
    };
    ArabicShapeRenderer2.prototype.doShape = function(input, level) {
      var str = "";
      var ligature = 0;
      var len = 0;
      var i = 0;
      var next = "";
      var previous = new ArabicShape();
      var present = new ArabicShape();
      while (i < input.length) {
        next = input[i++];
        ligature = this.ligature(next, present);
        if (ligature === 0) {
          var shapeCount = this.getShapeCount(next);
          len = shapeCount === 1 ? 0 : 2;
          if (previous.Shapes > 2) {
            len += 1;
          }
          len = len % present.Shapes;
          present.Value = this.getCharacterShape(present.Value, len);
          str = this.append(str, previous, level);
          previous = present;
          present = new ArabicShape();
          present.Value = next;
          present.Shapes = shapeCount;
          present.Ligature++;
        }
      }
      len = previous.Shapes > 2 ? 1 : 0;
      len = len % present.Shapes;
      present.Value = this.getCharacterShape(present.Value, len);
      str = this.append(str, previous, level);
      str = this.append(str, present, level);
      return str.toString();
    };
    ArabicShapeRenderer2.prototype.append = function(builder, shape, level) {
      if (shape.Value !== "") {
        builder = builder + shape.Value;
        shape.Ligature -= 1;
        if (shape.Type !== "") {
          if ((level & this.vowel) === 0) {
            builder = builder + shape.Type;
            shape.Ligature -= 1;
          } else {
            shape.Ligature -= 1;
          }
        }
        if (shape.vowel !== "") {
          if ((level & this.vowel) === 0) {
            builder = builder + shape.vowel;
            shape.Ligature -= 1;
          } else {
            shape.Ligature -= 1;
          }
        }
      }
      return builder;
    };
    ArabicShapeRenderer2.prototype.ligature = function(value, shape) {
      if (shape.Value !== "") {
        var result = 0;
        if (value >= this.fathatan && value <= this.hamzaBelow || value === this.superScriptalef) {
          result = 1;
          if (shape.vowel !== "" && value !== this.shadda) {
            result = 2;
          }
          if (value === this.shadda) {
            if (shape.Type == null) {
              shape.Type = this.shadda;
            } else {
              return 0;
            }
          } else if (value === this.hamzaBelow) {
            if (shape.Value === this.alef) {
              shape.Value = this.alefHamzaBelow;
              result = 2;
            } else if (value === this.lwa) {
              shape.Value = this.lwawhb;
              result = 2;
            } else {
              shape.Type = this.hamzaBelow;
            }
          } else if (value === this.hamzaAbove) {
            if (shape.Value === this.alef) {
              shape.Value = this.alefHamza;
              result = 2;
            } else if (shape.Value === this.lwa) {
              shape.Value = this.lwawh;
              result = 2;
            } else if (shape.Value === this.waw) {
              shape.Value = this.wawHamza;
              result = 2;
            } else if (shape.Value === this.yeh || shape.Value === this.alefMaksura || shape.Value === this.farsiYeh) {
              shape.Value = this.yehHamza;
              result = 2;
            } else {
              shape.Type = this.hamzaAbove;
            }
          } else if (value === this.madda) {
            if (shape.Value === this.alef) {
              shape.Value = this.alefMadda;
              result = 2;
            }
          } else {
            shape.vowel = value;
          }
          if (result === 1) {
            shape.Ligature++;
          }
          return result;
        }
        if (shape.vowel !== "") {
          return 0;
        }
        if (shape.Value === this.lam) {
          if (value === this.alef) {
            shape.Value = this.lwa;
            shape.Shapes = 2;
            result = 3;
          } else if (value === this.alefHamza) {
            shape.Value = this.lwawh;
            shape.Shapes = 2;
            result = 3;
          } else if (value === this.alefHamzaBelow) {
            shape.Value = this.lwawhb;
            shape.Shapes = 2;
            result = 3;
          } else if (value === this.alefMadda) {
            shape.Value = this.lwawm;
            shape.Shapes = 2;
            result = 3;
          }
        }
        return result;
      } else {
        return 0;
      }
    };
    ArabicShapeRenderer2.prototype.getShapeCount = function(shape) {
      if (shape >= this.hamza && shape <= this.bwhb && !(shape >= this.fathatan && shape <= this.hamzaBelow || shape === this.superScriptalef)) {
        var c = [];
        if (this.arabicMapTable.getValue(shape)) {
          c = this.arabicMapTable.getValue(shape);
          return c.length - 1;
        }
      } else if (shape === this.zeroWidthJoiner) {
        return 4;
      }
      return 1;
    };
    return ArabicShapeRenderer2;
  })()
);
var ArabicShape = (
  /** @class */
  (function() {
    function ArabicShape2() {
      this.shapeValue = "";
      this.shapeType = "";
      this.shapeVowel = "";
      this.shapeLigature = 0;
      this.shapeShapes = 1;
    }
    Object.defineProperty(ArabicShape2.prototype, "Value", {
      //#endregion
      //#region Properties 
      /**
       * Gets or sets the values.
       * @private
       */
      get: function() {
        return this.shapeValue;
      },
      set: function(value) {
        this.shapeValue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArabicShape2.prototype, "Type", {
      /**
       * Gets or sets the values.
       * @private
       */
      get: function() {
        return this.shapeType;
      },
      set: function(value) {
        this.shapeType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArabicShape2.prototype, "vowel", {
      /**
       * Gets or sets the values.
       * @private
       */
      get: function() {
        return this.shapeVowel;
      },
      set: function(value) {
        this.shapeVowel = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArabicShape2.prototype, "Ligature", {
      /**
       * Gets or sets the values.
       * @private
       */
      get: function() {
        return this.shapeLigature;
      },
      set: function(value) {
        this.shapeLigature = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArabicShape2.prototype, "Shapes", {
      /**
       * Gets or sets the values.
       * @private
       */
      get: function() {
        return this.shapeShapes;
      },
      set: function(value) {
        this.shapeShapes = value;
      },
      enumerable: true,
      configurable: true
    });
    return ArabicShape2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/rtl/rtl-bidirectional.js
var Bidi = (
  /** @class */
  (function() {
    function Bidi2() {
      this.indexes = [];
      this.indexLevels = [];
      this.mirroringShapeCharacters = new Dictionary();
      this.update();
    }
    Bidi2.prototype.doMirrorShaping = function(text) {
      var result = [];
      for (var i = 0; i < text.length; i++) {
        if ((this.indexLevels[i] & 1) === 1 && this.mirroringShapeCharacters.containsKey(text[i].charCodeAt(0))) {
          result[i] = String.fromCharCode(this.mirroringShapeCharacters.getValue(text[i].charCodeAt(0)));
        } else {
          result[i] = text[i].toString();
        }
      }
      var res = "";
      for (var j = 0; j < result.length; j++) {
        res = res + result[j];
      }
      return res;
    };
    Bidi2.prototype.getLogicalToVisualString = function(inputText, isRtl) {
      var rtlCharacters = new RtlCharacters();
      this.indexLevels = rtlCharacters.getVisualOrder(inputText, isRtl);
      this.setDefaultIndexLevel();
      this.doOrder(0, this.indexLevels.length - 1);
      var text = this.doMirrorShaping(inputText);
      var resultBuilder = "";
      for (var i = 0; i < this.indexes.length; i++) {
        var index = this.indexes[i];
        resultBuilder += text[index];
      }
      return resultBuilder.toString();
    };
    Bidi2.prototype.setDefaultIndexLevel = function() {
      for (var i = 0; i < this.indexLevels.length; i++) {
        this.indexes[i] = i;
      }
    };
    Bidi2.prototype.doOrder = function(sIndex, eIndex) {
      var max = this.indexLevels[sIndex];
      var min = max;
      var odd = max;
      var even = max;
      for (var i = sIndex + 1; i <= eIndex; ++i) {
        var data = this.indexLevels[i];
        if (data > max) {
          max = data;
        } else if (data < min) {
          min = data;
        }
        odd &= data;
        even |= data;
      }
      if ((even & 1) === 0) {
        return;
      }
      if ((odd & 1) === 1) {
        this.reArrange(sIndex, eIndex + 1);
        return;
      }
      min |= 1;
      while (max >= min) {
        var pstart = sIndex;
        while (true) {
          while (pstart <= eIndex) {
            if (this.indexLevels[pstart] >= max) {
              break;
            }
            pstart += 1;
          }
          if (pstart > eIndex) {
            break;
          }
          var pend = pstart + 1;
          while (pend <= eIndex) {
            if (this.indexLevels[pend] < max) {
              break;
            }
            pend += 1;
          }
          this.reArrange(pstart, pend);
          pstart = pend + 1;
        }
        max -= 1;
      }
    };
    Bidi2.prototype.reArrange = function(i, j) {
      var length = (i + j) / 2;
      --j;
      for (; i < length; ++i, --j) {
        var temp = this.indexes[i];
        this.indexes[i] = this.indexes[j];
        this.indexes[j] = temp;
      }
    };
    Bidi2.prototype.update = function() {
      this.mirroringShapeCharacters.setValue(40, 41);
      this.mirroringShapeCharacters.setValue(41, 40);
      this.mirroringShapeCharacters.setValue(60, 62);
      this.mirroringShapeCharacters.setValue(62, 60);
      this.mirroringShapeCharacters.setValue(91, 93);
      this.mirroringShapeCharacters.setValue(93, 91);
      this.mirroringShapeCharacters.setValue(123, 125);
      this.mirroringShapeCharacters.setValue(125, 123);
      this.mirroringShapeCharacters.setValue(171, 187);
      this.mirroringShapeCharacters.setValue(187, 171);
      this.mirroringShapeCharacters.setValue(8249, 8250);
      this.mirroringShapeCharacters.setValue(8250, 8249);
      this.mirroringShapeCharacters.setValue(8261, 8262);
      this.mirroringShapeCharacters.setValue(8262, 8261);
      this.mirroringShapeCharacters.setValue(8317, 8318);
      this.mirroringShapeCharacters.setValue(8318, 8317);
      this.mirroringShapeCharacters.setValue(8333, 8334);
      this.mirroringShapeCharacters.setValue(8334, 8333);
      this.mirroringShapeCharacters.setValue(8712, 8715);
      this.mirroringShapeCharacters.setValue(8713, 8716);
      this.mirroringShapeCharacters.setValue(8714, 8717);
      this.mirroringShapeCharacters.setValue(8715, 8712);
      this.mirroringShapeCharacters.setValue(8716, 8713);
      this.mirroringShapeCharacters.setValue(8717, 8714);
      this.mirroringShapeCharacters.setValue(8725, 10741);
      this.mirroringShapeCharacters.setValue(8764, 8765);
      this.mirroringShapeCharacters.setValue(8765, 8764);
      this.mirroringShapeCharacters.setValue(8771, 8909);
      this.mirroringShapeCharacters.setValue(8786, 8787);
      this.mirroringShapeCharacters.setValue(8787, 8786);
      this.mirroringShapeCharacters.setValue(8788, 8789);
      this.mirroringShapeCharacters.setValue(8789, 8788);
      this.mirroringShapeCharacters.setValue(8804, 8805);
      this.mirroringShapeCharacters.setValue(8805, 8804);
      this.mirroringShapeCharacters.setValue(8806, 8807);
      this.mirroringShapeCharacters.setValue(8807, 8806);
      this.mirroringShapeCharacters.setValue(8808, 8809);
      this.mirroringShapeCharacters.setValue(8809, 8808);
      this.mirroringShapeCharacters.setValue(8810, 8811);
      this.mirroringShapeCharacters.setValue(8811, 8810);
      this.mirroringShapeCharacters.setValue(8814, 8815);
      this.mirroringShapeCharacters.setValue(8815, 8814);
      this.mirroringShapeCharacters.setValue(8816, 8817);
      this.mirroringShapeCharacters.setValue(8817, 8816);
      this.mirroringShapeCharacters.setValue(8818, 8819);
      this.mirroringShapeCharacters.setValue(8819, 8818);
      this.mirroringShapeCharacters.setValue(8820, 8821);
      this.mirroringShapeCharacters.setValue(8821, 8820);
      this.mirroringShapeCharacters.setValue(8822, 8823);
      this.mirroringShapeCharacters.setValue(8823, 8822);
      this.mirroringShapeCharacters.setValue(8824, 8825);
      this.mirroringShapeCharacters.setValue(8825, 8824);
      this.mirroringShapeCharacters.setValue(8826, 8827);
      this.mirroringShapeCharacters.setValue(8827, 8826);
      this.mirroringShapeCharacters.setValue(8828, 8829);
      this.mirroringShapeCharacters.setValue(8829, 8828);
      this.mirroringShapeCharacters.setValue(8830, 8831);
      this.mirroringShapeCharacters.setValue(8831, 8830);
      this.mirroringShapeCharacters.setValue(8832, 8833);
      this.mirroringShapeCharacters.setValue(8833, 8832);
      this.mirroringShapeCharacters.setValue(8834, 8835);
      this.mirroringShapeCharacters.setValue(8835, 8834);
      this.mirroringShapeCharacters.setValue(8836, 8837);
      this.mirroringShapeCharacters.setValue(8837, 8836);
      this.mirroringShapeCharacters.setValue(8838, 8839);
      this.mirroringShapeCharacters.setValue(8839, 8838);
      this.mirroringShapeCharacters.setValue(8840, 8841);
      this.mirroringShapeCharacters.setValue(8841, 8840);
      this.mirroringShapeCharacters.setValue(8842, 8843);
      this.mirroringShapeCharacters.setValue(8843, 8842);
      this.mirroringShapeCharacters.setValue(8847, 8848);
      this.mirroringShapeCharacters.setValue(8848, 8847);
      this.mirroringShapeCharacters.setValue(8849, 8850);
      this.mirroringShapeCharacters.setValue(8850, 8849);
      this.mirroringShapeCharacters.setValue(8856, 10680);
      this.mirroringShapeCharacters.setValue(8866, 8867);
      this.mirroringShapeCharacters.setValue(8867, 8866);
      this.mirroringShapeCharacters.setValue(8870, 10974);
      this.mirroringShapeCharacters.setValue(8872, 10980);
      this.mirroringShapeCharacters.setValue(8873, 10979);
      this.mirroringShapeCharacters.setValue(8875, 10981);
      this.mirroringShapeCharacters.setValue(8880, 8881);
      this.mirroringShapeCharacters.setValue(8881, 8880);
      this.mirroringShapeCharacters.setValue(8882, 8883);
      this.mirroringShapeCharacters.setValue(8883, 8882);
      this.mirroringShapeCharacters.setValue(8884, 8885);
      this.mirroringShapeCharacters.setValue(8885, 8884);
      this.mirroringShapeCharacters.setValue(8886, 8887);
      this.mirroringShapeCharacters.setValue(8887, 8886);
      this.mirroringShapeCharacters.setValue(8905, 8906);
      this.mirroringShapeCharacters.setValue(8906, 8905);
      this.mirroringShapeCharacters.setValue(8907, 8908);
      this.mirroringShapeCharacters.setValue(8908, 8907);
      this.mirroringShapeCharacters.setValue(8909, 8771);
      this.mirroringShapeCharacters.setValue(8912, 8913);
      this.mirroringShapeCharacters.setValue(8913, 8912);
      this.mirroringShapeCharacters.setValue(8918, 8919);
      this.mirroringShapeCharacters.setValue(8919, 8918);
      this.mirroringShapeCharacters.setValue(8920, 8921);
      this.mirroringShapeCharacters.setValue(8921, 8920);
      this.mirroringShapeCharacters.setValue(8922, 8923);
      this.mirroringShapeCharacters.setValue(8923, 8922);
      this.mirroringShapeCharacters.setValue(8924, 8925);
      this.mirroringShapeCharacters.setValue(8925, 8924);
      this.mirroringShapeCharacters.setValue(8926, 8927);
      this.mirroringShapeCharacters.setValue(8927, 8926);
      this.mirroringShapeCharacters.setValue(8928, 8929);
      this.mirroringShapeCharacters.setValue(8929, 8928);
      this.mirroringShapeCharacters.setValue(8930, 8931);
      this.mirroringShapeCharacters.setValue(8931, 8930);
      this.mirroringShapeCharacters.setValue(8932, 8933);
      this.mirroringShapeCharacters.setValue(8933, 8932);
      this.mirroringShapeCharacters.setValue(8934, 8935);
      this.mirroringShapeCharacters.setValue(8935, 8934);
      this.mirroringShapeCharacters.setValue(8936, 8937);
      this.mirroringShapeCharacters.setValue(8937, 8936);
      this.mirroringShapeCharacters.setValue(8938, 8939);
      this.mirroringShapeCharacters.setValue(8939, 8938);
      this.mirroringShapeCharacters.setValue(8940, 8941);
      this.mirroringShapeCharacters.setValue(8941, 8940);
      this.mirroringShapeCharacters.setValue(8944, 8945);
      this.mirroringShapeCharacters.setValue(8945, 8944);
      this.mirroringShapeCharacters.setValue(8946, 8954);
      this.mirroringShapeCharacters.setValue(8947, 8955);
      this.mirroringShapeCharacters.setValue(8948, 8956);
      this.mirroringShapeCharacters.setValue(8950, 8957);
      this.mirroringShapeCharacters.setValue(8951, 8958);
      this.mirroringShapeCharacters.setValue(8954, 8946);
      this.mirroringShapeCharacters.setValue(8955, 8947);
      this.mirroringShapeCharacters.setValue(8956, 8948);
      this.mirroringShapeCharacters.setValue(8957, 8950);
      this.mirroringShapeCharacters.setValue(8958, 8951);
      this.mirroringShapeCharacters.setValue(8968, 8969);
      this.mirroringShapeCharacters.setValue(8969, 8968);
      this.mirroringShapeCharacters.setValue(8970, 8971);
      this.mirroringShapeCharacters.setValue(8971, 8970);
      this.mirroringShapeCharacters.setValue(9001, 9002);
      this.mirroringShapeCharacters.setValue(9002, 9001);
      this.mirroringShapeCharacters.setValue(10088, 10089);
      this.mirroringShapeCharacters.setValue(10089, 10088);
      this.mirroringShapeCharacters.setValue(10090, 10091);
      this.mirroringShapeCharacters.setValue(10091, 10090);
      this.mirroringShapeCharacters.setValue(10092, 10093);
      this.mirroringShapeCharacters.setValue(10093, 10092);
      this.mirroringShapeCharacters.setValue(10094, 10095);
      this.mirroringShapeCharacters.setValue(10095, 10094);
      this.mirroringShapeCharacters.setValue(10096, 10097);
      this.mirroringShapeCharacters.setValue(10097, 10096);
      this.mirroringShapeCharacters.setValue(10098, 10099);
      this.mirroringShapeCharacters.setValue(10099, 10098);
      this.mirroringShapeCharacters.setValue(10100, 10101);
      this.mirroringShapeCharacters.setValue(10101, 10100);
      this.mirroringShapeCharacters.setValue(10197, 10198);
      this.mirroringShapeCharacters.setValue(10198, 10197);
      this.mirroringShapeCharacters.setValue(10205, 10206);
      this.mirroringShapeCharacters.setValue(10206, 10205);
      this.mirroringShapeCharacters.setValue(10210, 10211);
      this.mirroringShapeCharacters.setValue(10211, 10210);
      this.mirroringShapeCharacters.setValue(10212, 10213);
      this.mirroringShapeCharacters.setValue(10213, 10212);
      this.mirroringShapeCharacters.setValue(10214, 10215);
      this.mirroringShapeCharacters.setValue(10215, 10214);
      this.mirroringShapeCharacters.setValue(10216, 10217);
      this.mirroringShapeCharacters.setValue(10217, 10216);
      this.mirroringShapeCharacters.setValue(10218, 10219);
      this.mirroringShapeCharacters.setValue(10219, 10218);
      this.mirroringShapeCharacters.setValue(10627, 10628);
      this.mirroringShapeCharacters.setValue(10628, 10627);
      this.mirroringShapeCharacters.setValue(10629, 10630);
      this.mirroringShapeCharacters.setValue(10630, 10629);
      this.mirroringShapeCharacters.setValue(10631, 10632);
      this.mirroringShapeCharacters.setValue(10632, 10631);
      this.mirroringShapeCharacters.setValue(10633, 10634);
      this.mirroringShapeCharacters.setValue(10634, 10633);
      this.mirroringShapeCharacters.setValue(10635, 10636);
      this.mirroringShapeCharacters.setValue(10636, 10635);
      this.mirroringShapeCharacters.setValue(10637, 10640);
      this.mirroringShapeCharacters.setValue(10638, 10639);
      this.mirroringShapeCharacters.setValue(10639, 10638);
      this.mirroringShapeCharacters.setValue(10640, 10637);
      this.mirroringShapeCharacters.setValue(10641, 10642);
      this.mirroringShapeCharacters.setValue(10642, 10641);
      this.mirroringShapeCharacters.setValue(10643, 10644);
      this.mirroringShapeCharacters.setValue(10644, 10643);
      this.mirroringShapeCharacters.setValue(10645, 10646);
      this.mirroringShapeCharacters.setValue(10646, 10645);
      this.mirroringShapeCharacters.setValue(10647, 10648);
      this.mirroringShapeCharacters.setValue(10648, 10647);
      this.mirroringShapeCharacters.setValue(10680, 8856);
      this.mirroringShapeCharacters.setValue(10688, 10689);
      this.mirroringShapeCharacters.setValue(10689, 10688);
      this.mirroringShapeCharacters.setValue(10692, 10693);
      this.mirroringShapeCharacters.setValue(10693, 10692);
      this.mirroringShapeCharacters.setValue(10703, 10704);
      this.mirroringShapeCharacters.setValue(10704, 10703);
      this.mirroringShapeCharacters.setValue(10705, 10706);
      this.mirroringShapeCharacters.setValue(10706, 10705);
      this.mirroringShapeCharacters.setValue(10708, 10709);
      this.mirroringShapeCharacters.setValue(10709, 10708);
      this.mirroringShapeCharacters.setValue(10712, 10713);
      this.mirroringShapeCharacters.setValue(10713, 10712);
      this.mirroringShapeCharacters.setValue(10714, 10715);
      this.mirroringShapeCharacters.setValue(10715, 10714);
      this.mirroringShapeCharacters.setValue(10741, 8725);
      this.mirroringShapeCharacters.setValue(10744, 10745);
      this.mirroringShapeCharacters.setValue(10745, 10744);
      this.mirroringShapeCharacters.setValue(10748, 10749);
      this.mirroringShapeCharacters.setValue(10749, 10748);
      this.mirroringShapeCharacters.setValue(10795, 10796);
      this.mirroringShapeCharacters.setValue(10796, 10795);
      this.mirroringShapeCharacters.setValue(10797, 10796);
      this.mirroringShapeCharacters.setValue(10798, 10797);
      this.mirroringShapeCharacters.setValue(10804, 10805);
      this.mirroringShapeCharacters.setValue(10805, 10804);
      this.mirroringShapeCharacters.setValue(10812, 10813);
      this.mirroringShapeCharacters.setValue(10813, 10812);
      this.mirroringShapeCharacters.setValue(10852, 10853);
      this.mirroringShapeCharacters.setValue(10853, 10852);
      this.mirroringShapeCharacters.setValue(10873, 10874);
      this.mirroringShapeCharacters.setValue(10874, 10873);
      this.mirroringShapeCharacters.setValue(10877, 10878);
      this.mirroringShapeCharacters.setValue(10878, 10877);
      this.mirroringShapeCharacters.setValue(10879, 10880);
      this.mirroringShapeCharacters.setValue(10880, 10879);
      this.mirroringShapeCharacters.setValue(10881, 10882);
      this.mirroringShapeCharacters.setValue(10882, 10881);
      this.mirroringShapeCharacters.setValue(10883, 10884);
      this.mirroringShapeCharacters.setValue(10884, 10883);
      this.mirroringShapeCharacters.setValue(10891, 10892);
      this.mirroringShapeCharacters.setValue(10892, 10891);
      this.mirroringShapeCharacters.setValue(10897, 10898);
      this.mirroringShapeCharacters.setValue(10898, 10897);
      this.mirroringShapeCharacters.setValue(10899, 10900);
      this.mirroringShapeCharacters.setValue(10900, 10899);
      this.mirroringShapeCharacters.setValue(10901, 10902);
      this.mirroringShapeCharacters.setValue(10902, 10901);
      this.mirroringShapeCharacters.setValue(10903, 10904);
      this.mirroringShapeCharacters.setValue(10904, 10903);
      this.mirroringShapeCharacters.setValue(10905, 10906);
      this.mirroringShapeCharacters.setValue(10906, 10905);
      this.mirroringShapeCharacters.setValue(10907, 10908);
      this.mirroringShapeCharacters.setValue(10908, 10907);
      this.mirroringShapeCharacters.setValue(10913, 10914);
      this.mirroringShapeCharacters.setValue(10914, 10913);
      this.mirroringShapeCharacters.setValue(10918, 10919);
      this.mirroringShapeCharacters.setValue(10919, 10918);
      this.mirroringShapeCharacters.setValue(10920, 10921);
      this.mirroringShapeCharacters.setValue(10921, 10920);
      this.mirroringShapeCharacters.setValue(10922, 10923);
      this.mirroringShapeCharacters.setValue(10923, 10922);
      this.mirroringShapeCharacters.setValue(10924, 10925);
      this.mirroringShapeCharacters.setValue(10925, 10924);
      this.mirroringShapeCharacters.setValue(10927, 10928);
      this.mirroringShapeCharacters.setValue(10928, 10927);
      this.mirroringShapeCharacters.setValue(10931, 10932);
      this.mirroringShapeCharacters.setValue(10932, 10931);
      this.mirroringShapeCharacters.setValue(10939, 10940);
      this.mirroringShapeCharacters.setValue(10940, 10939);
      this.mirroringShapeCharacters.setValue(10941, 10942);
      this.mirroringShapeCharacters.setValue(10942, 10941);
      this.mirroringShapeCharacters.setValue(10943, 10944);
      this.mirroringShapeCharacters.setValue(10944, 10943);
      this.mirroringShapeCharacters.setValue(10945, 10946);
      this.mirroringShapeCharacters.setValue(10946, 10945);
      this.mirroringShapeCharacters.setValue(10947, 10948);
      this.mirroringShapeCharacters.setValue(10948, 10947);
      this.mirroringShapeCharacters.setValue(10949, 10950);
      this.mirroringShapeCharacters.setValue(10950, 10949);
      this.mirroringShapeCharacters.setValue(10957, 10958);
      this.mirroringShapeCharacters.setValue(10958, 10957);
      this.mirroringShapeCharacters.setValue(10959, 10960);
      this.mirroringShapeCharacters.setValue(10960, 10959);
      this.mirroringShapeCharacters.setValue(10961, 10962);
      this.mirroringShapeCharacters.setValue(10962, 10961);
      this.mirroringShapeCharacters.setValue(10963, 10964);
      this.mirroringShapeCharacters.setValue(10964, 10963);
      this.mirroringShapeCharacters.setValue(10965, 10966);
      this.mirroringShapeCharacters.setValue(10966, 10965);
      this.mirroringShapeCharacters.setValue(10974, 8870);
      this.mirroringShapeCharacters.setValue(10979, 8873);
      this.mirroringShapeCharacters.setValue(10980, 8872);
      this.mirroringShapeCharacters.setValue(10981, 8875);
      this.mirroringShapeCharacters.setValue(10988, 10989);
      this.mirroringShapeCharacters.setValue(10989, 10988);
      this.mirroringShapeCharacters.setValue(10999, 11e3);
      this.mirroringShapeCharacters.setValue(11e3, 10999);
      this.mirroringShapeCharacters.setValue(11001, 11002);
      this.mirroringShapeCharacters.setValue(11002, 11001);
      this.mirroringShapeCharacters.setValue(12296, 12297);
      this.mirroringShapeCharacters.setValue(12297, 12296);
      this.mirroringShapeCharacters.setValue(12298, 12299);
      this.mirroringShapeCharacters.setValue(12299, 12298);
      this.mirroringShapeCharacters.setValue(12300, 12301);
      this.mirroringShapeCharacters.setValue(12301, 12300);
      this.mirroringShapeCharacters.setValue(12302, 12303);
      this.mirroringShapeCharacters.setValue(12303, 12302);
      this.mirroringShapeCharacters.setValue(12304, 12305);
      this.mirroringShapeCharacters.setValue(12305, 12304);
      this.mirroringShapeCharacters.setValue(12308, 12309);
      this.mirroringShapeCharacters.setValue(12309, 12308);
      this.mirroringShapeCharacters.setValue(12310, 12311);
      this.mirroringShapeCharacters.setValue(12311, 12310);
      this.mirroringShapeCharacters.setValue(12312, 12313);
      this.mirroringShapeCharacters.setValue(12313, 12312);
      this.mirroringShapeCharacters.setValue(12314, 12315);
      this.mirroringShapeCharacters.setValue(12315, 12314);
      this.mirroringShapeCharacters.setValue(65288, 65289);
      this.mirroringShapeCharacters.setValue(65289, 65288);
      this.mirroringShapeCharacters.setValue(65308, 65310);
      this.mirroringShapeCharacters.setValue(65310, 65308);
      this.mirroringShapeCharacters.setValue(65339, 65341);
      this.mirroringShapeCharacters.setValue(65341, 65339);
      this.mirroringShapeCharacters.setValue(65371, 65373);
      this.mirroringShapeCharacters.setValue(65373, 65371);
      this.mirroringShapeCharacters.setValue(65375, 65376);
      this.mirroringShapeCharacters.setValue(65376, 65375);
      this.mirroringShapeCharacters.setValue(65378, 65379);
      this.mirroringShapeCharacters.setValue(65379, 65378);
    };
    return Bidi2;
  })()
);
var RtlCharacters = (
  /** @class */
  (function() {
    function RtlCharacters2() {
      this.types = [];
      this.textOrder = -1;
      this.rtlCharacterTypes = new Array(65536);
      this.L = 0;
      this.LRE = 1;
      this.LRO = 2;
      this.R = 3;
      this.AL = 4;
      this.RLE = 5;
      this.RLO = 6;
      this.PDF = 7;
      this.EN = 8;
      this.ES = 9;
      this.ET = 10;
      this.AN = 11;
      this.CS = 12;
      this.NSM = 13;
      this.BN = 14;
      this.B = 15;
      this.S = 16;
      this.WS = 17;
      this.ON = 18;
      this.charTypes = [
        this.L,
        this.EN,
        this.BN,
        this.ES,
        this.ES,
        this.S,
        this.ET,
        this.ET,
        this.B,
        this.AN,
        this.AN,
        this.S,
        this.CS,
        this.CS,
        this.WS,
        this.NSM,
        this.NSM,
        this.B,
        this.BN,
        27,
        this.BN,
        28,
        30,
        this.B,
        31,
        31,
        this.S,
        32,
        32,
        this.WS,
        33,
        34,
        this.ON,
        35,
        37,
        this.ET,
        38,
        42,
        this.ON,
        43,
        43,
        this.ET,
        44,
        44,
        this.CS,
        45,
        45,
        this.ET,
        46,
        46,
        this.CS,
        47,
        47,
        this.CS,
        48,
        57,
        this.EN,
        58,
        58,
        this.CS,
        59,
        64,
        this.ON,
        65,
        90,
        this.L,
        91,
        96,
        this.ON,
        97,
        122,
        this.L,
        123,
        126,
        this.ON,
        127,
        132,
        this.BN,
        133,
        133,
        this.B,
        134,
        159,
        this.BN,
        160,
        160,
        this.CS,
        161,
        161,
        this.ON,
        162,
        165,
        this.ET,
        166,
        169,
        this.ON,
        170,
        170,
        this.L,
        171,
        175,
        this.ON,
        176,
        177,
        this.ET,
        178,
        179,
        this.EN,
        180,
        180,
        this.ON,
        181,
        181,
        this.L,
        182,
        184,
        this.ON,
        185,
        185,
        this.EN,
        186,
        186,
        this.L,
        187,
        191,
        this.ON,
        192,
        214,
        this.L,
        215,
        215,
        this.ON,
        216,
        246,
        this.L,
        247,
        247,
        this.ON,
        248,
        696,
        this.L,
        697,
        698,
        this.ON,
        699,
        705,
        this.L,
        706,
        719,
        this.ON,
        720,
        721,
        this.L,
        722,
        735,
        this.ON,
        736,
        740,
        this.L,
        741,
        749,
        this.ON,
        750,
        750,
        this.L,
        751,
        767,
        this.ON,
        768,
        855,
        this.NSM,
        856,
        860,
        this.L,
        861,
        879,
        this.NSM,
        880,
        883,
        this.L,
        884,
        885,
        this.ON,
        886,
        893,
        this.L,
        894,
        894,
        this.ON,
        895,
        899,
        this.L,
        900,
        901,
        this.ON,
        902,
        902,
        this.L,
        903,
        903,
        this.ON,
        904,
        1013,
        this.L,
        1014,
        1014,
        this.ON,
        1015,
        1154,
        this.L,
        1155,
        1158,
        this.NSM,
        1159,
        1159,
        this.L,
        1160,
        1161,
        this.NSM,
        1162,
        1417,
        this.L,
        1418,
        1418,
        this.ON,
        1419,
        1424,
        this.L,
        1425,
        1441,
        this.NSM,
        1442,
        1442,
        this.L,
        1443,
        1465,
        this.NSM,
        1466,
        1466,
        this.L,
        1467,
        1469,
        this.NSM,
        1470,
        1470,
        this.R,
        1471,
        1471,
        this.NSM,
        1472,
        1472,
        this.R,
        1473,
        1474,
        this.NSM,
        1475,
        1475,
        this.R,
        1476,
        1476,
        this.NSM,
        1477,
        1487,
        this.L,
        1488,
        1514,
        this.R,
        1515,
        1519,
        this.L,
        1520,
        1524,
        this.R,
        1525,
        1535,
        this.L,
        1536,
        1539,
        this.AL,
        1540,
        1547,
        this.L,
        1548,
        1548,
        this.CS,
        1549,
        1549,
        this.AL,
        1550,
        1551,
        this.ON,
        1552,
        1557,
        this.NSM,
        1558,
        1562,
        this.L,
        1563,
        1563,
        this.AL,
        1564,
        1566,
        this.L,
        1567,
        1567,
        this.AL,
        1568,
        1568,
        this.L,
        1569,
        1594,
        this.AL,
        1595,
        1599,
        this.L,
        1600,
        1610,
        this.AL,
        1611,
        1624,
        this.NSM,
        1625,
        1631,
        this.L,
        1632,
        1641,
        this.AN,
        1642,
        1642,
        this.ET,
        1643,
        1644,
        this.AN,
        1645,
        1647,
        this.AL,
        1648,
        1648,
        this.NSM,
        1649,
        1749,
        this.AL,
        1750,
        1756,
        this.NSM,
        1757,
        1757,
        this.AL,
        1758,
        1764,
        this.NSM,
        1765,
        1766,
        this.AL,
        1767,
        1768,
        this.NSM,
        1769,
        1769,
        this.ON,
        1770,
        1773,
        this.NSM,
        1774,
        1775,
        this.AL,
        1776,
        1785,
        this.EN,
        1786,
        1805,
        this.AL,
        1806,
        1806,
        this.L,
        1807,
        1807,
        this.BN,
        1808,
        1808,
        this.AL,
        1809,
        1809,
        this.NSM,
        1810,
        1839,
        this.AL,
        1840,
        1866,
        this.NSM,
        1867,
        1868,
        this.L,
        1869,
        1871,
        this.AL,
        1872,
        1919,
        this.L,
        1920,
        1957,
        this.AL,
        1958,
        1968,
        this.NSM,
        1969,
        1969,
        this.AL,
        1970,
        2304,
        this.L,
        2305,
        2306,
        this.NSM,
        2307,
        2363,
        this.L,
        2364,
        2364,
        this.NSM,
        2365,
        2368,
        this.L,
        2369,
        2376,
        this.NSM,
        2377,
        2380,
        this.L,
        2381,
        2381,
        this.NSM,
        2382,
        2384,
        this.L,
        2385,
        2388,
        this.NSM,
        2389,
        2401,
        this.L,
        2402,
        2403,
        this.NSM,
        2404,
        2432,
        this.L,
        2433,
        2433,
        this.NSM,
        2434,
        2491,
        this.L,
        2492,
        2492,
        this.NSM,
        2493,
        2496,
        this.L,
        2497,
        2500,
        this.NSM,
        2501,
        2508,
        this.L,
        2509,
        2509,
        this.NSM,
        2510,
        2529,
        this.L,
        2530,
        2531,
        this.NSM,
        2532,
        2545,
        this.L,
        2546,
        2547,
        this.ET,
        2548,
        2560,
        this.L,
        2561,
        2562,
        this.NSM,
        2563,
        2619,
        this.L,
        2620,
        2620,
        this.NSM,
        2621,
        2624,
        this.L,
        2625,
        2626,
        this.NSM,
        2627,
        2630,
        this.L,
        2631,
        2632,
        this.NSM,
        2633,
        2634,
        this.L,
        2635,
        2637,
        this.NSM,
        2638,
        2671,
        this.L,
        2672,
        2673,
        this.NSM,
        2674,
        2688,
        this.L,
        2689,
        2690,
        this.NSM,
        2691,
        2747,
        this.L,
        2748,
        2748,
        this.NSM,
        2749,
        2752,
        this.L,
        2753,
        2757,
        this.NSM,
        2758,
        2758,
        this.L,
        2759,
        2760,
        this.NSM,
        2761,
        2764,
        this.L,
        2765,
        2765,
        this.NSM,
        2766,
        2785,
        this.L,
        2786,
        2787,
        this.NSM,
        2788,
        2800,
        this.L,
        2801,
        2801,
        this.ET,
        2802,
        2816,
        this.L,
        2817,
        2817,
        this.NSM,
        2818,
        2875,
        this.L,
        2876,
        2876,
        this.NSM,
        2877,
        2878,
        this.L,
        2879,
        2879,
        this.NSM,
        2880,
        2880,
        this.L,
        2881,
        2883,
        this.NSM,
        2884,
        2892,
        this.L,
        2893,
        2893,
        this.NSM,
        2894,
        2901,
        this.L,
        2902,
        2902,
        this.NSM,
        2903,
        2945,
        this.L,
        2946,
        2946,
        this.NSM,
        2947,
        3007,
        this.L,
        3008,
        3008,
        this.NSM,
        3009,
        3020,
        this.L,
        3021,
        3021,
        this.NSM,
        3022,
        3058,
        this.L,
        3059,
        3064,
        this.ON,
        3065,
        3065,
        this.ET,
        3066,
        3066,
        this.ON,
        3067,
        3133,
        this.L,
        3134,
        3136,
        this.NSM,
        3137,
        3141,
        this.L,
        3142,
        3144,
        this.NSM,
        3145,
        3145,
        this.L,
        3146,
        3149,
        this.NSM,
        3150,
        3156,
        this.L,
        3157,
        3158,
        this.NSM,
        3159,
        3259,
        this.L,
        3260,
        3260,
        this.NSM,
        3261,
        3275,
        this.L,
        3276,
        3277,
        this.NSM,
        3278,
        3392,
        this.L,
        3393,
        3395,
        this.NSM,
        3396,
        3404,
        this.L,
        3405,
        3405,
        this.NSM,
        3406,
        3529,
        this.L,
        3530,
        3530,
        this.NSM,
        3531,
        3537,
        this.L,
        3538,
        3540,
        this.NSM,
        3541,
        3541,
        this.L,
        3542,
        3542,
        this.NSM,
        3543,
        3632,
        this.L,
        3633,
        3633,
        this.NSM,
        3634,
        3635,
        this.L,
        3636,
        3642,
        this.NSM,
        3643,
        3646,
        this.L,
        3647,
        3647,
        this.ET,
        3648,
        3654,
        this.L,
        3655,
        3662,
        this.NSM,
        3663,
        3760,
        this.L,
        3761,
        3761,
        this.NSM,
        3762,
        3763,
        this.L,
        3764,
        3769,
        this.NSM,
        3770,
        3770,
        this.L,
        3771,
        3772,
        this.NSM,
        3773,
        3783,
        this.L,
        3784,
        3789,
        this.NSM,
        3790,
        3863,
        this.L,
        3864,
        3865,
        this.NSM,
        3866,
        3892,
        this.L,
        3893,
        3893,
        this.NSM,
        3894,
        3894,
        this.L,
        3895,
        3895,
        this.NSM,
        3896,
        3896,
        this.L,
        3897,
        3897,
        this.NSM,
        3898,
        3901,
        this.ON,
        3902,
        3952,
        this.L,
        3953,
        3966,
        this.NSM,
        3967,
        3967,
        this.L,
        3968,
        3972,
        this.NSM,
        3973,
        3973,
        this.L,
        3974,
        3975,
        this.NSM,
        3976,
        3983,
        this.L,
        3984,
        3991,
        this.NSM,
        3992,
        3992,
        this.L,
        3993,
        4028,
        this.NSM,
        4029,
        4037,
        this.L,
        4038,
        4038,
        this.NSM,
        4039,
        4140,
        this.L,
        4141,
        4144,
        this.NSM,
        4145,
        4145,
        this.L,
        4146,
        4146,
        this.NSM,
        4147,
        4149,
        this.L,
        4150,
        4151,
        this.NSM,
        4152,
        4152,
        this.L,
        4153,
        4153,
        this.NSM,
        4154,
        4183,
        this.L,
        4184,
        4185,
        this.NSM,
        4186,
        5759,
        this.L,
        5760,
        5760,
        this.WS,
        5761,
        5786,
        this.L,
        5787,
        5788,
        this.ON,
        5789,
        5905,
        this.L,
        5906,
        5908,
        this.NSM,
        5909,
        5937,
        this.L,
        5938,
        5940,
        this.NSM,
        5941,
        5969,
        this.L,
        5970,
        5971,
        this.NSM,
        5972,
        6001,
        this.L,
        6002,
        6003,
        this.NSM,
        6004,
        6070,
        this.L,
        6071,
        6077,
        this.NSM,
        6078,
        6085,
        this.L,
        6086,
        6086,
        this.NSM,
        6087,
        6088,
        this.L,
        6089,
        6099,
        this.NSM,
        6100,
        6106,
        this.L,
        6107,
        6107,
        this.ET,
        6108,
        6108,
        this.L,
        6109,
        6109,
        this.NSM,
        6110,
        6127,
        this.L,
        6128,
        6137,
        this.ON,
        6138,
        6143,
        this.L,
        6144,
        6154,
        this.ON,
        6155,
        6157,
        this.NSM,
        6158,
        6158,
        this.WS,
        6159,
        6312,
        this.L,
        6313,
        6313,
        this.NSM,
        6314,
        6431,
        this.L,
        6432,
        6434,
        this.NSM,
        6435,
        6438,
        this.L,
        6439,
        6443,
        this.NSM,
        6444,
        6449,
        this.L,
        6450,
        6450,
        this.NSM,
        6451,
        6456,
        this.L,
        6457,
        6459,
        this.NSM,
        6460,
        6463,
        this.L,
        6464,
        6464,
        this.ON,
        6465,
        6467,
        this.L,
        6468,
        6469,
        this.ON,
        6470,
        6623,
        this.L,
        6624,
        6655,
        this.ON,
        6656,
        8124,
        this.L,
        8125,
        8125,
        this.ON,
        8126,
        8126,
        this.L,
        8127,
        8129,
        this.ON,
        8130,
        8140,
        this.L,
        8141,
        8143,
        this.ON,
        8144,
        8156,
        this.L,
        8157,
        8159,
        this.ON,
        8160,
        8172,
        this.L,
        8173,
        8175,
        this.ON,
        8176,
        8188,
        this.L,
        8189,
        8190,
        this.ON,
        8191,
        8191,
        this.L,
        8192,
        8202,
        this.WS,
        8203,
        8205,
        this.BN,
        8206,
        8206,
        this.L,
        8207,
        8207,
        this.R,
        8208,
        8231,
        this.ON,
        8232,
        8232,
        this.WS,
        8233,
        8233,
        this.B,
        8234,
        8234,
        this.LRE,
        8235,
        8235,
        this.RLE,
        8236,
        8236,
        this.PDF,
        8237,
        8237,
        this.LRO,
        8238,
        8238,
        this.RLO,
        8239,
        8239,
        this.WS,
        8240,
        8244,
        this.ET,
        8245,
        8276,
        this.ON,
        8277,
        8278,
        this.L,
        8279,
        8279,
        this.ON,
        8280,
        8286,
        this.L,
        8287,
        8287,
        this.WS,
        8288,
        8291,
        this.BN,
        8292,
        8297,
        this.L,
        8298,
        8303,
        this.BN,
        8304,
        8304,
        this.EN,
        8305,
        8307,
        this.L,
        8308,
        8313,
        this.EN,
        8314,
        8315,
        this.ET,
        8316,
        8318,
        this.ON,
        8319,
        8319,
        this.L,
        8320,
        8329,
        this.EN,
        8330,
        8331,
        this.ET,
        8332,
        8334,
        this.ON,
        8335,
        8351,
        this.L,
        8352,
        8369,
        this.ET,
        8370,
        8399,
        this.L,
        8400,
        8426,
        this.NSM,
        8427,
        8447,
        this.L,
        8448,
        8449,
        this.ON,
        8450,
        8450,
        this.L,
        8451,
        8454,
        this.ON,
        8455,
        8455,
        this.L,
        8456,
        8457,
        this.ON,
        8458,
        8467,
        this.L,
        8468,
        8468,
        this.ON,
        8469,
        8469,
        this.L,
        8470,
        8472,
        this.ON,
        8473,
        8477,
        this.L,
        8478,
        8483,
        this.ON,
        8484,
        8484,
        this.L,
        8485,
        8485,
        this.ON,
        8486,
        8486,
        this.L,
        8487,
        8487,
        this.ON,
        8488,
        8488,
        this.L,
        8489,
        8489,
        this.ON,
        8490,
        8493,
        this.L,
        8494,
        8494,
        this.ET,
        8495,
        8497,
        this.L,
        8498,
        8498,
        this.ON,
        8499,
        8505,
        this.L,
        8506,
        8507,
        this.ON,
        8508,
        8511,
        this.L,
        8512,
        8516,
        this.ON,
        8517,
        8521,
        this.L,
        8522,
        8523,
        this.ON,
        8524,
        8530,
        this.L,
        8531,
        8543,
        this.ON,
        8544,
        8591,
        this.L,
        8592,
        8721,
        this.ON,
        8722,
        8723,
        this.ET,
        8724,
        9013,
        this.ON,
        9014,
        9082,
        this.L,
        9083,
        9108,
        this.ON,
        9109,
        9109,
        this.L,
        9110,
        9168,
        this.ON,
        9169,
        9215,
        this.L,
        9216,
        9254,
        this.ON,
        9255,
        9279,
        this.L,
        9280,
        9290,
        this.ON,
        9291,
        9311,
        this.L,
        9312,
        9371,
        this.EN,
        9372,
        9449,
        this.L,
        9450,
        9450,
        this.EN,
        9451,
        9751,
        this.ON,
        9752,
        9752,
        this.L,
        9753,
        9853,
        this.ON,
        9854,
        9855,
        this.L,
        9856,
        9873,
        this.ON,
        9874,
        9887,
        this.L,
        9888,
        9889,
        this.ON,
        9890,
        9984,
        this.L,
        9985,
        9988,
        this.ON,
        9989,
        9989,
        this.L,
        9990,
        9993,
        this.ON,
        9994,
        9995,
        this.L,
        9996,
        10023,
        this.ON,
        10024,
        10024,
        this.L,
        10025,
        10059,
        this.ON,
        10060,
        10060,
        this.L,
        10061,
        10061,
        this.ON,
        10062,
        10062,
        this.L,
        10063,
        10066,
        this.ON,
        10067,
        10069,
        this.L,
        10070,
        10070,
        this.ON,
        10071,
        10071,
        this.L,
        10072,
        10078,
        this.ON,
        10079,
        10080,
        this.L,
        10081,
        10132,
        this.ON,
        10133,
        10135,
        this.L,
        10136,
        10159,
        this.ON,
        10160,
        10160,
        this.L,
        10161,
        10174,
        this.ON,
        10175,
        10191,
        this.L,
        10192,
        10219,
        this.ON,
        10220,
        10223,
        this.L,
        10224,
        11021,
        this.ON,
        11022,
        11903,
        this.L,
        11904,
        11929,
        this.ON,
        11930,
        11930,
        this.L,
        11931,
        12019,
        this.ON,
        12020,
        12031,
        this.L,
        12032,
        12245,
        this.ON,
        12246,
        12271,
        this.L,
        12272,
        12283,
        this.ON,
        12284,
        12287,
        this.L,
        12288,
        12288,
        this.WS,
        12289,
        12292,
        this.ON,
        12293,
        12295,
        this.L,
        12296,
        12320,
        this.ON,
        12321,
        12329,
        this.L,
        12330,
        12335,
        this.NSM,
        12336,
        12336,
        this.ON,
        12337,
        12341,
        this.L,
        12342,
        12343,
        this.ON,
        12344,
        12348,
        this.L,
        12349,
        12351,
        this.ON,
        12352,
        12440,
        this.L,
        12441,
        12442,
        this.NSM,
        12443,
        12444,
        this.ON,
        12445,
        12447,
        this.L,
        12448,
        12448,
        this.ON,
        12449,
        12538,
        this.L,
        12539,
        12539,
        this.ON,
        12540,
        12828,
        this.L,
        12829,
        12830,
        this.ON,
        12831,
        12879,
        this.L,
        12880,
        12895,
        this.ON,
        12896,
        12923,
        this.L,
        12924,
        12925,
        this.ON,
        12926,
        12976,
        this.L,
        12977,
        12991,
        this.ON,
        12992,
        13003,
        this.L,
        13004,
        13007,
        this.ON,
        13008,
        13174,
        this.L,
        13175,
        13178,
        this.ON,
        13179,
        13277,
        this.L,
        13278,
        13279,
        this.ON,
        13280,
        13310,
        this.L,
        13311,
        13311,
        this.ON,
        13312,
        19903,
        this.L,
        19904,
        19967,
        this.ON,
        19968,
        42127,
        this.L,
        42128,
        42182,
        this.ON,
        42183,
        64284,
        this.L,
        64285,
        64285,
        this.R,
        64286,
        64286,
        this.NSM,
        64287,
        64296,
        this.R,
        64297,
        64297,
        this.ET,
        64298,
        64310,
        this.R,
        64311,
        64311,
        this.L,
        64312,
        64316,
        this.R,
        64317,
        64317,
        this.L,
        64318,
        64318,
        this.R,
        64319,
        64319,
        this.L,
        64320,
        64321,
        this.R,
        64322,
        64322,
        this.L,
        64323,
        64324,
        this.R,
        64325,
        64325,
        this.L,
        64326,
        64335,
        this.R,
        64336,
        64433,
        this.AL,
        64434,
        64466,
        this.L,
        64467,
        64829,
        this.AL,
        64830,
        64831,
        this.ON,
        64832,
        64847,
        this.L,
        64848,
        64911,
        this.AL,
        64912,
        64913,
        this.L,
        64914,
        64967,
        this.AL,
        64968,
        65007,
        this.L,
        65008,
        65020,
        this.AL,
        65021,
        65021,
        this.ON,
        65022,
        65023,
        this.L,
        65024,
        65039,
        this.NSM,
        65040,
        65055,
        this.L,
        65056,
        65059,
        this.NSM,
        65060,
        65071,
        this.L,
        65072,
        65103,
        this.ON,
        65104,
        65104,
        this.CS,
        65105,
        65105,
        this.ON,
        65106,
        65106,
        this.CS,
        65107,
        65107,
        this.L,
        65108,
        65108,
        this.ON,
        65109,
        65109,
        this.CS,
        65110,
        65118,
        this.ON,
        65119,
        65119,
        this.ET,
        65120,
        65121,
        this.ON,
        65122,
        65123,
        this.ET,
        65124,
        65126,
        this.ON,
        65127,
        65127,
        this.L,
        65128,
        65128,
        this.ON,
        65129,
        65130,
        this.ET,
        65131,
        65131,
        this.ON,
        65132,
        65135,
        this.L,
        65136,
        65140,
        this.AL,
        65141,
        65141,
        this.L,
        65142,
        65276,
        this.AL,
        65277,
        65278,
        this.L,
        65279,
        65279,
        this.BN,
        65280,
        65280,
        this.L,
        65281,
        65282,
        this.ON,
        65283,
        65285,
        this.ET,
        65286,
        65290,
        this.ON,
        65291,
        65291,
        this.ET,
        65292,
        65292,
        this.CS,
        65293,
        65293,
        this.ET,
        65294,
        65294,
        this.CS,
        65295,
        65295,
        this.ES,
        65296,
        65305,
        this.EN,
        65306,
        65306,
        this.CS,
        65307,
        65312,
        this.ON,
        65313,
        65338,
        this.L,
        65339,
        65344,
        this.ON,
        65345,
        65370,
        this.L,
        65371,
        65381,
        this.ON,
        65382,
        65503,
        this.L,
        65504,
        65505,
        this.ET,
        65506,
        65508,
        this.ON,
        65509,
        65510,
        this.ET,
        65511,
        65511,
        this.L,
        65512,
        65518,
        this.ON,
        65519,
        65528,
        this.L,
        65529,
        65531,
        this.BN,
        65532,
        65533,
        this.ON,
        65534,
        65535,
        this.L
      ];
      for (var i = 0; i < this.charTypes.length; ++i) {
        var start = this.charTypes[i];
        var end = this.charTypes[++i];
        var b = this.charTypes[++i];
        while (start <= end) {
          this.rtlCharacterTypes[start++] = b;
        }
      }
    }
    RtlCharacters2.prototype.getVisualOrder = function(inputText, isRtl) {
      this.types = this.getCharacterCode(inputText);
      this.textOrder = isRtl ? this.LRE : this.L;
      this.doVisualOrder();
      var result = [];
      for (var i = 0; i < this.levels.length; i++) {
        result[i] = this.levels[i];
      }
      return result;
    };
    RtlCharacters2.prototype.getCharacterCode = function(text) {
      var characterCodes = [];
      for (var i = 0; i < text.length; i++) {
        characterCodes[i] = this.rtlCharacterTypes[text[i].charCodeAt(0)];
      }
      return characterCodes;
    };
    RtlCharacters2.prototype.setDefaultLevels = function() {
      for (var i = 0; i < this.length; i++) {
        this.levels[i] = this.textOrder;
      }
    };
    RtlCharacters2.prototype.setLevels = function() {
      this.setDefaultLevels();
      for (var n = 0; n < this.length; ++n) {
        var level = this.levels[n];
        if ((level & 128) !== 0) {
          level &= 127;
          this.result[n] = (level & 1) === 0 ? this.L : this.R;
        }
        this.levels[n] = level;
      }
    };
    RtlCharacters2.prototype.updateLevels = function(index, level, length) {
      if ((level & 1) === 0) {
        for (var i = index; i < length; ++i) {
          if (this.result[i] === this.R) {
            this.levels[i] += 1;
          } else if (this.result[i] !== this.L) {
            this.levels[i] += 2;
          }
        }
      } else {
        for (var i = index; i < length; ++i) {
          if (this.result[i] !== this.R) {
            this.levels[i] += 1;
          }
        }
      }
    };
    RtlCharacters2.prototype.doVisualOrder = function() {
      this.length = this.types.length;
      this.result = this.types;
      this.levels = [];
      this.setLevels();
      this.length = this.getEmbeddedCharactersLength();
      var preview = this.textOrder;
      var i = 0;
      while (i < this.length) {
        var level = this.levels[i];
        var preType = (Math.max(preview, level) & 1) === 0 ? this.L : this.R;
        var length_1 = i + 1;
        while (length_1 < this.length && this.levels[length_1] === level) {
          ++length_1;
        }
        var success = length_1 < this.length ? this.levels[length_1] : this.textOrder;
        var type = (Math.max(success, level) & 1) === 0 ? this.L : this.R;
        this.checkNSM(i, length_1, level, preType, type);
        this.updateLevels(i, level, length_1);
        preview = level;
        i = length_1;
      }
      this.checkEmbeddedCharacters(this.length);
    };
    RtlCharacters2.prototype.getEmbeddedCharactersLength = function() {
      var index = 0;
      for (var i = 0; i < this.length; ++i) {
        if (!(this.types[i] === this.LRE || this.types[i] === this.RLE || this.types[i] === this.LRO || this.types[i] === this.RLO || this.types[i] === this.PDF || this.types[i] === this.BN)) {
          this.result[index] = this.result[i];
          this.levels[index] = this.levels[i];
          index++;
        }
      }
      return index;
    };
    RtlCharacters2.prototype.checkEmbeddedCharacters = function(length) {
      for (var i = this.types.length - 1; i >= 0; --i) {
        if (this.types[i] === this.LRE || this.types[i] === this.RLE || this.types[i] === this.LRO || this.types[i] === this.RLO || this.types[i] === this.PDF || this.types[i] === this.BN) {
          this.result[i] = this.types[i];
          this.levels[i] = -1;
        } else {
          length -= 1;
          this.result[i] = this.result[length];
          this.levels[i] = this.levels[length];
        }
      }
      for (var i = 0; i < this.types.length; i++) {
        if (this.levels[i] === -1) {
          if (i === 0) {
            this.levels[i] = this.textOrder;
          } else {
            this.levels[i] = this.levels[i - 1];
          }
        }
      }
    };
    RtlCharacters2.prototype.checkNSM = function(index, length, level, startType, endType) {
      var charType = startType;
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.NSM) {
          this.result[i] = charType;
        } else {
          charType = this.result[i];
        }
      }
      this.checkEuropeanDigits(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.checkEuropeanDigits = function(index, length, level, startType, endType) {
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.EN) {
          for (var j = i - 1; j >= index; --j) {
            if (this.result[j] === this.L || this.result[j] === this.R || this.result[j] === this.AL) {
              if (this.result[j] === this.AL) {
                this.result[i] = this.AN;
              }
              break;
            }
          }
        }
      }
      this.checkArabicCharacters(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.checkArabicCharacters = function(index, length, level, startType, endType) {
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.AL) {
          this.result[i] = this.R;
        }
      }
      this.checkEuropeanNumberSeparator(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.checkEuropeanNumberSeparator = function(index, length, level, startType, endType) {
      for (var i = index + 1; i < length - 1; ++i) {
        if (this.result[i] === this.ES || this.result[i] === this.CS) {
          var preview = this.result[i - 1];
          var success = this.result[i + 1];
          if (preview === this.EN && success === this.EN) {
            this.result[i] = this.EN;
          } else if (this.result[i] === this.CS && preview === this.AN && success === this.AN) {
            this.result[i] = this.AN;
          }
        }
      }
      this.checkEuropeanNumberTerminator(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.checkEuropeanNumberTerminator = function(index, length, level, startType, endType) {
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.ET) {
          var s = i;
          var b = [];
          b.push(this.ET);
          var l = this.getLength(s, length, b);
          var data = s === index ? startType : this.result[s - 1];
          if (data !== this.EN) {
            data = l === length ? endType : this.result[l];
          }
          if (data === this.EN) {
            for (var j = s; j < l; ++j) {
              this.result[j] = this.EN;
            }
          }
          i = l;
        }
      }
      this.checkOtherNeutrals(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.checkOtherNeutrals = function(index, length, level, startType, endType) {
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.ES || this.result[i] === this.ET || this.result[i] === this.CS) {
          this.result[i] = this.ON;
        }
      }
      this.checkOtherCharacters(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.checkOtherCharacters = function(index, length, level, startType, endType) {
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.EN) {
          var pst = startType;
          for (var j = i - 1; j >= index; --j) {
            if (this.result[j] === this.L || this.result[j] === this.R) {
              pst = this.result[j];
              break;
            }
          }
          if (pst === this.L) {
            this.result[i] = this.L;
          }
        }
      }
      this.checkCommanCharacters(index, length, level, startType, endType);
    };
    RtlCharacters2.prototype.getLength = function(index, length, validSet) {
      --index;
      while (++index < length) {
        var t = this.result[index];
        for (var i = 0; i < validSet.length; ++i) {
          if (t === validSet[i]) {
            index = this.getLength(++index, length, validSet);
          }
        }
        return index;
      }
      return length;
    };
    RtlCharacters2.prototype.checkCommanCharacters = function(index, length, level, startType, endType) {
      for (var i = index; i < length; ++i) {
        if (this.result[i] === this.WS || this.result[i] === this.ON || this.result[i] === this.B || this.result[i] === this.S) {
          var s = i;
          var byte = [this.B, this.S, this.WS, this.ON];
          var l = this.getLength(s, length, byte);
          var lt = 0;
          var tt = 0;
          var rt = 0;
          if (s === index) {
            lt = startType;
          } else {
            lt = this.result[s - 1];
            if (lt === this.AN) {
              lt = this.R;
            } else if (lt === this.EN) {
              lt = this.R;
            }
          }
          if (l === length) {
            tt = endType;
          } else {
            tt = this.result[l];
            if (tt === this.AN) {
              tt = this.R;
            } else if (tt === this.EN) {
              tt = this.R;
            }
          }
          if (lt === tt) {
            rt = lt;
          } else {
            rt = (level & 1) === 0 ? this.L : this.R;
          }
          for (var j = s; j < l; ++j) {
            this.result[j] = rt;
          }
          i = l;
        }
      }
    };
    return RtlCharacters2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/rtl-renderer.js
var RtlRenderer = (
  /** @class */
  (function() {
    function RtlRenderer2() {
      this.openBracket = "(";
      this.closeBracket = ")";
    }
    RtlRenderer2.prototype.layout = function(line, font, rtl, wordSpace, format) {
      if (line == null) {
        throw new Error("ArgumentNullException : line");
      }
      if (font == null) {
        throw new Error("ArgumentNullException : font");
      }
      var result = [];
      if (font.Unicode) {
        result = this.customLayout(line, rtl, format, font, wordSpace);
      } else {
        result = [];
        result[0] = line;
      }
      return result;
    };
    RtlRenderer2.prototype.splitLayout = function(line, font, rtl, wordSpace, format) {
      if (line == null) {
        throw new Error("ArgumentNullException : line");
      }
      if (font == null) {
        throw new Error("ArgumentNullException : font");
      }
      var words = [];
      var system = false;
      if (!system || words == null) {
        words = this.customSplitLayout(line, font, rtl, wordSpace, format);
      }
      return words;
    };
    RtlRenderer2.prototype.getGlyphIndex = function(line, font, rtl, glyphs, custom) {
      var success = true;
      var fail = false;
      if (line == null) {
        throw new Error("ArgumentNullException : line");
      }
      if (font == null) {
        throw new Error("ArgumentNullException : font");
      }
      glyphs = null;
      if (line.length === 0) {
        return { success: fail, glyphs };
      }
      var renderer = new ArabicShapeRenderer();
      var text = renderer.shape(line, 0);
      var internalFont = font.fontInternal;
      var ttfReader = internalFont.ttfReader;
      glyphs = new Uint16Array(text.length);
      var i = 0;
      for (var k = 0, len = text.length; k < len; k++) {
        var ch = text[k];
        var glyphInfo = ttfReader.getGlyph(ch);
        if (glyphInfo !== null && typeof glyphInfo !== "undefined") {
          glyphs[i++] = glyphInfo.index;
        }
      }
      return { success, glyphs };
    };
    RtlRenderer2.prototype.customLayout = function(line, rtl, format, font, wordSpace) {
      if (wordSpace === null || typeof wordSpace === "undefined") {
        if (line == null) {
          throw new Error("ArgumentNullException : line");
        }
        var result = null;
        if (format !== null && typeof format !== "undefined" && format.textDirection !== PdfTextDirection.None) {
          var bidi = new Bidi();
          result = bidi.getLogicalToVisualString(line, rtl);
        }
        return result;
      } else {
        if (line == null) {
          throw new Error("ArgumentNullException : line");
        }
        if (font == null) {
          throw new Error("ArgumentNullException : font");
        }
        var layouted = null;
        if (format !== null && typeof format !== "undefined" && format.textDirection !== PdfTextDirection.None) {
          var renderer = new ArabicShapeRenderer();
          var txt = renderer.shape(line, 0);
          layouted = this.customLayout(txt, rtl, format);
        }
        var result = [];
        if (wordSpace) {
          var words = layouted.split("");
          var count = words.length;
          for (var i = 0; i < count; i++) {
            words[i] = this.addChars(font, words[i]);
          }
          result = words;
        } else {
          result = [];
          result[0] = this.addChars(font, layouted);
        }
        return result;
      }
    };
    RtlRenderer2.prototype.addChars = function(font, glyphs) {
      var line = glyphs;
      if (font == null) {
        throw new Error("ArgumentNullException : font");
      }
      if (line == null) {
        throw new Error("ArgumentNullException : line");
      }
      var text = line;
      var internalFont = font.fontInternal;
      var ttfReader = internalFont.ttfReader;
      font.setSymbols(text);
      text = ttfReader.convertString(text);
      var bytes = PdfString.toUnicodeArray(text, false);
      text = PdfString.byteToString(bytes);
      return text;
    };
    RtlRenderer2.prototype.customSplitLayout = function(line, font, rtl, wordSpace, format) {
      if (line == null) {
        throw new Error("ArgumentNullException : line");
      }
      if (font == null) {
        throw new Error("ArgumentNullException : font");
      }
      var reversedLine = this.customLayout(line, rtl, format);
      var words = reversedLine.split("");
      return words;
    };
    return RtlRenderer2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/enum.js
var PdfLayoutType;
(function(PdfLayoutType2) {
  PdfLayoutType2[PdfLayoutType2["Paginate"] = 0] = "Paginate";
  PdfLayoutType2[PdfLayoutType2["OnePage"] = 1] = "OnePage";
})(PdfLayoutType || (PdfLayoutType = {}));
var PdfLayoutBreakType;
(function(PdfLayoutBreakType2) {
  PdfLayoutBreakType2[PdfLayoutBreakType2["FitPage"] = 0] = "FitPage";
  PdfLayoutBreakType2[PdfLayoutBreakType2["FitElement"] = 1] = "FitElement";
  PdfLayoutBreakType2[PdfLayoutBreakType2["FitColumnsToPage"] = 2] = "FitColumnsToPage";
})(PdfLayoutBreakType || (PdfLayoutBreakType = {}));
var PathPointType;
(function(PathPointType2) {
  PathPointType2[PathPointType2["Start"] = 0] = "Start";
  PathPointType2[PathPointType2["Line"] = 1] = "Line";
  PathPointType2[PathPointType2["Bezier3"] = 3] = "Bezier3";
  PathPointType2[PathPointType2["Bezier"] = 3] = "Bezier";
  PathPointType2[PathPointType2["PathTypeMask"] = 7] = "PathTypeMask";
  PathPointType2[PathPointType2["DashMode"] = 16] = "DashMode";
  PathPointType2[PathPointType2["PathMarker"] = 32] = "PathMarker";
  PathPointType2[PathPointType2["CloseSubpath"] = 128] = "CloseSubpath";
})(PathPointType || (PathPointType = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-gradient-brush.js
var __extends30 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfGradientBrush = (
  /** @class */
  (function(_super) {
    __extends30(PdfGradientBrush2, _super);
    function PdfGradientBrush2(shading) {
      var _this = _super.call(this) || this;
      _this.mbackground = new PdfColor(255, 255, 255);
      _this.mbStroking = false;
      _this.mfunction = null;
      _this.dictionaryProperties = new DictionaryProperties();
      _this.mpatternDictionary = new PdfDictionary();
      _this.mpatternDictionary.items.setValue(_this.dictionaryProperties.type, new PdfName(_this.dictionaryProperties.pattern));
      _this.mpatternDictionary.items.setValue(_this.dictionaryProperties.patternType, new PdfNumber(2));
      _this.shading = shading;
      _this.colorSpace = PdfColorSpace.Rgb;
      return _this;
    }
    Object.defineProperty(PdfGradientBrush2.prototype, "background", {
      //Properties
      /**
       * Gets or sets the background color of the brush.
       * @public
       */
      get: function() {
        return this.mbackground;
      },
      set: function(value) {
        this.mbackground = value;
        var sh = this.shading;
        if (value.isEmpty) {
          sh.remove(this.dictionaryProperties.background);
        } else {
          sh.items.setValue(this.dictionaryProperties.background, value.toArray(this.colorSpace));
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "antiAlias", {
      /**
       * Gets or sets a value indicating whether use anti aliasing algorithm.
       * @public
       */
      get: function() {
        var sh = this.shading;
        var aa = sh.items.getValue(this.dictionaryProperties.antiAlias);
        return aa.value;
      },
      set: function(value) {
        var sh = this.shading;
        var aa = sh.items.getValue(this.dictionaryProperties.antiAlias);
        if (aa == null && typeof aa === "undefined") {
          aa = new PdfBoolean(value);
          sh.items.setValue(this.dictionaryProperties.antiAlias, aa);
        } else {
          aa.value = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "function", {
      /**
       * Gets or sets the function of the brush.
       * @protected
       */
      get: function() {
        return this.mfunction;
      },
      set: function(value) {
        this.mfunction = value;
        if (value != null && typeof value !== "undefined") {
          this.shading.items.setValue(this.dictionaryProperties.function, new PdfReferenceHolder(this.mfunction));
        } else {
          this.shading.remove(this.dictionaryProperties.function);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "bBox", {
      /**
       * Gets or sets the boundary box of the brush.
       * @protected
       */
      get: function() {
        var sh = this.shading;
        var box = sh.items.getValue(this.dictionaryProperties.bBox);
        return box;
      },
      set: function(value) {
        var sh = this.shading;
        if (value == null && typeof value === "undefined") {
          sh.remove(this.dictionaryProperties.bBox);
        } else {
          sh.items.setValue(this.dictionaryProperties.bBox, value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "colorSpace", {
      /**
       * Gets or sets the color space of the brush.
       * @public
       */
      get: function() {
        return this.mcolorSpace;
      },
      set: function(value) {
        var colorSpace = this.shading.items.getValue(this.dictionaryProperties.colorSpace);
        if (value !== this.mcolorSpace || colorSpace == null) {
          this.mcolorSpace = value;
          var csValue = this.colorSpaceToDeviceName(value);
          this.shading.items.setValue(this.dictionaryProperties.colorSpace, new PdfName(csValue));
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "stroking", {
      /**
       * Gets or sets a value indicating whether this PdfGradientBrush is stroking.
       * @public
       */
      get: function() {
        return this.mbStroking;
      },
      set: function(value) {
        this.mbStroking = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "patternDictionary", {
      /**
       * Gets the pattern dictionary.
       * @protected
       */
      get: function() {
        if (this.mpatternDictionary == null) {
          this.mpatternDictionary = new PdfDictionary();
        }
        return this.mpatternDictionary;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "shading", {
      /**
       * Gets or sets the shading dictionary.
       * @protected
       */
      get: function() {
        return this.mshading;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : Shading");
        }
        if (value !== this.mshading) {
          this.mshading = value;
          this.patternDictionary.items.setValue(this.dictionaryProperties.shading, new PdfReferenceHolder(this.mshading));
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGradientBrush2.prototype, "matrix", {
      /**
       * Gets or sets the transformation matrix.
       * @public
       */
      get: function() {
        return this.mmatrix;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : Matrix");
        }
        if (value !== this.mmatrix) {
          this.mmatrix = value.clone();
          var m = new PdfArray(this.mmatrix.matrix.elements);
          this.mpatternDictionary.items.setValue(this.dictionaryProperties.matrix, m);
        }
      },
      enumerable: true,
      configurable: true
    });
    PdfGradientBrush2.prototype.monitorChanges = function(brush, streamWriter, getResources, saveChanges, currentColorSpace) {
      var diff = false;
      if (brush instanceof PdfGradientBrush2) {
        if (this.colorSpace !== currentColorSpace) {
          this.colorSpace = currentColorSpace;
          this.resetFunction();
        }
        streamWriter.setColorSpace("Pattern", this.mbStroking);
        var resources = getResources.getResources();
        var name_1 = resources.getName(this);
        streamWriter.setColourWithPattern(null, name_1, this.mbStroking);
        diff = true;
      }
      return diff;
    };
    PdfGradientBrush2.prototype.resetChanges = function(streamWriter) {
    };
    PdfGradientBrush2.prototype.colorSpaceToDeviceName = function(colorSpace) {
      var result;
      switch (colorSpace) {
        case PdfColorSpace.Rgb:
          result = "DeviceRGB";
          break;
      }
      return result;
    };
    PdfGradientBrush2.prototype.resetPatternDictionary = function(dictionary) {
      this.mpatternDictionary = dictionary;
    };
    PdfGradientBrush2.prototype.cloneAntiAliasingValue = function(brush) {
      if (brush == null) {
        throw new Error("ArgumentNullException : brush");
      }
      var sh = this.shading;
      var aa = sh.items.getValue(this.dictionaryProperties.antiAlias);
      if (aa != null) {
        brush.shading.items.setValue(this.dictionaryProperties.antiAlias, new PdfBoolean(aa.value));
      }
    };
    PdfGradientBrush2.prototype.cloneBackgroundValue = function(brush) {
      var background = this.background;
      if (!background.isEmpty) {
        brush.background = background;
      }
    };
    Object.defineProperty(PdfGradientBrush2.prototype, "element", {
      /* tslint:enable */
      // IPdfWrapper Members
      /**
       * Gets the `element`.
       * @private
       */
      get: function() {
        return this.patternDictionary;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGradientBrush2;
  })(PdfBrush)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/pdf-template.js
var PdfTemplate = (
  /** @class */
  (function() {
    function PdfTemplate2(arg1, arg2) {
      this.dictionaryProperties = new DictionaryProperties();
      this.writeTransformation = true;
      if (typeof arg1 === "undefined") {
      } else if (arg1 instanceof SizeF && typeof arg2 === "undefined") {
        this.content = new PdfStream();
        var tempSize = new SizeF(arg1.width, arg1.height);
        this.setSize(tempSize);
        this.initialize();
      } else {
        this.content = new PdfStream();
        this.setSize(new SizeF(arg1, arg2));
        this.initialize();
      }
    }
    Object.defineProperty(PdfTemplate2.prototype, "size", {
      //Properties
      /**
       * Gets the size of the 'PdfTemplate'.
       */
      get: function() {
        return this.templateSize;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTemplate2.prototype, "width", {
      /**
       * Gets the width of the 'PdfTemplate'.
       */
      get: function() {
        return this.size.width;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTemplate2.prototype, "height", {
      /**
       * Gets the height of the 'PdfTemplate'.
       */
      get: function() {
        return this.size.height;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTemplate2.prototype, "graphics", {
      /**
       * Gets the `graphics` of the 'PdfTemplate'.
       */
      get: function() {
        if (this.pdfGraphics == null || typeof this.pdfGraphics === "undefined") {
          var gr = new GetResourceEventHandler(this);
          var g = new PdfGraphics(this.size, gr, this.content);
          this.pdfGraphics = g;
          this.pdfGraphics.initializeCoordinates();
        }
        return this.pdfGraphics;
      },
      enumerable: true,
      configurable: true
    });
    PdfTemplate2.prototype.getResources = function() {
      if (this.resources == null) {
        this.resources = new PdfResources();
        this.content.items.setValue(this.dictionaryProperties.resources, this.resources);
      }
      return this.resources;
    };
    PdfTemplate2.prototype.initialize = function() {
      this.addType();
      this.addSubType();
    };
    PdfTemplate2.prototype.addType = function() {
      var value = new PdfName(this.dictionaryProperties.xObject);
      this.content.items.setValue(this.dictionaryProperties.type, value);
    };
    PdfTemplate2.prototype.addSubType = function() {
      var value = new PdfName(this.dictionaryProperties.form);
      this.content.items.setValue(this.dictionaryProperties.subtype, value);
    };
    PdfTemplate2.prototype.reset = function(size) {
      if (typeof size === "undefined") {
        if (this.resources != null) {
          this.resources = null;
          this.content.remove(this.dictionaryProperties.resources);
        }
        if (this.graphics != null) {
          this.graphics.reset(this.size);
        }
      } else {
        this.setSize(size);
        this.reset();
      }
    };
    PdfTemplate2.prototype.setSize = function(size) {
      var rect = new RectangleF(new PointF(0, 0), size);
      var val = PdfArray.fromRectangle(rect);
      this.content.items.setValue(this.dictionaryProperties.bBox, val);
      this.templateSize = size;
    };
    Object.defineProperty(PdfTemplate2.prototype, "element", {
      // /**
      //  * Returns the value of current graphics.
      //  * @private
      //  */
      // public GetGraphics(g : PdfGraphics) : PdfGraphics {
      //     if (this.graphics == null || typeof this.graphics === 'undefined') {
      //         this.graphics = g;
      //         this.graphics.Size = this.Size;
      //         this.graphics.StreamWriter = new PdfStreamWriter(this.content)
      //         this.graphics.Initialize();
      //         if(this.writeTransformation) {
      //             this.graphics.InitializeCoordinates();
      //         }
      //     }
      //     return this.graphics;
      // }
      // IPdfWrapper Members
      /**
       * Gets the `content stream` of 'PdfTemplate' class.
       * @private
       */
      get: function() {
        return this.content;
      },
      enumerable: true,
      configurable: true
    });
    return PdfTemplate2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-resources.js
var __extends31 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfResources = (
  /** @class */
  (function(_super) {
    __extends31(PdfResources2, _super);
    function PdfResources2(baseDictionary) {
      var _this = _super.call(this, baseDictionary) || this;
      _this.properties = new PdfDictionary();
      return _this;
    }
    Object.defineProperty(PdfResources2.prototype, "names", {
      //Properties
      /**
       * Gets the `font names`.
       * @private
       */
      get: function() {
        return this.getNames();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfResources2.prototype, "document", {
      /**
       * Get or set the `page document`.
       * @private
       */
      get: function() {
        return this.pdfDocument;
      },
      set: function(value) {
        this.pdfDocument = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfResources2.prototype.getName = function(obj) {
      var primitive = obj.element;
      var name = null;
      if (this.names.containsKey(primitive)) {
        name = this.names.getValue(primitive);
      }
      if (name == null) {
        var sName = this.generateName();
        name = new PdfName(sName);
        this.names.setValue(primitive, name);
        if (obj instanceof PdfFont) {
          this.add(obj, name);
        } else if (obj instanceof PdfTemplate) {
          this.add(obj, name);
        } else if (obj instanceof PdfGradientBrush || obj instanceof PdfTilingBrush) {
          this.add(obj, name);
        } else if (obj instanceof PdfTransparency) {
          this.add(obj, name);
        } else if (obj instanceof PdfImage || obj instanceof PdfBitmap) {
          this.add(obj, name);
        }
      }
      return name;
    };
    PdfResources2.prototype.getNames = function() {
      if (this.pdfNames == null) {
        this.pdfNames = new TemporaryDictionary();
      }
      var fonts = this.items.getValue(this.dictionaryProperties.font);
      if (fonts != null) {
        var reference = fonts;
        var dictionary = fonts;
        dictionary = PdfCrossTable.dereference(fonts);
      }
      return this.pdfNames;
    };
    PdfResources2.prototype.requireProcedureSet = function(procedureSetName) {
      if (procedureSetName == null) {
        throw new Error("ArgumentNullException:procedureSetName");
      }
      var procSets = this.items.getValue(this.dictionaryProperties.procset);
      if (procSets == null) {
        procSets = new PdfArray();
        this.items.setValue(this.dictionaryProperties.procset, procSets);
      }
      var name = new PdfName(procedureSetName);
      if (!procSets.contains(name)) {
        procSets.add(name);
      }
    };
    PdfResources2.prototype.removeFont = function(name) {
      var key = null;
      var keys2 = this.pdfNames.keys();
      for (var index = 0; index < this.pdfNames.size(); index++) {
        if (this.pdfNames.getValue(keys2[index]) === new PdfName(name)) {
          key = keys2[index];
          break;
        }
      }
      if (key != null) {
        this.pdfNames.remove(key);
      }
    };
    PdfResources2.prototype.generateName = function() {
      var name = Guid.getNewGuidString();
      return name;
    };
    PdfResources2.prototype.add = function(arg1, arg2) {
      if (arg1 instanceof PdfFont) {
        var dictionary = null;
        var fonts = this.items.getValue(this.dictionaryProperties.font);
        if (fonts != null) {
          var reference = fonts;
          dictionary = fonts;
          dictionary = fonts;
        } else {
          dictionary = new PdfDictionary();
          this.items.setValue(this.dictionaryProperties.font, dictionary);
        }
        dictionary.items.setValue(arg2.value, new PdfReferenceHolder(arg1.element));
      } else if (arg1 instanceof PdfTemplate) {
        var xobjects = void 0;
        xobjects = this.items.getValue(this.dictionaryProperties.xObject);
        if (xobjects == null) {
          xobjects = new PdfDictionary();
          this.items.setValue(this.dictionaryProperties.xObject, xobjects);
        }
        xobjects.items.setValue(arg2.value, new PdfReferenceHolder(arg1.element));
      } else if (arg1 instanceof PdfBrush) {
        if (arg1 instanceof PdfGradientBrush || arg1 instanceof PdfTilingBrush) {
          var savable = arg1.element;
          if (savable != null) {
            var pattern = this.items.getValue(this.dictionaryProperties.pattern);
            if (pattern == null) {
              pattern = new PdfDictionary();
              this.items.setValue(this.dictionaryProperties.pattern, pattern);
            }
            pattern.items.setValue(arg2.value, new PdfReferenceHolder(savable));
          }
        }
      } else if (arg1 instanceof PdfTransparency) {
        var savable = arg1.element;
        var transDic = null;
        transDic = this.items.getValue(this.dictionaryProperties.extGState);
        if (transDic == null) {
          transDic = new PdfDictionary();
          this.items.setValue(this.dictionaryProperties.extGState, transDic);
        }
        transDic.items.setValue(arg2.value, new PdfReferenceHolder(savable));
      } else {
        var xobjects = this.Dictionary.items.getValue(this.dictionaryProperties.xObject);
        var parentXObjects = void 0;
        if (typeof this.pdfDocument !== "undefined") {
          parentXObjects = this.pdfDocument.sections.element.items.getValue(this.dictionaryProperties.resources).items.getValue(this.dictionaryProperties.xObject);
        }
        var values = this.Dictionary.items.values();
        var hasSameImageStream = false;
        var oldReference = void 0;
        if (typeof this.pdfDocument !== "undefined" && (typeof parentXObjects === void 0 || parentXObjects == null)) {
          parentXObjects = new PdfDictionary();
          this.pdfDocument.sections.element.items.getValue(this.dictionaryProperties.resources).items.setValue(this.dictionaryProperties.xObject, parentXObjects);
        } else if (typeof this.pdfDocument !== "undefined") {
          var values_1 = parentXObjects.items.values();
          for (var i = 0; i < values_1.length; i++) {
            if (typeof values_1[i] !== "undefined" && typeof values_1[i].element !== "undefined") {
              if (values_1[i].element.data[0] === arg1.element.data[0]) {
                oldReference = values_1[i];
                hasSameImageStream = true;
              }
            }
          }
        }
        if (xobjects == null) {
          xobjects = new PdfDictionary();
          this.Dictionary.items.setValue(this.dictionaryProperties.xObject, xobjects);
        }
        if (hasSameImageStream && typeof oldReference !== "undefined") {
          xobjects.items.setValue(arg2.value, oldReference);
        } else {
          var reference = new PdfReferenceHolder(arg1.element);
          xobjects.items.setValue(arg2.value, reference);
          if (typeof this.pdfDocument !== "undefined") {
            parentXObjects.items.setValue(arg2.value, reference);
          }
        }
      }
    };
    return PdfResources2;
  })(PdfDictionary)
);
var Guid = (
  /** @class */
  (function() {
    function Guid2() {
    }
    Guid2.getNewGuidString = function() {
      return "aaaaaaaa-aaaa-4aaa-baaa-aaaaaaaaaaaa".replace(/[ab]/g, function(c) {
        var random = Math.random() * 16 | 0;
        var result = c === "a" ? random : random & 3 | 8;
        return result.toString(16);
      });
    };
    return Guid2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-tiling-brush.js
var __extends32 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfTilingBrush = (
  /** @class */
  (function(_super) {
    __extends32(PdfTilingBrush2, _super);
    function PdfTilingBrush2(arg1, arg2) {
      var _this = _super.call(this) || this;
      _this.mStroking = false;
      _this.mLocation = new PointF(0, 0);
      _this.mDictionaryProperties = new DictionaryProperties();
      var rect = null;
      if (arg1 instanceof Rectangle) {
        rect = arg1;
      } else if (arg1 instanceof SizeF) {
        rect = new Rectangle(0, 0, arg1.width, arg1.height);
      }
      if (arg2 !== null && arg2 instanceof PdfPage) {
        _this.mPage = arg2;
      }
      _this.brushStream = new PdfStream();
      _this.mResources = new PdfResources();
      _this.brushStream.items.setValue(_this.mDictionaryProperties.resources, _this.mResources);
      _this.setBox(rect);
      _this.setObligatoryFields();
      if (arg2 !== null && arg2 instanceof PdfPage) {
        _this.mPage = arg2;
        _this.graphics.colorSpace = arg2.document.colorSpace;
      }
      return _this;
    }
    PdfTilingBrush2.prototype.initialize = function(rectangle, page, location2, matrix) {
      this.mPage = page;
      this.mLocation = location2;
      this.mTransformationMatrix = matrix;
      this.tempBrushStream = this.brushStream;
      this.brushStream = new PdfStream();
      var tempResource = new PdfResources();
      this.brushStream.items.setValue(this.mDictionaryProperties.resources, tempResource);
      this.setBox(rectangle);
      this.setObligatoryFields();
      return this;
    };
    Object.defineProperty(PdfTilingBrush2.prototype, "location", {
      //Properties
      /**
       * Location representing the start position of the tiles.
       * @public
       */
      get: function() {
        return this.mLocation;
      },
      set: function(value) {
        this.mLocation = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfTilingBrush2.prototype.setObligatoryFields = function() {
      this.brushStream.items.setValue(this.mDictionaryProperties.patternType, new PdfNumber(1));
      this.brushStream.items.setValue(this.mDictionaryProperties.paintType, new PdfNumber(1));
      this.brushStream.items.setValue(this.mDictionaryProperties.tilingType, new PdfNumber(1));
      this.brushStream.items.setValue(this.mDictionaryProperties.xStep, new PdfNumber(this.mBox.right - this.mBox.left));
      this.brushStream.items.setValue(this.mDictionaryProperties.yStep, new PdfNumber(this.mBox.bottom - this.mBox.top));
      if (this.mPage != null && this.mLocation != null) {
        if (this.mTransformationMatrix == null && typeof this.mTransformationMatrix === "undefined") {
          var tileTransform = this.mPage.size.height % this.rectangle.size.height - this.mLocation.y;
          this.brushStream.items.setValue(this.mDictionaryProperties.matrix, new PdfArray([1, 0, 0, 1, this.mLocation.x, tileTransform]));
        } else {
          var tileTransform = 0;
          var elements = this.mTransformationMatrix.matrix.elements;
          if (this.mPage.size.height > this.rectangle.size.height) {
            tileTransform = this.mTransformationMatrix.matrix.offsetY - this.mPage.size.height % this.rectangle.size.height;
          } else {
            tileTransform = this.mPage.size.height % this.rectangle.size.height + this.mTransformationMatrix.matrix.offsetY;
          }
          this.brushStream.items.setValue(this.mDictionaryProperties.matrix, new PdfArray([
            elements[0],
            elements[1],
            elements[2],
            elements[3],
            elements[4],
            tileTransform
          ]));
        }
      }
    };
    PdfTilingBrush2.prototype.setBox = function(box) {
      this.mBox = box;
      var rect = new RectangleF(this.mBox.left, this.mBox.top, this.mBox.right, this.mBox.bottom);
      this.brushStream.items.setValue(this.mDictionaryProperties.bBox, PdfArray.fromRectangle(rect));
    };
    Object.defineProperty(PdfTilingBrush2.prototype, "rectangle", {
      //Properties
      /**
       * Gets the boundary box of the smallest brush cell.
       * @public
       */
      get: function() {
        return this.mBox;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTilingBrush2.prototype, "size", {
      /**
       * Gets the size of the smallest brush cell.
       * @public
       */
      get: function() {
        return this.mBox.size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTilingBrush2.prototype, "graphics", {
      /**
       * Gets Graphics context of the brush.
       */
      get: function() {
        if (this.mGraphics == null && typeof this.mGraphics === "undefined") {
          var gr = new GetResourceEventHandler(this);
          var g = new PdfGraphics(this.size, gr, this.brushStream);
          this.mGraphics = g;
          this.mResources = this.getResources();
          this.mGraphics.initializeCoordinates();
        }
        return this.mGraphics;
      },
      enumerable: true,
      configurable: true
    });
    PdfTilingBrush2.prototype.getResources = function() {
      return this.mResources;
    };
    Object.defineProperty(PdfTilingBrush2.prototype, "stroking", {
      /**
       * Gets or sets a value indicating whether this PdfTilingBrush
       * is used for stroking operations.
       */
      get: function() {
        return this.mStroking;
      },
      set: function(value) {
        this.mStroking = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfTilingBrush2.prototype.clone = function() {
      var brush = this.initialize(this.rectangle, this.mPage, this.location, this.mTransformationMatrix);
      if (this.mTransformationMatrix != null && this.mTransformationMatrix.matrix != null) {
        brush.brushStream.items.setValue(this.mDictionaryProperties.matrix, new PdfArray(this.mTransformationMatrix.matrix.elements));
      }
      brush.brushStream.data = this.tempBrushStream.data;
      brush.mResources = new PdfResources(this.mResources);
      brush.brushStream.items.setValue(this.mDictionaryProperties.resources, brush.mResources);
      return brush;
    };
    PdfTilingBrush2.prototype.monitorChanges = function(brush, streamWriter, getResources, saveChanges, currentColorSpace) {
      var diff = false;
      if (brush !== this) {
        streamWriter.setColorSpace("Pattern", this.mStroking);
        var resources1 = getResources.getResources();
        var name1 = resources1.getName(this);
        streamWriter.setColourWithPattern(null, name1, this.mStroking);
        diff = true;
      } else if (brush instanceof PdfTilingBrush2) {
        streamWriter.setColorSpace("Pattern", this.mStroking);
        var resources = getResources.getResources();
        var name_1 = resources.getName(this);
        streamWriter.setColourWithPattern(null, name_1, this.mStroking);
        diff = true;
      }
      return diff;
    };
    PdfTilingBrush2.prototype.resetChanges = function(streamWriter) {
    };
    Object.defineProperty(PdfTilingBrush2.prototype, "element", {
      /* tslint:enable */
      // IPdfWrapper Members
      /**
       * Gets the `element`.
       * @public
       */
      get: function() {
        return this.brushStream;
      },
      enumerable: true,
      configurable: true
    });
    return PdfTilingBrush2;
  })(PdfBrush)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/pdf-graphics.js
var PdfGraphics = (
  /** @class */
  (function() {
    function PdfGraphics2(arg1, arg2, arg3) {
      this.currentColorSpace = PdfColorSpace.Rgb;
      this.previousTextRenderingMode = TextRenderingMode.Fill;
      this.previousCharacterSpacing = 0;
      this.previousWordSpacing = 0;
      this.previousTextScaling = 100;
      this.procedureSets = new ProcedureSets();
      this.isNormalRender = true;
      this.isUseFontSize = false;
      this.isItalic = false;
      this.isEmfTextScaled = false;
      this.isEmf = false;
      this.isEmfPlus = false;
      this.isBaselineFormat = true;
      this.emfScalingFactor = new SizeF(0, 0);
      this.colorSpaceChanged = false;
      this.dictionaryProperties = new DictionaryProperties();
      this.isOverloadWithPosition = false;
      this.isPointOverload = false;
      this.currentColorSpaces = ["RGB", "CMYK", "GrayScale", "Indexed"];
      this.isImageOptimized = false;
      this.graphicsState = [];
      this.istransparencySet = false;
      this.internalAutomaticFields = null;
      this.startCutIndex = -1;
      this.getResources = arg2;
      this.canvasSize = arg1;
      if (arg3 instanceof PdfStreamWriter) {
        this.pdfStreamWriter = arg3;
      } else {
        this.pdfStreamWriter = new PdfStreamWriter(arg3);
      }
      this.initialize();
    }
    Object.defineProperty(PdfGraphics2.prototype, "stringLayoutResult", {
      //  Properties
      /**
       * Returns the `result` after drawing string.
       * @private
       */
      get: function() {
        return this.pdfStringLayoutResult;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "size", {
      /**
       * Gets the `size` of the canvas.
       * @private
       */
      get: function() {
        return this.canvasSize;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "mediaBoxUpperRightBound", {
      /**
       * Gets and Sets the value of `MediaBox upper right bound`.
       * @private
       */
      get: function() {
        if (typeof this.internalMediaBoxUpperRightBound === "undefined") {
          this.internalMediaBoxUpperRightBound = 0;
        }
        return this.internalMediaBoxUpperRightBound;
      },
      set: function(value) {
        this.internalMediaBoxUpperRightBound = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "clientSize", {
      /**
       * Gets the `size` of the canvas reduced by margins and page templates.
       * @private
       */
      get: function() {
        return new SizeF(this.clipBounds.width, this.clipBounds.height);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "colorSpace", {
      /**
       * Gets or sets the current `color space` of the document
       * @private
       */
      get: function() {
        return this.currentColorSpace;
      },
      set: function(value) {
        this.currentColorSpace = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "streamWriter", {
      /**
       * Gets the `stream writer`.
       * @private
       */
      get: function() {
        return this.pdfStreamWriter;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "matrix", {
      /**
       * Gets the `transformation matrix` reflecting current transformation.
       * @private
       */
      get: function() {
        if (this.transformationMatrix == null) {
          this.transformationMatrix = new PdfTransformationMatrix();
        }
        return this.transformationMatrix;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "layer", {
      /**
       * Gets the `layer` for the graphics, if exists.
       * @private
       */
      get: function() {
        return this.pageLayer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "page", {
      /**
       * Gets the `page` for this graphics, if exists.
       * @private
       */
      get: function() {
        return this.pageLayer.page;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphics2.prototype, "automaticFields", {
      get: function() {
        if (this.internalAutomaticFields == null || typeof this.internalAutomaticFields === "undefined") {
          this.internalAutomaticFields = new PdfAutomaticFieldInfoCollection();
        }
        return this.internalAutomaticFields;
      },
      enumerable: true,
      configurable: true
    });
    PdfGraphics2.prototype.initialize = function() {
      this.bStateSaved = false;
      this.currentPen = null;
      this.currentBrush = null;
      this.currentFont = null;
      this.currentColorSpace = PdfColorSpace.Rgb;
      this.bCSInitialized = false;
      this.transformationMatrix = null;
      this.previousTextRenderingMode = -1;
      this.previousCharacterSpacing = -1;
      this.previousWordSpacing = -1;
      this.previousTextScaling = -100;
      this.currentStringFormat = null;
      this.clipBounds = new RectangleF(new PointF(0, 0), this.size);
      this.getResources.getResources().requireProcedureSet(this.procedureSets.pdf);
    };
    PdfGraphics2.prototype.drawPdfTemplate = function(template, location2, size) {
      if (typeof size === "undefined") {
        if (template == null) {
          throw Error("ArgumentNullException-template");
        }
        this.drawPdfTemplate(template, location2, template.size);
      } else {
        if (template == null) {
          throw Error("ArgumentNullException-template");
        }
        var scaleX = template.width > 0 ? size.width / template.width : 1;
        var scaleY = template.height > 0 ? size.height / template.height : 1;
        var bNeedScale = !(scaleX === 1 && scaleY === 1);
        var state = this.save();
        var matrix = new PdfTransformationMatrix();
        if (this.pageLayer != null) {
          this.getTranslateTransform(location2.x, location2.y + size.height, matrix);
        }
        if (bNeedScale) {
          this.getScaleTransform(scaleX, scaleY, matrix);
        }
        this.pdfStreamWriter.modifyCtm(matrix);
        var resources = this.getResources.getResources();
        var name_1 = resources.getName(template);
        this.pdfStreamWriter.executeObject(name_1);
        this.restore(state);
        var g = template.graphics;
        if (g != null) {
          for (var index = 0; index < g.automaticFields.automaticFields.length; index++) {
            var fieldInfo = g.automaticFields.automaticFields[index];
            var newLocation = new PointF(fieldInfo.location.x + location2.x, fieldInfo.location.y + location2.y);
            var scalingX = template.size.width == 0 ? 0 : size.width / template.size.width;
            var scalingY = template.size.height == 0 ? 0 : size.height / template.size.height;
            this.automaticFields.add(new PdfAutomaticFieldInfo(fieldInfo.field, newLocation, scalingX, scalingY));
            this.page.dictionary.modify();
          }
        }
        this.getResources.getResources().requireProcedureSet(this.procedureSets.imageB);
        this.getResources.getResources().requireProcedureSet(this.procedureSets.imageC);
        this.getResources.getResources().requireProcedureSet(this.procedureSets.imageI);
        this.getResources.getResources().requireProcedureSet(this.procedureSets.text);
      }
    };
    PdfGraphics2.prototype.drawString = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
      if (typeof arg1 === "string" && arg2 instanceof PdfFont && (arg3 instanceof PdfPen || arg3 === null) && (arg4 instanceof PdfBrush || arg4 === null) && typeof arg5 === "number" && typeof arg6 === "number" && (arg7 instanceof PdfStringFormat || arg7 === null) && typeof arg8 === "undefined") {
        this.isOverloadWithPosition = true;
        this.drawString(arg1, arg2, arg3, arg4, arg5, arg6, this.clientSize.width - arg5, 0, arg7);
      } else {
        var temparg3 = arg3;
        var temparg4 = arg4;
        var temparg5 = arg5;
        var temparg6 = arg6;
        var temparg7 = arg7;
        var temparg8 = arg8;
        var temparg9 = arg9;
        var layouter = new PdfStringLayouter();
        var result = layouter.layout(arg1, arg2, temparg9, new SizeF(temparg7, temparg8), this.isOverloadWithPosition, this.clientSize);
        if (!result.empty) {
          var rect = this.checkCorrectLayoutRectangle(result.actualSize, temparg5, temparg6, temparg9);
          if (temparg7 <= 0) {
            temparg5 = rect.x;
            temparg7 = rect.width;
          }
          if (temparg8 <= 0) {
            temparg6 = rect.y;
            temparg8 = rect.height;
          }
          this.drawStringLayoutResult(result, arg2, temparg3, temparg4, new RectangleF(temparg5, temparg6, temparg7, temparg8), temparg9);
          this.isEmfTextScaled = false;
          this.emfScalingFactor = new SizeF(0, 0);
        }
        this.getResources.getResources().requireProcedureSet(this.procedureSets.text);
        this.isNormalRender = true;
        this.pdfStringLayoutResult = result;
        this.isUseFontSize = false;
      }
    };
    PdfGraphics2.prototype.drawLine = function(arg1, arg2, arg3, arg4, arg5) {
      if (arg2 instanceof PointF) {
        var temparg2 = arg2;
        var temparg3 = arg3;
        this.drawLine(arg1, temparg2.x, temparg2.y, temparg3.x, temparg3.y);
      } else {
        var temparg2 = arg2;
        var temparg3 = arg3;
        var temparg4 = arg4;
        var temparg5 = arg5;
        this.stateControl(arg1, null, null);
        var sw = this.streamWriter;
        sw.beginPath(temparg2, temparg3);
        sw.appendLineSegment(temparg4, temparg5);
        sw.strokePath();
        this.getResources.getResources().requireProcedureSet(this.procedureSets.pdf);
      }
    };
    PdfGraphics2.prototype.drawRectangle = function(arg1, arg2, arg3, arg4, arg5, arg6) {
      if (arg1 instanceof PdfPen && typeof arg2 === "number") {
        var temparg3 = arg3;
        this.drawRectangle(arg1, null, arg2, temparg3, arg4, arg5);
      } else if (arg1 instanceof PdfBrush && typeof arg2 === "number") {
        var temparg3 = arg3;
        this.drawRectangle(null, arg1, arg2, temparg3, arg4, arg5);
      } else {
        var temparg3 = arg3;
        var temparg4 = arg4;
        var temparg5 = arg5;
        var temparg6 = arg6;
        if (arg2 instanceof PdfTilingBrush) {
          this.bCSInitialized = false;
          var xOffset = this.matrix.matrix.offsetX + temparg3;
          var yOffset = void 0;
          if (this.layer != null && this.layer.page != null) {
            yOffset = this.layer.page.size.height - this.matrix.matrix.offsetY + temparg4;
          } else {
            yOffset = this.clientSize.height - this.matrix.matrix.offsetY + temparg4;
          }
          arg2.location = new PointF(xOffset, yOffset);
          arg2.graphics.colorSpace = this.colorSpace;
        } else if (arg2 instanceof PdfGradientBrush) {
          arg2.colorSpace = this.colorSpace;
        }
        if (arg2 instanceof PdfSolidBrush && arg2.color.isEmpty) {
          arg2 = null;
        }
        var temparg1 = arg1;
        var temparg2 = arg2;
        this.stateControl(temparg1, temparg2, null);
        this.streamWriter.appendRectangle(temparg3, temparg4, temparg5, temparg6);
        this.drawPathHelper(temparg1, temparg2, false);
      }
    };
    PdfGraphics2.prototype.drawRoundedRectangle = function(pen, brush, x, y, width, height, radius) {
      if (pen === null) {
        throw new Error("pen");
      }
      if (brush === null) {
        throw new Error("brush");
      }
      if (radius === 0) {
        this.drawRectangle(pen, brush, x, y, width, height);
      } else {
        var bounds = [x, y, width, height];
        var diameter = radius * 2;
        var size = [diameter, diameter];
        var arc = [bounds[0], bounds[1], size[0], size[1]];
        this._pathPoints = [];
        this._pathTypes = [];
        var startFigure = true;
        startFigure = this._addArc(arc[0], arc[1], arc[2], arc[3], 180, 90, startFigure);
        arc[0] = bounds[0] + bounds[2] - diameter;
        startFigure = this._addArc(arc[0], arc[1], arc[2], arc[3], 270, 90, startFigure);
        arc[1] = bounds[1] + bounds[3] - diameter;
        startFigure = this._addArc(arc[0], arc[1], arc[2], arc[3], 0, 90, startFigure);
        arc[0] = bounds[0];
        startFigure = this._addArc(arc[0], arc[1], arc[2], arc[3], 90, 90, startFigure);
        var index = this._pathPoints.length - 1;
        var type = this._pathTypes[index];
        type = type | PathPointType.CloseSubpath;
        this._pathTypes[index] = type;
        this._drawPath(pen, brush, this._pathPoints, this._pathTypes, PdfFillMode.Alternate);
        this._pathPoints = [];
        this._pathTypes = [];
      }
    };
    PdfGraphics2.prototype._addArc = function(x, y, width, height, startAngle, sweepAngle, startFigure) {
      var points = this._getBezierArcPoints(x, y, x + width, y + height, startAngle, sweepAngle);
      for (var i = 0; i < points.length; i = i + 8) {
        var point = [points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5], points[i + 6], points[i + 7]];
        startFigure = this._addArcPoints(point, PathPointType.Bezier3, startFigure);
      }
      return startFigure;
    };
    PdfGraphics2.prototype._addArcPoints = function(points, pointType, startFigure) {
      for (var i = 0; i < points.length; i++) {
        var point = new PointF(points[i], points[i + 1]);
        if (i === 0) {
          if (this._pathPoints.length === 0 || startFigure) {
            this._addPoint(point, PathPointType.Start);
            startFigure = false;
          } else if (point.x !== this._getLastPoint().x || point.y !== this._getLastPoint().y) {
            this._addPoint(point, PathPointType.Line);
          }
        } else {
          this._addPoint(point, pointType);
        }
        i++;
      }
      return startFigure;
    };
    PdfGraphics2.prototype._getLastPoint = function() {
      var lastPoint = new PointF(0, 0);
      var count = this._pathPoints.length;
      if (count > 0) {
        lastPoint.x = this._pathPoints[count - 1].x;
        lastPoint.y = this._pathPoints[count - 1].y;
      }
      return lastPoint;
    };
    PdfGraphics2.prototype._addPoint = function(point, type) {
      this._pathPoints.push(point);
      this._pathTypes.push(type);
    };
    PdfGraphics2.prototype._getBezierArcPoints = function(x1, y1, x2, y2, s1, e1) {
      if (x1 > x2) {
        var tmp = void 0;
        tmp = x1;
        x1 = x2;
        x2 = tmp;
      }
      if (y2 > y1) {
        var tmp = void 0;
        tmp = y1;
        y1 = y2;
        y2 = tmp;
      }
      var fragAngle;
      var numFragments;
      if (Math.abs(e1) <= 90) {
        fragAngle = e1;
        numFragments = 1;
      } else {
        numFragments = Math.ceil(Math.abs(e1) / 90);
        fragAngle = e1 / numFragments;
      }
      var xcen = (x1 + x2) / 2;
      var ycen = (y1 + y2) / 2;
      var rx = (x2 - x1) / 2;
      var ry = (y2 - y1) / 2;
      var halfAng = fragAngle * (Math.PI / 360);
      var kappa = Math.abs(4 / 3 * (1 - Math.cos(halfAng)) / Math.sin(halfAng));
      var pointList = [];
      for (var i = 0; i < numFragments; i++) {
        var theta0 = (s1 + i * fragAngle) * (Math.PI / 180);
        var theta1 = (s1 + (i + 1) * fragAngle) * (Math.PI / 180);
        var cos0 = Math.cos(theta0);
        var cos1 = Math.cos(theta1);
        var sin0 = Math.sin(theta0);
        var sin1 = Math.sin(theta1);
        if (fragAngle > 0) {
          pointList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 - kappa * sin0), ycen - ry * (sin0 + kappa * cos0), xcen + rx * (cos1 + kappa * sin1), ycen - ry * (sin1 - kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);
        } else {
          pointList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 + kappa * sin0), ycen - ry * (sin0 - kappa * cos0), xcen + rx * (cos1 - kappa * sin1), ycen - ry * (sin1 + kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);
        }
      }
      return pointList;
    };
    PdfGraphics2.prototype.drawPathHelper = function(arg1, arg2, arg3, arg4) {
      if (typeof arg3 === "boolean") {
        var temparg3 = arg3;
        this.drawPathHelper(arg1, arg2, PdfFillMode.Winding, temparg3);
      } else {
        var temparg3 = arg3;
        var temparg4 = arg4;
        var isPen = arg1 != null;
        var isBrush = arg2 != null;
        var isEvenOdd = temparg3 === PdfFillMode.Alternate;
        if (isPen && isBrush) {
          this.streamWriter.fillStrokePath(isEvenOdd);
        } else if (!isPen && !isBrush) {
          this.streamWriter.endPath();
        } else if (isPen) {
          this.streamWriter.strokePath();
        } else {
          this.streamWriter.fillPath(isEvenOdd);
        }
      }
    };
    PdfGraphics2.prototype.drawImage = function(arg1, arg2, arg3, arg4, arg5) {
      if (typeof arg2 === "number" && typeof arg3 === "number" && typeof arg4 === "undefined") {
        var size = arg1.physicalDimension;
        this.drawImage(arg1, arg2, arg3, size.width, size.height);
      } else {
        var temparg2 = arg2;
        var temparg3 = arg3;
        var temparg4 = arg4;
        var temparg5 = arg5;
        arg1.save();
        var matrix = new PdfTransformationMatrix();
        this.getTranslateTransform(temparg2, temparg3 + temparg5, matrix);
        this.getScaleTransform(arg4, arg5, matrix);
        this.pdfStreamWriter.write("q");
        this.pdfStreamWriter.modifyCtm(matrix);
        var resources = this.getResources.getResources();
        if (typeof this.pageLayer !== "undefined" && this.page != null) {
          resources.document = this.page.document;
        }
        var name_2 = resources.getName(arg1);
        if (typeof this.pageLayer !== "undefined") {
          this.page.setResources(resources);
        }
        this.pdfStreamWriter.executeObject(name_2);
        this.pdfStreamWriter.write(Operators.restoreState);
        this.pdfStreamWriter.write(Operators.newLine);
        var resource = this.getResources.getResources();
        resource.requireProcedureSet(this.procedureSets.imageB);
        resource.requireProcedureSet(this.procedureSets.imageC);
        resource.requireProcedureSet(this.procedureSets.imageI);
        resource.requireProcedureSet(this.procedureSets.text);
      }
    };
    PdfGraphics2.prototype.getLineBounds = function(lineIndex, result, font, layoutRectangle, format) {
      var bounds;
      if (!result.empty && lineIndex < result.lineCount && lineIndex >= 0) {
        var line = result.lines[lineIndex];
        var vShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);
        var y = vShift + layoutRectangle.y + result.lineHeight * lineIndex;
        var lineWidth = line.width;
        var hShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);
        var lineIndent = this.getLineIndent(line, format, layoutRectangle, lineIndex === 0);
        hShift += !this.rightToLeft(format) ? lineIndent : 0;
        var x = layoutRectangle.x + hShift;
        var width = !this.shouldJustify(line, layoutRectangle.width, format) ? lineWidth - lineIndent : layoutRectangle.width - lineIndent;
        var height = result.lineHeight;
        bounds = new RectangleF(x, y, width, height);
      } else {
        bounds = new RectangleF(0, 0, 0, 0);
      }
      return bounds;
    };
    PdfGraphics2.prototype.checkCorrectLayoutRectangle = function(textSize, x, y, format) {
      var layoutedRectangle = new RectangleF(x, y, textSize.width, textSize.width);
      if (format != null) {
        switch (format.alignment) {
          case PdfTextAlignment.Center:
            layoutedRectangle.x -= layoutedRectangle.width / 2;
            break;
          case PdfTextAlignment.Right:
            layoutedRectangle.x -= layoutedRectangle.width;
            break;
        }
        switch (format.lineAlignment) {
          case PdfVerticalAlignment.Middle:
            layoutedRectangle.y -= layoutedRectangle.height / 2;
            break;
          case PdfVerticalAlignment.Bottom:
            layoutedRectangle.y -= layoutedRectangle.height;
            break;
        }
      }
      return layoutedRectangle;
    };
    PdfGraphics2.prototype.setLayer = function(layer) {
      this.pageLayer = layer;
      var page = layer.page;
      if (page != null && typeof page !== "undefined") {
        page.beginSave = this.pageSave;
      }
    };
    PdfGraphics2.prototype.pageSave = function(page) {
      if (page.graphics.automaticFields != null) {
        for (var i = 0; i < page.graphics.automaticFields.automaticFields.length; i++) {
          var fieldInfo = page.graphics.automaticFields.automaticFields[i];
          fieldInfo.field.performDraw(page.graphics, fieldInfo.location, fieldInfo.scalingX, fieldInfo.scalingY);
        }
      }
    };
    PdfGraphics2.prototype.drawStringLayoutResult = function(result, font, pen, brush, layoutRectangle, format) {
      if (!result.empty) {
        this.applyStringSettings(font, pen, brush, format, layoutRectangle);
        var textScaling = format != null ? format.horizontalScalingFactor : 100;
        if (textScaling !== this.previousTextScaling && !this.isEmfTextScaled) {
          this.pdfStreamWriter.setTextScaling(textScaling);
          this.previousTextScaling = textScaling;
        }
        var height = format == null || format.lineSpacing === 0 ? font.height : format.lineSpacing + font.height;
        var subScript = format != null && format.subSuperScript === PdfSubSuperScript.SubScript;
        var shift = 0;
        shift = subScript ? height - (font.height + font.metrics.getDescent(format)) : height - font.metrics.getAscent(format);
        this.shift = shift;
        this.pdfStreamWriter.startNextLine(layoutRectangle.x, layoutRectangle.y - shift);
        this.pdfStreamWriter.setLeading(+height);
        var resultHeight = 0;
        var remainingString = "";
        for (var i = 0; i < result.lines.length; i++) {
          resultHeight += result.lineHeight;
          if (layoutRectangle.y + resultHeight > this.clientSize.height) {
            this.startCutIndex = i;
            break;
          }
        }
        for (var j = this.startCutIndex; j < result.lines.length && j >= 0; j++) {
          remainingString += result.lines[j].text;
        }
        var bounds = new RectangleF(layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height);
        this.drawLayoutResult(result, font, format, layoutRectangle);
        this.underlineStrikeoutText(pen, brush, result, font, bounds, format);
        this.isEmfPlus = false;
        this.isUseFontSize = false;
        if (this.startCutIndex !== -1) {
          var page = this.getNextPage();
          page.graphics.drawString(remainingString, font, pen, brush, layoutRectangle.x, 0, layoutRectangle.width, 0, format);
        }
      } else {
        throw new Error("ArgumentNullException:result");
      }
    };
    PdfGraphics2.prototype.getNextPage = function() {
      var section = this.currentPage.section;
      var nextPage = null;
      var index = section.indexOf(this.currentPage);
      if (index === section.count - 1) {
        nextPage = section.add();
      } else {
        nextPage = section.getPages()[index + 1];
      }
      return nextPage;
    };
    PdfGraphics2.prototype.setClip = function(rectangle, mode) {
      if (typeof mode === "undefined") {
        this.setClip(rectangle, PdfFillMode.Winding);
      } else {
        this.pdfStreamWriter.appendRectangle(rectangle);
        this.pdfStreamWriter.clipPath(mode === PdfFillMode.Alternate);
      }
    };
    PdfGraphics2.prototype.applyStringSettings = function(font, pen, brush, format, bounds) {
      if (brush instanceof PdfTilingBrush) {
        this.bCSInitialized = false;
        brush.graphics.colorSpace = this.colorSpace;
      } else if (brush instanceof PdfGradientBrush) {
        this.bCSInitialized = false;
        brush.colorSpace = this.colorSpace;
      }
      var setLineWidth = false;
      var tm = this.getTextRenderingMode(pen, brush, format);
      this.stateControl(pen, brush, font, format);
      this.pdfStreamWriter.beginText();
      if (tm !== this.previousTextRenderingMode) {
        this.pdfStreamWriter.setTextRenderingMode(tm);
        this.previousTextRenderingMode = tm;
      }
      var cs = format != null ? format.characterSpacing : 0;
      if (cs !== this.previousCharacterSpacing && !this.isEmfTextScaled) {
        this.pdfStreamWriter.setCharacterSpacing(cs);
        this.previousCharacterSpacing = cs;
      }
      var ws = format != null ? format.wordSpacing : 0;
      if (ws !== this.previousWordSpacing) {
        this.pdfStreamWriter.setWordSpacing(ws);
        this.previousWordSpacing = ws;
      }
    };
    PdfGraphics2.prototype.getTextVerticalAlignShift = function(textHeight, boundsHeight, format) {
      var shift = 0;
      if (boundsHeight >= 0 && format != null && format.lineAlignment !== PdfVerticalAlignment.Top) {
        switch (format.lineAlignment) {
          case PdfVerticalAlignment.Middle:
            shift = (boundsHeight - textHeight) / 2;
            break;
          case PdfVerticalAlignment.Bottom:
            shift = boundsHeight - textHeight;
            break;
        }
      }
      return shift;
    };
    PdfGraphics2.prototype.drawLayoutResult = function(result, font, format, layoutRectangle) {
      var vAlignShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);
      if (vAlignShift !== 0) {
        this.pdfStreamWriter.startNextLine(0, vAlignShift);
      }
      var ttfFont = font;
      var unicode = ttfFont != null && ttfFont.isUnicode;
      var embed = ttfFont != null && ttfFont.isEmbedFont;
      var lines = result.lines;
      for (var i = 0, len = lines.length; i < len && i !== this.startCutIndex; i++) {
        var lineInfo = lines[i];
        var line = lineInfo.text;
        var lineWidth = lineInfo.width;
        var hAlignShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);
        var lineIndent = this.getLineIndent(lineInfo, format, layoutRectangle, i === 0);
        hAlignShift += !this.rightToLeft(format) ? lineIndent : 0;
        if (hAlignShift !== 0 && !this.isEmfTextScaled) {
          this.pdfStreamWriter.startNextLine(hAlignShift, 0);
        }
        if (unicode) {
          this.drawUnicodeLine(lineInfo, layoutRectangle, font, format);
        } else {
          this.drawAsciiLine(lineInfo, layoutRectangle, font, format);
        }
        if (hAlignShift !== 0 && !this.isEmfTextScaled) {
          this.pdfStreamWriter.startNextLine(-hAlignShift, 0);
        }
        if (this.isOverloadWithPosition && lines.length > 1) {
          this.pdfStreamWriter.startNextLine(-layoutRectangle.x, 0);
          layoutRectangle.x = 0;
          layoutRectangle.width = this.clientSize.width;
          this.isOverloadWithPosition = false;
          this.isPointOverload = true;
        } else if (this.isOverloadWithPosition) {
          this.isOverloadWithPosition = false;
        }
      }
      this.getResources.getResources().requireProcedureSet(this.procedureSets.text);
      if (vAlignShift !== 0) {
        this.pdfStreamWriter.startNextLine(0, -(vAlignShift - result.lineHeight));
      }
      this.pdfStreamWriter.endText();
    };
    PdfGraphics2.prototype.drawAsciiLine = function(lineInfo, layoutRectangle, font, format) {
      this.justifyLine(lineInfo, layoutRectangle.width, format);
      var value = "";
      if (lineInfo.text.indexOf("(") !== -1 || lineInfo.text.indexOf(")") !== -1) {
        for (var i = 0; i < lineInfo.text.length; i++) {
          if (lineInfo.text[i] === "(") {
            value += "\\(";
          } else if (lineInfo.text[i] === ")") {
            value += "\\)";
          } else {
            value += lineInfo.text[i];
          }
        }
      }
      if (value === "") {
        value = lineInfo.text;
      }
      var line = "(" + value + ")";
      this.pdfStreamWriter.showNextLineText(new PdfString(line));
    };
    PdfGraphics2.prototype.drawUnicodeLine = function(lineInfo, layoutRectangle, font, format) {
      var line = lineInfo.text;
      var lineWidth = lineInfo.width;
      var rtl = format !== null && typeof format !== "undefined" && format.rightToLeft;
      var useWordSpace = format !== null && typeof format !== "undefined" && (format.wordSpacing !== 0 || format.alignment === PdfTextAlignment.Justify);
      var ttfFont = font;
      var wordSpacing = this.justifyLine(lineInfo, layoutRectangle.width, format);
      var rtlRender = new RtlRenderer();
      if (rtl || format !== null && typeof format !== "undefined" && format.textDirection !== PdfTextDirection.None) {
        var blocks = null;
        var rightAlign = format !== null && typeof format !== "undefined" && format.alignment === PdfTextAlignment.Right;
        if (format !== null && typeof format !== "undefined" && format.textDirection !== PdfTextDirection.None) {
          blocks = rtlRender.layout(line, ttfFont, format.textDirection === PdfTextDirection.RightToLeft ? true : false, useWordSpace, format);
        } else {
          blocks = rtlRender.layout(line, ttfFont, rightAlign, useWordSpace, format);
        }
        var words = null;
        if (blocks.length > 1) {
          if (format !== null && typeof format !== "undefined" && format.textDirection !== PdfTextDirection.None) {
            words = rtlRender.splitLayout(line, ttfFont, format.textDirection === PdfTextDirection.RightToLeft ? true : false, useWordSpace, format);
          } else {
            words = rtlRender.splitLayout(line, ttfFont, rightAlign, useWordSpace, format);
          }
        } else {
          words = [line];
        }
        this.drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);
      } else {
        if (useWordSpace) {
          var result = this.breakUnicodeLine(line, ttfFont, null);
          var blocks = result.tokens;
          var words = result.words;
          this.drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);
        } else {
          var token = this.convertToUnicode(line, ttfFont);
          var value = this.getUnicodeString(token);
          this.streamWriter.showNextLineText(value);
        }
      }
    };
    PdfGraphics2.prototype.drawUnicodeBlocks = function(blocks, words, font, format, wordSpacing) {
      if (blocks == null) {
        throw new Error("Argument Null Exception : blocks");
      }
      if (words == null) {
        throw new Error("Argument Null Exception : words");
      }
      if (font == null) {
        throw new Error("Argument Null Exception : font");
      }
      this.streamWriter.startNextLine();
      var x = 0;
      var xShift = 0;
      var firstLineIndent = 0;
      var paragraphIndent = 0;
      try {
        if (format !== null && typeof format !== "undefined") {
          firstLineIndent = format.firstLineIndent;
          paragraphIndent = format.paragraphIndent;
          format.firstLineIndent = 0;
          format.paragraphIndent = 0;
        }
        var spaceWidth = font.getCharWidth(StringTokenizer.whiteSpace, format) + wordSpacing;
        var characterSpacing = format != null ? format.characterSpacing : 0;
        var wordSpace = format !== null && typeof format !== "undefined" && wordSpacing === 0 ? format.wordSpacing : 0;
        spaceWidth += characterSpacing + wordSpace;
        for (var i = 0; i < blocks.length; i++) {
          var token = blocks[i];
          var word = words[i];
          var tokenWidth = 0;
          if (x !== 0) {
            this.streamWriter.startNextLine(x, 0);
          }
          if (word.length > 0) {
            tokenWidth += /*Utils.Round(*/
            font.measureString(word, format).width;
            tokenWidth += characterSpacing;
            var val = this.getUnicodeString(token);
            this.streamWriter.showText(val);
          }
          if (i !== blocks.length - 1) {
            x = tokenWidth + spaceWidth;
            xShift += x;
          }
        }
        if (xShift > 0) {
          this.streamWriter.startNextLine(-xShift, 0);
        }
      } finally {
        if (format !== null && typeof format !== "undefined") {
          format.firstLineIndent = firstLineIndent;
          format.paragraphIndent = paragraphIndent;
        }
      }
    };
    PdfGraphics2.prototype.breakUnicodeLine = function(line, ttfFont, words) {
      if (line === null) {
        throw new Error("Argument Null Exception : line");
      }
      words = line.split(null);
      var tokens = [];
      for (var i = 0; i < words.length; i++) {
        var word = words[i];
        var token = this.convertToUnicode(word, ttfFont);
        tokens[i] = token;
      }
      return { tokens, words };
    };
    PdfGraphics2.prototype.getUnicodeString = function(token) {
      if (token === null) {
        throw new Error("Argument Null Exception : token");
      }
      var val = new PdfString(token);
      val.converted = true;
      val.encode = InternalEnum.ForceEncoding.Ascii;
      return val;
    };
    PdfGraphics2.prototype.convertToUnicode = function(text, ttfFont) {
      var token = null;
      if (text == null) {
        throw new Error("Argument Null Exception : text");
      }
      if (ttfFont == null) {
        throw new Error("Argument Null Exception : ttfFont");
      }
      if (ttfFont.fontInternal instanceof UnicodeTrueTypeFont) {
        var ttfReader = ttfFont.fontInternal.ttfReader;
        ttfFont.setSymbols(text);
        token = ttfReader.convertString(text);
        var bytes = PdfString.toUnicodeArray(token, false);
        token = PdfString.byteToString(bytes);
      }
      return token;
    };
    PdfGraphics2.prototype.justifyLine = function(lineInfo, boundsWidth, format) {
      var line = lineInfo.text;
      var lineWidth = lineInfo.width;
      var shouldJustify = this.shouldJustify(lineInfo, boundsWidth, format);
      var hasWordSpacing = format != null && format.wordSpacing !== 0;
      var symbols = StringTokenizer.spaces;
      var whitespacesCount = StringTokenizer.getCharsCount(line, symbols);
      var wordSpace = 0;
      if (shouldJustify) {
        if (hasWordSpacing) {
          lineWidth -= whitespacesCount * format.wordSpacing;
        }
        var difference = boundsWidth - lineWidth;
        wordSpace = difference / whitespacesCount;
        this.pdfStreamWriter.setWordSpacing(wordSpace);
      } else {
        if (hasWordSpacing) {
          this.pdfStreamWriter.setWordSpacing(format.wordSpacing);
        } else {
          this.pdfStreamWriter.setWordSpacing(0);
        }
      }
      return wordSpace;
    };
    PdfGraphics2.prototype.reset = function(size) {
      this.canvasSize = size;
      this.streamWriter.clear();
      this.initialize();
      this.initializeCoordinates();
    };
    PdfGraphics2.prototype.shouldJustify = function(lineInfo, boundsWidth, format) {
      var line = lineInfo.text;
      var lineWidth = lineInfo.width;
      var justifyStyle = format != null && format.alignment === PdfTextAlignment.Justify;
      var goodWidth = boundsWidth >= 0 && lineWidth < boundsWidth;
      var symbols = StringTokenizer.spaces;
      var whitespacesCount = StringTokenizer.getCharsCount(line, symbols);
      var hasSpaces = whitespacesCount > 0 && line[0] !== StringTokenizer.whiteSpace;
      var goodLineBreakStyle = (lineInfo.lineType & LineType.LayoutBreak) > 0 || format && format.wordWrap === PdfWordWrapType.None;
      var shouldJustify = justifyStyle && goodWidth && hasSpaces && goodLineBreakStyle;
      return shouldJustify;
    };
    PdfGraphics2.prototype.underlineStrikeoutText = function(pen, brush, result, font, layoutRectangle, format) {
      if (font.underline || font.strikeout) {
        var linePen = this.createUnderlineStikeoutPen(pen, brush, font, format);
        if (linePen != null) {
          var vShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);
          var underlineYOffset = 0;
          underlineYOffset = layoutRectangle.y + vShift + font.metrics.getAscent(format) + 1.5 * linePen.width;
          var strikeoutYOffset = layoutRectangle.y + vShift + font.metrics.getHeight(format) / 2 + 1.5 * linePen.width;
          var lines = result.lines;
          for (var i = 0, len = result.lineCount; i < len; i++) {
            var lineInfo = lines[i];
            var line = lineInfo.text;
            var lineWidth = lineInfo.width;
            var hShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);
            var lineIndent = this.getLineIndent(lineInfo, format, layoutRectangle, i === 0);
            hShift += !this.rightToLeft(format) ? lineIndent : 0;
            var x1 = layoutRectangle.x + hShift;
            var x2 = !this.shouldJustify(lineInfo, layoutRectangle.width, format) ? x1 + lineWidth - lineIndent : x1 + layoutRectangle.width - lineIndent;
            if (font.underline) {
              var y = underlineYOffset;
              this.drawLine(linePen, x1, y, x2, y);
              underlineYOffset += result.lineHeight;
            }
            if (font.strikeout) {
              var y = strikeoutYOffset;
              this.drawLine(linePen, x1, y, x2, y);
              strikeoutYOffset += result.lineHeight;
            }
            if (this.isPointOverload && lines.length > 1) {
              layoutRectangle.x = 0;
              layoutRectangle.width = this.clientSize.width;
            }
          }
          this.isPointOverload = false;
        }
      }
    };
    PdfGraphics2.prototype.createUnderlineStikeoutPen = function(pen, brush, font, format) {
      var lineWidth = font.metrics.getSize(format) / 20;
      var linePen = null;
      if (pen != null) {
        linePen = new PdfPen(pen.color, lineWidth);
      } else if (brush != null) {
        linePen = new PdfPen(brush, lineWidth);
      }
      return linePen;
    };
    PdfGraphics2.prototype.getTextRenderingMode = function(pen, brush, format) {
      var tm = TextRenderingMode.None;
      if (pen != null && brush != null) {
        tm = TextRenderingMode.FillStroke;
      } else if (pen != null) {
        tm = TextRenderingMode.Stroke;
      } else {
        tm = TextRenderingMode.Fill;
      }
      if (format != null && format.clipPath) {
        tm |= TextRenderingMode.ClipFlag;
      }
      return tm;
    };
    PdfGraphics2.prototype.getLineIndent = function(lineInfo, format, layoutBounds, firstLine) {
      var lineIndent = 0;
      var firstParagraphLine = (lineInfo.lineType & LineType.FirstParagraphLine) > 0;
      if (format != null && firstParagraphLine) {
        lineIndent = firstLine ? format.firstLineIndent : format.paragraphIndent;
        lineIndent = layoutBounds.width > 0 ? Math.min(layoutBounds.width, lineIndent) : lineIndent;
      }
      return lineIndent;
    };
    PdfGraphics2.prototype.getHorizontalAlignShift = function(lineWidth, boundsWidth, format) {
      var shift = 0;
      if (boundsWidth >= 0 && format != null && format.alignment !== PdfTextAlignment.Left) {
        switch (format.alignment) {
          case PdfTextAlignment.Center:
            shift = (boundsWidth - lineWidth) / 2;
            break;
          case PdfTextAlignment.Right:
            shift = boundsWidth - lineWidth;
            break;
        }
      }
      return shift;
    };
    PdfGraphics2.prototype.rightToLeft = function(format) {
      var rtl = format !== null && typeof format !== "undefined" && format.rightToLeft;
      if (format !== null && typeof format !== "undefined") {
        if (format.textDirection !== PdfTextDirection.None && typeof format.textDirection !== "undefined") {
          rtl = true;
        }
      }
      return rtl;
    };
    PdfGraphics2.prototype.stateControl = function(pen, brush, font, format) {
      if (typeof format === "undefined") {
        this.stateControl(pen, brush, font, null);
      } else {
        if (brush instanceof PdfGradientBrush) {
          this.bCSInitialized = false;
          brush.colorSpace = this.colorSpace;
        }
        if (brush instanceof PdfTilingBrush) {
          this.bCSInitialized = false;
          brush.graphics.colorSpace = this.colorSpace;
        }
        var saveState = false;
        if (brush !== null) {
          var solidBrush = brush;
          if (typeof this.pageLayer !== "undefined" && this.pageLayer != null) {
            if (this.colorSpaceChanged === false) {
              this.lastDocumentCS = this.pageLayer.page.document.colorSpace;
              this.lastGraphicsCS = this.pageLayer.page.graphics.colorSpace;
              this.colorSpace = this.pageLayer.page.document.colorSpace;
              this.currentColorSpace = this.pageLayer.page.document.colorSpace;
              this.colorSpaceChanged = true;
            }
          }
          this.initCurrentColorSpace(this.currentColorSpace);
        } else if (pen != null) {
          var pdfPen = pen;
          if (typeof this.pageLayer !== "undefined" && this.pageLayer != null) {
            this.colorSpace = this.pageLayer.page.document.colorSpace;
            this.currentColorSpace = this.pageLayer.page.document.colorSpace;
          }
          this.initCurrentColorSpace(this.currentColorSpace);
        }
        this.penControl(pen, saveState);
        this.brushControl(brush, saveState);
        this.fontControl(font, format, saveState);
      }
    };
    PdfGraphics2.prototype.initCurrentColorSpace = function(colorspace) {
      var re = this.getResources.getResources();
      if (!this.bCSInitialized) {
        if (this.currentColorSpace != PdfColorSpace.GrayScale) {
          this.pdfStreamWriter.setColorSpace("Device" + this.currentColorSpaces[this.currentColorSpace], true);
          this.pdfStreamWriter.setColorSpace("Device" + this.currentColorSpaces[this.currentColorSpace], false);
          this.bCSInitialized = true;
        } else {
          this.pdfStreamWriter.setColorSpace("DeviceGray", true);
          this.pdfStreamWriter.setColorSpace("DeviceGray", false);
          this.bCSInitialized = true;
        }
      }
    };
    PdfGraphics2.prototype.penControl = function(pen, saveState) {
      if (pen != null) {
        this.currentPen = pen;
        pen.monitorChanges(this.currentPen, this.pdfStreamWriter, this.getResources, saveState, this.colorSpace, this.matrix.clone());
        this.currentPen = pen.clone();
      }
    };
    PdfGraphics2.prototype.brushControl = function(brush, saveState) {
      if (brush != null && typeof brush !== "undefined") {
        var b = brush.clone();
        var lgb = b;
        if (lgb !== null && typeof lgb !== "undefined" && !(brush instanceof PdfSolidBrush) && !(brush instanceof PdfTilingBrush)) {
          var m = lgb.matrix;
          var matrix = this.matrix.clone();
          if (m != null) {
            m.multiply(matrix);
            matrix = m;
          }
          lgb.matrix = matrix;
        }
        this.currentBrush = lgb;
        var br = brush;
        b.monitorChanges(this.currentBrush, this.pdfStreamWriter, this.getResources, saveState, this.colorSpace);
        this.currentBrush = brush;
        brush = null;
      }
    };
    PdfGraphics2.prototype.fontControl = function(font, format, saveState) {
      if (font != null) {
        var curSubSuper = format != null ? format.subSuperScript : PdfSubSuperScript.None;
        var prevSubSuper = this.currentStringFormat != null ? this.currentStringFormat.subSuperScript : PdfSubSuperScript.None;
        if (saveState || font !== this.currentFont || curSubSuper !== prevSubSuper) {
          var resources = this.getResources.getResources();
          this.currentFont = font;
          this.currentStringFormat = format;
          var size = font.metrics.getSize(format);
          this.isEmfTextScaled = false;
          var fontName = resources.getName(font);
          this.pdfStreamWriter.setFont(font, fontName, size);
        }
      }
    };
    PdfGraphics2.prototype.setTransparency = function(arg1, arg2, arg3) {
      if (typeof arg2 === "undefined") {
        this.istransparencySet = true;
        this.setTransparency(arg1, arg1, PdfBlendMode.Normal);
      } else if (typeof arg2 === "number" && typeof arg3 === "undefined") {
        this.setTransparency(arg1, arg2, PdfBlendMode.Normal);
      } else {
        if (this.trasparencies == null) {
          this.trasparencies = new TemporaryDictionary();
        }
        var transp = null;
        var td = new TransparencyData(arg1, arg2, arg3);
        if (this.trasparencies.containsKey(td)) {
          transp = this.trasparencies.getValue(td);
        }
        if (transp == null) {
          transp = new PdfTransparency(arg1, arg2, arg3);
          this.trasparencies.setValue(td, transp);
        }
        var resources = this.getResources.getResources();
        var name_3 = resources.getName(transp);
        var sw = this.streamWriter;
        sw.setGraphicsState(name_3);
      }
    };
    PdfGraphics2.prototype.clipTranslateMargins = function(x, y, left, top, right, bottom) {
      if (x instanceof RectangleF && typeof y === "undefined") {
        this.clipBounds = x;
        this.pdfStreamWriter.writeComment("Clip margins.");
        this.pdfStreamWriter.appendRectangle(x);
        this.pdfStreamWriter.closePath();
        this.pdfStreamWriter.clipPath(false);
        this.pdfStreamWriter.writeComment("Translate co-ordinate system.");
        this.translateTransform(x.x, x.y);
      } else if (typeof x === "number") {
        var clipArea = new RectangleF(left, top, this.size.width - left - right, this.size.height - top - bottom);
        this.clipBounds = clipArea;
        this.pdfStreamWriter.writeComment("Clip margins.");
        this.pdfStreamWriter.appendRectangle(clipArea);
        this.pdfStreamWriter.closePath();
        this.pdfStreamWriter.clipPath(false);
        this.pdfStreamWriter.writeComment("Translate co-ordinate system.");
        this.translateTransform(x, y);
      }
    };
    PdfGraphics2.prototype.updateY = function(y) {
      return -y;
    };
    PdfGraphics2.prototype.translateTransform = function(offsetX, offsetY) {
      var matrix = new PdfTransformationMatrix();
      this.getTranslateTransform(offsetX, offsetY, matrix);
      this.pdfStreamWriter.modifyCtm(matrix);
      this.matrix.multiply(matrix);
    };
    PdfGraphics2.prototype.getTranslateTransform = function(x, y, input) {
      input.translate(x, this.updateY(y));
      return input;
    };
    PdfGraphics2.prototype.scaleTransform = function(scaleX, scaleY) {
      var matrix = new PdfTransformationMatrix();
      this.getScaleTransform(scaleX, scaleY, matrix);
      this.pdfStreamWriter.modifyCtm(matrix);
      this.matrix.multiply(matrix);
    };
    PdfGraphics2.prototype.getScaleTransform = function(x, y, input) {
      if (input == null) {
        input = new PdfTransformationMatrix();
      }
      input.scale(x, y);
      return input;
    };
    PdfGraphics2.prototype.rotateTransform = function(angle) {
      var matrix = new PdfTransformationMatrix();
      this.getRotateTransform(angle, matrix);
      this.pdfStreamWriter.modifyCtm(matrix);
      this.matrix.multiply(matrix);
    };
    PdfGraphics2.prototype.initializeCoordinates = function() {
      this.pdfStreamWriter.writeComment("Change co-ordinate system to left/top.");
      if (this.mediaBoxUpperRightBound !== -this.size.height) {
        if (this.cropBox == null) {
          if (this.mediaBoxUpperRightBound === this.size.height || this.mediaBoxUpperRightBound === 0) {
            this.translateTransform(0, this.updateY(this.size.height));
          } else {
            this.translateTransform(0, this.updateY(this.mediaBoxUpperRightBound));
          }
        }
      }
    };
    PdfGraphics2.prototype.getRotateTransform = function(angle, input) {
      if (input == null || typeof input === "undefined") {
        input = new PdfTransformationMatrix();
      }
      input.rotate(this.updateY(angle));
      return input;
    };
    PdfGraphics2.prototype.save = function() {
      var state = new PdfGraphicsState(this, this.matrix.clone());
      state.brush = this.currentBrush;
      state.pen = this.currentPen;
      state.font = this.currentFont;
      state.colorSpace = this.currentColorSpace;
      state.characterSpacing = this.previousCharacterSpacing;
      state.wordSpacing = this.previousWordSpacing;
      state.textScaling = this.previousTextScaling;
      state.textRenderingMode = this.previousTextRenderingMode;
      this.graphicsState.push(state);
      this.pdfStreamWriter.saveGraphicsState();
      return state;
    };
    PdfGraphics2.prototype.restore = function(state) {
      if (typeof state === "undefined") {
        if (this.graphicsState.length > 0) {
          this.doRestoreState();
        }
      } else {
        if (this.graphicsState.indexOf(state) !== -1) {
          for (; ; ) {
            if (this.graphicsState.length === 0) {
              break;
            }
            var popState = this.doRestoreState();
            if (popState === state) {
              break;
            }
          }
        }
      }
    };
    PdfGraphics2.prototype.doRestoreState = function() {
      var state = this.graphicsState.pop();
      this.transformationMatrix = state.matrix;
      this.currentBrush = state.brush;
      this.currentPen = state.pen;
      this.currentFont = state.font;
      this.currentColorSpace = state.colorSpace;
      this.previousCharacterSpacing = state.characterSpacing;
      this.previousWordSpacing = state.wordSpacing;
      this.previousTextScaling = state.textScaling;
      this.previousTextRenderingMode = state.textRenderingMode;
      this.pdfStreamWriter.restoreGraphicsState();
      return state;
    };
    PdfGraphics2.prototype.drawPath = function(pen, brush, path) {
      this._drawPath(pen, brush, path.pathPoints, path.pathTypes, path.fillMode);
    };
    PdfGraphics2.prototype._drawPath = function(pen, brush, pathPoints, pathTypes, fillMode) {
      if (brush instanceof PdfTilingBrush) {
        this.bCSInitialized = false;
        brush.graphics.colorSpace = this.colorSpace;
      } else if (brush instanceof PdfGradientBrush) {
        this.bCSInitialized = false;
        brush.colorSpace = this.colorSpace;
      }
      this.stateControl(pen, brush, null);
      this.buildUpPath(pathPoints, pathTypes);
      this.drawPathHelper(pen, brush, fillMode, false);
    };
    PdfGraphics2.prototype.drawArc = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      if (arg2 instanceof RectangleF) {
        this.drawArc(arg1, arg2.x, arg2.y, arg2.width, arg2.height, arg3, arg4);
      } else {
        if (arg7 !== 0) {
          this.stateControl(arg1, null, null);
          this.constructArcPath(arg2, arg3, arg2 + arg4, arg3 + arg5, arg6, arg7);
          this.drawPathHelper(arg1, null, false);
        }
      }
    };
    PdfGraphics2.prototype.buildUpPath = function(arg1, arg2) {
      var cnt = arg1.length;
      for (var i = 0; i < cnt; ++i) {
        var typeValue = 0;
        var point = arg1[i];
        switch (arg2[i] & PdfGraphics2.pathTypesValuesMask) {
          case PathPointType.Start:
            this.pdfStreamWriter.beginPath(point.x, point.y);
            break;
          case PathPointType.Bezier3:
            var p2 = new PointF(0, 0);
            var p3 = new PointF(0, 0);
            var result1 = this.getBezierPoints(arg1, arg2, i, p2, p3);
            this.pdfStreamWriter.appendBezierSegment(point, result1.p2, result1.p3);
            i = result1.i;
            break;
          case PathPointType.Line:
            this.pdfStreamWriter.appendLineSegment(point);
            break;
          default:
            throw new Error("ArithmeticException - Incorrect path formation.");
        }
        typeValue = arg2[i];
        this.checkFlags(typeValue);
      }
    };
    PdfGraphics2.prototype.getBezierPoints = function(points, types, i, p2, p3) {
      var errorMsg = "Malforming path.";
      ++i;
      if ((types[i] & PdfGraphics2.pathTypesValuesMask) === PathPointType.Bezier3) {
        p2 = points[i];
        ++i;
        if ((types[i] & PdfGraphics2.pathTypesValuesMask) === PathPointType.Bezier3) {
          p3 = points[i];
        } else {
          throw new Error("ArgumentException : errorMsg");
        }
      } else {
        throw new Error("ArgumentException : errorMsg");
      }
      return { i, p2, p3 };
    };
    PdfGraphics2.prototype.checkFlags = function(type) {
      if ((type & PathPointType.CloseSubpath) === PathPointType.CloseSubpath) {
        this.pdfStreamWriter.closePath();
      }
    };
    PdfGraphics2.prototype.constructArcPath = function(x1, y1, x2, y2, startAng, sweepAngle) {
      var points = this.getBezierArc(x1, y1, x2, y2, startAng, sweepAngle);
      if (points.length === 0) {
        return;
      }
      var pt = [points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]];
      this.pdfStreamWriter.beginPath(pt[0], pt[1]);
      var i = 0;
      for (i = 0; i < points.length; i = i + 8) {
        pt = [points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5], points[i + 6], points[i + 7]];
        this.pdfStreamWriter.appendBezierSegment(pt[2], pt[3], pt[4], pt[5], pt[6], pt[7]);
      }
    };
    PdfGraphics2.prototype.getBezierArc = function(numX1, numY1, numX2, numY2, s1, e1) {
      if (numX1 > numX2) {
        var tmp = void 0;
        tmp = numX1;
        numX1 = numX2;
        numX2 = tmp;
      }
      if (numY2 > numY1) {
        var tmp = void 0;
        tmp = numY1;
        numY1 = numY2;
        numY2 = tmp;
      }
      var fragAngle1;
      var numFragments;
      if (Math.abs(e1) <= 90) {
        fragAngle1 = e1;
        numFragments = 1;
      } else {
        numFragments = Math.ceil(Math.abs(e1) / 90);
        fragAngle1 = e1 / numFragments;
      }
      var xcen = (numX1 + numX2) / 2;
      var ycen = (numY1 + numY2) / 2;
      var rx = (numX2 - numX1) / 2;
      var ry = (numY2 - numY1) / 2;
      var halfAng = fragAngle1 * (Math.PI / 360);
      var kappa = Math.abs(4 / 3 * (1 - Math.cos(halfAng)) / Math.sin(halfAng));
      var pointsList = [];
      for (var i = 0; i < numFragments; i++) {
        var thetaValue0 = (s1 + i * fragAngle1) * (Math.PI / 180);
        var thetaValue1 = (s1 + (i + 1) * fragAngle1) * (Math.PI / 180);
        var cos0 = Math.cos(thetaValue0);
        var cos1 = Math.cos(thetaValue1);
        var sin0 = Math.sin(thetaValue0);
        var sin1 = Math.sin(thetaValue1);
        if (fragAngle1 > 0) {
          pointsList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 - kappa * sin0), ycen - ry * (sin0 + kappa * cos0), xcen + rx * (cos1 + kappa * sin1), ycen - ry * (sin1 - kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);
        } else {
          pointsList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 + kappa * sin0), ycen - ry * (sin0 - kappa * cos0), xcen + rx * (cos1 - kappa * sin1), ycen - ry * (sin1 + kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);
        }
      }
      return pointsList;
    };
    PdfGraphics2.pathTypesValuesMask = 15;
    PdfGraphics2.transparencyObject = false;
    return PdfGraphics2;
  })()
);
var GetResourceEventHandler = (
  /** @class */
  (function() {
    function GetResourceEventHandler2(sender) {
      this.sender = sender;
    }
    GetResourceEventHandler2.prototype.getResources = function() {
      return this.sender.getResources();
    };
    return GetResourceEventHandler2;
  })()
);
var PdfGraphicsState = (
  /** @class */
  (function() {
    function PdfGraphicsState2(graphics, matrix) {
      this.internalTextRenderingMode = TextRenderingMode.Fill;
      this.internalCharacterSpacing = 0;
      this.internalWordSpacing = 0;
      this.internalTextScaling = 100;
      this.pdfColorSpace = PdfColorSpace.Rgb;
      if (typeof graphics !== "undefined") {
        this.pdfGraphics = graphics;
        var elements_1 = [];
        graphics.matrix.matrix.elements.forEach(function(element) {
          elements_1.push(element);
        });
        this.transformationMatrix = new PdfTransformationMatrix();
        this.transformationMatrix.matrix = new Matrix(elements_1);
      }
    }
    Object.defineProperty(PdfGraphicsState2.prototype, "graphics", {
      // Properties
      /**
       * Gets the parent `graphics object`.
       * @private
       */
      get: function() {
        return this.pdfGraphics;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "matrix", {
      /**
       * Gets the `current matrix`.
       * @private
       */
      get: function() {
        return this.transformationMatrix;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "characterSpacing", {
      /**
       * Gets or sets the `current character spacing`.
       * @private
       */
      get: function() {
        return this.internalCharacterSpacing;
      },
      set: function(value) {
        this.internalCharacterSpacing = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "wordSpacing", {
      /**
       * Gets or sets the `word spacing` value.
       * @private
       */
      get: function() {
        return this.internalWordSpacing;
      },
      set: function(value) {
        this.internalWordSpacing = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "textScaling", {
      /**
       * Gets or sets the `text scaling` value.
       * @private
       */
      get: function() {
        return this.internalTextScaling;
      },
      set: function(value) {
        this.internalTextScaling = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "pen", {
      /**
       * Gets or sets the `current pen` object.
       * @private
       */
      get: function() {
        return this.pdfPen;
      },
      set: function(value) {
        this.pdfPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "brush", {
      /**
       * Gets or sets the `brush`.
       * @private
       */
      get: function() {
        return this.pdfBrush;
      },
      set: function(value) {
        this.pdfBrush = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "font", {
      /**
       * Gets or sets the `current font` object.
       * @private
       */
      get: function() {
        return this.pdfFont;
      },
      set: function(value) {
        this.pdfFont = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "colorSpace", {
      /**
       * Gets or sets the `current color space` value.
       * @private
       */
      get: function() {
        return this.pdfColorSpace;
      },
      set: function(value) {
        this.pdfColorSpace = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGraphicsState2.prototype, "textRenderingMode", {
      /**
       * Gets or sets the `text rendering mode`.
       * @private
       */
      get: function() {
        return this.internalTextRenderingMode;
      },
      set: function(value) {
        this.internalTextRenderingMode = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGraphicsState2;
  })()
);
var TransparencyData = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TransparencyData2(alphaPen, alphaBrush, blendMode) {
      this.alphaPen = alphaPen;
      this.alphaBrush = alphaBrush;
      this.blendMode = blendMode;
    }
    return TransparencyData2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page-layer.js
var PdfPageLayer = (
  /** @class */
  (function() {
    function PdfPageLayer2(page, streamClipPageTemplates) {
      this.pdfColorSpace = PdfColorSpace.Rgb;
      this.isVisible = true;
      this.sublayer = false;
      this.contentLength = 0;
      this.dictionaryProperties = new DictionaryProperties();
      if (page === null) {
        throw new Error("ArgumentNullException:page");
      }
      this.pdfPage = page;
      this.clipPageTemplates = true;
      if (typeof streamClipPageTemplates === "undefined") {
        this.content = new PdfStream();
      } else if (streamClipPageTemplates instanceof PdfStream || streamClipPageTemplates === null) {
        if (streamClipPageTemplates === null) {
          throw new Error("ArgumentNullException:stream");
        }
        this.content = streamClipPageTemplates;
      } else {
        this.content = new PdfStream();
        this.clipPageTemplates = streamClipPageTemplates;
      }
    }
    Object.defineProperty(PdfPageLayer2.prototype, "colorSpace", {
      // Properties
      /**
       * Get or set the `color space`.
       * @private
       */
      get: function() {
        return this.pdfColorSpace;
      },
      set: function(value) {
        this.pdfColorSpace = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageLayer2.prototype, "page", {
      /**
       * Gets parent `page` of the layer.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageLayer2.prototype, "layerId", {
      /**
       * Gets and Sets the `id of the layer`.
       * @private
       */
      get: function() {
        return this.layerid;
      },
      set: function(value) {
        this.layerid = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageLayer2.prototype, "name", {
      /**
       * Gets or sets the `name` of the layer.
       * @private
       */
      get: function() {
        return this.layerName;
      },
      set: function(value) {
        this.layerName = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageLayer2.prototype, "visible", {
      /**
       * Gets or sets the `visibility` of the layer.
       * @private
       */
      get: function() {
        return this.isVisible;
      },
      set: function(value) {
        this.isVisible = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageLayer2.prototype, "graphics", {
      /**
       * Gets `Graphics` context of the layer, used to draw various graphical content on layer.
       * @private
       */
      get: function() {
        if (this.pdfGraphics == null) {
          this.initializeGraphics(this.page);
        }
        return this.pdfGraphics;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageLayer2.prototype, "layers", {
      /**
       * Gets the collection of `PdfPageLayer`, this collection handle by the class 'PdfPageLayerCollection'.
       * @private
       */
      get: function() {
        if (this.layer == null) {
          this.layer = new PdfPageLayerCollection(this.page);
          this.layer.sublayer = true;
          return this.layer;
        } else {
          return this.layer;
        }
      },
      enumerable: true,
      configurable: true
    });
    PdfPageLayer2.prototype.add = function() {
      var layer = new PdfPageLayer2(this.pdfPage);
      layer.name = "";
      return layer;
    };
    PdfPageLayer2.prototype.sign = function(number) {
      if (number === 0) {
        return 0;
      } else if (number > 0) {
        return 1;
      } else {
        return -1;
      }
    };
    PdfPageLayer2.prototype.initializeGraphics = function(page) {
      var oPage = page;
      var gr = new GetResourceEventHandler(this.page);
      var cropBox = null;
      this.pdfGraphics = new PdfGraphics(page.size, gr, this.content);
      this.pdfGraphics.mediaBoxUpperRightBound = 0;
      if (oPage != null) {
        var sc = oPage.section.parent;
        if (sc != null) {
          this.pdfGraphics.colorSpace = sc.document.colorSpace;
          this.colorSpace = sc.document.colorSpace;
        }
      }
      var isSame = this.sign(page.origin.y) === this.sign(page.origin.x);
      if (page.origin.x >= 0 && page.origin.y >= 0 || !isSame) {
        this.pdfGraphics.initializeCoordinates();
      } else {
      }
      var clipRect = oPage.section.getActualBounds(oPage, true);
      var margins = oPage.section.pageSettings.margins;
      if (this.clipPageTemplates) {
        if (page.origin.x >= 0 && page.origin.y >= 0) {
          this.pdfGraphics.clipTranslateMargins(clipRect);
        }
      } else {
        this.graphics.clipTranslateMargins(clipRect.x, clipRect.y, margins.left, margins.top, margins.right, margins.bottom);
      }
      this.pdfGraphics.setLayer(this);
    };
    Object.defineProperty(PdfPageLayer2.prototype, "element", {
      // IPdfWrapper Members
      /**
       * Gets the wrapped `element`.
       * @private
       */
      get: function() {
        return this.content;
      },
      enumerable: true,
      configurable: true
    });
    return PdfPageLayer2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/general/pdf-collection.js
var PdfCollection = (
  /** @class */
  (function() {
    function PdfCollection2() {
    }
    Object.defineProperty(PdfCollection2.prototype, "count", {
      // Properties
      /**
       * Gets the `Count` of stored objects.
       * @private
       */
      get: function() {
        if (typeof this.collection === "undefined") {
          this.collection = [];
        }
        return this.collection.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCollection2.prototype, "list", {
      /**
       * Gets the `list` of stored objects.
       * @private
       */
      get: function() {
        if (typeof this.collection === "undefined") {
          this.collection = [];
        }
        return this.collection;
      },
      enumerable: true,
      configurable: true
    });
    return PdfCollection2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page-layer-collection.js
var __extends33 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfPageLayerCollection = (
  /** @class */
  (function(_super) {
    __extends33(PdfPageLayerCollection2, _super);
    function PdfPageLayerCollection2(page) {
      var _this = _super.call(this) || this;
      _this.parentLayerCount = 0;
      _this.sublayer = false;
      _this.optionalContent = new PdfDictionary();
      if (page instanceof PdfPageBase) {
        _this.page = page;
        var lPage = page;
        _this.parseLayers(lPage);
      }
      return _this;
    }
    PdfPageLayerCollection2.prototype.items = function(index, value) {
      if (typeof index === "number" && typeof value === "undefined") {
        var obj = this.list[index];
        return obj;
      } else {
        if (value == null) {
          throw new Error("ArgumentNullException: layer");
        }
        if (value.page !== this.page) {
          throw new Error("ArgumentException: The layer belongs to another page");
        }
      }
    };
    PdfPageLayerCollection2.prototype.add = function(firstArgument, secondArgument) {
      if (typeof firstArgument === "undefined") {
        var layer = new PdfPageLayer(this.page);
        layer.name = "";
        this.add(layer);
        return layer;
      } else if (firstArgument instanceof PdfPageLayer) {
        var index = this.list.push(firstArgument);
        this.addLayer(index, firstArgument);
        return index;
      } else {
        return 0;
      }
    };
    PdfPageLayerCollection2.prototype.addLayer = function(index, layer) {
      var reference = new PdfReferenceHolder(layer);
      this.page.contents.add(reference);
    };
    PdfPageLayerCollection2.prototype.insert = function(index, layer) {
      var list = [];
      var length = this.list.length;
      for (var i = index; i < length; i++) {
        list.push(this.list.pop());
      }
      this.list.push(layer);
      for (var i = 0; i < list.length; i++) {
        this.list.push(list[i]);
      }
      this.insertLayer(index, layer);
    };
    PdfPageLayerCollection2.prototype.insertLayer = function(index, layer) {
      if (layer == null) {
        throw new Error("ArgumentNullException:layer");
      }
      var reference = new PdfReferenceHolder(layer);
      this.page.contents.insert(index, reference);
    };
    PdfPageLayerCollection2.prototype.parseLayers = function(loadedPage) {
      var contents = this.page.contents;
      var resource = this.page.getResources();
      var crossTable = null;
      var ocproperties = null;
      var propertie = null;
      var isLayerAdded = false;
      crossTable = loadedPage.crossTable;
      var saveStream = new PdfStream();
      var restoreStream = new PdfStream();
      var saveState = "q";
      var newLine = "\n";
      var restoreState = "Q";
      var saveData = [];
      saveData.push(saveState);
      saveStream.data = saveData;
      contents.insert(0, new PdfReferenceHolder(saveStream));
      saveData = [];
      saveData.push(restoreState);
      restoreStream.data = saveData;
      contents.insert(contents.count, new PdfReferenceHolder(restoreStream));
    };
    PdfPageLayerCollection2.prototype.indexOf = function(layer) {
      if (layer == null) {
        throw new Error("ArgumentNullException: layer");
      }
      var index = this.list.indexOf(layer);
      return index;
    };
    return PdfPageLayerCollection2;
  })(PdfCollection)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page-base.js
var PdfPageBase = (
  /** @class */
  (function() {
    function PdfPageBase2(dictionary) {
      this.defLayerIndex = -1;
      this.modified = false;
      this.dictionaryProperties = new DictionaryProperties();
      this.pageDictionary = dictionary;
    }
    Object.defineProperty(PdfPageBase2.prototype, "section", {
      //Properties
      /**
       * Gets the `section` of a page.
       * @private
       */
      get: function() {
        return this.pdfSection;
      },
      set: function(value) {
        this.pdfSection = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageBase2.prototype, "dictionary", {
      /**
       * Gets the page `dictionary`.
       * @private
       */
      get: function() {
        return this.pageDictionary;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageBase2.prototype, "element", {
      /**
       * Gets the wrapped `element`.
       * @private
       */
      get: function() {
        return this.pageDictionary;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageBase2.prototype, "defaultLayer", {
      /**
       * Gets the `default layer` of the page (Read only).
       * @private
       */
      get: function() {
        var layer = this.layers;
        var index = this.defaultLayerIndex;
        var returnlayer = layer.items(index);
        return returnlayer;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageBase2.prototype, "defaultLayerIndex", {
      /**
       * Gets or sets `index of the default layer`.
       * @private
       */
      get: function() {
        if (this.layerCollection.count === 0 || this.defLayerIndex === -1) {
          var layer = this.layerCollection.add();
          this.defLayerIndex = this.layerCollection.indexOf(layer);
        }
        return this.defLayerIndex;
      },
      /**
       * Gets or sets` index of the default layer`.
       * @private
       */
      set: function(value) {
        if (value < 0 || value > this.layers.count - 1) {
          throw new Error("ArgumentOutOfRangeException : value, Index can not be less 0 and greater Layers.Count - 1");
        } else {
          this.defLayerIndex = value;
          this.modified = true;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageBase2.prototype, "layers", {
      /**
       * Gets the collection of the page's `layers` (Read only).
       * @private
       */
      get: function() {
        if (this.layerCollection == null || typeof this.layerCollection === "undefined") {
          this.layerCollection = new PdfPageLayerCollection(this);
        }
        return this.layerCollection;
      },
      enumerable: true,
      configurable: true
    });
    PdfPageBase2.prototype.getResources = function() {
      if (this.resources == null) {
        this.resources = new PdfResources();
        this.dictionary.items.setValue(this.dictionaryProperties.resources, this.resources);
      }
      return this.resources;
    };
    Object.defineProperty(PdfPageBase2.prototype, "contents", {
      /**
       * Gets `array of page's content`.
       * @private
       */
      get: function() {
        var obj = this.pageDictionary.items.getValue(this.dictionaryProperties.contents);
        var contents = obj;
        var rh = obj;
        if (contents == null) {
          contents = new PdfArray();
          this.pageDictionary.items.setValue(this.dictionaryProperties.contents, contents);
        }
        return contents;
      },
      enumerable: true,
      configurable: true
    });
    PdfPageBase2.prototype.setResources = function(res) {
      this.resources = res;
      this.dictionary.items.setValue(this.dictionaryProperties.resources, this.resources);
      this.modified = true;
    };
    return PdfPageBase2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/annotation-collection.js
var PdfAnnotationCollection = (
  /** @class */
  (function() {
    function PdfAnnotationCollection2(page) {
      this.alreadyExistsAnnotationError = "This annotatation had been already added to page";
      this.missingAnnotationException = "Annotation is not contained in collection.";
      this.dictionaryProperties = new DictionaryProperties();
      this.internalAnnotations = new PdfArray();
      this.lists = [];
      if (typeof page !== "undefined") {
        this.page = page;
      }
    }
    Object.defineProperty(PdfAnnotationCollection2.prototype, "annotations", {
      /**
       * Gets the `PdfAnnotation` object at the specified index. Read-Only.
       * @private
       */
      get: function() {
        return this.internalAnnotations;
      },
      set: function(value) {
        this.internalAnnotations = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfAnnotationCollection2.prototype.add = function(annotation) {
      this.doAdd(annotation);
    };
    PdfAnnotationCollection2.prototype.doAdd = function(annotation) {
      if (typeof annotation.destination !== "undefined") {
        var layout = new PdfStringLayouter();
        var layoutResult = layout.layout(annotation.text, annotation.font, annotation.stringFormat, new SizeF(annotation.bounds.width, 0), false, new SizeF(0, 0));
        var lastPosition = annotation.bounds.y;
        if (layoutResult.lines.length === 1) {
          var size = annotation.font.measureString(layoutResult.lines[0].text);
          annotation.bounds = new RectangleF(new PointF(annotation.bounds.x, lastPosition), size);
          annotation.text = layoutResult.lines[0].text;
          this.page.graphics.drawString(annotation.text, annotation.font, null, annotation.brush, annotation.bounds.x, annotation.bounds.y, annotation.bounds.width, annotation.bounds.height, null);
          annotation.setPage(this.page);
          this.setColor(annotation);
          this.internalAnnotations.add(new PdfReferenceHolder(annotation));
          this.lists.push(annotation);
        } else {
          for (var i = 0; i < layoutResult.lines.length; i++) {
            var size = annotation.font.measureString(layoutResult.lines[i].text);
            if (i === 0) {
              annotation.bounds = new RectangleF(annotation.bounds.x, lastPosition, size.width, size.height);
              annotation.text = layoutResult.lines[i].text;
              this.page.graphics.drawString(annotation.text, annotation.font, null, annotation.brush, annotation.bounds.x, lastPosition, size.width, size.height, null);
              annotation.setPage(this.page);
              this.setColor(annotation);
              this.internalAnnotations.add(new PdfReferenceHolder(annotation));
              this.lists.push(annotation);
              lastPosition += annotation.bounds.height;
            } else {
              var annot = annotation.clone();
              annot.bounds = new RectangleF(new PointF(annotation.bounds.x, lastPosition), size);
              annot.text = layoutResult.lines[i].text;
              this.page.graphics.drawString(annot.text, annot.font, null, annot.brush, annot.bounds.x, annot.bounds.y, annot.bounds.width, annot.bounds.height, null);
              annot.setPage(this.page);
              this.setColor(annot);
              this.internalAnnotations.add(new PdfReferenceHolder(annot));
              this.lists.push(annot);
              lastPosition += annot.bounds.height;
            }
          }
        }
      } else {
        annotation.setPage(this.page);
        this.internalAnnotations.add(new PdfReferenceHolder(annotation));
        return this.lists.push(annotation);
      }
    };
    PdfAnnotationCollection2.prototype.setColor = function(annotation) {
      var cs = PdfColorSpace.Rgb;
      var colours = annotation.color.toArray(cs);
      annotation.dictionary.items.setValue(this.dictionaryProperties.c, colours);
    };
    Object.defineProperty(PdfAnnotationCollection2.prototype, "element", {
      // IPdfWrapper Members
      /**
       * Gets the `Element` representing this object.
       * @private
       */
      get: function() {
        return this.internalAnnotations;
      },
      enumerable: true,
      configurable: true
    });
    return PdfAnnotationCollection2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page.js
var __extends34 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfPage = (
  /** @class */
  (function(_super) {
    __extends34(PdfPage2, _super);
    function PdfPage2() {
      var _this = _super.call(this, new PdfDictionary()) || this;
      _this.annotationCollection = null;
      _this.beginSave = null;
      _this.initialize();
      return _this;
    }
    Object.defineProperty(PdfPage2.prototype, "document", {
      //Properties
      /**
       * Gets current `document`.
       * @private
       */
      get: function() {
        if (this.section !== null && this.section.parent !== null) {
          return this.section.parent.document;
        } else {
          return null;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPage2.prototype, "graphics", {
      /**
       * Get the current `graphics`.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // add a new page to the document
       * let page1 : PdfPage = document.pages.add();
       * //
       * // get graphics
       * let graphics : PdfGraphics = page1.graphics;
       * //
       * // set the font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // create black brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * // draw the text
       * graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        var result = this.defaultLayer.graphics;
        result.currentPage = this;
        return result;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPage2.prototype, "crossTable", {
      /**
       * Gets the `cross table`.
       * @private
       */
      get: function() {
        if (this.section === null) {
          throw new Error("PdfDocumentException : Page is not created");
        }
        return this.section.parent === null ? this.section.parentDocument.crossTable : this.section.parent.document.crossTable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPage2.prototype, "size", {
      /**
       * Gets the size of the PDF page- Read only.
       * @public
       */
      get: function() {
        return this.section.pageSettings.size;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPage2.prototype, "origin", {
      /**
       * Gets the `origin` of the page.
       * @private
       */
      get: function() {
        return this.section.pageSettings.origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPage2.prototype, "annotations", {
      /**
       * Gets a collection of the `annotations` of the page- Read only.
       * @private
       */
      get: function() {
        if (this.annotationCollection == null) {
          this.annotationCollection = new PdfAnnotationCollection(this);
          this.dictionary.items.setValue(this.dictionaryProperties.annots, this.annotationCollection.element);
          this.annotationCollection.annotations = this.dictionary.items.getValue(this.dictionaryProperties.annots);
        }
        return this.annotationCollection;
      },
      enumerable: true,
      configurable: true
    });
    PdfPage2.prototype.initialize = function() {
      this.dictionary.items.setValue(this.dictionaryProperties.type, new PdfName("Page"));
      this.dictionary.pageBeginDrawTemplate = new SaveTemplateEventHandler(this);
    };
    PdfPage2.prototype.setSection = function(section) {
      this.section = section;
      this.dictionary.items.setValue(this.dictionaryProperties.parent, new PdfReferenceHolder(section));
    };
    PdfPage2.prototype.resetProgress = function() {
      this.isProgressOn = false;
    };
    PdfPage2.prototype.getClientSize = function() {
      var returnValue = this.section.getActualBounds(this, true);
      return new SizeF(returnValue.width, returnValue.height);
    };
    PdfPage2.prototype.pageBeginSave = function() {
      var doc = this.document;
      if (typeof doc !== void 0 && doc != null) {
        this.drawPageTemplates(doc);
      }
      if (this.beginSave != null && typeof this.beginSave !== "undefined") {
        this.beginSave(this);
      }
    };
    PdfPage2.prototype.drawPageTemplates = function(document2) {
      var hasBackTemplates = this.section.containsTemplates(document2, this, false);
      if (hasBackTemplates) {
        var backLayer = new PdfPageLayer(this, false);
        this.layers.insert(0, backLayer);
        this.section.drawTemplates(this, backLayer, document2, false);
        if (backLayer.graphics !== null && typeof backLayer.graphics !== "undefined") {
          for (var i = 0; i < backLayer.graphics.automaticFields.automaticFields.length; i++) {
            var fieldInfo = backLayer.graphics.automaticFields.automaticFields[i];
            fieldInfo.field.performDraw(backLayer.graphics, fieldInfo.location, fieldInfo.scalingX, fieldInfo.scalingY);
          }
        }
      }
      var hasFrontTemplates = this.section.containsTemplates(document2, this, true);
      if (hasFrontTemplates) {
        var frontLayer = new PdfPageLayer(this, false);
        this.layers.add(frontLayer);
        this.section.drawTemplates(this, frontLayer, document2, true);
      }
    };
    return PdfPage2;
  })(PdfPageBase)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/page-added-event-arguments.js
var PageAddedEventArgs = (
  /** @class */
  (function() {
    function PageAddedEventArgs2(page) {
      if (typeof page !== "undefined") {
        this.pdfPage = page;
      } else {
        this.pdfPage = null;
      }
    }
    Object.defineProperty(PageAddedEventArgs2.prototype, "page", {
      /**
       * Gets the `newly added page`.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      enumerable: true,
      configurable: true
    });
    return PageAddedEventArgs2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-section-page-collection.js
var PdfSectionPageCollection = (
  /** @class */
  (function() {
    function PdfSectionPageCollection2(section) {
      this.pdfSection = null;
      if (section == null) {
        throw Error('ArgumentNullException("section")');
      }
      this.section = section;
    }
    Object.defineProperty(PdfSectionPageCollection2.prototype, "section", {
      // Properties
      /**
       * Gets the `PdfPage` at the specified index.
       * @private
       */
      get: function() {
        return this.pdfSection;
      },
      set: function(value) {
        this.pdfSection = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfSectionPageCollection2.prototype.contains = function(page) {
      return this.section.contains(page);
    };
    PdfSectionPageCollection2.prototype.remove = function(page) {
      this.section.remove(page);
    };
    PdfSectionPageCollection2.prototype.add = function() {
      return this.section.add();
    };
    return PdfSectionPageCollection2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/pdf-document-template.js
var PdfDocumentTemplate = (
  /** @class */
  (function() {
    function PdfDocumentTemplate2() {
    }
    Object.defineProperty(PdfDocumentTemplate2.prototype, "left", {
      // private m_stamps : PdfStampCollection;
      // Properties
      /**
       * `Left` page template object.
       * @public
       */
      get: function() {
        return this.leftTemplate;
      },
      set: function(value) {
        this.leftTemplate = this.checkElement(value, TemplateType.Left);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "top", {
      /**
       * `Top` page template object.
       * @public
       */
      get: function() {
        return this.topTemplate;
      },
      set: function(value) {
        this.topTemplate = this.checkElement(value, TemplateType.Top);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "right", {
      /**
       * `Right` page template object.
       * @public
       */
      get: function() {
        return this.rightTemplate;
      },
      set: function(value) {
        this.rightTemplate = this.checkElement(value, TemplateType.Right);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "bottom", {
      /**
       * `Bottom` page template object.
       * @public
       */
      get: function() {
        return this.bottomTemplate;
      },
      set: function(value) {
        this.bottomTemplate = this.checkElement(value, TemplateType.Bottom);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "EvenLeft", {
      /**
       * `EvenLeft` page template object.
       * @public
       */
      get: function() {
        return this.evenLeft;
      },
      set: function(value) {
        this.evenLeft = this.checkElement(value, TemplateType.Left);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "EvenTop", {
      /**
       * `EvenTop` page template object.
       * @public
       */
      get: function() {
        return this.evenTop;
      },
      set: function(value) {
        this.evenTop = this.checkElement(value, TemplateType.Top);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "EvenRight", {
      /**
       * `EvenRight` page template object.
       * @public
       */
      get: function() {
        return this.evenRight;
      },
      set: function(value) {
        this.evenRight = this.checkElement(value, TemplateType.Right);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "EvenBottom", {
      /**
       * `EvenBottom` page template object.
       * @public
       */
      get: function() {
        return this.evenBottom;
      },
      set: function(value) {
        this.evenBottom = this.checkElement(value, TemplateType.Bottom);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "OddLeft", {
      /**
       * `OddLeft` page template object.
       * @public
       */
      get: function() {
        return this.oddLeft;
      },
      set: function(value) {
        this.oddLeft = this.checkElement(value, TemplateType.Left);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "OddTop", {
      /**
       * `OddTop` page template object.
       * @public
       */
      get: function() {
        return this.oddTop;
      },
      set: function(value) {
        this.oddTop = this.checkElement(value, TemplateType.Top);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "OddRight", {
      /**
       * `OddRight` page template object.
       * @public
       */
      get: function() {
        return this.oddRight;
      },
      set: function(value) {
        this.oddRight = this.checkElement(value, TemplateType.Right);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentTemplate2.prototype, "OddBottom", {
      /**
       * `OddBottom` page template object.
       * @public
       */
      get: function() {
        return this.oddBottom;
      },
      set: function(value) {
        this.oddBottom = this.checkElement(value, TemplateType.Bottom);
      },
      enumerable: true,
      configurable: true
    });
    PdfDocumentTemplate2.prototype.getLeft = function(page) {
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var template = null;
      var even = this.isEven(page);
      if (even) {
        template = this.EvenLeft != null ? this.EvenLeft : this.left;
      } else {
        template = this.OddLeft != null ? this.OddLeft : this.left;
      }
      return template;
    };
    PdfDocumentTemplate2.prototype.getTop = function(page) {
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var template = null;
      var even = this.isEven(page);
      if (even) {
        template = this.EvenTop != null ? this.EvenTop : this.top;
      } else {
        template = this.OddTop != null ? this.OddTop : this.top;
      }
      return template;
    };
    PdfDocumentTemplate2.prototype.getRight = function(page) {
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var template = null;
      var even = this.isEven(page);
      if (even) {
        template = this.EvenRight != null ? this.EvenRight : this.right;
      } else {
        template = this.OddRight != null ? this.OddRight : this.right;
      }
      return template;
    };
    PdfDocumentTemplate2.prototype.getBottom = function(page) {
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var template = null;
      var even = this.isEven(page);
      if (even) {
        template = this.EvenBottom != null ? this.EvenBottom : this.bottom;
      } else {
        template = this.OddBottom != null ? this.OddBottom : this.bottom;
      }
      return template;
    };
    PdfDocumentTemplate2.prototype.isEven = function(page) {
      var pages = page.section.document.pages;
      var index = 0;
      if (pages.pageCollectionIndex.containsKey(page)) {
        index = pages.pageCollectionIndex.getValue(page) + 1;
      } else {
        index = pages.indexOf(page) + 1;
      }
      var even = index % 2 === 0;
      return even;
    };
    PdfDocumentTemplate2.prototype.checkElement = function(templateElement, type) {
      if (templateElement != null) {
        if (typeof templateElement.type !== "undefined" && templateElement.type !== TemplateType.None) {
          throw new Error("NotSupportedException:Can not reassign the template element. Please, create new one.");
        }
        templateElement.type = type;
      }
      return templateElement;
    };
    return PdfDocumentTemplate2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-section-templates.js
var __extends35 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfSectionTemplate = (
  /** @class */
  (function(_super) {
    __extends35(PdfSectionTemplate2, _super);
    function PdfSectionTemplate2() {
      var _this = _super.call(this) || this;
      _this.leftValue = _this.topValue = _this.rightValue = _this.bottomValue = _this.stampValue = true;
      return _this;
    }
    Object.defineProperty(PdfSectionTemplate2.prototype, "applyDocumentLeftTemplate", {
      // Properties
      /**
       * Gets or sets value indicating whether parent `Left page template should be used or not`.
       * @private
       */
      get: function() {
        return this.leftValue;
      },
      set: function(value) {
        this.leftValue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionTemplate2.prototype, "applyDocumentTopTemplate", {
      /**
       * Gets or sets value indicating whether parent `Top page template should be used or not`.
       * @private
       */
      get: function() {
        return this.topValue;
      },
      set: function(value) {
        this.topValue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionTemplate2.prototype, "applyDocumentRightTemplate", {
      /**
       * Gets or sets value indicating whether parent `Right page template should be used or not`.
       * @private
       */
      get: function() {
        return this.rightValue;
      },
      set: function(value) {
        this.rightValue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionTemplate2.prototype, "applyDocumentBottomTemplate", {
      /**
       * Gets or sets value indicating whether parent `Bottom page template should be used or not`.
       * @private
       */
      get: function() {
        return this.bottomValue;
      },
      set: function(value) {
        this.bottomValue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionTemplate2.prototype, "applyDocumentStamps", {
      /**
       * Gets or sets value indicating whether the `stamp value` is true or not.
       * @private
       */
      get: function() {
        return this.stampValue;
      },
      set: function(value) {
        this.stampValue = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfSectionTemplate2;
  })(PdfDocumentTemplate)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-section.js
var PdfSection = (
  /** @class */
  (function() {
    function PdfSection2(document2, pageSettings) {
      this.pageAdded = new PageAddedEventArgs();
      this.pdfPages = [];
      this.dictionaryProperties = new DictionaryProperties();
      this.pdfDocument = document2;
      if (typeof pageSettings === "undefined") {
        this.settings = document2.pageSettings.clone();
        this.initialSettings = this.settings.clone();
      } else {
        this.settings = pageSettings.clone();
        this.initialSettings = this.settings.clone();
      }
      this.initialize();
    }
    Object.defineProperty(PdfSection2.prototype, "parent", {
      //Property
      /**
       * Gets or sets the `parent`.
       * @private
       */
      get: function() {
        return this.sectionCollection;
      },
      set: function(value) {
        this.sectionCollection = value;
        this.section.items.setValue(this.dictionaryProperties.parent, new PdfReferenceHolder(value));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "parentDocument", {
      /**
       * Gets the `parent document`.
       * @private
       */
      get: function() {
        return this.pdfDocument;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "pageSettings", {
      /**
       * Gets or sets the `page settings` of the section.
       * @private
       */
      get: function() {
        return this.settings;
      },
      set: function(value) {
        if (value != null) {
          this.settings = value;
        } else {
          throw Error("Value can not be null.");
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "element", {
      /**
       * Gets the wrapped `element`.
       * @private
       */
      get: function() {
        return this.section;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "count", {
      /**
       * Gets the `count` of the pages in the section.
       * @private
       */
      get: function() {
        return this.pagesReferences.count;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "template", {
      /**
       * Gets or sets a `template` for the pages in the section.
       * @private
       */
      get: function() {
        if (this.pageTemplate == null) {
          this.pageTemplate = new PdfSectionTemplate();
        }
        return this.pageTemplate;
      },
      set: function(value) {
        this.pageTemplate = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "document", {
      /**
       * Gets the `document`.
       * @private
       */
      get: function() {
        return this.sectionCollection.document;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSection2.prototype, "pages", {
      /**
       * Gets the collection of `pages` in a section (Read only)
       * @private
       */
      get: function() {
        if (this.pagesCollection == null || typeof this.pagesCollection === "undefined") {
          this.pagesCollection = new PdfSectionPageCollection(this);
        }
        return this.pagesCollection;
      },
      enumerable: true,
      configurable: true
    });
    PdfSection2.prototype.getPages = function() {
      return this.pdfPages;
    };
    PdfSection2.prototype.pointToNativePdf = function(page, point) {
      var bounds = this.getActualBounds(page, true);
      point.x += bounds.x;
      point.y = this.pageSettings.height - point.y;
      return point;
    };
    PdfSection2.prototype.setPageSettings = function(settings) {
      this.settings = settings;
      this.state.orientation = settings.orientation;
      this.state.rotate = settings.rotate;
      this.state.size = settings.size;
      this.state.origin = settings.origin;
    };
    PdfSection2.prototype.initialize = function() {
      this.pagesReferences = new PdfArray();
      this.section = new PdfDictionary();
      this.state = new PageSettingsState(this.pdfDocument);
      this.section.sectionBeginSave = new SaveSectionEventHandler(this, this.state);
      this.pageCount = new PdfNumber(0);
      this.section.items.setValue(this.dictionaryProperties.count, this.pageCount);
      this.section.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.pages));
      this.section.items.setValue(this.dictionaryProperties.kids, this.pagesReferences);
    };
    PdfSection2.prototype.containsTemplates = function(document2, page, foreground) {
      var documentHeaders = this.getDocumentTemplates(document2, page, foreground);
      var sectionTemplates = this.getSectionTemplates(page, foreground);
      return documentHeaders.length > 0 || sectionTemplates.length > 0;
    };
    PdfSection2.prototype.getDocumentTemplates = function(document2, page, foreground) {
      var templates = [];
      if (this.template.applyDocumentTopTemplate && document2.template.getTop(page) != null) {
        if (!(document2.template.getTop(page).foreground || foreground) || document2.template.getTop(page).foreground && foreground) {
          templates.push(document2.template.getTop(page));
        }
      }
      if (this.template.applyDocumentBottomTemplate && document2.template.getBottom(page) != null) {
        if (!(document2.template.getBottom(page).foreground || foreground) || document2.template.getBottom(page).foreground && foreground) {
          templates.push(document2.template.getBottom(page));
        }
      }
      if (this.template.applyDocumentLeftTemplate && document2.template.getLeft(page) != null) {
        if (!(document2.template.getLeft(page).foreground || foreground) || document2.template.getLeft(page).foreground && foreground) {
          templates.push(document2.template.getLeft(page));
        }
      }
      if (this.template.applyDocumentRightTemplate && document2.template.getRight(page) != null) {
        if (!(document2.template.getRight(page).foreground || foreground) || document2.template.getRight(page).foreground && foreground) {
          templates.push(document2.template.getRight(page));
        }
      }
      return templates;
    };
    PdfSection2.prototype.getSectionTemplates = function(page, foreground) {
      var templates = [];
      if (this.template.getTop(page) != null) {
        var pageTemplate = this.template.getTop(page);
        if (!(pageTemplate.foreground || foreground) || pageTemplate.foreground && foreground) {
          templates.push(pageTemplate);
        }
      }
      if (this.template.getBottom(page) != null) {
        var pageTemplate = this.template.getBottom(page);
        if (!(pageTemplate.foreground || foreground) || pageTemplate.foreground && foreground) {
          templates.push(pageTemplate);
        }
      }
      if (this.template.getLeft(page) != null) {
        var pageTemplate = this.template.getLeft(page);
        if (!(pageTemplate.foreground || foreground) || pageTemplate.foreground && foreground) {
          templates.push(pageTemplate);
        }
      }
      if (this.template.getRight(page) != null) {
        var pageTemplate = this.template.getRight(page);
        if (!(pageTemplate.foreground || foreground) || pageTemplate.foreground && foreground) {
          templates.push(pageTemplate);
        }
      }
      return templates;
    };
    PdfSection2.prototype.add = function(page) {
      if (typeof page === "undefined") {
        var page_1 = new PdfPage();
        this.add(page_1);
        return page_1;
      } else {
        var r = this.checkPresence(page);
        this.pdfPages.push(page);
        this.pagesReferences.add(r);
        page.setSection(this);
        page.resetProgress();
        this.pageAddedMethod(page);
      }
    };
    PdfSection2.prototype.checkPresence = function(page) {
      var rh = new PdfReferenceHolder(page);
      var contains = false;
      var sc = this.parent;
      for (var index = 0; index < sc.section.length; index++) {
        var section = sc.section[index];
        contains = contains || section.contains(page);
      }
      return rh;
    };
    PdfSection2.prototype.contains = function(page) {
      var index = this.indexOf(page);
      return 0 <= index;
    };
    PdfSection2.prototype.indexOf = function(page) {
      for (var index = 0; index < this.pdfPages.length; index++) {
        if (this.pdfPages[index] === page) {
          return this.pdfPages.indexOf(page);
        }
      }
      var r = new PdfReferenceHolder(page);
      return this.pagesReferences.indexOf(r);
    };
    PdfSection2.prototype.pageAddedMethod = function(page) {
      var args = new PageAddedEventArgs(page);
      this.onPageAdded(args);
      var parent = this.parent;
      parent.document.pages.onPageAdded(args);
      this.pageCount.intValue = this.count;
    };
    PdfSection2.prototype.onPageAdded = function(args) {
    };
    PdfSection2.prototype.getActualBounds = function(arg1, arg2, arg3) {
      if (arg1 instanceof PdfPage && typeof arg2 === "boolean") {
        var result = void 0;
        var document_1 = this.parent.document;
        result = this.getActualBounds(document_1, arg1, arg2);
        return result;
      } else {
        arg1 = arg1;
        arg2 = arg2;
        arg3 = arg3;
        var bounds = new RectangleF(0, 0, 0, 0);
        bounds.height = arg3 ? this.pageSettings.size.height : this.pageSettings.getActualSize().height;
        bounds.width = arg3 ? this.pageSettings.size.width : this.pageSettings.getActualSize().width;
        var left = this.getLeftIndentWidth(arg1, arg2, arg3);
        var top_1 = this.getTopIndentHeight(arg1, arg2, arg3);
        var right = this.getRightIndentWidth(arg1, arg2, arg3);
        var bottom = this.getBottomIndentHeight(arg1, arg2, arg3);
        bounds.x += left;
        bounds.y += top_1;
        bounds.width -= left + right;
        bounds.height -= top_1 + bottom;
        return bounds;
      }
    };
    PdfSection2.prototype.getLeftIndentWidth = function(document2, page, includeMargins) {
      if (document2 == null) {
        throw new Error("ArgumentNullException:document");
      }
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var value = includeMargins ? this.pageSettings.margins.left : 0;
      var templateWidth = this.template.getLeft(page) != null ? this.template.getLeft(page).width : 0;
      var docTemplateWidth = document2.template.getLeft(page) != null ? document2.template.getLeft(page).width : 0;
      value += this.template.applyDocumentLeftTemplate ? Math.max(templateWidth, docTemplateWidth) : templateWidth;
      return value;
    };
    PdfSection2.prototype.getTopIndentHeight = function(document2, page, includeMargins) {
      if (document2 == null) {
        throw new Error("ArgumentNullException:document");
      }
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var value = includeMargins ? this.pageSettings.margins.top : 0;
      var templateHeight = this.template.getTop(page) != null ? this.template.getTop(page).height : 0;
      var docTemplateHeight = document2.template.getTop(page) != null ? document2.template.getTop(page).height : 0;
      value += this.template.applyDocumentTopTemplate ? Math.max(templateHeight, docTemplateHeight) : templateHeight;
      return value;
    };
    PdfSection2.prototype.getRightIndentWidth = function(document2, page, includeMargins) {
      if (document2 == null) {
        throw new Error("ArgumentNullException:document");
      }
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var value = includeMargins ? this.pageSettings.margins.right : 0;
      var templateWidth = this.template.getRight(page) != null ? this.template.getRight(page).width : 0;
      var docTemplateWidth = document2.template.getRight(page) != null ? document2.template.getRight(page).width : 0;
      value += this.template.applyDocumentRightTemplate ? Math.max(templateWidth, docTemplateWidth) : templateWidth;
      return value;
    };
    PdfSection2.prototype.getBottomIndentHeight = function(document2, page, includeMargins) {
      if (document2 == null) {
        throw new Error("ArgumentNullException:document");
      }
      if (page == null) {
        throw new Error("ArgumentNullException:page");
      }
      var value = includeMargins ? this.pageSettings.margins.bottom : 0;
      var templateHeight = this.template.getBottom(page) != null ? this.template.getBottom(page).height : 0;
      var docTemplateHeight = document2.template.getBottom(page) != null ? document2.template.getBottom(page).height : 0;
      value += this.template.applyDocumentBottomTemplate ? Math.max(templateHeight, docTemplateHeight) : templateHeight;
      return value;
    };
    PdfSection2.prototype.remove = function(page) {
      if (page == null) {
        throw Error('ArgumentNullException("page")');
      }
      var index = this.pdfPages.indexOf(page);
      this.pagesReferences.removeAt(index);
      var temproaryPages = [];
      for (var j = 0; j < index; j++) {
        temproaryPages.push(this.pdfPages[j]);
      }
      for (var j = index + 1; j < this.pdfPages.length; j++) {
        temproaryPages.push(this.pdfPages[j]);
      }
      this.pdfPages = temproaryPages;
    };
    PdfSection2.prototype.applyPageSettings = function(container, parentSettings, state) {
      var bounds = new RectangleF(state.origin, state.size);
      container.items.setValue(this.dictionaryProperties.mediaBox, PdfArray.fromRectangle(bounds));
      var rotate = 0;
      rotate = PdfSectionCollection.rotateFactor * state.rotate;
      var angle = new PdfNumber(rotate);
      container.items.setValue(this.dictionaryProperties.rotate, angle);
    };
    PdfSection2.prototype.beginSave = function(state, writer) {
      var doc = writer.document;
      this.applyPageSettings(this.section, doc.pageSettings, state);
    };
    PdfSection2.prototype.drawTemplates = function(page, layer, document2, foreground) {
      var documentHeaders = this.getDocumentTemplates(document2, page, foreground);
      var sectionHeaders = this.getSectionTemplates(page, foreground);
      this.drawTemplatesHelper(layer, document2, documentHeaders);
      this.drawTemplatesHelper(layer, document2, sectionHeaders);
    };
    PdfSection2.prototype.drawTemplatesHelper = function(layer, document2, templates) {
      if (templates != null && templates.length > 0) {
        var len = templates.length;
        for (var i = 0; i < len; i++) {
          var template = templates[i];
          template.draw(layer, document2);
        }
      }
    };
    return PdfSection2;
  })()
);
var PageSettingsState = (
  /** @class */
  (function() {
    function PageSettingsState2(document2) {
      this.pageOrientation = document2.pageSettings.orientation;
      this.pageRotate = document2.pageSettings.rotate;
      this.pageSize = document2.pageSettings.size;
      this.pageOrigin = document2.pageSettings.origin;
    }
    Object.defineProperty(PageSettingsState2.prototype, "orientation", {
      //public Properties
      /**
       * @hidden
       * @private
       */
      get: function() {
        return this.pageOrientation;
      },
      set: function(value) {
        this.pageOrientation = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PageSettingsState2.prototype, "rotate", {
      /**
       * @hidden
       * @private
       */
      get: function() {
        return this.pageRotate;
      },
      set: function(value) {
        this.pageRotate = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PageSettingsState2.prototype, "size", {
      /**
       * @hidden
       * @private
       */
      get: function() {
        return this.pageSize;
      },
      set: function(value) {
        this.pageSize = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PageSettingsState2.prototype, "origin", {
      /**
       * @hidden
       * @private
       */
      get: function() {
        return this.pageOrigin;
      },
      set: function(value) {
        this.pageOrigin = value;
      },
      enumerable: true,
      configurable: true
    });
    return PageSettingsState2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-section-collection.js
var PdfSectionCollection = (
  /** @class */
  (function() {
    function PdfSectionCollection2(document2) {
      this.sections = [];
      this.dictionaryProperties = new DictionaryProperties();
      this.pdfDocument = document2.clone();
      this.initialize();
    }
    Object.defineProperty(PdfSectionCollection2.prototype, "section", {
      //Properties
      /**
       * Gets the `Section` collection.
       */
      get: function() {
        return this.sections;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionCollection2.prototype, "document", {
      /**
       * Gets a parent `document`.
       * @private
       */
      get: function() {
        return this.pdfDocument;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionCollection2.prototype, "count", {
      /**
       * Gets the `number of sections` in a document.
       * @private
       */
      get: function() {
        return this.sections.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfSectionCollection2.prototype, "element", {
      /**
       * Gets the wrapped `element`.
       * @private
       */
      get: function() {
        return this.pages;
      },
      enumerable: true,
      configurable: true
    });
    PdfSectionCollection2.prototype.initialize = function() {
      this.sectionCount = new PdfNumber(0);
      this.sectionCollection = new PdfArray();
      this.pages = new PdfDictionary();
      this.pages.beginSave = new SaveSectionCollectionEventHandler(this);
      this.pages.items.setValue(this.dictionaryProperties.type, new PdfName("Pages"));
      this.pages.items.setValue(this.dictionaryProperties.kids, this.sectionCollection);
      this.pages.items.setValue(this.dictionaryProperties.count, this.sectionCount);
      this.pages.items.setValue(this.dictionaryProperties.resources, new PdfDictionary());
      this.setPageSettings(this.pages, this.pdfDocument.pageSettings);
    };
    PdfSectionCollection2.prototype.pdfSectionCollection = function(index) {
      if (index < 0 || index >= this.count) {
        throw new Error("IndexOutOfRangeException()");
      }
      return this.sections[index];
    };
    PdfSectionCollection2.prototype.setPageSettings = function(container, pageSettings) {
      var bounds = new RectangleF(new PointF(), pageSettings.size);
      container.items.setValue(this.dictionaryProperties.mediaBox, PdfArray.fromRectangle(bounds));
    };
    PdfSectionCollection2.prototype.add = function(section) {
      if (typeof section === "undefined") {
        var section_1 = new PdfSection(this.pdfDocument);
        this.add(section_1);
        return section_1;
      } else {
        var r = this.checkSection(section);
        this.sections.push(section);
        section.parent = this;
        this.sectionCollection.add(r);
        return this.sections.indexOf(section);
      }
    };
    PdfSectionCollection2.prototype.checkSection = function(section) {
      var r = new PdfReferenceHolder(section);
      var contains = this.sectionCollection.contains(r);
      return r;
    };
    PdfSectionCollection2.prototype.countPages = function() {
      var count = 0;
      this.sections.forEach(function(n) {
        return count += n.count;
      });
      return count;
    };
    PdfSectionCollection2.prototype.beginSave = function() {
      this.sectionCount.intValue = this.countPages();
    };
    PdfSectionCollection2.rotateFactor = 90;
    return PdfSectionCollection2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-document-page-collection.js
var PdfDocumentPageCollection = (
  /** @class */
  (function() {
    function PdfDocumentPageCollection2(document2) {
      this.pdfPageCollectionIndex = new Dictionary();
      this.document = document2;
    }
    Object.defineProperty(PdfDocumentPageCollection2.prototype, "count", {
      //Property
      /**
       * Gets the total `number of the pages`.
       * @private
       */
      get: function() {
        return this.countPages();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocumentPageCollection2.prototype, "pageCollectionIndex", {
      /**
       * Gets a `page index` from the document.
       * @private
       */
      get: function() {
        return this.pdfPageCollectionIndex;
      },
      enumerable: true,
      configurable: true
    });
    PdfDocumentPageCollection2.prototype.add = function(page) {
      if (typeof page === "undefined") {
        var page_1 = new PdfPage();
        this.add(page_1);
        return page_1;
      } else {
        var section = this.getLastSection();
        section.add(page);
      }
    };
    PdfDocumentPageCollection2.prototype.getLastSection = function() {
      var sc = this.document.sections;
      if (sc.section.length === 0) {
        sc.add();
      }
      var section = sc.section[sc.section.length - 1];
      return section;
    };
    PdfDocumentPageCollection2.prototype.onPageAdded = function(args) {
    };
    PdfDocumentPageCollection2.prototype.countPages = function() {
      var sc = this.document.sections;
      var count = 0;
      for (var index = 0; index < sc.section.length; index++) {
        count += sc.section[index].count;
      }
      return count;
    };
    PdfDocumentPageCollection2.prototype.getPageByIndex = function(index) {
      return this.getPage(index);
    };
    PdfDocumentPageCollection2.prototype.getPage = function(index) {
      if (index < 0 || index >= this.count) {
        throw Error('ArgumentOutOfRangeException("index", "Value can not be less 0")');
      }
      var page = null;
      var sectionStartIndex = 0;
      var sectionCount = 0;
      var pageIndex = 0;
      var length = this.document.sections.count;
      for (var i = 0; i < length; i++) {
        var section = this.document.sections.section[i];
        sectionCount = section.count;
        pageIndex = index - sectionStartIndex;
        if (index >= sectionStartIndex && pageIndex < sectionCount) {
          page = section.getPages()[pageIndex];
          break;
        }
        sectionStartIndex += sectionCount;
      }
      return page;
    };
    PdfDocumentPageCollection2.prototype.indexOf = function(page) {
      var index = -1;
      if (page == null) {
        throw new Error("ArgumentNullException: page");
      } else {
        var numPages = 0;
        for (var i = 0, len = this.document.sections.count; i < len; i++) {
          var section = this.document.sections.pdfSectionCollection(i);
          index = section.indexOf(page);
          if (index >= 0) {
            index += numPages;
            break;
          } else {
            index = -1;
          }
          numPages += section.count;
        }
      }
      return index;
    };
    PdfDocumentPageCollection2.prototype.remove = function(page) {
      if (page == null) {
        throw Error('ArgumentNullException("page")');
      }
      var section = null;
      var len;
      for (var i = 0, len_1 = this.document.sections.count; i < len_1; i++) {
        section = this.document.sections.pdfSectionCollection(i);
        if (section.pages.contains(page)) {
          section.pages.remove(page);
          break;
        }
      }
      return section;
    };
    return PdfDocumentPageCollection2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/general/pdf-cache-collection.js
var PdfCacheCollection = (
  /** @class */
  (function() {
    function PdfCacheCollection2() {
      this.referenceObjects = [];
      this.pdfFontCollection = new Dictionary();
    }
    PdfCacheCollection2.prototype.search = function(obj) {
      var result = null;
      var group = this.getGroup(obj);
      if (group == null) {
        group = this.createNewGroup();
      } else if (group.length > 0) {
        result = group[0];
      }
      group.push(obj);
      return result;
    };
    PdfCacheCollection2.prototype.createNewGroup = function() {
      var group = [];
      this.referenceObjects.push(group);
      return group;
    };
    PdfCacheCollection2.prototype.getGroup = function(result) {
      var group = null;
      if (result !== null) {
        var len = this.referenceObjects.length;
        for (var i = 0; i < len; i++) {
          if (this.referenceObjects.length > 0) {
            var tGroup = this.referenceObjects[i];
            if (tGroup.length > 0) {
              var representative = tGroup[0];
              if (result.equalsTo(representative)) {
                group = tGroup;
                break;
              }
            } else {
              this.removeGroup(tGroup);
            }
          }
          len = this.referenceObjects.length;
        }
      }
      return group;
    };
    PdfCacheCollection2.prototype.removeGroup = function(group) {
      if (group !== null) {
        var index = this.referenceObjects.indexOf(group);
        this.referenceObjects.slice(index, index + 1);
      }
    };
    PdfCacheCollection2.prototype.destroy = function() {
      this.pdfFontCollection = void 0;
      this.referenceObjects = void 0;
    };
    return PdfCacheCollection2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/pdf-document.js
var __extends36 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfDocument = (
  /** @class */
  (function(_super) {
    __extends36(PdfDocument2, _super);
    function PdfDocument2(isMerging) {
      var _this = _super.call(this) || this;
      _this.defaultMargin = 40;
      _this.streamWriter = null;
      _this.document = _this;
      var isMerge = false;
      if (typeof isMerging === "undefined") {
        PdfDocument2.cacheCollection = new PdfCacheCollection();
        isMerge = false;
      } else {
        isMerge = isMerging;
      }
      var objects = new PdfMainObjectCollection();
      _this.setMainObjectCollection(objects);
      var crossTable = new PdfCrossTable();
      crossTable.isMerging = isMerge;
      crossTable.document = _this;
      _this.setCrossTable(crossTable);
      var catalog = new PdfCatalog();
      _this.setCatalog(catalog);
      objects.add(catalog);
      catalog.position = -1;
      _this.sectionCollection = new PdfSectionCollection(_this);
      _this.documentPageCollection = new PdfDocumentPageCollection(_this);
      catalog.pages = _this.sectionCollection;
      return _this;
    }
    Object.defineProperty(PdfDocument2, "defaultFont", {
      //Properties
      /**
       * Gets the `default font`. It is used for complex objects when font is not explicitly defined.
       * @private
       */
      get: function() {
        if (this.defaultStandardFont == null) {
          this.defaultStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 8);
        }
        return this.defaultStandardFont;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2.prototype, "sections", {
      /**
       * Gets the collection of the `sections` in the document.
       * @private
       */
      get: function() {
        return this.sectionCollection;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2.prototype, "pageSettings", {
      /**
       * Gets the document's page setting.
       * @public
       */
      get: function() {
        if (this.settings == null) {
          this.settings = new PdfPageSettings(this.defaultMargin);
        }
        return this.settings;
      },
      /**
       * Sets the document's page setting.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       *
       * // sets the right margin of the page
       * document.pageSettings.margins.right = 0;
       * // set the page size.
       * document.pageSettings.size = new SizeF(500, 500);
       * // change the page orientation to landscape
       * document.pageSettings.orientation = PdfPageOrientation.Landscape;
       * // apply 90 degree rotation on the page
       * document.pageSettings.rotate = PdfPageRotateAngle.RotateAngle90;
       *
       * // add a pages to the document
       * let page1 : PdfPage = document.pages.add();
       * // set font
       * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
       * // set brush
       * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
       * // set the specified Point
       * let point : PointF = new PointF(page1.getClientSize().width - 200, page1.getClientSize().height - 200);
       * // draw the text
       * page1.graphics.drawString('Hello World', font, blackBrush, point);
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      set: function(value) {
        this.settings = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2.prototype, "pages", {
      /**
       * Represents the collection of pages in the PDF document.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * //
       * // get the collection of pages in the document
       * let pageCollection : PdfDocumentPageCollection  = document.pages;
       * //
       * // add pages
       * let page1 : PdfPage = pageCollection.add();
       * // save the document
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.documentPageCollection;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2, "cache", {
      /**
       * Gets collection of the `cached objects`.
       * @private
       */
      get: function() {
        if (typeof PdfDocument2.cacheCollection === "undefined" || PdfDocument2.cacheCollection == null) {
          return new PdfCacheCollection();
        }
        return PdfDocument2.cacheCollection;
      },
      /**
       * Sets collection of the `cached objects`.
       * @private
       */
      set: function(value) {
        this.cacheCollection = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2, "enableCache", {
      /**
       * Gets the value of enable cache.
       * @private
       */
      get: function() {
        return this.isCacheEnabled;
      },
      /**
       * Sets thie value of enable cache.
       * @private
       */
      set: function(value) {
        this.isCacheEnabled = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2.prototype, "colorSpace", {
      /* tslint:disable */
      /**
       * Gets or sets the `color space` of the document. This property can be used to create PDF document in RGB, Gray scale or CMYK color spaces.
       * @private
       */
      get: function() {
        if (this.pdfColorSpace === PdfColorSpace.Rgb || (this.pdfColorSpace === PdfColorSpace.Cmyk || this.pdfColorSpace === PdfColorSpace.GrayScale)) {
          return this.pdfColorSpace;
        } else {
          return PdfColorSpace.Rgb;
        }
      },
      set: function(value) {
        if (value === PdfColorSpace.Rgb || (value === PdfColorSpace.Cmyk || value === PdfColorSpace.GrayScale)) {
          this.pdfColorSpace = value;
        } else {
          this.pdfColorSpace = PdfColorSpace.Rgb;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDocument2.prototype, "template", {
      /* tslint:enable */
      /**
       * Gets or sets a `template` to all pages in the document.
       * @private
       */
      get: function() {
        if (this.pageTemplate == null) {
          this.pageTemplate = new PdfDocumentTemplate();
        }
        return this.pageTemplate;
      },
      set: function(value) {
        this.pageTemplate = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfDocument2.prototype.docSave = function(stream, arg2, arg3) {
      this.checkPagesPresence();
      if (stream === null) {
        throw new Error("ArgumentNullException : stream");
      }
      this.streamWriter = stream;
      var writer = new PdfWriter(stream);
      writer.document = this;
      if (typeof arg2 === "boolean" && typeof arg3 === "undefined") {
        return this.crossTable.save(writer);
      } else {
        this.crossTable.save(writer, arg2);
      }
    };
    PdfDocument2.prototype._docSave = function() {
      var stream = new PdfWriterHelper();
      this.checkPagesPresence();
      if (stream === null) {
        throw new Error("ArgumentNullException : stream");
      }
      this.streamWriter = stream;
      var writer = new PdfWriter(stream);
      writer.document = this;
      return this.crossTable._save(writer);
    };
    PdfDocument2.prototype.checkPagesPresence = function() {
      if (this.pages.count === 0) {
        this.pages.add();
      }
    };
    PdfDocument2.prototype.destroy = function() {
      this.catalog = void 0;
      this.colorSpace = void 0;
      this.currentSavingObj = void 0;
      this.documentPageCollection = void 0;
      this.isStreamCopied = void 0;
      this.pageSettings = void 0;
      this.pageTemplate = void 0;
      this.pdfColorSpace = void 0;
      this.sectionCollection = void 0;
      PdfDocument2.cache.destroy();
      this.crossTable.pdfObjects.destroy();
      PdfDocument2.cache = void 0;
      if (this.streamWriter) {
        this.streamWriter.destroy();
      }
    };
    PdfDocument2.defaultStandardFont = null;
    PdfDocument2.isCacheEnabled = true;
    return PdfDocument2;
  })(PdfDocumentBase)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/pdf-standard-font-metrics-factory.js
var PdfStandardFontMetricsFactory = (
  /** @class */
  (function() {
    function PdfStandardFontMetricsFactory2() {
    }
    PdfStandardFontMetricsFactory2.getMetrics = function(fontFamily, fontStyle, size) {
      var metrics = null;
      switch (fontFamily) {
        case PdfFontFamily.Helvetica:
          metrics = this.getHelveticaMetrics(fontFamily, fontStyle, size);
          break;
        case PdfFontFamily.Courier:
          metrics = this.getCourierMetrics(fontFamily, fontStyle, size);
          break;
        case PdfFontFamily.TimesRoman:
          metrics = this.getTimesMetrics(fontFamily, fontStyle, size);
          break;
        case PdfFontFamily.Symbol:
          metrics = this.getSymbolMetrics(fontFamily, fontStyle, size);
          break;
        case PdfFontFamily.ZapfDingbats:
          metrics = this.getZapfDingbatsMetrics(fontFamily, fontStyle, size);
          break;
        default:
          metrics = this.getHelveticaMetrics(PdfFontFamily.Helvetica, fontStyle, size);
          break;
      }
      metrics.name = fontFamily.toString();
      metrics.subScriptSizeFactor = this.subSuperScriptFactor;
      metrics.superscriptSizeFactor = this.subSuperScriptFactor;
      return metrics;
    };
    PdfStandardFontMetricsFactory2.getHelveticaMetrics = function(fontFamily, fontStyle, size) {
      var metrics = new PdfFontMetrics();
      if ((fontStyle & PdfFontStyle.Bold) > 0 && (fontStyle & PdfFontStyle.Italic) > 0) {
        metrics.ascent = this.helveticaBoldItalicAscent;
        metrics.descent = this.helveticaBoldItalicDescent;
        metrics.postScriptName = this.helveticaBoldItalicName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.arialBoldWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else if ((fontStyle & PdfFontStyle.Bold) > 0) {
        metrics.ascent = this.helveticaBoldAscent;
        metrics.descent = this.helveticaBoldDescent;
        metrics.postScriptName = this.helveticaBoldName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.arialBoldWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else if ((fontStyle & PdfFontStyle.Italic) > 0) {
        metrics.ascent = this.helveticaItalicAscent;
        metrics.descent = this.helveticaItalicDescent;
        metrics.postScriptName = this.helveticaItalicName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.arialWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else {
        metrics.ascent = this.helveticaAscent;
        metrics.descent = this.helveticaDescent;
        metrics.postScriptName = this.helveticaName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.arialWidth);
        metrics.height = metrics.ascent - metrics.descent;
      }
      return metrics;
    };
    PdfStandardFontMetricsFactory2.getCourierMetrics = function(fontFamily, fontStyle, size) {
      var metrics = new PdfFontMetrics();
      if ((fontStyle & PdfFontStyle.Bold) > 0 && (fontStyle & PdfFontStyle.Italic) > 0) {
        metrics.ascent = this.courierBoldItalicAscent;
        metrics.descent = this.courierBoldItalicDescent;
        metrics.postScriptName = this.courierBoldItalicName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.fixedWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else if ((fontStyle & PdfFontStyle.Bold) > 0) {
        metrics.ascent = this.courierBoldAscent;
        metrics.descent = this.courierBoldDescent;
        metrics.postScriptName = this.courierBoldName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.fixedWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else if ((fontStyle & PdfFontStyle.Italic) > 0) {
        metrics.ascent = this.courierItalicAscent;
        metrics.descent = this.courierItalicDescent;
        metrics.postScriptName = this.courierItalicName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.fixedWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else {
        metrics.ascent = this.courierAscent;
        metrics.descent = this.courierDescent;
        metrics.postScriptName = this.courierName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.fixedWidth);
        metrics.height = metrics.ascent - metrics.descent;
      }
      return metrics;
    };
    PdfStandardFontMetricsFactory2.getTimesMetrics = function(fontFamily, fontStyle, size) {
      var metrics = new PdfFontMetrics();
      if ((fontStyle & PdfFontStyle.Bold) > 0 && (fontStyle & PdfFontStyle.Italic) > 0) {
        metrics.ascent = this.timesBoldItalicAscent;
        metrics.descent = this.timesBoldItalicDescent;
        metrics.postScriptName = this.timesBoldItalicName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.timesRomanBoldItalicWidths);
        metrics.height = metrics.ascent - metrics.descent;
      } else if ((fontStyle & PdfFontStyle.Bold) > 0) {
        metrics.ascent = this.timesBoldAscent;
        metrics.descent = this.timesBoldDescent;
        metrics.postScriptName = this.timesBoldName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.timesRomanBoldWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else if ((fontStyle & PdfFontStyle.Italic) > 0) {
        metrics.ascent = this.timesItalicAscent;
        metrics.descent = this.timesItalicDescent;
        metrics.postScriptName = this.timesItalicName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.timesRomanItalicWidth);
        metrics.height = metrics.ascent - metrics.descent;
      } else {
        metrics.ascent = this.timesAscent;
        metrics.descent = this.timesDescent;
        metrics.postScriptName = this.timesName;
        metrics.size = size;
        metrics.widthTable = new StandardWidthTable(this.timesRomanWidth);
        metrics.height = metrics.ascent - metrics.descent;
      }
      return metrics;
    };
    PdfStandardFontMetricsFactory2.getSymbolMetrics = function(fontFamily, fontStyle, size) {
      var metrics = new PdfFontMetrics();
      metrics.ascent = this.symbolAscent;
      metrics.descent = this.symbolDescent;
      metrics.postScriptName = this.symbolName;
      metrics.size = size;
      metrics.widthTable = new StandardWidthTable(this.symbolWidth);
      metrics.height = metrics.ascent - metrics.descent;
      return metrics;
    };
    PdfStandardFontMetricsFactory2.getZapfDingbatsMetrics = function(fontFamily, fontStyle, size) {
      var metrics = new PdfFontMetrics();
      metrics.ascent = this.zapfDingbatsAscent;
      metrics.descent = this.zapfDingbatsDescent;
      metrics.postScriptName = this.zapfDingbatsName;
      metrics.size = size;
      metrics.widthTable = new StandardWidthTable(this.zapfDingbatsWidth);
      metrics.height = metrics.ascent - metrics.descent;
      return metrics;
    };
    PdfStandardFontMetricsFactory2.subSuperScriptFactor = 1.52;
    PdfStandardFontMetricsFactory2.helveticaAscent = 931;
    PdfStandardFontMetricsFactory2.helveticaDescent = -225;
    PdfStandardFontMetricsFactory2.helveticaName = "Helvetica";
    PdfStandardFontMetricsFactory2.helveticaBoldAscent = 962;
    PdfStandardFontMetricsFactory2.helveticaBoldDescent = -228;
    PdfStandardFontMetricsFactory2.helveticaBoldName = "Helvetica-Bold";
    PdfStandardFontMetricsFactory2.helveticaItalicAscent = 931;
    PdfStandardFontMetricsFactory2.helveticaItalicDescent = -225;
    PdfStandardFontMetricsFactory2.helveticaItalicName = "Helvetica-Oblique";
    PdfStandardFontMetricsFactory2.helveticaBoldItalicAscent = 962;
    PdfStandardFontMetricsFactory2.helveticaBoldItalicDescent = -228;
    PdfStandardFontMetricsFactory2.helveticaBoldItalicName = "Helvetica-BoldOblique";
    PdfStandardFontMetricsFactory2.courierAscent = 805;
    PdfStandardFontMetricsFactory2.courierDescent = -250;
    PdfStandardFontMetricsFactory2.courierName = "Courier";
    PdfStandardFontMetricsFactory2.courierBoldAscent = 801;
    PdfStandardFontMetricsFactory2.courierBoldDescent = -250;
    PdfStandardFontMetricsFactory2.courierBoldName = "Courier-Bold";
    PdfStandardFontMetricsFactory2.courierItalicAscent = 805;
    PdfStandardFontMetricsFactory2.courierItalicDescent = -250;
    PdfStandardFontMetricsFactory2.courierItalicName = "Courier-Oblique";
    PdfStandardFontMetricsFactory2.courierBoldItalicAscent = 801;
    PdfStandardFontMetricsFactory2.courierBoldItalicDescent = -250;
    PdfStandardFontMetricsFactory2.courierBoldItalicName = "Courier-BoldOblique";
    PdfStandardFontMetricsFactory2.timesAscent = 898;
    PdfStandardFontMetricsFactory2.timesDescent = -218;
    PdfStandardFontMetricsFactory2.timesName = "Times-Roman";
    PdfStandardFontMetricsFactory2.timesBoldAscent = 935;
    PdfStandardFontMetricsFactory2.timesBoldDescent = -218;
    PdfStandardFontMetricsFactory2.timesBoldName = "Times-Bold";
    PdfStandardFontMetricsFactory2.timesItalicAscent = 883;
    PdfStandardFontMetricsFactory2.timesItalicDescent = -217;
    PdfStandardFontMetricsFactory2.timesItalicName = "Times-Italic";
    PdfStandardFontMetricsFactory2.timesBoldItalicAscent = 921;
    PdfStandardFontMetricsFactory2.timesBoldItalicDescent = -218;
    PdfStandardFontMetricsFactory2.timesBoldItalicName = "Times-BoldItalic";
    PdfStandardFontMetricsFactory2.symbolAscent = 1010;
    PdfStandardFontMetricsFactory2.symbolDescent = -293;
    PdfStandardFontMetricsFactory2.symbolName = "Symbol";
    PdfStandardFontMetricsFactory2.zapfDingbatsAscent = 820;
    PdfStandardFontMetricsFactory2.zapfDingbatsDescent = -143;
    PdfStandardFontMetricsFactory2.zapfDingbatsName = "ZapfDingbats";
    PdfStandardFontMetricsFactory2.arialWidth = [
      278,
      278,
      355,
      556,
      556,
      889,
      667,
      191,
      333,
      333,
      389,
      584,
      278,
      333,
      278,
      278,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      278,
      278,
      584,
      584,
      584,
      556,
      1015,
      667,
      667,
      722,
      722,
      667,
      611,
      778,
      722,
      278,
      500,
      667,
      556,
      833,
      722,
      778,
      667,
      778,
      722,
      667,
      611,
      722,
      667,
      944,
      667,
      667,
      611,
      278,
      278,
      278,
      469,
      556,
      333,
      556,
      556,
      500,
      556,
      556,
      278,
      556,
      556,
      222,
      222,
      500,
      222,
      833,
      556,
      556,
      556,
      556,
      333,
      500,
      278,
      556,
      500,
      722,
      500,
      500,
      500,
      334,
      260,
      334,
      584,
      0,
      556,
      0,
      222,
      556,
      333,
      1e3,
      556,
      556,
      333,
      1e3,
      667,
      333,
      1e3,
      0,
      611,
      0,
      0,
      222,
      222,
      333,
      333,
      350,
      556,
      1e3,
      333,
      1e3,
      500,
      333,
      944,
      0,
      500,
      667,
      0,
      333,
      556,
      556,
      556,
      556,
      260,
      556,
      333,
      737,
      370,
      556,
      584,
      0,
      737,
      333,
      400,
      584,
      333,
      333,
      333,
      556,
      537,
      278,
      333,
      333,
      365,
      556,
      834,
      834,
      834,
      611,
      667,
      667,
      667,
      667,
      667,
      667,
      1e3,
      722,
      667,
      667,
      667,
      667,
      278,
      278,
      278,
      278,
      722,
      722,
      778,
      778,
      778,
      778,
      778,
      584,
      778,
      722,
      722,
      722,
      722,
      667,
      667,
      611,
      556,
      556,
      556,
      556,
      556,
      556,
      889,
      500,
      556,
      556,
      556,
      556,
      278,
      278,
      278,
      278,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      584,
      611,
      556,
      556,
      556,
      556,
      500,
      556,
      500
    ];
    PdfStandardFontMetricsFactory2.arialBoldWidth = [
      278,
      333,
      474,
      556,
      556,
      889,
      722,
      238,
      333,
      333,
      389,
      584,
      278,
      333,
      278,
      278,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      556,
      333,
      333,
      584,
      584,
      584,
      611,
      975,
      722,
      722,
      722,
      722,
      667,
      611,
      778,
      722,
      278,
      556,
      722,
      611,
      833,
      722,
      778,
      667,
      778,
      722,
      667,
      611,
      722,
      667,
      944,
      667,
      667,
      611,
      333,
      278,
      333,
      584,
      556,
      333,
      556,
      611,
      556,
      611,
      556,
      333,
      611,
      611,
      278,
      278,
      556,
      278,
      889,
      611,
      611,
      611,
      611,
      389,
      556,
      333,
      611,
      556,
      778,
      556,
      556,
      500,
      389,
      280,
      389,
      584,
      0,
      556,
      0,
      278,
      556,
      500,
      1e3,
      556,
      556,
      333,
      1e3,
      667,
      333,
      1e3,
      0,
      611,
      0,
      0,
      278,
      278,
      500,
      500,
      350,
      556,
      1e3,
      333,
      1e3,
      556,
      333,
      944,
      0,
      500,
      667,
      0,
      333,
      556,
      556,
      556,
      556,
      280,
      556,
      333,
      737,
      370,
      556,
      584,
      0,
      737,
      333,
      400,
      584,
      333,
      333,
      333,
      611,
      556,
      278,
      333,
      333,
      365,
      556,
      834,
      834,
      834,
      611,
      722,
      722,
      722,
      722,
      722,
      722,
      1e3,
      722,
      667,
      667,
      667,
      667,
      278,
      278,
      278,
      278,
      722,
      722,
      778,
      778,
      778,
      778,
      778,
      584,
      778,
      722,
      722,
      722,
      722,
      667,
      667,
      611,
      556,
      556,
      556,
      556,
      556,
      556,
      889,
      556,
      556,
      556,
      556,
      556,
      278,
      278,
      278,
      278,
      611,
      611,
      611,
      611,
      611,
      611,
      611,
      584,
      611,
      611,
      611,
      611,
      611,
      556,
      611,
      556
    ];
    PdfStandardFontMetricsFactory2.fixedWidth = [
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600,
      600
    ];
    PdfStandardFontMetricsFactory2.timesRomanWidth = [
      250,
      333,
      408,
      500,
      500,
      833,
      778,
      180,
      333,
      333,
      500,
      564,
      250,
      333,
      250,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      278,
      278,
      564,
      564,
      564,
      444,
      921,
      722,
      667,
      667,
      722,
      611,
      556,
      722,
      722,
      333,
      389,
      722,
      611,
      889,
      722,
      722,
      556,
      722,
      667,
      556,
      611,
      722,
      722,
      944,
      722,
      722,
      611,
      333,
      278,
      333,
      469,
      500,
      333,
      444,
      500,
      444,
      500,
      444,
      333,
      500,
      500,
      278,
      278,
      500,
      278,
      778,
      500,
      500,
      500,
      500,
      333,
      389,
      278,
      500,
      500,
      722,
      500,
      500,
      444,
      480,
      200,
      480,
      541,
      0,
      500,
      0,
      333,
      500,
      444,
      1e3,
      500,
      500,
      333,
      1e3,
      556,
      333,
      889,
      0,
      611,
      0,
      0,
      333,
      333,
      444,
      444,
      350,
      500,
      1e3,
      333,
      980,
      389,
      333,
      722,
      0,
      444,
      722,
      0,
      333,
      500,
      500,
      500,
      500,
      200,
      500,
      333,
      760,
      276,
      500,
      564,
      0,
      760,
      333,
      400,
      564,
      300,
      300,
      333,
      500,
      453,
      250,
      333,
      300,
      310,
      500,
      750,
      750,
      750,
      444,
      722,
      722,
      722,
      722,
      722,
      722,
      889,
      667,
      611,
      611,
      611,
      611,
      333,
      333,
      333,
      333,
      722,
      722,
      722,
      722,
      722,
      722,
      722,
      564,
      722,
      722,
      722,
      722,
      722,
      722,
      556,
      500,
      444,
      444,
      444,
      444,
      444,
      444,
      667,
      444,
      444,
      444,
      444,
      444,
      278,
      278,
      278,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      564,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500
    ];
    PdfStandardFontMetricsFactory2.timesRomanBoldWidth = [
      250,
      333,
      555,
      500,
      500,
      1e3,
      833,
      278,
      333,
      333,
      500,
      570,
      250,
      333,
      250,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      333,
      333,
      570,
      570,
      570,
      500,
      930,
      722,
      667,
      722,
      722,
      667,
      611,
      778,
      778,
      389,
      500,
      778,
      667,
      944,
      722,
      778,
      611,
      778,
      722,
      556,
      667,
      722,
      722,
      1e3,
      722,
      722,
      667,
      333,
      278,
      333,
      581,
      500,
      333,
      500,
      556,
      444,
      556,
      444,
      333,
      500,
      556,
      278,
      333,
      556,
      278,
      833,
      556,
      500,
      556,
      556,
      444,
      389,
      333,
      556,
      500,
      722,
      500,
      500,
      444,
      394,
      220,
      394,
      520,
      0,
      500,
      0,
      333,
      500,
      500,
      1e3,
      500,
      500,
      333,
      1e3,
      556,
      333,
      1e3,
      0,
      667,
      0,
      0,
      333,
      333,
      500,
      500,
      350,
      500,
      1e3,
      333,
      1e3,
      389,
      333,
      722,
      0,
      444,
      722,
      0,
      333,
      500,
      500,
      500,
      500,
      220,
      500,
      333,
      747,
      300,
      500,
      570,
      0,
      747,
      333,
      400,
      570,
      300,
      300,
      333,
      556,
      540,
      250,
      333,
      300,
      330,
      500,
      750,
      750,
      750,
      500,
      722,
      722,
      722,
      722,
      722,
      722,
      1e3,
      722,
      667,
      667,
      667,
      667,
      389,
      389,
      389,
      389,
      722,
      722,
      778,
      778,
      778,
      778,
      778,
      570,
      778,
      722,
      722,
      722,
      722,
      722,
      611,
      556,
      500,
      500,
      500,
      500,
      500,
      500,
      722,
      444,
      444,
      444,
      444,
      444,
      278,
      278,
      278,
      278,
      500,
      556,
      500,
      500,
      500,
      500,
      500,
      570,
      500,
      556,
      556,
      556,
      556,
      500,
      556,
      500
    ];
    PdfStandardFontMetricsFactory2.timesRomanItalicWidth = [
      250,
      333,
      420,
      500,
      500,
      833,
      778,
      214,
      333,
      333,
      500,
      675,
      250,
      333,
      250,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      333,
      333,
      675,
      675,
      675,
      500,
      920,
      611,
      611,
      667,
      722,
      611,
      611,
      722,
      722,
      333,
      444,
      667,
      556,
      833,
      667,
      722,
      611,
      722,
      611,
      500,
      556,
      722,
      611,
      833,
      611,
      556,
      556,
      389,
      278,
      389,
      422,
      500,
      333,
      500,
      500,
      444,
      500,
      444,
      278,
      500,
      500,
      278,
      278,
      444,
      278,
      722,
      500,
      500,
      500,
      500,
      389,
      389,
      278,
      500,
      444,
      667,
      444,
      444,
      389,
      400,
      275,
      400,
      541,
      0,
      500,
      0,
      333,
      500,
      556,
      889,
      500,
      500,
      333,
      1e3,
      500,
      333,
      944,
      0,
      556,
      0,
      0,
      333,
      333,
      556,
      556,
      350,
      500,
      889,
      333,
      980,
      389,
      333,
      667,
      0,
      389,
      556,
      0,
      389,
      500,
      500,
      500,
      500,
      275,
      500,
      333,
      760,
      276,
      500,
      675,
      0,
      760,
      333,
      400,
      675,
      300,
      300,
      333,
      500,
      523,
      250,
      333,
      300,
      310,
      500,
      750,
      750,
      750,
      500,
      611,
      611,
      611,
      611,
      611,
      611,
      889,
      667,
      611,
      611,
      611,
      611,
      333,
      333,
      333,
      333,
      722,
      667,
      722,
      722,
      722,
      722,
      722,
      675,
      722,
      722,
      722,
      722,
      722,
      556,
      611,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      667,
      444,
      444,
      444,
      444,
      444,
      278,
      278,
      278,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      675,
      500,
      500,
      500,
      500,
      500,
      444,
      500,
      444
    ];
    PdfStandardFontMetricsFactory2.timesRomanBoldItalicWidths = [
      250,
      389,
      555,
      500,
      500,
      833,
      778,
      278,
      333,
      333,
      500,
      570,
      250,
      333,
      250,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      333,
      333,
      570,
      570,
      570,
      500,
      832,
      667,
      667,
      667,
      722,
      667,
      667,
      722,
      778,
      389,
      500,
      667,
      611,
      889,
      722,
      722,
      611,
      722,
      667,
      556,
      611,
      722,
      667,
      889,
      667,
      611,
      611,
      333,
      278,
      333,
      570,
      500,
      333,
      500,
      500,
      444,
      500,
      444,
      333,
      500,
      556,
      278,
      278,
      500,
      278,
      778,
      556,
      500,
      500,
      500,
      389,
      389,
      278,
      556,
      444,
      667,
      500,
      444,
      389,
      348,
      220,
      348,
      570,
      0,
      500,
      0,
      333,
      500,
      500,
      1e3,
      500,
      500,
      333,
      1e3,
      556,
      333,
      944,
      0,
      611,
      0,
      0,
      333,
      333,
      500,
      500,
      350,
      500,
      1e3,
      333,
      1e3,
      389,
      333,
      722,
      0,
      389,
      611,
      0,
      389,
      500,
      500,
      500,
      500,
      220,
      500,
      333,
      747,
      266,
      500,
      606,
      0,
      747,
      333,
      400,
      570,
      300,
      300,
      333,
      576,
      500,
      250,
      333,
      300,
      300,
      500,
      750,
      750,
      750,
      500,
      667,
      667,
      667,
      667,
      667,
      667,
      944,
      667,
      667,
      667,
      667,
      667,
      389,
      389,
      389,
      389,
      722,
      722,
      722,
      722,
      722,
      722,
      722,
      570,
      722,
      722,
      722,
      722,
      722,
      611,
      611,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      722,
      444,
      444,
      444,
      444,
      444,
      278,
      278,
      278,
      278,
      500,
      556,
      500,
      500,
      500,
      500,
      500,
      570,
      500,
      556,
      556,
      556,
      556,
      444,
      500,
      444
    ];
    PdfStandardFontMetricsFactory2.symbolWidth = [
      250,
      333,
      713,
      500,
      549,
      833,
      778,
      439,
      333,
      333,
      500,
      549,
      250,
      549,
      250,
      278,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      500,
      278,
      278,
      549,
      549,
      549,
      444,
      549,
      722,
      667,
      722,
      612,
      611,
      763,
      603,
      722,
      333,
      631,
      722,
      686,
      889,
      722,
      722,
      768,
      741,
      556,
      592,
      611,
      690,
      439,
      768,
      645,
      795,
      611,
      333,
      863,
      333,
      658,
      500,
      500,
      631,
      549,
      549,
      494,
      439,
      521,
      411,
      603,
      329,
      603,
      549,
      549,
      576,
      521,
      549,
      549,
      521,
      549,
      603,
      439,
      576,
      713,
      686,
      493,
      686,
      494,
      480,
      200,
      480,
      549,
      750,
      620,
      247,
      549,
      167,
      713,
      500,
      753,
      753,
      753,
      753,
      1042,
      987,
      603,
      987,
      603,
      400,
      549,
      411,
      549,
      549,
      713,
      494,
      460,
      549,
      549,
      549,
      549,
      1e3,
      603,
      1e3,
      658,
      823,
      686,
      795,
      987,
      768,
      768,
      823,
      768,
      768,
      713,
      713,
      713,
      713,
      713,
      713,
      713,
      768,
      713,
      790,
      790,
      890,
      823,
      549,
      250,
      713,
      603,
      603,
      1042,
      987,
      603,
      987,
      603,
      494,
      329,
      790,
      790,
      786,
      713,
      384,
      384,
      384,
      384,
      384,
      384,
      494,
      494,
      494,
      494,
      329,
      274,
      686,
      686,
      686,
      384,
      384,
      384,
      384,
      384,
      384,
      494,
      494,
      494,
      -1
    ];
    PdfStandardFontMetricsFactory2.zapfDingbatsWidth = [
      278,
      974,
      961,
      974,
      980,
      719,
      789,
      790,
      791,
      690,
      960,
      939,
      549,
      855,
      911,
      933,
      911,
      945,
      974,
      755,
      846,
      762,
      761,
      571,
      677,
      763,
      760,
      759,
      754,
      494,
      552,
      537,
      577,
      692,
      786,
      788,
      788,
      790,
      793,
      794,
      816,
      823,
      789,
      841,
      823,
      833,
      816,
      831,
      923,
      744,
      723,
      749,
      790,
      792,
      695,
      776,
      768,
      792,
      759,
      707,
      708,
      682,
      701,
      826,
      815,
      789,
      789,
      707,
      687,
      696,
      689,
      786,
      787,
      713,
      791,
      785,
      791,
      873,
      761,
      762,
      762,
      759,
      759,
      892,
      892,
      788,
      784,
      438,
      138,
      277,
      415,
      392,
      392,
      668,
      668,
      390,
      390,
      317,
      317,
      276,
      276,
      509,
      509,
      410,
      410,
      234,
      234,
      334,
      334,
      732,
      544,
      544,
      910,
      667,
      760,
      760,
      776,
      595,
      694,
      626,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      788,
      894,
      838,
      1016,
      458,
      748,
      924,
      748,
      918,
      927,
      928,
      928,
      834,
      873,
      828,
      924,
      924,
      917,
      930,
      931,
      463,
      883,
      836,
      836,
      867,
      867,
      696,
      696,
      874,
      874,
      760,
      946,
      771,
      865,
      771,
      888,
      967,
      888,
      831,
      873,
      927,
      970,
      918
    ];
    return PdfStandardFontMetricsFactory2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/pdf-standard-font.js
var __extends37 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfStandardFont = (
  /** @class */
  (function(_super) {
    __extends37(PdfStandardFont2, _super);
    function PdfStandardFont2(fontFamilyPrototype, size, style) {
      var _this = _super.call(this, size, typeof style === "undefined" ? fontFamilyPrototype instanceof PdfStandardFont2 ? fontFamilyPrototype.style : PdfFontStyle.Regular : style) || this;
      _this.dictionaryProperties = new DictionaryProperties();
      _this.encodings = [
        "Unknown",
        "StandardEncoding",
        "MacRomanEncoding",
        "MacExpertEncoding",
        "WinAnsiEncoding",
        "PDFDocEncoding",
        "IdentityH"
      ];
      if (typeof fontFamilyPrototype === "undefined") {
        _this.pdfFontFamily = PdfFontFamily.Helvetica;
      } else if (fontFamilyPrototype instanceof PdfStandardFont2) {
        _this.pdfFontFamily = fontFamilyPrototype.fontFamily;
      } else {
        _this.pdfFontFamily = fontFamilyPrototype;
      }
      _this.checkStyle();
      _this.initializeInternals();
      return _this;
    }
    Object.defineProperty(PdfStandardFont2.prototype, "fontFamily", {
      /* tslint:enable */
      //Properties
      /**
       * Gets the `FontFamily`.
       * @private
       */
      get: function() {
        return this.pdfFontFamily;
      },
      enumerable: true,
      configurable: true
    });
    PdfStandardFont2.prototype.checkStyle = function() {
      if (this.fontFamily === PdfFontFamily.Symbol || this.fontFamily === PdfFontFamily.ZapfDingbats) {
        var style = this.style;
        style &= ~(PdfFontStyle.Bold | PdfFontStyle.Italic);
        this.setStyle(style);
      }
    };
    PdfStandardFont2.prototype.getLineWidth = function(line, format) {
      if (line == null) {
        throw new Error("ArgumentNullException:line");
      }
      var width = 0;
      var name = this.name;
      line = PdfStandardFont2.convert(line);
      for (var i = 0, len = line.length; i < len; i++) {
        var ch = line[i];
        var charWidth = this.getCharWidthInternal(ch, format);
        width += charWidth;
      }
      var size = this.metrics.getSize(format);
      width *= PdfFont.charSizeMultiplier * size;
      width = this.applyFormatSettings(line, format, width);
      return width;
    };
    PdfStandardFont2.prototype.equalsToFont = function(font) {
      var equal = false;
      var stFont = font;
      if (stFont != null) {
        var fontFamilyEqual = this.fontFamily === stFont.fontFamily;
        var lineReducer = ~(PdfFontStyle.Underline | PdfFontStyle.Strikeout);
        var styleEqual = (this.style & lineReducer) === (stFont.style & lineReducer);
        equal = fontFamilyEqual && styleEqual;
      }
      return equal;
    };
    PdfStandardFont2.prototype.initializeInternals = function() {
      var equalFont = null;
      equalFont = PdfDocument.cache.search(this);
      var internals = null;
      var metrics = PdfStandardFontMetricsFactory.getMetrics(this.pdfFontFamily, this.style, this.size);
      this.metrics = metrics;
      internals = this.createInternals();
      this.setInternals(internals);
    };
    PdfStandardFont2.prototype.createInternals = function() {
      var dictionary = new PdfDictionary();
      dictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.font));
      dictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.type1));
      dictionary.items.setValue(this.dictionaryProperties.baseFont, new PdfName(this.metrics.postScriptName));
      if (this.fontFamily !== PdfFontFamily.Symbol && this.fontFamily !== PdfFontFamily.ZapfDingbats) {
        var encoding = this.encodings[FontEncoding.WinAnsiEncoding];
        dictionary.items.setValue(this.dictionaryProperties.encoding, new PdfName(encoding));
      }
      return dictionary;
    };
    PdfStandardFont2.prototype.getCharWidthInternal = function(charCode, format) {
      var width = 0;
      var code = 0;
      code = charCode.charCodeAt(0);
      if (this.name === "0" || this.name === "1" || this.name === "2" || this.name === "3" || this.name === "4") {
        code = code - PdfStandardFont2.charOffset;
      }
      code = code >= 0 && code !== 128 ? code : 0;
      var metrics = this.metrics;
      var widthTable = metrics.widthTable;
      width = widthTable.items(code);
      return width;
    };
    PdfStandardFont2.convert = function(text) {
      return text;
    };
    PdfStandardFont2.charOffset = 32;
    return PdfStandardFont2;
  })(PdfFont)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/annotation.js
var PdfAnnotation = (
  /** @class */
  (function() {
    function PdfAnnotation2(arg1) {
      this.dictionaryProperties = new DictionaryProperties();
      this.pdfColor = new PdfColor(255, 255, 255);
      this.rectangle = new RectangleF(0, 0, 0, 0);
      this.pdfPage = null;
      this.textBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
      this.textFont = new PdfStandardFont(PdfFontFamily.TimesRoman, 10);
      this.format = new PdfStringFormat(PdfTextAlignment.Left);
      this.content = "";
      this.pdfDictionary = new PdfDictionary();
      this.internalColor = new PdfColor();
      this.darkness = 1;
      if (typeof arg1 === "undefined") {
        this.initialize();
      } else {
        this.initialize();
        this.bounds = arg1;
      }
    }
    Object.defineProperty(PdfAnnotation2.prototype, "color", {
      // Properties
      /**
       * `Color` of the annotation
       * @private
       */
      get: function() {
        return this.pdfColor;
      },
      set: function(value) {
        this.pdfColor = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "innerColor", {
      /**
       * To specifying the `Inner color` with which to fill the annotation
       * @private
       */
      get: function() {
        return this.internalColor;
      },
      set: function(value) {
        this.internalColor = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "bounds", {
      /**
       * `bounds` of the annotation.
       * @private
       */
      get: function() {
        return this.rectangle;
      },
      set: function(value) {
        this.rectangle = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "page", {
      /**
       * Parent `page` of the annotation.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "font", {
      /**
       * To specifying the `Font of the text` in the annotation.
       * @private
       */
      get: function() {
        return this.textFont;
      },
      set: function(value) {
        this.textFont = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "stringFormat", {
      /**
       * To specifying the `StringFormat of the text` in the annotation.
       * @private
       */
      get: function() {
        return this.format;
      },
      set: function(value) {
        this.format = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "brush", {
      /**
       * To specifying the `Brush of the text` in the annotation.
       * @private
       */
      get: function() {
        return this.textBrush;
      },
      set: function(value) {
        this.textBrush = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "text", {
      /**
       * `Text` of the annotation.
       * @private
       */
      get: function() {
        return this.content;
      },
      set: function(value) {
        this.content = value;
        this.dictionary.items.setValue(this.dictionaryProperties.contents, new PdfString(this.content));
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfAnnotation2.prototype, "dictionary", {
      /**
       * Internal variable to store `dictionary`.
       * @hidden
       */
      get: function() {
        return this.pdfDictionary;
      },
      set: function(value) {
        this.pdfDictionary = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfAnnotation2.prototype.initialize = function() {
      this.pdfDictionary.annotationBeginSave = new SaveAnnotationEventHandler(this);
      this.pdfDictionary.items.setValue(this.dictionaryProperties.type, new PdfName(this.dictionaryProperties.annot));
    };
    PdfAnnotation2.prototype.setPage = function(page) {
      this.pdfPage = page;
      this.pdfDictionary.items.setValue(this.dictionaryProperties.p, new PdfReferenceHolder(this.pdfPage));
    };
    PdfAnnotation2.prototype.beginSave = function() {
      this.save();
    };
    PdfAnnotation2.prototype.save = function() {
      var nativeRectangle = new RectangleF(this.rectangle.x, this.rectangle.y, this.rectangle.width, this.rectangle.height);
      var section = this.pdfPage.section;
      var initialHeight = nativeRectangle.height;
      var tempLoacation = section.pointToNativePdf(this.page, new PointF(nativeRectangle.x, nativeRectangle.y));
      nativeRectangle.x = tempLoacation.x;
      nativeRectangle.width = tempLoacation.x + nativeRectangle.width;
      nativeRectangle.y = tempLoacation.y - this.page.document.pageSettings.margins.top;
      nativeRectangle.height = nativeRectangle.y - initialHeight;
      this.pdfDictionary.items.setValue(this.dictionaryProperties.rect, PdfArray.fromRectangle(nativeRectangle));
      this.dictionary.items.setValue(this.dictionaryProperties.ca, new PdfNumber(this.darkness));
    };
    Object.defineProperty(PdfAnnotation2.prototype, "element", {
      /* tslint:enable */
      // IPdfWrapper Members
      /**
       * Gets the `element`.
       * @private
       */
      get: function() {
        return this.pdfDictionary;
      },
      enumerable: true,
      configurable: true
    });
    return PdfAnnotation2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/link-annotation.js
var __extends38 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfLinkAnnotation = (
  /** @class */
  (function(_super) {
    __extends38(PdfLinkAnnotation2, _super);
    function PdfLinkAnnotation2(rectangle) {
      return _super.call(this, rectangle) || this;
    }
    PdfLinkAnnotation2.prototype.initialize = function() {
      _super.prototype.initialize.call(this);
      this.dictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.link));
    };
    return PdfLinkAnnotation2;
  })(PdfAnnotation)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/action-link-annotation.js
var __extends39 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfActionLinkAnnotation = (
  /** @class */
  (function(_super) {
    __extends39(PdfActionLinkAnnotation2, _super);
    function PdfActionLinkAnnotation2(rectangle) {
      var _this = _super.call(this, rectangle) || this;
      _this.pdfAction = null;
      return _this;
    }
    PdfActionLinkAnnotation2.prototype.getSetAction = function(value) {
      if (typeof value === "undefined") {
        return this.pdfAction;
      } else {
        this.pdfAction = value;
      }
    };
    return PdfActionLinkAnnotation2;
  })(PdfLinkAnnotation)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/document-link-annotation.js
var __extends40 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfDocumentLinkAnnotation = (
  /** @class */
  (function(_super) {
    __extends40(PdfDocumentLinkAnnotation2, _super);
    function PdfDocumentLinkAnnotation2(rectangle, destination) {
      var _this = _super.call(this, rectangle) || this;
      _this.pdfDestination = null;
      if (typeof destination !== "undefined") {
        _this.destination = destination;
      }
      return _this;
    }
    Object.defineProperty(PdfDocumentLinkAnnotation2.prototype, "destination", {
      // Properties
      /**
       * Gets or sets the `destination` of the annotation.
       * ```typescript
       * // create a new PDF document
       * let document : PdfDocument = new PdfDocument();
       * // create new pages
       * let page1 : PdfPage = document.pages.add();
       * let page2 : PdfPage = document.pages.add();
       * // create a new rectangle
       * let bounds : RectangleF = new RectangleF({x : 10, y : 200}, {width : 300, height : 25});
       * //
       * // create a new document link annotation
       * let documentLinkAnnotation : PdfDocumentLinkAnnotation = new PdfDocumentLinkAnnotation(bounds);
       * // set the annotation text
       * documentLinkAnnotation.text = 'Document link annotation';
       * // set the destination
       * documentLinkAnnotation.destination = new PdfDestination(page2);
       * // set the documentlink annotation location
       * documentLinkAnnotation.destination.location = new PointF(10, 0);
       * // add this annotation to a new page
       * page1.annotations.add(documentLinkAnnotation);
       * //
       * // save the document to disk
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       * @default null
       */
      get: function() {
        return this.pdfDestination;
      },
      set: function(value) {
        this.pdfDestination = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfDocumentLinkAnnotation2.prototype.save = function() {
      _super.prototype.save.call(this);
      if (this.pdfDestination != null) {
        this.dictionary.items.setValue(this.dictionaryProperties.dest, this.pdfDestination.element);
      }
    };
    PdfDocumentLinkAnnotation2.prototype.clone = function() {
      var annot = new PdfDocumentLinkAnnotation2(this.bounds, this.destination);
      annot.color = this.color;
      annot.brush = this.brush;
      annot.destination = this.destination;
      annot.font = this.font;
      return annot;
    };
    return PdfDocumentLinkAnnotation2;
  })(PdfLinkAnnotation)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/element-layouter.js
var ElementLayouter = (
  /** @class */
  (function() {
    function ElementLayouter2(element) {
      this.layoutElement = element;
    }
    Object.defineProperty(ElementLayouter2.prototype, "elements", {
      // Properties
      /**
       * Gets the `element`.
       * @private
       */
      get: function() {
        return this.layoutElement;
      },
      enumerable: true,
      configurable: true
    });
    ElementLayouter2.prototype.getElement = function() {
      return this.layoutElement;
    };
    ElementLayouter2.prototype.layout = function(param) {
      return this.layoutInternal(param);
    };
    ElementLayouter2.prototype.Layouter = function(param) {
      return this.layoutInternal(param);
    };
    ElementLayouter2.prototype.getNextPage = function(currentPage) {
      var section = currentPage.section;
      var nextPage = section.add();
      return nextPage;
    };
    ElementLayouter2.prototype.getPaginateBounds = function(param) {
      if (param == null) {
        throw new Error("ArgumentNullException : param");
      }
      var result = param.format.usePaginateBounds ? param.format.paginateBounds : new RectangleF(param.bounds.x, 0, param.bounds.width, param.bounds.height);
      return result;
    };
    return ElementLayouter2;
  })()
);
var PdfLayoutFormat = (
  /** @class */
  (function() {
    function PdfLayoutFormat2(baseFormat) {
      if (typeof baseFormat === "undefined") {
      } else {
        this.break = baseFormat.break;
        this.layout = baseFormat.layout;
        this.paginateBounds = baseFormat.paginateBounds;
        this.boundsSet = baseFormat.usePaginateBounds;
      }
    }
    Object.defineProperty(PdfLayoutFormat2.prototype, "layout", {
      // Properties
      /**
       * Gets or sets `layout` type of the element.
       * @private
       */
      get: function() {
        return this.layoutType;
      },
      set: function(value) {
        this.layoutType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutFormat2.prototype, "break", {
      /**
       * Gets or sets `break` type of the element.
       * @private
       */
      get: function() {
        return this.breakType;
      },
      set: function(value) {
        this.breakType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutFormat2.prototype, "paginateBounds", {
      /**
       * Gets or sets the `bounds` on the next page.
       * @private
       */
      get: function() {
        if (typeof this.layoutPaginateBounds === "undefined" && this.layoutPaginateBounds == null) {
          this.layoutPaginateBounds = new RectangleF(0, 0, 0, 0);
        }
        return this.layoutPaginateBounds;
      },
      set: function(value) {
        this.layoutPaginateBounds = value;
        this.boundsSet = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutFormat2.prototype, "usePaginateBounds", {
      /**
       * Gets a value indicating whether [`use paginate bounds`].
       * @private
       */
      get: function() {
        return this.boundsSet;
      },
      enumerable: true,
      configurable: true
    });
    return PdfLayoutFormat2;
  })()
);
var PdfLayoutParams = (
  /** @class */
  (function() {
    function PdfLayoutParams2() {
    }
    Object.defineProperty(PdfLayoutParams2.prototype, "page", {
      // Properties
      /**
       * Gets or sets the layout `page` for the element.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      set: function(value) {
        this.pdfPage = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutParams2.prototype, "bounds", {
      /**
       * Gets or sets layout `bounds` for the element.
       * @private
       */
      get: function() {
        return new RectangleF(this.layoutBounds.x, this.layoutBounds.y, this.layoutBounds.width, this.layoutBounds.height);
      },
      set: function(value) {
        this.layoutBounds = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutParams2.prototype, "format", {
      /**
       * Gets or sets `layout settings` for the element.
       * @private
       */
      get: function() {
        return this.layoutFormat;
      },
      set: function(value) {
        this.layoutFormat = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfLayoutParams2;
  })()
);
var PdfLayoutResult = (
  /** @class */
  (function() {
    function PdfLayoutResult2(page, bounds) {
      this.pdfPage = page;
      this.layoutBounds = bounds;
    }
    Object.defineProperty(PdfLayoutResult2.prototype, "page", {
      // Properties
      /**
       * Gets the last `page` where the element was drawn.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutResult2.prototype, "bounds", {
      /**
       * Gets the `bounds` of the element on the last page where it was drawn.
       * @private
       */
      get: function() {
        return this.layoutBounds;
      },
      enumerable: true,
      configurable: true
    });
    return PdfLayoutResult2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/styles/pdf-borders.js
var PdfBorders = (
  /** @class */
  (function() {
    function PdfBorders2() {
      var defaultBorderPenLeft = new PdfPen(new PdfColor(0, 0, 0));
      defaultBorderPenLeft.dashStyle = PdfDashStyle.Solid;
      var defaultBorderPenRight = new PdfPen(new PdfColor(0, 0, 0));
      defaultBorderPenRight.dashStyle = PdfDashStyle.Solid;
      var defaultBorderPenTop = new PdfPen(new PdfColor(0, 0, 0));
      defaultBorderPenTop.dashStyle = PdfDashStyle.Solid;
      var defaultBorderPenBottom = new PdfPen(new PdfColor(0, 0, 0));
      defaultBorderPenBottom.dashStyle = PdfDashStyle.Solid;
      this.leftPen = defaultBorderPenLeft;
      this.rightPen = defaultBorderPenRight;
      this.topPen = defaultBorderPenTop;
      this.bottomPen = defaultBorderPenBottom;
    }
    Object.defineProperty(PdfBorders2.prototype, "left", {
      // Properties
      /**
       * Gets or sets the `Left`.
       * @private
       */
      get: function() {
        return this.leftPen;
      },
      set: function(value) {
        this.leftPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBorders2.prototype, "right", {
      /**
       * Gets or sets the `Right`.
       * @private
       */
      get: function() {
        return this.rightPen;
      },
      set: function(value) {
        this.rightPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBorders2.prototype, "top", {
      /**
       * Gets or sets the `Top`.
       * @private
       */
      get: function() {
        return this.topPen;
      },
      set: function(value) {
        this.topPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBorders2.prototype, "bottom", {
      /**
       * Gets or sets the `Bottom`.
       * @private
       */
      get: function() {
        return this.bottomPen;
      },
      set: function(value) {
        this.bottomPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBorders2.prototype, "all", {
      /**
       * sets the `All`.
       * @private
       */
      set: function(value) {
        this.leftPen = this.rightPen = this.topPen = this.bottomPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBorders2.prototype, "isAll", {
      /**
       * Gets a value indicating whether this instance `is all`.
       * @private
       */
      get: function() {
        return this.leftPen === this.rightPen && this.leftPen === this.topPen && this.leftPen === this.bottomPen;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBorders2, "default", {
      /**
       * Gets the `default`.
       * @private
       */
      get: function() {
        return new PdfBorders2();
      },
      enumerable: true,
      configurable: true
    });
    return PdfBorders2;
  })()
);
var PdfPaddings = (
  /** @class */
  (function() {
    function PdfPaddings2(left, right, top, bottom) {
      this.hasLeftPad = false;
      this.hasRightPad = false;
      this.hasTopPad = false;
      this.hasBottomPad = false;
      if (typeof left === "undefined") {
        this.bottomPad = this.topPad = this.leftPad = this.rightPad = 0.5;
      } else {
        this.leftPad = left;
        this.rightPad = right;
        this.topPad = top;
        this.bottomPad = bottom;
        this.hasLeftPad = true;
        this.hasRightPad = true;
        this.hasTopPad = true;
        this.hasBottomPad = true;
      }
    }
    Object.defineProperty(PdfPaddings2.prototype, "left", {
      // Properties
      /**
       * Gets or sets the `left` value of the edge
       * @private
       */
      get: function() {
        return this.leftPad;
      },
      set: function(value) {
        this.leftPad = value;
        this.hasLeftPad = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPaddings2.prototype, "right", {
      /**
       * Gets or sets the `right` value of the edge.
       * @private
       */
      get: function() {
        return this.rightPad;
      },
      set: function(value) {
        this.rightPad = value;
        this.hasRightPad = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPaddings2.prototype, "top", {
      /**
       * Gets or sets the `top` value of the edge
       * @private
       */
      get: function() {
        return this.topPad;
      },
      set: function(value) {
        this.topPad = value;
        this.hasTopPad = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPaddings2.prototype, "bottom", {
      /**
       * Gets or sets the `bottom` value of the edge.
       * @private
       */
      get: function() {
        return this.bottomPad;
      },
      set: function(value) {
        this.bottomPad = value;
        this.hasBottomPad = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPaddings2.prototype, "all", {
      /**
       * Sets value to all sides `left,right,top and bottom`.s
       * @private
       */
      set: function(value) {
        this.leftPad = this.rightPad = this.topPad = this.bottomPad = value;
        this.hasLeftPad = true;
        this.hasRightPad = true;
        this.hasTopPad = true;
        this.hasBottomPad = true;
      },
      enumerable: true,
      configurable: true
    });
    return PdfPaddings2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/layout-element.js
var PdfLayoutElement = (
  /** @class */
  (function() {
    function PdfLayoutElement2() {
    }
    Object.defineProperty(PdfLayoutElement2.prototype, "raiseBeginPageLayout", {
      // Property
      /**
       * Gets a value indicating whether the `start page layout event` should be raised.
       * @private
       */
      get: function() {
        return typeof this.beginPageLayout !== "undefined";
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLayoutElement2.prototype, "raiseEndPageLayout", {
      /**
       * Gets a value indicating whether the `ending page layout event` should be raised.
       * @private
       */
      get: function() {
        return typeof this.endPageLayout !== "undefined";
      },
      enumerable: true,
      configurable: true
    });
    PdfLayoutElement2.prototype.onBeginPageLayout = function(args) {
      if (this.beginPageLayout) {
        this.beginPageLayout(this, args);
      }
    };
    PdfLayoutElement2.prototype.onEndPageLayout = function(args) {
      if (this.endPageLayout) {
        this.endPageLayout(this, args);
      }
    };
    PdfLayoutElement2.prototype.drawHelper = function(arg2, arg3, arg4, arg5) {
      if (arg3 instanceof PointF && typeof arg3.width === "undefined" && typeof arg4 === "undefined") {
        return this.drawHelper(arg2, arg3.x, arg3.y);
      } else if (typeof arg3 === "number" && typeof arg4 === "number" && typeof arg5 === "undefined") {
        return this.drawHelper(arg2, arg3, arg4, null);
      } else if (arg3 instanceof RectangleF && typeof arg3.width !== "undefined" && typeof arg4 === "undefined") {
        return this.drawHelper(arg2, arg3, null);
      } else if (arg3 instanceof PointF && typeof arg3.width === "undefined" && arg4 instanceof PdfLayoutFormat) {
        return this.drawHelper(arg2, arg3.x, arg3.y, arg4);
      } else if (typeof arg3 === "number" && typeof arg4 === "number" && (arg5 instanceof PdfLayoutFormat || arg5 == null)) {
        var width = arg2.graphics.clientSize.width - arg3;
        var layoutRectangle = new RectangleF(arg3, arg4, width, 0);
        return this.drawHelper(arg2, layoutRectangle, arg5);
      } else if (arg3 instanceof RectangleF && typeof arg3.width !== "undefined" && typeof arg4 === "boolean") {
        this.bEmbedFonts = arg4;
        return this.drawHelper(arg2, arg3, null);
      } else {
        var param = new PdfLayoutParams();
        var temparg3 = arg3;
        var temparg4 = arg4;
        param.page = arg2;
        param.bounds = temparg3;
        if (param != null) {
          var x = param.bounds.x;
          var y = param.bounds.y;
          if (param.bounds.x === 0) {
            x = PdfBorders.default.right.width / 2;
          }
          if (param.bounds.y === 0) {
            y = PdfBorders.default.top.width / 2;
          }
          var newBound = new RectangleF(x, y, param.bounds.width, param.bounds.height);
          param.bounds = newBound;
        }
        param.format = temparg4 != null ? temparg4 : new PdfLayoutFormat();
        var result = this.layout(param);
        return result;
      }
    };
    return PdfLayoutElement2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/text-layouter.js
var __extends41 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var TextLayouter = (
  /** @class */
  (function(_super) {
    __extends41(TextLayouter2, _super);
    function TextLayouter2(element) {
      return _super.call(this, element) || this;
    }
    Object.defineProperty(TextLayouter2.prototype, "element", {
      /**
       * Gets the layout `element`.
       * @private
       */
      get: function() {
        return _super.prototype.getElement.call(this);
      },
      enumerable: true,
      configurable: true
    });
    TextLayouter2.prototype.layoutInternal = function(param) {
      this.format = this.element.stringFormat !== null && typeof this.element.stringFormat !== "undefined" ? this.element.stringFormat : null;
      var currentPage = param.page;
      var currentBounds = param.bounds;
      var text = this.element.value;
      var result = null;
      var pageResult = new TextPageLayoutResult();
      pageResult.page = currentPage;
      pageResult.remainder = text;
      for (; ; ) {
        pageResult = this.layoutOnPage(text, currentPage, currentBounds, param);
        result = this.getLayoutResult(pageResult);
        break;
      }
      return result;
    };
    TextLayouter2.prototype.getLayoutResult = function(pageResult) {
      var result = new PdfTextLayoutResult(pageResult.page, pageResult.bounds, pageResult.remainder, pageResult.lastLineBounds);
      return result;
    };
    TextLayouter2.prototype.layoutOnPage = function(text, currentPage, currentBounds, param) {
      var result = new TextPageLayoutResult();
      result.remainder = text;
      result.page = currentPage;
      currentBounds = this.checkCorrectBounds(currentPage, currentBounds);
      var layouter = new PdfStringLayouter();
      var stringResult = layouter.layout(text, this.element.font, this.format, currentBounds, currentPage.getClientSize().height, false, new SizeF(0, 0));
      var textFinished = stringResult.remainder == null;
      var doesntFit = param.format.break === PdfLayoutBreakType.FitElement;
      var canDraw = !(doesntFit || stringResult.empty);
      var graphics = currentPage.graphics;
      var brush = this.element.getBrush();
      if (this.element instanceof PdfTextWebLink) {
        brush.color = new PdfColor(0, 0, 255);
        if (!this.element._isLastElement && this.element.stringFormat && this.element.stringFormat.alignment === PdfTextAlignment.Justify) {
          stringResult.layoutLines[0].type = LineType.LayoutBreak | LineType.FirstParagraphLine;
        }
      }
      if (this.element && this.element instanceof PdfTextElement && !this.element._isLastElement && this.element.stringFormat && this.element.stringFormat.alignment === PdfTextAlignment.Justify) {
        stringResult.layoutLines[0].type = LineType.LayoutBreak | LineType.FirstParagraphLine;
      }
      graphics.drawStringLayoutResult(stringResult, this.element.font, this.element.pen, brush, currentBounds, this.format);
      var lineInfo = stringResult.lines[stringResult.lineCount - 1];
      result.lastLineBounds = graphics.getLineBounds(stringResult.lineCount - 1, stringResult, this.element.font, currentBounds, this.format);
      result.bounds = this.getTextPageBounds(currentPage, currentBounds, stringResult);
      result.remainder = stringResult.remainder;
      result.end = textFinished;
      return result;
    };
    TextLayouter2.prototype.checkCorrectBounds = function(currentPage, currentBounds) {
      var pageSize = currentPage.graphics.clientSize;
      currentBounds.height = currentBounds.height > 0 ? currentBounds.height : pageSize.height - currentBounds.y;
      return currentBounds;
    };
    TextLayouter2.prototype.getTextPageBounds = function(currentPage, currentBounds, stringResult) {
      var textSize = stringResult.actualSize;
      var x = currentBounds.x;
      var y = currentBounds.y;
      var width = currentBounds.width > 0 ? currentBounds.width : textSize.width;
      var height = textSize.height;
      var shiftedRect = currentPage.graphics.checkCorrectLayoutRectangle(textSize, currentBounds.x, currentBounds.y, this.format);
      x = shiftedRect.x;
      var verticalShift = currentPage.graphics.getTextVerticalAlignShift(textSize.height, currentBounds.height, this.format);
      y += verticalShift;
      var bounds = new RectangleF(x, y, width, height);
      return bounds;
    };
    return TextLayouter2;
  })(ElementLayouter)
);
var TextPageLayoutResult = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TextPageLayoutResult2() {
    }
    return TextPageLayoutResult2;
  })()
);
var PdfTextLayoutResult = (
  /** @class */
  (function(_super) {
    __extends41(PdfTextLayoutResult2, _super);
    function PdfTextLayoutResult2(page, bounds, remainder, lastLineBounds) {
      var _this = _super.call(this, page, bounds) || this;
      _this.remainderText = remainder;
      _this.lastLineTextBounds = lastLineBounds;
      return _this;
    }
    Object.defineProperty(PdfTextLayoutResult2.prototype, "remainder", {
      // Properties
      /**
       * Gets a value that contains the `text` that was not printed.
       * @private
       */
      get: function() {
        return this.remainderText;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTextLayoutResult2.prototype, "lastLineBounds", {
      /**
       * Gets a value that indicates the `bounds` of the last line that was printed on the page.
       * @private
       */
      get: function() {
        return this.lastLineTextBounds;
      },
      enumerable: true,
      configurable: true
    });
    return PdfTextLayoutResult2;
  })(PdfLayoutResult)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/text-element.js
var __extends42 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfTextElement = (
  /** @class */
  (function(_super) {
    __extends42(PdfTextElement2, _super);
    function PdfTextElement2(arg1, arg2, arg3, arg4, arg5) {
      var _this = _super.call(this) || this;
      _this.content = "";
      _this.elementValue = "";
      _this.hasPointOverload = false;
      _this._isLastElement = false;
      _this.isPdfTextElement = false;
      if (typeof arg1 === "undefined") {
      } else if (typeof arg1 === "string" && typeof arg2 === "undefined") {
        _this.content = arg1;
        _this.elementValue = arg1;
      } else if (typeof arg1 === "string" && arg2 instanceof PdfFont && typeof arg3 === "undefined") {
        _this.content = arg1;
        _this.elementValue = arg1;
        _this.pdfFont = arg2;
      } else if (typeof arg1 === "string" && arg2 instanceof PdfFont && arg3 instanceof PdfPen && typeof arg4 === "undefined") {
        _this.content = arg1;
        _this.elementValue = arg1;
        _this.pdfFont = arg2;
        _this.pdfPen = arg3;
      } else if (typeof arg1 === "string" && arg2 instanceof PdfFont && arg3 instanceof PdfBrush && typeof arg4 === "undefined") {
        _this.content = arg1;
        _this.elementValue = arg1;
        _this.pdfFont = arg2;
        _this.pdfBrush = arg3;
      } else {
        _this.content = arg1;
        _this.elementValue = arg1;
        _this.pdfFont = arg2;
        _this.pdfPen = arg3;
        _this.pdfBrush = arg4;
        _this.format = arg5;
      }
      return _this;
    }
    Object.defineProperty(PdfTextElement2.prototype, "text", {
      // Properties
      /**
       * Gets or sets a value indicating the `text` that should be printed.
       * ```typescript
       * // create a new PDF document.
       * let document : PdfDocument = new PdfDocument();
       * // add a page to the document.
       * let page1 : PdfPage = document.pages.add();
       * // create the font
       * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
       * // create the Text Web Link
       * let textLink : PdfTextWebLink = new PdfTextWebLink();
       * // set the hyperlink
       * textLink.url = 'http://www.google.com';
       * //
       * // set the link text
       * textLink.text = 'Google';
       * //
       * // set the font
       * textLink.font = font;
       * // draw the hyperlink in PDF page
       * textLink.draw(page1, new PointF(10, 40));
       * // save the document.
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.content;
      },
      set: function(value) {
        this.elementValue = value;
        this.content = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTextElement2.prototype, "value", {
      //get value
      /**
       * Gets or sets a `value` indicating the text that should be printed.
       * @private
       */
      get: function() {
        return this.elementValue;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTextElement2.prototype, "pen", {
      //get pen
      /**
       * Gets or sets a `PdfPen` that determines the color, width, and style of the text
       * @private
       */
      get: function() {
        return this.pdfPen;
      },
      //Set pen value
      set: function(value) {
        this.pdfPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTextElement2.prototype, "brush", {
      //get brush
      /**
       * Gets or sets the `PdfBrush` that will be used to draw the text with color and texture.
       * @private
       */
      get: function() {
        return this.pdfBrush;
      },
      //Set brush value
      set: function(value) {
        this.pdfBrush = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTextElement2.prototype, "font", {
      //get font
      /**
       * Gets or sets a `PdfFont` that defines the text format.
       * ```typescript
       * // create a new PDF document.
       * let document : PdfDocument = new PdfDocument();
       * // add a page to the document.
       * let page1 : PdfPage = document.pages.add();
       * // create the font
       * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
       * // create the Text Web Link
       * let textLink : PdfTextWebLink = new PdfTextWebLink();
       * // set the hyperlink
       * textLink.url = 'http://www.google.com';
       * // set the link text
       * textLink.text = 'Google';
       * //
       * // set the font
       * textLink.font = font;
       * //
       * // draw the hyperlink in PDF page
       * textLink.draw(page1, new PointF(10, 40));
       * // save the document.
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.pdfFont;
      },
      set: function(value) {
        this.pdfFont = value;
        if (this.pdfFont instanceof PdfStandardFont && this.content != null) {
          this.elementValue = PdfStandardFont.convert(this.content);
        } else {
          this.elementValue = this.content;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTextElement2.prototype, "stringFormat", {
      /**
       * Gets or sets the `PdfStringFormat` that will be used to set the string format
       * @private
       */
      get: function() {
        return this.format;
      },
      set: function(value) {
        this.format = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfTextElement2.prototype.getBrush = function() {
      return this.pdfBrush == null || typeof this.pdfBrush === "undefined" ? new PdfSolidBrush(new PdfColor(0, 0, 0)) : this.pdfBrush;
    };
    PdfTextElement2.prototype.layout = function(param) {
      var layouter = new TextLayouter(this);
      var result = layouter.layout(param);
      return result;
    };
    PdfTextElement2.prototype.drawText = function(arg2, arg3, arg4, arg5) {
      if (arg3 instanceof PointF && typeof arg3.width === "undefined" && typeof arg4 === "undefined") {
        this.hasPointOverload = true;
        return this.drawText(arg2, arg3.x, arg3.y);
      } else if (typeof arg3 === "number" && typeof arg4 === "number" && typeof arg5 === "undefined") {
        this.hasPointOverload = true;
        return this.drawText(arg2, arg3, arg4, null);
      } else if (arg3 instanceof RectangleF && typeof arg3.width !== "undefined" && typeof arg4 === "undefined") {
        return this.drawText(arg2, arg3, null);
      } else if (arg3 instanceof PointF && typeof arg3.width === "undefined" && arg4 instanceof PdfLayoutFormat) {
        this.hasPointOverload = true;
        return this.drawText(arg2, arg3.x, arg3.y, arg4);
      } else if (typeof arg3 === "number" && typeof arg4 === "number" && (arg5 instanceof PdfLayoutFormat || arg5 == null)) {
        this.hasPointOverload = true;
        var width = arg2.graphics.clientSize.width - arg3;
        var layoutRectangle = new RectangleF(arg3, arg4, width, 0);
        return this.drawText(arg2, layoutRectangle, arg5);
      } else if (arg3 instanceof RectangleF && typeof arg3.width !== "undefined" && typeof arg4 === "boolean") {
        return this.drawText(arg2, arg3, null);
      } else {
        var layout = new PdfStringLayouter();
        if (this.hasPointOverload) {
          var stringLayoutResult = layout.layout(this.value, this.font, this.stringFormat, new SizeF(arg2.graphics.clientSize.width - arg3.x, 0), true, arg2.graphics.clientSize);
          var layoutResult = void 0;
          var param = new PdfLayoutParams();
          var temparg3 = arg3;
          var temparg4 = arg4;
          param.page = arg2;
          var previousPage = arg2;
          param.bounds = temparg3;
          param.format = temparg4 != null ? temparg4 : new PdfLayoutFormat();
          if (stringLayoutResult.lines.length > 1) {
            this.text = stringLayoutResult.layoutLines[0].text;
            if (param.bounds.y <= param.page.graphics.clientSize.height) {
              var previousPosition = new PointF(param.bounds.x, param.bounds.y);
              layoutResult = this.layout(param);
              var bounds = new RectangleF(0, layoutResult.bounds.y + stringLayoutResult.lineHeight, arg2.graphics.clientSize.width, stringLayoutResult.lineHeight);
              var isPaginate = false;
              for (var i = 1; i < stringLayoutResult.lines.length; i++) {
                param.page = layoutResult.page;
                param.bounds = new RectangleF(new PointF(bounds.x, bounds.y), new SizeF(bounds.width, bounds.height));
                this.text = stringLayoutResult.layoutLines[i].text;
                if (bounds.y + stringLayoutResult.lineHeight > layoutResult.page.graphics.clientSize.height) {
                  isPaginate = true;
                  param.page = param.page.graphics.getNextPage();
                  if (previousPosition.y > layoutResult.page.graphics.clientSize.height - layoutResult.bounds.height) {
                    bounds = new RectangleF(0, layoutResult.bounds.height, layoutResult.page.graphics.clientSize.width, stringLayoutResult.lineHeight);
                  } else {
                    bounds = new RectangleF(0, 0, layoutResult.page.graphics.clientSize.width, stringLayoutResult.lineHeight);
                  }
                  param.bounds = bounds;
                }
                if (i === stringLayoutResult.lines.length - 1) {
                  this._isLastElement = true;
                }
                layoutResult = this.layout(param);
                if (i !== stringLayoutResult.lines.length - 1) {
                  bounds = new RectangleF(0, layoutResult.bounds.y + stringLayoutResult.lineHeight, layoutResult.page.graphics.clientSize.width, stringLayoutResult.lineHeight);
                } else {
                  var lineWidth = this.font.measureString(this.text, this.format).width;
                  layoutResult = this.calculateResultBounds(layoutResult, lineWidth, layoutResult.page.graphics.clientSize.width, 0);
                }
              }
            }
            return layoutResult;
          } else {
            var lineSize = this.font.measureString(this.text, this.format);
            if (param.bounds.y <= param.page.graphics.clientSize.height) {
              layoutResult = this.layout(param);
              layoutResult = this.calculateResultBounds(layoutResult, lineSize.width, layoutResult.page.graphics.clientSize.width, 0);
            }
            return layoutResult;
          }
        } else {
          var layoutResult = layout.layout(this.value, this.font, this.stringFormat, new SizeF(arg3.width, 0), false, arg2.graphics.clientSize);
          var result = void 0;
          var param = new PdfLayoutParams();
          var temparg3 = arg3;
          var temparg4 = arg4;
          param.page = arg2;
          param.bounds = temparg3;
          param.format = temparg4 != null ? temparg4 : new PdfLayoutFormat();
          if (layoutResult.lines.length > 1) {
            this.text = layoutResult.layoutLines[0].text;
            if (param.bounds.y <= param.page.graphics.clientSize.height) {
              var previousPosition = new PointF(param.bounds.x, param.bounds.y);
              result = this.layout(param);
              var bounds = new RectangleF(temparg3.x, result.bounds.y + layoutResult.lineHeight, temparg3.width, layoutResult.lineHeight);
              var isPaginate = false;
              for (var i = 1; i < layoutResult.lines.length; i++) {
                param.page = result.page;
                param.bounds = new RectangleF(bounds.x, bounds.y, bounds.width, bounds.height);
                this.text = layoutResult.layoutLines[i].text;
                if (bounds.y + layoutResult.lineHeight > result.page.graphics.clientSize.height) {
                  isPaginate = true;
                  param.page = param.page.graphics.getNextPage();
                  if (previousPosition.y > result.page.graphics.clientSize.height - result.bounds.height) {
                    bounds = new RectangleF(temparg3.x, layoutResult.lineHeight, temparg3.width, layoutResult.lineHeight);
                  } else {
                    bounds = new RectangleF(temparg3.x, 0, temparg3.width, layoutResult.lineHeight);
                  }
                  param.bounds = bounds;
                }
                result = this.layout(param);
                if (i !== layoutResult.lines.length - 1) {
                  bounds = new RectangleF(temparg3.x, result.bounds.y + layoutResult.lineHeight, temparg3.width, layoutResult.lineHeight);
                } else {
                  var lineWidth = this.font.measureString(this.text, this.format).width;
                  result = this.calculateResultBounds(result, lineWidth, temparg3.width, temparg3.x);
                }
              }
            }
            return result;
          } else {
            var lineSize = this.font.measureString(this.text, this.format);
            if (param.bounds.y <= param.page.graphics.clientSize.height) {
              result = this.layout(param);
              result = this.calculateResultBounds(result, lineSize.width, temparg3.width, temparg3.x);
            }
            return result;
          }
        }
      }
    };
    PdfTextElement2.prototype.calculateResultBounds = function(result, lineWidth, maximumWidth, startPosition) {
      var shift = 0;
      if (this.stringFormat != null && typeof this.stringFormat !== "undefined" && this.stringFormat.alignment === PdfTextAlignment.Center) {
        result.bounds.x = startPosition + (maximumWidth - lineWidth) / 2;
        result.bounds.width = lineWidth;
      } else if (this.stringFormat != null && typeof this.stringFormat !== "undefined" && this.stringFormat.alignment === PdfTextAlignment.Right) {
        result.bounds.x = startPosition + (maximumWidth - lineWidth);
        result.bounds.width = lineWidth;
      } else if (this.stringFormat != null && typeof this.stringFormat !== "undefined" && this.stringFormat.alignment === PdfTextAlignment.Justify) {
        result.bounds.x = startPosition;
        result.bounds.width = maximumWidth;
      } else {
        result.bounds.width = startPosition;
        result.bounds.width = lineWidth;
      }
      return result;
    };
    return PdfTextElement2;
  })(PdfLayoutElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/uri-annotation.js
var __extends43 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfUriAnnotation = (
  /** @class */
  (function(_super) {
    __extends43(PdfUriAnnotation2, _super);
    function PdfUriAnnotation2(rectangle, uri) {
      var _this = _super.call(this, rectangle) || this;
      if (typeof uri !== "undefined") {
        _this.uri = uri;
      }
      return _this;
    }
    Object.defineProperty(PdfUriAnnotation2.prototype, "uriAction", {
      /**
       * Get `action` of the annotation.
       * @private
       */
      get: function() {
        if (typeof this.pdfUriAction === "undefined") {
          this.pdfUriAction = new PdfUriAction();
        }
        return this.pdfUriAction;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfUriAnnotation2.prototype, "uri", {
      // Properties
      /**
       * Gets or sets the `Uri` address.
       * @private
       */
      get: function() {
        return this.uriAction.uri;
      },
      set: function(value) {
        if (this.uriAction.uri !== value) {
          this.uriAction.uri = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfUriAnnotation2.prototype, "action", {
      /**
       * Gets or sets the `action`.
       * @private
       */
      get: function() {
        return this.getSetAction();
      },
      set: function(value) {
        this.getSetAction(value);
        this.uriAction.next = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfUriAnnotation2.prototype.initialize = function() {
      _super.prototype.initialize.call(this);
      this.dictionary.items.setValue(this.dictionaryProperties.subtype, new PdfName(this.dictionaryProperties.link));
      var tempPrimitive = this.uriAction.element;
      this.dictionary.items.setValue(this.dictionaryProperties.a, this.uriAction.element);
    };
    return PdfUriAnnotation2;
  })(PdfActionLinkAnnotation)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/annotations/pdf-text-web-link.js
var __extends44 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfTextWebLink = (
  /** @class */
  (function(_super) {
    __extends44(PdfTextWebLink2, _super);
    function PdfTextWebLink2() {
      var _this = _super.call(this) || this;
      _this.uniformResourceLocator = "";
      _this.uriAnnotation = null;
      _this.recalculateBounds = false;
      _this.defaultBorder = new PdfArray();
      for (var i = 0; i < 3; i++) {
        _this.defaultBorder.add(new PdfNumber(0));
      }
      return _this;
    }
    Object.defineProperty(PdfTextWebLink2.prototype, "url", {
      // Properties
      /**
       * Gets or sets the `Uri address`.
       * ```typescript
       * // create a new PDF document.
       * let document : PdfDocument = new PdfDocument();
       * // add a page to the document.
       * let page1 : PdfPage = document.pages.add();
       * // create the font
       * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
       * // create the Text Web Link
       * let textLink : PdfTextWebLink = new PdfTextWebLink();
       * //
       * // set the hyperlink
       * textLink.url = 'http://www.google.com';
       * //
       * // set the link text
       * textLink.text = 'Google';
       * // set the font
       * textLink.font = font;
       * // draw the hyperlink in PDF page
       * textLink.draw(page1, new PointF(10, 40));
       * // save the document.
       * document.save('output.pdf');
       * // destroy the document
       * document.destroy();
       * ```
       */
      get: function() {
        return this.uniformResourceLocator;
      },
      set: function(value) {
        if (value.length === 0) {
          throw new Error("ArgumentException : Url - string can not be empty");
        }
        this.uniformResourceLocator = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfTextWebLink2.prototype.draw = function(arg1, arg2) {
      if (arg1 instanceof PdfPage) {
        var layout = new PdfStringLayouter();
        var previousFontStyle = this.font.style;
        if (arg2 instanceof PointF) {
          this.recalculateBounds = true;
          this.font.style = PdfFontStyle.Underline;
          var layoutResult = layout.layout(this.value, this.font, this.stringFormat, new SizeF(arg1.graphics.clientSize.width - arg2.x, 0), true, arg1.graphics.clientSize);
          if (layoutResult.lines.length === 1) {
            var textSize = this.font.measureString(this.value);
            var rect = new RectangleF(arg2, textSize);
            rect = this.calculateBounds(rect, textSize.width, arg1.graphics.clientSize.width, arg2.x);
            this.uriAnnotation = new PdfUriAnnotation(rect, this.url);
            this.uriAnnotation.dictionary.items.setValue("Border", this.defaultBorder);
            arg1.annotations.add(this.uriAnnotation);
            var result = this.drawText(arg1, arg2);
            this.font.style = previousFontStyle;
            return result;
          } else {
            var result = this.drawMultipleLineWithPoint(layoutResult, arg1, arg2);
            this.font.style = previousFontStyle;
            return result;
          }
        } else {
          var layoutResult = layout.layout(this.value, this.font, this.stringFormat, new SizeF(arg2.width, 0), false, new SizeF(0, 0));
          this.font.style = PdfFontStyle.Underline;
          if (layoutResult.lines.length === 1) {
            var textSize = this.font.measureString(this.value);
            var rect = new RectangleF(new PointF(arg2.x, arg2.y), textSize);
            rect = this.calculateBounds(rect, textSize.width, arg2.width, arg2.x);
            this.uriAnnotation = new PdfUriAnnotation(rect, this.url);
            this.uriAnnotation.dictionary.items.setValue("Border", this.defaultBorder);
            arg1.annotations.add(this.uriAnnotation);
            var returnValue = this.drawText(arg1, arg2);
            this.font.style = previousFontStyle;
            return returnValue;
          } else {
            var returnValue = this.drawMultipleLineWithBounds(layoutResult, arg1, arg2);
            this.font.style = previousFontStyle;
            return returnValue;
          }
        }
      } else {
        var page = new PdfPage();
        page = arg1.page;
        return this.draw(page, arg2);
      }
    };
    PdfTextWebLink2.prototype.drawMultipleLineWithPoint = function(result, page, location2) {
      var layoutResult;
      for (var i = 0; i < result.layoutLines.length; i++) {
        var size = this.font.measureString(result.lines[i].text);
        if (i === result.layoutLines.length - 1 && this.stringFormat && this.stringFormat.alignment === PdfTextAlignment.Justify) {
          this._isLastElement = true;
        }
        var bounds = new RectangleF(location2, size);
        if (i !== 0) {
          bounds.x = 0;
        }
        this.text = result.lines[i].text;
        if (bounds.y + size.height > page.graphics.clientSize.height) {
          if (i !== 0) {
            page = page.graphics.getNextPage();
            bounds = new RectangleF(0, 0, page.graphics.clientSize.width, size.height);
            location2.y = 0;
          } else {
            break;
          }
        }
        bounds = this.calculateBounds(bounds, size.width, page.graphics.clientSize.width, bounds.x);
        this.uriAnnotation = new PdfUriAnnotation(bounds, this.url);
        this.uriAnnotation.dictionary.items.setValue("Border", this.defaultBorder);
        page.annotations.add(this.uriAnnotation);
        if (i !== 0) {
          layoutResult = this.drawText(page, new PointF(0, bounds.y));
        } else {
          layoutResult = this.drawText(page, bounds.x, bounds.y);
        }
        location2.y += size.height;
      }
      return layoutResult;
    };
    PdfTextWebLink2.prototype.drawMultipleLineWithBounds = function(result, page, bounds) {
      var layoutResult;
      for (var i = 0; i < result.layoutLines.length; i++) {
        var size = this.font.measureString(result.lines[i].text);
        var internalBounds = new RectangleF(new PointF(bounds.x, bounds.y), size);
        internalBounds = this.calculateBounds(internalBounds, size.width, bounds.width, bounds.x);
        this.text = result.lines[i].text;
        if (bounds.y + size.height > page.graphics.clientSize.height) {
          if (i !== 0) {
            page = page.graphics.getNextPage();
            bounds = new RectangleF(bounds.x, 0, bounds.width, size.height);
            internalBounds.y = 0;
          } else {
            break;
          }
        }
        this.uriAnnotation = new PdfUriAnnotation(internalBounds, this.url);
        this.uriAnnotation.dictionary.items.setValue("Border", this.defaultBorder);
        page.annotations.add(this.uriAnnotation);
        layoutResult = this.drawText(page, bounds);
        bounds.y += size.height;
      }
      return layoutResult;
    };
    PdfTextWebLink2.prototype.calculateBounds = function(currentBounds, lineWidth, maximumWidth, startPosition) {
      var shift = 0;
      if (this.stringFormat != null && typeof this.stringFormat !== "undefined" && this.stringFormat.alignment === PdfTextAlignment.Center) {
        currentBounds.x = startPosition + (maximumWidth - lineWidth) / 2;
        currentBounds.width = lineWidth;
      } else if (this.stringFormat != null && typeof this.stringFormat !== "undefined" && this.stringFormat.alignment === PdfTextAlignment.Right) {
        currentBounds.x = startPosition + (maximumWidth - lineWidth);
        currentBounds.width = lineWidth;
      } else if (this.stringFormat != null && typeof this.stringFormat !== "undefined" && this.stringFormat.alignment === PdfTextAlignment.Justify) {
        currentBounds.x = startPosition;
        currentBounds.width = maximumWidth;
      } else {
        currentBounds.width = startPosition;
        currentBounds.width = lineWidth;
      }
      return currentBounds;
    };
    return PdfTextWebLink2;
  })(PdfTextElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/pdf-numbers-convertor.js
var PdfNumbersConvertor = (
  /** @class */
  (function() {
    function PdfNumbersConvertor2() {
    }
    PdfNumbersConvertor2.convert = function(intArabic, numberStyle) {
      var result = "";
      switch (numberStyle) {
        case PdfNumberStyle.None:
          result = "";
          break;
        case PdfNumberStyle.Numeric:
          result = intArabic.toString();
          break;
        case PdfNumberStyle.LowerLatin:
          result = this.arabicToLetter(intArabic).toLowerCase();
          break;
        case PdfNumberStyle.LowerRoman:
          result = this.arabicToRoman(intArabic).toLowerCase();
          break;
        case PdfNumberStyle.UpperLatin:
          result = this.arabicToLetter(intArabic);
          break;
        case PdfNumberStyle.UpperRoman:
          result = this.arabicToRoman(intArabic);
          break;
      }
      return result;
    };
    PdfNumbersConvertor2.arabicToRoman = function(intArabic) {
      var retval = "";
      var retvalM = this.generateNumber(intArabic, 1e3, "M");
      retval += retvalM.returnValue;
      intArabic = retvalM.intArabic;
      var retvalCM = this.generateNumber(intArabic, 900, "CM");
      retval += retvalCM.returnValue;
      intArabic = retvalCM.intArabic;
      var retvalD = this.generateNumber(intArabic, 500, "D");
      retval += retvalD.returnValue;
      intArabic = retvalD.intArabic;
      var retvalCD = this.generateNumber(intArabic, 400, "CD");
      retval += retvalCD.returnValue;
      intArabic = retvalCD.intArabic;
      var retvalC = this.generateNumber(intArabic, 100, "C");
      retval += retvalC.returnValue;
      intArabic = retvalC.intArabic;
      var retvalXC = this.generateNumber(intArabic, 90, "XC");
      retval += retvalXC.returnValue;
      intArabic = retvalXC.intArabic;
      var retvalL = this.generateNumber(intArabic, 50, "L");
      retval += retvalL.returnValue;
      intArabic = retvalL.intArabic;
      var retvalXL = this.generateNumber(intArabic, 40, "XL");
      retval += retvalXL.returnValue;
      intArabic = retvalXL.intArabic;
      var retvalX = this.generateNumber(intArabic, 10, "X");
      retval += retvalX.returnValue;
      intArabic = retvalX.intArabic;
      var retvalIX = this.generateNumber(intArabic, 9, "IX");
      retval += retvalIX.returnValue;
      intArabic = retvalIX.intArabic;
      var retvalV = this.generateNumber(intArabic, 5, "V");
      retval += retvalV.returnValue;
      intArabic = retvalV.intArabic;
      var retvalIV = this.generateNumber(intArabic, 4, "IV");
      retval += retvalIV.returnValue;
      intArabic = retvalIV.intArabic;
      var retvalI = this.generateNumber(intArabic, 1, "I");
      retval += retvalI.returnValue;
      intArabic = retvalI.intArabic;
      return retval.toString();
    };
    PdfNumbersConvertor2.arabicToLetter = function(arabic) {
      var stack = this.convertToLetter(arabic);
      var result = "";
      while (stack.length > 0) {
        var num = stack.pop();
        result = this.appendChar(result, num);
      }
      return result.toString();
    };
    PdfNumbersConvertor2.generateNumber = function(value, magnitude, letter) {
      var numberstring = "";
      while (value >= magnitude) {
        value -= magnitude;
        numberstring += letter;
      }
      return { returnValue: numberstring.toString(), intArabic: value };
    };
    PdfNumbersConvertor2.convertToLetter = function(arabic) {
      if (arabic <= 0) {
        throw Error("ArgumentOutOfRangeException-arabic, Value can not be less 0");
      }
      var stack = [];
      while (arabic > this.letterLimit) {
        var remainder = arabic % this.letterLimit;
        if (remainder === 0) {
          arabic = arabic / this.letterLimit - 1;
          remainder = this.letterLimit;
        } else {
          arabic /= this.letterLimit;
        }
        stack.push(remainder);
      }
      stack.push(arabic);
      return stack;
    };
    PdfNumbersConvertor2.appendChar = function(builder, value) {
      var letter = String.fromCharCode(PdfNumbersConvertor2.acsiiStartIndex + value);
      builder += letter;
      return builder;
    };
    PdfNumbersConvertor2.letterLimit = 26;
    PdfNumbersConvertor2.acsiiStartIndex = 65 - 1;
    return PdfNumbersConvertor2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/pdf-template-value-pair.js
var PdfTemplateValuePair = (
  /** @class */
  (function() {
    function PdfTemplateValuePair2(template, value) {
      this.pdfTemplate = null;
      this.content = "";
      if (typeof template === "undefined") {
      } else {
        this.template = template;
        this.value = value;
      }
    }
    Object.defineProperty(PdfTemplateValuePair2.prototype, "template", {
      // Properties
      /**
       * Gets or sets the template.
       * @private
       */
      get: function() {
        return this.pdfTemplate;
      },
      set: function(value) {
        this.pdfTemplate = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfTemplateValuePair2.prototype, "value", {
      /**
       * Gets or sets the value.
       * @private
       */
      get: function() {
        return this.content;
      },
      set: function(value) {
        this.content = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfTemplateValuePair2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/multiple-value-field.js
var __extends45 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfMultipleValueField = (
  /** @class */
  (function(_super) {
    __extends45(PdfMultipleValueField2, _super);
    function PdfMultipleValueField2() {
      var _this = _super.call(this) || this;
      _this.list = new TemporaryDictionary();
      return _this;
    }
    PdfMultipleValueField2.prototype.performDraw = function(graphics, location2, scalingX, scalingY) {
      _super.prototype.performDrawHelper.call(this, graphics, location2, scalingX, scalingY);
      var value = this.getValue(graphics);
      var template = new PdfTemplate(this.getSize());
      this.list.setValue(graphics, new PdfTemplateValuePair(template, value));
      var g = template.graphics;
      var size = this.getSize();
      template.graphics.drawString(value, this.getFont(), this.pen, this.getBrush(), 0, 0, size.width, size.height, this.stringFormat);
      var drawLocation = new PointF(location2.x + this.location.x, location2.y + this.location.y);
      graphics.drawPdfTemplate(template, drawLocation, new SizeF(template.width * scalingX, template.height * scalingY));
    };
    return PdfMultipleValueField2;
  })(PdfAutomaticField)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/pdf-page-number-field.js
var __extends46 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfPageNumberField = (
  /** @class */
  (function(_super) {
    __extends46(PdfPageNumberField2, _super);
    function PdfPageNumberField2(font, arg2) {
      var _this = _super.call(this) || this;
      _this.internalNumberStyle = PdfNumberStyle.Numeric;
      if (typeof arg2 === "undefined") {
        _this.font = font;
      } else if (arg2 instanceof PdfBrush) {
        _this.font = font;
        _this.brush = arg2;
      } else {
        _this.font = font;
        _this.bounds = arg2;
      }
      return _this;
    }
    Object.defineProperty(PdfPageNumberField2.prototype, "numberStyle", {
      // Properties
      /**
       * Gets and sets the number style of the page number field.
       * @private
       */
      get: function() {
        return this.internalNumberStyle;
      },
      set: function(value) {
        this.internalNumberStyle = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfPageNumberField2.prototype.getValue = function(graphics) {
      var result = null;
      var page = this.getPageFromGraphics(graphics);
      result = this.internalGetValue(page);
      return result;
    };
    PdfPageNumberField2.prototype.internalGetValue = function(page) {
      var document2 = page.document;
      var pageIndex = document2.pages.indexOf(page) + 1;
      return PdfNumbersConvertor.convert(pageIndex, this.numberStyle);
    };
    return PdfPageNumberField2;
  })(PdfMultipleValueField)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/composite-field.js
var __extends47 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfCompositeField = (
  /** @class */
  (function(_super) {
    __extends47(PdfCompositeField2, _super);
    function PdfCompositeField2(font, brush, text) {
      var list = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        list[_i - 3] = arguments[_i];
      }
      var _this = _super.call(this) || this;
      _this.internalAutomaticFields = null;
      _this.internalText = "";
      _this.font = font;
      _this.brush = brush;
      _this.text = text;
      _this.automaticFields = list;
      return _this;
    }
    Object.defineProperty(PdfCompositeField2.prototype, "text", {
      // Properties
      /**
       * Gets and sets the content of the field.
       * @public
       */
      get: function() {
        return this.internalText;
      },
      set: function(value) {
        this.internalText = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfCompositeField2.prototype, "automaticFields", {
      /**
       * Gets and sets the list of the field to drawn.
       * @public
       */
      get: function() {
        return this.internalAutomaticFields;
      },
      set: function(value) {
        this.internalAutomaticFields = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfCompositeField2.prototype.getValue = function(graphics) {
      var values = [];
      var text = this.text.toString();
      if (typeof this.automaticFields !== "undefined" && this.automaticFields != null && this.automaticFields.length > 0) {
        for (var i = 0; i < this.automaticFields.length; i++) {
          var automaticField = this.automaticFields[i];
          text = text.replace("{" + i + "}", automaticField.getValue(graphics));
        }
      }
      return text;
    };
    return PdfCompositeField2;
  })(PdfMultipleValueField)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/single-value-field.js
var __extends48 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfSingleValueField = (
  /** @class */
  (function(_super) {
    __extends48(PdfSingleValueField2, _super);
    function PdfSingleValueField2() {
      var _this = _super.call(this) || this;
      _this.list = new TemporaryDictionary();
      _this.painterGraphics = [];
      return _this;
    }
    PdfSingleValueField2.prototype.performDraw = function(graphics, location2, scalingX, scalingY) {
      _super.prototype.performDrawHelper.call(this, graphics, location2, scalingX, scalingY);
      var page = this.getPageFromGraphics(graphics);
      var document2 = page.document;
      var textValue = this.getValue(graphics);
      if (this.list.containsKey(document2)) {
        var pair = this.list.getValue(document2);
        var drawLocation = new PointF(location2.x + this.location.x, location2.y + this.location.y);
        graphics.drawPdfTemplate(pair.template, drawLocation, new SizeF(pair.template.width * scalingX, pair.template.height * scalingY));
        this.painterGraphics.push(graphics);
      } else {
        var size = this.getSize();
        var template = new PdfTemplate(size);
        this.list.setValue(document2, new PdfTemplateValuePair(template, textValue));
        template.graphics.drawString(textValue, this.getFont(), this.pen, this.getBrush(), 0, 0, size.width, size.height, this.stringFormat);
        var drawLocation = new PointF(location2.x + this.location.x, location2.y + this.location.y);
        graphics.drawPdfTemplate(template, drawLocation, new SizeF(template.width * scalingX, template.height * scalingY));
        this.painterGraphics.push(graphics);
      }
    };
    return PdfSingleValueField2;
  })(PdfAutomaticField)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/document/automatic-fields/page-count-field.js
var __extends49 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfPageCountField = (
  /** @class */
  (function(_super) {
    __extends49(PdfPageCountField2, _super);
    function PdfPageCountField2(font, arg2) {
      var _this = _super.call(this) || this;
      _this.internalNumberStyle = PdfNumberStyle.Numeric;
      if (typeof arg2 === "undefined") {
        _this.font = font;
      } else if (arg2 instanceof PdfBrush) {
        _this.font = font;
        _this.brush = arg2;
      } else {
        _this.font = font;
        _this.bounds = arg2;
      }
      return _this;
    }
    Object.defineProperty(PdfPageCountField2.prototype, "numberStyle", {
      // Properties
      /**
       * Gets and sets the number style of the field.
       * @public
       */
      get: function() {
        return this.internalNumberStyle;
      },
      set: function(value) {
        this.internalNumberStyle = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfPageCountField2.prototype.getValue = function(graphics) {
      var result = null;
      var page = this.getPageFromGraphics(graphics);
      var document2 = page.section.parent.document;
      var count = document2.pages.count;
      result = PdfNumbersConvertor.convert(count, this.numberStyle);
      return result;
    };
    return PdfPageCountField2;
  })(PdfSingleValueField)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/general/enum.js
var PdfDestinationMode;
(function(PdfDestinationMode2) {
  PdfDestinationMode2[PdfDestinationMode2["Location"] = 0] = "Location";
  PdfDestinationMode2[PdfDestinationMode2["FitToPage"] = 1] = "FitToPage";
  PdfDestinationMode2[PdfDestinationMode2["FitR"] = 2] = "FitR";
})(PdfDestinationMode || (PdfDestinationMode = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/general/pdf-destination.js
var PdfDestination = (
  /** @class */
  (function() {
    function PdfDestination2(arg1, arg2) {
      this.dictionaryProperties = new DictionaryProperties();
      this.destinationMode = PdfDestinationMode.Location;
      this.zoomFactor = 0;
      this.destinationLocation = new PointF(0, 0);
      this.bounds = new RectangleF();
      this.array = new PdfArray();
      var angle = PdfPageRotateAngle.RotateAngle0;
      this.destinationLocation = new PointF(0, this.destinationLocation.y);
      this.pdfPage = arg1;
      if (arg2 instanceof PointF) {
        this.destinationLocation = arg2;
      } else {
        this.bounds = arg2;
      }
    }
    Object.defineProperty(PdfDestination2.prototype, "zoom", {
      // Properties
      /**
       * Gets and Sets the `zoom` factor.
       * @private
       */
      get: function() {
        return this.zoomFactor;
      },
      set: function(value) {
        this.zoomFactor = value;
        this.initializePrimitive();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDestination2.prototype, "page", {
      /**
       * Gets and Sets the `page` object.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      set: function(value) {
        this.pdfPage = value;
        this.initializePrimitive();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDestination2.prototype, "mode", {
      /**
       * Gets and Sets the destination `mode`.
       * @private
       */
      get: function() {
        return this.destinationMode;
      },
      set: function(value) {
        this.destinationMode = value;
        this.initializePrimitive();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfDestination2.prototype, "location", {
      /**
       * Gets and Sets the `location`.
       * @private
       */
      get: function() {
        return this.destinationLocation;
      },
      set: function(value) {
        this.destinationLocation = value;
        this.initializePrimitive();
      },
      enumerable: true,
      configurable: true
    });
    PdfDestination2.prototype.pointToNativePdf = function(page, point) {
      var section = page.section;
      return section.pointToNativePdf(page, point);
    };
    PdfDestination2.prototype.initializePrimitive = function() {
      this.array.clear();
      this.array.add(new PdfReferenceHolder(this.pdfPage));
      switch (this.destinationMode) {
        case PdfDestinationMode.Location:
          var simplePage = this.pdfPage;
          var point = new PointF();
          point = this.pointToNativePdf(simplePage, this.destinationLocation);
          this.array.add(new PdfName(this.dictionaryProperties.xyz));
          this.array.add(new PdfNumber(point.x));
          this.array.add(new PdfNumber(point.y));
          this.array.add(new PdfNumber(this.zoomFactor));
          break;
        case PdfDestinationMode.FitToPage:
          this.array.add(new PdfName(this.dictionaryProperties.fit));
          break;
      }
    };
    Object.defineProperty(PdfDestination2.prototype, "element", {
      /**
       * Gets the `element` representing this object.
       * @private
       */
      get: function() {
        this.initializePrimitive();
        return this.array;
      },
      enumerable: true,
      configurable: true
    });
    return PdfDestination2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/general/functions/pdf-function.js
var PdfFunction = (
  /** @class */
  (function() {
    function PdfFunction2(dictionary) {
      this.mDictionary = null;
      this.mDictionaryProperties = new DictionaryProperties();
      this.mDictionary = dictionary;
    }
    Object.defineProperty(PdfFunction2.prototype, "domain", {
      //Properties
      /**
       * Gets or sets the domain of the function.
       * @public
       */
      get: function() {
        var domain = this.mDictionary.items.getValue(this.mDictionaryProperties.domain);
        return domain;
      },
      set: function(value) {
        this.mDictionary.items.setValue(this.mDictionaryProperties.domain, value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFunction2.prototype, "range", {
      /**
       * Gets or sets the range.
       * @public
       */
      get: function() {
        var range = this.mDictionary.items.getValue(this.mDictionaryProperties.range);
        return range;
      },
      set: function(value) {
        this.mDictionary.items.setValue(this.mDictionaryProperties.range, value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFunction2.prototype, "dictionary", {
      /**
       * Gets the dictionary.
       */
      get: function() {
        return this.mDictionary;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfFunction2.prototype, "element", {
      //IPdfWrapper Members
      /**
       * Gets the element.
       */
      get: function() {
        return this.mDictionary;
      },
      enumerable: true,
      configurable: true
    });
    return PdfFunction2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/general/functions/pdf-sampled-function.js
var __extends50 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfSampledFunction = (
  /** @class */
  (function(_super) {
    __extends50(PdfSampledFunction2, _super);
    function PdfSampledFunction2(domain, range, sizes, samples) {
      var _this = _super.call(this, new PdfStream()) || this;
      if (typeof domain === "undefined") {
        _this.dictionary.items.setValue(_this.mDictionaryProperties.functionType, new PdfNumber(0));
      } else {
        _this.dictionary.items.setValue(_this.mDictionaryProperties.functionType, new PdfNumber(0));
        _this.checkParams(domain, range, sizes, samples);
        _this.setDomainAndRange(domain, range);
        _this.setSizeAndValues(sizes, samples);
      }
      return _this;
    }
    PdfSampledFunction2.prototype.checkParams = function(domain, range, sizes, samples) {
      var rLength = range.length;
      var dLength = domain.length;
      var sLength = samples.length;
      var frameLength = rLength * (dLength / 4);
    };
    PdfSampledFunction2.prototype.setDomainAndRange = function(domain, range) {
      this.domain = new PdfArray(domain);
      this.range = new PdfArray(range);
    };
    PdfSampledFunction2.prototype.setSizeAndValues = function(sizes, samples) {
      var s = this.dictionary;
      s.isResource = true;
      this.dictionary.items.setValue(this.mDictionaryProperties.size, new PdfArray(sizes));
      this.dictionary.items.setValue(this.mDictionaryProperties.bitsPerSample, new PdfNumber(8));
      s.writeBytes(samples);
    };
    return PdfSampledFunction2;
  })(PdfFunction)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/enum.js
var PdfExtend;
(function(PdfExtend2) {
  PdfExtend2[PdfExtend2["None"] = 0] = "None";
  PdfExtend2[PdfExtend2["Start"] = 1] = "Start";
  PdfExtend2[PdfExtend2["End"] = 2] = "End";
  PdfExtend2[PdfExtend2["Both"] = 3] = "Both";
})(PdfExtend || (PdfExtend = {}));
var PdfLinearGradientMode;
(function(PdfLinearGradientMode2) {
  PdfLinearGradientMode2[PdfLinearGradientMode2["BackwardDiagonal"] = 0] = "BackwardDiagonal";
  PdfLinearGradientMode2[PdfLinearGradientMode2["ForwardDiagonal"] = 1] = "ForwardDiagonal";
  PdfLinearGradientMode2[PdfLinearGradientMode2["Horizontal"] = 2] = "Horizontal";
  PdfLinearGradientMode2[PdfLinearGradientMode2["Vertical"] = 3] = "Vertical";
})(PdfLinearGradientMode || (PdfLinearGradientMode = {}));
var ShadingType;
(function(ShadingType2) {
  ShadingType2[ShadingType2["Function"] = 1] = "Function";
  ShadingType2[ShadingType2["Axial"] = 2] = "Axial";
  ShadingType2[ShadingType2["Radial"] = 3] = "Radial";
})(ShadingType || (ShadingType = {}));
var KnownColor;
(function(KnownColor2) {
  KnownColor2[KnownColor2["ActiveBorder"] = 1] = "ActiveBorder";
  KnownColor2[KnownColor2["ActiveCaption"] = 2] = "ActiveCaption";
  KnownColor2[KnownColor2["ActiveCaptionText"] = 3] = "ActiveCaptionText";
  KnownColor2[KnownColor2["AppWorkspace"] = 4] = "AppWorkspace";
  KnownColor2[KnownColor2["Control"] = 5] = "Control";
  KnownColor2[KnownColor2["ControlDark"] = 6] = "ControlDark";
  KnownColor2[KnownColor2["ControlDarkDark"] = 7] = "ControlDarkDark";
  KnownColor2[KnownColor2["ControlLight"] = 8] = "ControlLight";
  KnownColor2[KnownColor2["ControlLightLight"] = 9] = "ControlLightLight";
  KnownColor2[KnownColor2["ControlText"] = 10] = "ControlText";
  KnownColor2[KnownColor2["Desktop"] = 11] = "Desktop";
  KnownColor2[KnownColor2["GrayText"] = 12] = "GrayText";
  KnownColor2[KnownColor2["Highlight"] = 13] = "Highlight";
  KnownColor2[KnownColor2["HighlightText"] = 14] = "HighlightText";
  KnownColor2[KnownColor2["HotTrack"] = 15] = "HotTrack";
  KnownColor2[KnownColor2["InactiveBorder"] = 16] = "InactiveBorder";
  KnownColor2[KnownColor2["InactiveCaption"] = 17] = "InactiveCaption";
  KnownColor2[KnownColor2["InactiveCaptionText"] = 18] = "InactiveCaptionText";
  KnownColor2[KnownColor2["Info"] = 19] = "Info";
  KnownColor2[KnownColor2["InfoText"] = 20] = "InfoText";
  KnownColor2[KnownColor2["Menu"] = 21] = "Menu";
  KnownColor2[KnownColor2["MenuText"] = 22] = "MenuText";
  KnownColor2[KnownColor2["ScrollBar"] = 23] = "ScrollBar";
  KnownColor2[KnownColor2["Window"] = 24] = "Window";
  KnownColor2[KnownColor2["WindowFrame"] = 25] = "WindowFrame";
  KnownColor2[KnownColor2["WindowText"] = 26] = "WindowText";
  KnownColor2[KnownColor2["Transparent"] = 27] = "Transparent";
  KnownColor2[KnownColor2["AliceBlue"] = 28] = "AliceBlue";
  KnownColor2[KnownColor2["AntiqueWhite"] = 29] = "AntiqueWhite";
  KnownColor2[KnownColor2["Aqua"] = 30] = "Aqua";
  KnownColor2[KnownColor2["Aquamarine"] = 31] = "Aquamarine";
  KnownColor2[KnownColor2["Azure"] = 32] = "Azure";
  KnownColor2[KnownColor2["Beige"] = 33] = "Beige";
  KnownColor2[KnownColor2["Bisque"] = 34] = "Bisque";
  KnownColor2[KnownColor2["Black"] = 35] = "Black";
  KnownColor2[KnownColor2["BlanchedAlmond"] = 36] = "BlanchedAlmond";
  KnownColor2[KnownColor2["Blue"] = 37] = "Blue";
  KnownColor2[KnownColor2["BlueViolet"] = 38] = "BlueViolet";
  KnownColor2[KnownColor2["Brown"] = 39] = "Brown";
  KnownColor2[KnownColor2["BurlyWood"] = 40] = "BurlyWood";
  KnownColor2[KnownColor2["CadetBlue"] = 41] = "CadetBlue";
  KnownColor2[KnownColor2["Chartreuse"] = 42] = "Chartreuse";
  KnownColor2[KnownColor2["Chocolate"] = 43] = "Chocolate";
  KnownColor2[KnownColor2["Coral"] = 44] = "Coral";
  KnownColor2[KnownColor2["CornflowerBlue"] = 45] = "CornflowerBlue";
  KnownColor2[KnownColor2["Cornsilk"] = 46] = "Cornsilk";
  KnownColor2[KnownColor2["Crimson"] = 47] = "Crimson";
  KnownColor2[KnownColor2["Cyan"] = 48] = "Cyan";
  KnownColor2[KnownColor2["DarkBlue"] = 49] = "DarkBlue";
  KnownColor2[KnownColor2["DarkCyan"] = 50] = "DarkCyan";
  KnownColor2[KnownColor2["DarkGoldenrod"] = 51] = "DarkGoldenrod";
  KnownColor2[KnownColor2["DarkGray"] = 52] = "DarkGray";
  KnownColor2[KnownColor2["DarkGreen"] = 53] = "DarkGreen";
  KnownColor2[KnownColor2["DarkKhaki"] = 54] = "DarkKhaki";
  KnownColor2[KnownColor2["DarkMagenta"] = 55] = "DarkMagenta";
  KnownColor2[KnownColor2["DarkOliveGreen"] = 56] = "DarkOliveGreen";
  KnownColor2[KnownColor2["DarkOrange"] = 57] = "DarkOrange";
  KnownColor2[KnownColor2["DarkOrchid"] = 58] = "DarkOrchid";
  KnownColor2[KnownColor2["DarkRed"] = 59] = "DarkRed";
  KnownColor2[KnownColor2["DarkSalmon"] = 60] = "DarkSalmon";
  KnownColor2[KnownColor2["DarkSeaGreen"] = 61] = "DarkSeaGreen";
  KnownColor2[KnownColor2["DarkSlateBlue"] = 62] = "DarkSlateBlue";
  KnownColor2[KnownColor2["DarkSlateGray"] = 63] = "DarkSlateGray";
  KnownColor2[KnownColor2["DarkTurquoise"] = 64] = "DarkTurquoise";
  KnownColor2[KnownColor2["DarkViolet"] = 65] = "DarkViolet";
  KnownColor2[KnownColor2["DeepPink"] = 66] = "DeepPink";
  KnownColor2[KnownColor2["DeepSkyBlue"] = 67] = "DeepSkyBlue";
  KnownColor2[KnownColor2["DimGray"] = 68] = "DimGray";
  KnownColor2[KnownColor2["DodgerBlue"] = 69] = "DodgerBlue";
  KnownColor2[KnownColor2["Firebrick"] = 70] = "Firebrick";
  KnownColor2[KnownColor2["FloralWhite"] = 71] = "FloralWhite";
  KnownColor2[KnownColor2["ForestGreen"] = 72] = "ForestGreen";
  KnownColor2[KnownColor2["Fuchsia"] = 73] = "Fuchsia";
  KnownColor2[KnownColor2["Gainsboro"] = 74] = "Gainsboro";
  KnownColor2[KnownColor2["GhostWhite"] = 75] = "GhostWhite";
  KnownColor2[KnownColor2["Gold"] = 76] = "Gold";
  KnownColor2[KnownColor2["Goldenrod"] = 77] = "Goldenrod";
  KnownColor2[KnownColor2["Gray"] = 78] = "Gray";
  KnownColor2[KnownColor2["Green"] = 79] = "Green";
  KnownColor2[KnownColor2["GreenYellow"] = 80] = "GreenYellow";
  KnownColor2[KnownColor2["Honeydew"] = 81] = "Honeydew";
  KnownColor2[KnownColor2["HotPink"] = 82] = "HotPink";
  KnownColor2[KnownColor2["IndianRed"] = 83] = "IndianRed";
  KnownColor2[KnownColor2["Indigo"] = 84] = "Indigo";
  KnownColor2[KnownColor2["Ivory"] = 85] = "Ivory";
  KnownColor2[KnownColor2["Khaki"] = 86] = "Khaki";
  KnownColor2[KnownColor2["Lavender"] = 87] = "Lavender";
  KnownColor2[KnownColor2["LavenderBlush"] = 88] = "LavenderBlush";
  KnownColor2[KnownColor2["LawnGreen"] = 89] = "LawnGreen";
  KnownColor2[KnownColor2["LemonChiffon"] = 90] = "LemonChiffon";
  KnownColor2[KnownColor2["LightBlue"] = 91] = "LightBlue";
  KnownColor2[KnownColor2["LightCoral"] = 92] = "LightCoral";
  KnownColor2[KnownColor2["LightCyan"] = 93] = "LightCyan";
  KnownColor2[KnownColor2["LightGoldenrodYellow"] = 94] = "LightGoldenrodYellow";
  KnownColor2[KnownColor2["LightGray"] = 95] = "LightGray";
  KnownColor2[KnownColor2["LightGreen"] = 96] = "LightGreen";
  KnownColor2[KnownColor2["LightPink"] = 97] = "LightPink";
  KnownColor2[KnownColor2["LightSalmon"] = 98] = "LightSalmon";
  KnownColor2[KnownColor2["LightSeaGreen"] = 99] = "LightSeaGreen";
  KnownColor2[KnownColor2["LightSkyBlue"] = 100] = "LightSkyBlue";
  KnownColor2[KnownColor2["LightSlateGray"] = 101] = "LightSlateGray";
  KnownColor2[KnownColor2["LightSteelBlue"] = 102] = "LightSteelBlue";
  KnownColor2[KnownColor2["LightYellow"] = 103] = "LightYellow";
  KnownColor2[KnownColor2["Lime"] = 104] = "Lime";
  KnownColor2[KnownColor2["LimeGreen"] = 105] = "LimeGreen";
  KnownColor2[KnownColor2["Linen"] = 106] = "Linen";
  KnownColor2[KnownColor2["Magenta"] = 107] = "Magenta";
  KnownColor2[KnownColor2["Maroon"] = 108] = "Maroon";
  KnownColor2[KnownColor2["MediumAquamarine"] = 109] = "MediumAquamarine";
  KnownColor2[KnownColor2["MediumBlue"] = 110] = "MediumBlue";
  KnownColor2[KnownColor2["MediumOrchid"] = 111] = "MediumOrchid";
  KnownColor2[KnownColor2["MediumPurple"] = 112] = "MediumPurple";
  KnownColor2[KnownColor2["MediumSeaGreen"] = 113] = "MediumSeaGreen";
  KnownColor2[KnownColor2["MediumSlateBlue"] = 114] = "MediumSlateBlue";
  KnownColor2[KnownColor2["MediumSpringGreen"] = 115] = "MediumSpringGreen";
  KnownColor2[KnownColor2["MediumTurquoise"] = 116] = "MediumTurquoise";
  KnownColor2[KnownColor2["MediumVioletRed"] = 117] = "MediumVioletRed";
  KnownColor2[KnownColor2["MidnightBlue"] = 118] = "MidnightBlue";
  KnownColor2[KnownColor2["MintCream"] = 119] = "MintCream";
  KnownColor2[KnownColor2["MistyRose"] = 120] = "MistyRose";
  KnownColor2[KnownColor2["Moccasin"] = 121] = "Moccasin";
  KnownColor2[KnownColor2["NavajoWhite"] = 122] = "NavajoWhite";
  KnownColor2[KnownColor2["Navy"] = 123] = "Navy";
  KnownColor2[KnownColor2["OldLace"] = 124] = "OldLace";
  KnownColor2[KnownColor2["Olive"] = 125] = "Olive";
  KnownColor2[KnownColor2["OliveDrab"] = 126] = "OliveDrab";
  KnownColor2[KnownColor2["Orange"] = 127] = "Orange";
  KnownColor2[KnownColor2["OrangeRed"] = 128] = "OrangeRed";
  KnownColor2[KnownColor2["Orchid"] = 129] = "Orchid";
  KnownColor2[KnownColor2["PaleGoldenrod"] = 130] = "PaleGoldenrod";
  KnownColor2[KnownColor2["PaleGreen"] = 131] = "PaleGreen";
  KnownColor2[KnownColor2["PaleTurquoise"] = 132] = "PaleTurquoise";
  KnownColor2[KnownColor2["PaleVioletRed"] = 133] = "PaleVioletRed";
  KnownColor2[KnownColor2["PapayaWhip"] = 134] = "PapayaWhip";
  KnownColor2[KnownColor2["PeachPuff"] = 135] = "PeachPuff";
  KnownColor2[KnownColor2["Peru"] = 136] = "Peru";
  KnownColor2[KnownColor2["Pink"] = 137] = "Pink";
  KnownColor2[KnownColor2["Plum"] = 138] = "Plum";
  KnownColor2[KnownColor2["PowderBlue"] = 139] = "PowderBlue";
  KnownColor2[KnownColor2["Purple"] = 140] = "Purple";
  KnownColor2[KnownColor2["Red"] = 141] = "Red";
  KnownColor2[KnownColor2["RosyBrown"] = 142] = "RosyBrown";
  KnownColor2[KnownColor2["RoyalBlue"] = 143] = "RoyalBlue";
  KnownColor2[KnownColor2["SaddleBrown"] = 144] = "SaddleBrown";
  KnownColor2[KnownColor2["Salmon"] = 145] = "Salmon";
  KnownColor2[KnownColor2["SandyBrown"] = 146] = "SandyBrown";
  KnownColor2[KnownColor2["SeaGreen"] = 147] = "SeaGreen";
  KnownColor2[KnownColor2["SeaShell"] = 148] = "SeaShell";
  KnownColor2[KnownColor2["Sienna"] = 149] = "Sienna";
  KnownColor2[KnownColor2["Silver"] = 150] = "Silver";
  KnownColor2[KnownColor2["SkyBlue"] = 151] = "SkyBlue";
  KnownColor2[KnownColor2["SlateBlue"] = 152] = "SlateBlue";
  KnownColor2[KnownColor2["SlateGray"] = 153] = "SlateGray";
  KnownColor2[KnownColor2["Snow"] = 154] = "Snow";
  KnownColor2[KnownColor2["SpringGreen"] = 155] = "SpringGreen";
  KnownColor2[KnownColor2["SteelBlue"] = 156] = "SteelBlue";
  KnownColor2[KnownColor2["Tan"] = 157] = "Tan";
  KnownColor2[KnownColor2["Teal"] = 158] = "Teal";
  KnownColor2[KnownColor2["Thistle"] = 159] = "Thistle";
  KnownColor2[KnownColor2["Tomato"] = 160] = "Tomato";
  KnownColor2[KnownColor2["Turquoise"] = 161] = "Turquoise";
  KnownColor2[KnownColor2["Violet"] = 162] = "Violet";
  KnownColor2[KnownColor2["Wheat"] = 163] = "Wheat";
  KnownColor2[KnownColor2["White"] = 164] = "White";
  KnownColor2[KnownColor2["WhiteSmoke"] = 165] = "WhiteSmoke";
  KnownColor2[KnownColor2["Yellow"] = 166] = "Yellow";
  KnownColor2[KnownColor2["YellowGreen"] = 167] = "YellowGreen";
  KnownColor2[KnownColor2["ButtonFace"] = 168] = "ButtonFace";
  KnownColor2[KnownColor2["ButtonHighlight"] = 169] = "ButtonHighlight";
  KnownColor2[KnownColor2["ButtonShadow"] = 170] = "ButtonShadow";
  KnownColor2[KnownColor2["GradientActiveCaption"] = 171] = "GradientActiveCaption";
  KnownColor2[KnownColor2["GradientInactiveCaption"] = 172] = "GradientInactiveCaption";
  KnownColor2[KnownColor2["MenuBar"] = 173] = "MenuBar";
  KnownColor2[KnownColor2["MenuHighlight"] = 174] = "MenuHighlight";
})(KnownColor || (KnownColor = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-brushes.js
var PdfBrushes = (
  /** @class */
  (function() {
    function PdfBrushes2() {
    }
    Object.defineProperty(PdfBrushes2, "AliceBlue", {
      //Static Properties
      /**
       * Gets the AliceBlue brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.AliceBlue)) {
          brush = this.sBrushes.getValue(KnownColor.AliceBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.AliceBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "AntiqueWhite", {
      /**
       * Gets the antique white brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.AntiqueWhite)) {
          brush = this.sBrushes.getValue(KnownColor.AntiqueWhite);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.AntiqueWhite);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Aqua", {
      /**
       * Gets the Aqua default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Aqua)) {
          brush = this.sBrushes.getValue(KnownColor.Aqua);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Aqua);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Aquamarine", {
      /**
       * Gets the Aquamarine default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Aquamarine)) {
          brush = this.sBrushes.getValue(KnownColor.Aquamarine);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Aquamarine);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Azure", {
      /**
       * Gets the Azure default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Azure)) {
          brush = this.sBrushes.getValue(KnownColor.Azure);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Azure);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Beige", {
      /**
       * Gets the Beige default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Beige)) {
          brush = this.sBrushes.getValue(KnownColor.Beige);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Beige);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Bisque", {
      /**
       * Gets the Bisque default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Bisque)) {
          brush = this.sBrushes.getValue(KnownColor.Bisque);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Bisque);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Black", {
      /**
       * Gets the Black default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Black)) {
          brush = this.sBrushes.getValue(KnownColor.Black);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Black);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "BlanchedAlmond", {
      /**
       * Gets the BlanchedAlmond default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.BlanchedAlmond)) {
          brush = this.sBrushes.getValue(KnownColor.BlanchedAlmond);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.BlanchedAlmond);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Blue", {
      /**
       * Gets the Blue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Blue)) {
          brush = this.sBrushes.getValue(KnownColor.Blue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Blue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "BlueViolet", {
      /**
       * Gets the BlueViolet default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.BlueViolet)) {
          brush = this.sBrushes.getValue(KnownColor.BlueViolet);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.BlueViolet);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Brown", {
      /**
       * Gets the Brown default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Brown)) {
          brush = this.sBrushes.getValue(KnownColor.Brown);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Brown);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "BurlyWood", {
      /**
       * Gets the BurlyWood default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.BurlyWood)) {
          brush = this.sBrushes.getValue(KnownColor.BurlyWood);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.BurlyWood);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "CadetBlue", {
      /**
       * Gets the CadetBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.CadetBlue)) {
          brush = this.sBrushes.getValue(KnownColor.CadetBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.CadetBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Chartreuse", {
      /**
       * Gets the Chartreuse default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Chartreuse)) {
          brush = this.sBrushes.getValue(KnownColor.Chartreuse);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Chartreuse);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Chocolate", {
      /**
       * Gets the Chocolate default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Chocolate)) {
          brush = this.sBrushes.getValue(KnownColor.Chocolate);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Chocolate);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Coral", {
      /**
       * Gets the Coral default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Coral)) {
          brush = this.sBrushes.getValue(KnownColor.Coral);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Coral);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "CornflowerBlue", {
      /**
       * Gets the CornflowerBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.CornflowerBlue)) {
          brush = this.sBrushes.getValue(KnownColor.CornflowerBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.CornflowerBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Cornsilk", {
      /**
       * Gets the Corn silk default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Cornsilk)) {
          brush = this.sBrushes.getValue(KnownColor.Cornsilk);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Cornsilk);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Crimson", {
      /**
       *  Gets the Crimson default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Crimson)) {
          brush = this.sBrushes.getValue(KnownColor.Crimson);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Crimson);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Cyan", {
      /**
       * Gets the Cyan default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Cyan)) {
          brush = this.sBrushes.getValue(KnownColor.Cyan);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Cyan);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkBlue", {
      /**
       * Gets the DarkBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkBlue)) {
          brush = this.sBrushes.getValue(KnownColor.DarkBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkCyan", {
      /**
       * Gets the DarkCyan default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkCyan)) {
          brush = this.sBrushes.getValue(KnownColor.DarkCyan);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkCyan);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkGoldenrod", {
      /**
       * Gets the DarkGoldenrod default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkGoldenrod)) {
          brush = this.sBrushes.getValue(KnownColor.DarkGoldenrod);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkGoldenrod);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkGray", {
      /**
       * Gets the DarkGray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkGray)) {
          brush = this.sBrushes.getValue(KnownColor.DarkGray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkGray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkGreen", {
      /**
       * Gets the DarkGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkGreen)) {
          brush = this.sBrushes.getValue(KnownColor.DarkGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkKhaki", {
      /**
       * Gets the DarkKhaki default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkKhaki)) {
          brush = this.sBrushes.getValue(KnownColor.DarkKhaki);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkKhaki);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkMagenta", {
      /**
       * Gets the DarkMagenta default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkMagenta)) {
          brush = this.sBrushes.getValue(KnownColor.DarkMagenta);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkMagenta);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkOliveGreen", {
      /**
       * Gets the DarkOliveGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkOliveGreen)) {
          brush = this.sBrushes.getValue(KnownColor.DarkOliveGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkOliveGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkOrange", {
      /**
       * Gets the DarkOrange default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkOrange)) {
          brush = this.sBrushes.getValue(KnownColor.DarkOrange);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkOrange);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkOrchid", {
      /**
       * Gets the DarkOrchid default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkOrchid)) {
          brush = this.sBrushes.getValue(KnownColor.DarkOrchid);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkOrchid);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkRed", {
      /**
       * Gets the DarkRed default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkRed)) {
          brush = this.sBrushes.getValue(KnownColor.DarkRed);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkRed);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkSalmon", {
      /**
       * Gets the DarkSalmon default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkSalmon)) {
          brush = this.sBrushes.getValue(KnownColor.DarkSalmon);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkSalmon);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkSeaGreen", {
      /**
       * Gets the DarkSeaGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkSeaGreen)) {
          brush = this.sBrushes.getValue(KnownColor.DarkSeaGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkSeaGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkSlateBlue", {
      /**
       * Gets the DarkSlateBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkSlateBlue)) {
          brush = this.sBrushes.getValue(KnownColor.DarkSlateBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkSlateBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkSlateGray", {
      /**
       * Gets the DarkSlateGray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkSlateGray)) {
          brush = this.sBrushes.getValue(KnownColor.DarkSlateGray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkSlateGray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkTurquoise", {
      /**
       * Gets the DarkTurquoise default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkTurquoise)) {
          brush = this.sBrushes.getValue(KnownColor.DarkTurquoise);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkTurquoise);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DarkViolet", {
      /**
       * Gets the DarkViolet default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DarkViolet)) {
          brush = this.sBrushes.getValue(KnownColor.DarkViolet);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DarkViolet);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DeepPink", {
      /**
       * Gets the DeepPink default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DeepPink)) {
          brush = this.sBrushes.getValue(KnownColor.DeepPink);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DeepPink);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DeepSkyBlue", {
      /**
       * Gets the DeepSkyBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DeepSkyBlue)) {
          brush = this.sBrushes.getValue(KnownColor.DeepSkyBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DeepSkyBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DimGray", {
      /**
       * Gets the DimGray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DimGray)) {
          brush = this.sBrushes.getValue(KnownColor.DimGray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DimGray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "DodgerBlue", {
      /**
       * Gets the DodgerBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.DodgerBlue)) {
          brush = this.sBrushes.getValue(KnownColor.DodgerBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.DodgerBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Firebrick", {
      /**
       * Gets the Firebrick default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Firebrick)) {
          brush = this.sBrushes.getValue(KnownColor.Firebrick);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Firebrick);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "FloralWhite", {
      /**
       * Gets the FloralWhite default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.FloralWhite)) {
          brush = this.sBrushes.getValue(KnownColor.FloralWhite);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.FloralWhite);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "ForestGreen", {
      /**
       * Gets the ForestGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.ForestGreen)) {
          brush = this.sBrushes.getValue(KnownColor.ForestGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.ForestGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Fuchsia", {
      /**
       * Gets the Fuchsia default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Fuchsia)) {
          brush = this.sBrushes.getValue(KnownColor.Fuchsia);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Fuchsia);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Gainsboro", {
      /**
       * Gets the Gainsborough default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Gainsboro)) {
          brush = this.sBrushes.getValue(KnownColor.Gainsboro);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Gainsboro);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "GhostWhite", {
      /**
       * Gets the GhostWhite default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.GhostWhite)) {
          brush = this.sBrushes.getValue(KnownColor.GhostWhite);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.GhostWhite);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Gold", {
      /**
       * Gets the Gold default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Gold)) {
          brush = this.sBrushes.getValue(KnownColor.Gold);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Gold);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Goldenrod", {
      /**
       * Gets the Goldenrod default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Goldenrod)) {
          brush = this.sBrushes.getValue(KnownColor.Goldenrod);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Goldenrod);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Gray", {
      /**
       * Gets the Gray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Gray)) {
          brush = this.sBrushes.getValue(KnownColor.Gray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Gray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Green", {
      /**
       * Gets the Green default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Green)) {
          brush = this.sBrushes.getValue(KnownColor.Green);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Green);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "GreenYellow", {
      /**
       * Gets the GreenYellow default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.GreenYellow)) {
          brush = this.sBrushes.getValue(KnownColor.GreenYellow);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.GreenYellow);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Honeydew", {
      /**
       * Gets the Honeydew default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Honeydew)) {
          brush = this.sBrushes.getValue(KnownColor.Honeydew);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Honeydew);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "HotPink", {
      /**
       * Gets the HotPink default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.HotPink)) {
          brush = this.sBrushes.getValue(KnownColor.HotPink);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.HotPink);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "IndianRed", {
      /**
       * Gets the IndianRed default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.IndianRed)) {
          brush = this.sBrushes.getValue(KnownColor.IndianRed);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.IndianRed);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Indigo", {
      /**
       * Gets the Indigo default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Indigo)) {
          brush = this.sBrushes.getValue(KnownColor.Indigo);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Indigo);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Ivory", {
      /**
       * Gets the Ivory default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Ivory)) {
          brush = this.sBrushes.getValue(KnownColor.Ivory);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Ivory);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Khaki", {
      /**
       * Gets the Khaki default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Khaki)) {
          brush = this.sBrushes.getValue(KnownColor.Khaki);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Khaki);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Lavender", {
      /**
       * Gets the Lavender default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Lavender)) {
          brush = this.sBrushes.getValue(KnownColor.Lavender);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Lavender);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LavenderBlush", {
      /**
       * Gets the LavenderBlush default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LavenderBlush)) {
          brush = this.sBrushes.getValue(KnownColor.LavenderBlush);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LavenderBlush);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LawnGreen", {
      /**
       * Gets the LawnGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LawnGreen)) {
          brush = this.sBrushes.getValue(KnownColor.LawnGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LawnGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LemonChiffon", {
      /**
       * Gets the LemonChiffon default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LemonChiffon)) {
          brush = this.sBrushes.getValue(KnownColor.LemonChiffon);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LemonChiffon);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightBlue", {
      /**
       * Gets the LightBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightBlue)) {
          brush = this.sBrushes.getValue(KnownColor.LightBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightCoral", {
      /**
       * Gets the LightCoral default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightCoral)) {
          brush = this.sBrushes.getValue(KnownColor.LightCoral);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightCoral);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightCyan", {
      /**
       * Gets the LightCyan default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightCyan)) {
          brush = this.sBrushes.getValue(KnownColor.LightCyan);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightCyan);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightGoldenrodYellow", {
      /**
       * Gets the LightGoldenrodYellow default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightGoldenrodYellow)) {
          brush = this.sBrushes.getValue(KnownColor.LightGoldenrodYellow);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightGoldenrodYellow);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightGray", {
      /**
       * Gets the LightGray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightGray)) {
          brush = this.sBrushes.getValue(KnownColor.LightGray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightGray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightGreen", {
      /**
       * Gets the LightGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightGreen)) {
          brush = this.sBrushes.getValue(KnownColor.LightGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightPink", {
      /**
       * Gets the LightPink default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightPink)) {
          brush = this.sBrushes.getValue(KnownColor.LightPink);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightPink);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightSalmon", {
      /**
       * Gets the LightSalmon default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightSalmon)) {
          brush = this.sBrushes.getValue(KnownColor.LightSalmon);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightSalmon);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightSeaGreen", {
      /**
       * Gets the LightSeaGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightSeaGreen)) {
          brush = this.sBrushes.getValue(KnownColor.LightSeaGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightSeaGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightSkyBlue", {
      /**
       * Gets the LightSkyBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightSkyBlue)) {
          brush = this.sBrushes.getValue(KnownColor.LightSkyBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightSkyBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightSlateGray", {
      /**
       * Gets the LightSlateGray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightSlateGray)) {
          brush = this.sBrushes.getValue(KnownColor.LightSlateGray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightSlateGray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightSteelBlue", {
      /**
       * Gets the LightSteelBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightSteelBlue)) {
          brush = this.sBrushes.getValue(KnownColor.LightSteelBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightSteelBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LightYellow", {
      /**
       * Gets the LightYellow default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LightYellow)) {
          brush = this.sBrushes.getValue(KnownColor.LightYellow);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LightYellow);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Lime", {
      /**
       * Gets the Lime default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Lime)) {
          brush = this.sBrushes.getValue(KnownColor.Lime);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Lime);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "LimeGreen", {
      /**
       * Gets the LimeGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.LimeGreen)) {
          brush = this.sBrushes.getValue(KnownColor.LimeGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.LimeGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Linen", {
      /**
       * Gets the Linen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Linen)) {
          brush = this.sBrushes.getValue(KnownColor.Linen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Linen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Magenta", {
      /**
       * Gets the Magenta default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Magenta)) {
          brush = this.sBrushes.getValue(KnownColor.Magenta);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Magenta);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Maroon", {
      /**
       * Gets the Maroon default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Maroon)) {
          brush = this.sBrushes.getValue(KnownColor.Maroon);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Maroon);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumAquamarine", {
      /**
       * Gets the MediumAquamarine default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumAquamarine)) {
          brush = this.sBrushes.getValue(KnownColor.MediumAquamarine);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumAquamarine);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumBlue", {
      /**
       * Gets the MediumBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumBlue)) {
          brush = this.sBrushes.getValue(KnownColor.MediumBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumOrchid", {
      /**
       * Gets the MediumOrchid default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumOrchid)) {
          brush = this.sBrushes.getValue(KnownColor.MediumOrchid);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumOrchid);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumPurple", {
      /**
       * Gets the MediumPurple default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumPurple)) {
          brush = this.sBrushes.getValue(KnownColor.MediumPurple);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumPurple);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumSeaGreen", {
      /**
       * Gets the MediumSeaGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumSeaGreen)) {
          brush = this.sBrushes.getValue(KnownColor.MediumSeaGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumSeaGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumSlateBlue", {
      /**
       * Gets the MediumSlateBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumSlateBlue)) {
          brush = this.sBrushes.getValue(KnownColor.MediumSlateBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumSlateBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumSpringGreen", {
      /**
       * Gets the MediumSpringGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumSpringGreen)) {
          brush = this.sBrushes.getValue(KnownColor.MediumSpringGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumSpringGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumTurquoise", {
      /**
       * Gets the MediumTurquoise default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumTurquoise)) {
          brush = this.sBrushes.getValue(KnownColor.MediumTurquoise);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumTurquoise);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MediumVioletRed", {
      /**
       * Gets the MediumVioletRed default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MediumVioletRed)) {
          brush = this.sBrushes.getValue(KnownColor.MediumVioletRed);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MediumVioletRed);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MidnightBlue", {
      /**
       * Gets the MidnightBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MidnightBlue)) {
          brush = this.sBrushes.getValue(KnownColor.MidnightBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MidnightBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MintCream", {
      /**
       * Gets the MintCream default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MintCream)) {
          brush = this.sBrushes.getValue(KnownColor.MintCream);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MintCream);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "MistyRose", {
      /**
       * Gets the MistyRose default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.MistyRose)) {
          brush = this.sBrushes.getValue(KnownColor.MistyRose);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.MistyRose);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Moccasin", {
      /**
       * Gets the Moccasin default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Moccasin)) {
          brush = this.sBrushes.getValue(KnownColor.Moccasin);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Moccasin);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "NavajoWhite", {
      /**
       * Gets the NavajoWhite default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.NavajoWhite)) {
          brush = this.sBrushes.getValue(KnownColor.NavajoWhite);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.NavajoWhite);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Navy", {
      /**
       * Gets the Navy default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Navy)) {
          brush = this.sBrushes.getValue(KnownColor.Navy);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Navy);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "OldLace", {
      /**
       * Gets the OldLace default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.OldLace)) {
          brush = this.sBrushes.getValue(KnownColor.OldLace);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.OldLace);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Olive", {
      /**
       * Gets the Olive default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Olive)) {
          brush = this.sBrushes.getValue(KnownColor.Olive);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Olive);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "OliveDrab", {
      /**
       * Gets the OliveDrab default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.OliveDrab)) {
          brush = this.sBrushes.getValue(KnownColor.OliveDrab);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.OliveDrab);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Orange", {
      /**
       * Gets the Orange default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Orange)) {
          brush = this.sBrushes.getValue(KnownColor.Orange);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Orange);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "OrangeRed", {
      /**
       * Gets the OrangeRed default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.OrangeRed)) {
          brush = this.sBrushes.getValue(KnownColor.OrangeRed);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.OrangeRed);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Orchid", {
      /**
       * Gets the Orchid default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Orchid)) {
          brush = this.sBrushes.getValue(KnownColor.Orchid);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Orchid);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PaleGoldenrod", {
      /**
       * Gets the PaleGoldenrod default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PaleGoldenrod)) {
          brush = this.sBrushes.getValue(KnownColor.PaleGoldenrod);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PaleGoldenrod);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PaleGreen", {
      /**
       * Gets the PaleGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PaleGreen)) {
          brush = this.sBrushes.getValue(KnownColor.PaleGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PaleGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PaleTurquoise", {
      /**
       * Gets the PaleTurquoise default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PaleTurquoise)) {
          brush = this.sBrushes.getValue(KnownColor.PaleTurquoise);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PaleTurquoise);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PaleVioletRed", {
      /**
       * Gets the PaleVioletRed default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PaleVioletRed)) {
          brush = this.sBrushes.getValue(KnownColor.PaleVioletRed);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PaleVioletRed);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PapayaWhip", {
      /**
       * Gets the PapayaWhip default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PapayaWhip)) {
          brush = this.sBrushes.getValue(KnownColor.PapayaWhip);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PapayaWhip);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PeachPuff", {
      /**
       * Gets the PeachPuff default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PeachPuff)) {
          brush = this.sBrushes.getValue(KnownColor.PeachPuff);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PeachPuff);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Peru", {
      /**
       * Gets the Peru default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Peru)) {
          brush = this.sBrushes.getValue(KnownColor.Peru);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Peru);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Pink", {
      /**
       * Gets the Pink default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Pink)) {
          brush = this.sBrushes.getValue(KnownColor.Pink);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Pink);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Plum", {
      /**
       * Gets the Plum default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Plum)) {
          brush = this.sBrushes.getValue(KnownColor.Plum);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Plum);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "PowderBlue", {
      /**
       * Gets the PowderBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.PowderBlue)) {
          brush = this.sBrushes.getValue(KnownColor.PowderBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.PowderBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Purple", {
      /**
       * Gets the Purple default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Purple)) {
          brush = this.sBrushes.getValue(KnownColor.Purple);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Purple);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Red", {
      /**
       * Gets the Red default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Red)) {
          brush = this.sBrushes.getValue(KnownColor.Red);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Red);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "RosyBrown", {
      /**
       * Gets the RosyBrown default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.RosyBrown)) {
          brush = this.sBrushes.getValue(KnownColor.RosyBrown);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.RosyBrown);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "RoyalBlue", {
      /**
       * Gets the RoyalBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.RoyalBlue)) {
          brush = this.sBrushes.getValue(KnownColor.RoyalBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.RoyalBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SaddleBrown", {
      /**
       * Gets the SaddleBrown default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SaddleBrown)) {
          brush = this.sBrushes.getValue(KnownColor.SaddleBrown);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SaddleBrown);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Salmon", {
      /**
       * Gets the Salmon default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Salmon)) {
          brush = this.sBrushes.getValue(KnownColor.Salmon);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Salmon);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SandyBrown", {
      /**
       * Gets the SandyBrown default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SandyBrown)) {
          brush = this.sBrushes.getValue(KnownColor.SandyBrown);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SandyBrown);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SeaGreen", {
      /**
       * Gets the SeaGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SeaGreen)) {
          brush = this.sBrushes.getValue(KnownColor.SeaGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SeaGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SeaShell", {
      /**
       * Gets the SeaShell default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SeaShell)) {
          brush = this.sBrushes.getValue(KnownColor.SeaShell);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SeaShell);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Sienna", {
      /**
       * Gets the Sienna default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Sienna)) {
          brush = this.sBrushes.getValue(KnownColor.Sienna);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Sienna);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Silver", {
      /**
       * Gets the Silver default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Silver)) {
          brush = this.sBrushes.getValue(KnownColor.Silver);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Silver);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SkyBlue", {
      /**
       * Gets the SkyBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SkyBlue)) {
          brush = this.sBrushes.getValue(KnownColor.SkyBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SkyBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SlateBlue", {
      /**
       * Gets the SlateBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SlateBlue)) {
          brush = this.sBrushes.getValue(KnownColor.SlateBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SlateBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SlateGray", {
      /**
       * Gets the SlateGray default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SlateGray)) {
          brush = this.sBrushes.getValue(KnownColor.SlateGray);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SlateGray);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Snow", {
      /**
       * Gets the Snow default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Snow)) {
          brush = this.sBrushes.getValue(KnownColor.Snow);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Snow);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SpringGreen", {
      /**
       * Gets the SpringGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SpringGreen)) {
          brush = this.sBrushes.getValue(KnownColor.SpringGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SpringGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "SteelBlue", {
      /**
       * Gets the SteelBlue default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.SteelBlue)) {
          brush = this.sBrushes.getValue(KnownColor.SteelBlue);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.SteelBlue);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Tan", {
      /**
       * Gets the Tan default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Tan)) {
          brush = this.sBrushes.getValue(KnownColor.Tan);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Tan);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Teal", {
      /**
       * Gets the Teal default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Teal)) {
          brush = this.sBrushes.getValue(KnownColor.Teal);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Teal);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Thistle", {
      /**
       * Gets the Thistle default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Thistle)) {
          brush = this.sBrushes.getValue(KnownColor.Thistle);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Thistle);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Tomato", {
      /**
       * Gets the Tomato default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Tomato)) {
          brush = this.sBrushes.getValue(KnownColor.Tomato);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Tomato);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Transparent", {
      /**
       * Gets the Transparent default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Transparent)) {
          brush = this.sBrushes.getValue(KnownColor.Transparent);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Transparent);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Turquoise", {
      /**
       * Gets the Turquoise default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Turquoise)) {
          brush = this.sBrushes.getValue(KnownColor.Turquoise);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Turquoise);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Violet", {
      /**
       * Gets the Violet default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Violet)) {
          brush = this.sBrushes.getValue(KnownColor.Violet);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Violet);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Wheat", {
      /**
       * Gets the Wheat default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Wheat)) {
          brush = this.sBrushes.getValue(KnownColor.Wheat);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Wheat);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "White", {
      /**
       * Gets the White default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.White)) {
          brush = this.sBrushes.getValue(KnownColor.White);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.White);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "WhiteSmoke", {
      /**
       * Gets the WhiteSmoke default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.WhiteSmoke)) {
          brush = this.sBrushes.getValue(KnownColor.WhiteSmoke);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.WhiteSmoke);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "Yellow", {
      /**
       * Gets the Yellow default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.Yellow)) {
          brush = this.sBrushes.getValue(KnownColor.Yellow);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.Yellow);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBrushes2, "YellowGreen", {
      /**
       * Gets the YellowGreen default brush.
       * @public
       */
      get: function() {
        var brush = null;
        if (this.sBrushes.containsKey(KnownColor.YellowGreen)) {
          brush = this.sBrushes.getValue(KnownColor.YellowGreen);
        }
        if (brush == null) {
          brush = this.getBrush(KnownColor.YellowGreen);
        }
        return brush;
      },
      enumerable: true,
      configurable: true
    });
    PdfBrushes2.getBrush = function(colorName) {
      var pdfColor = this.getColorValue(colorName);
      var brush = new PdfSolidBrush(pdfColor);
      this.sBrushes.setValue(colorName, brush);
      return brush;
    };
    PdfBrushes2.getColorValue = function(colorName) {
      var color = new PdfColor();
      switch (colorName) {
        case KnownColor.Transparent:
          color = new PdfColor(0, 255, 255, 255);
          break;
        case KnownColor.AliceBlue:
          color = new PdfColor(255, 240, 248, 255);
          break;
        case KnownColor.AntiqueWhite:
          color = new PdfColor(255, 250, 235, 215);
          break;
        case KnownColor.Aqua:
          color = new PdfColor(255, 0, 255, 255);
          break;
        case KnownColor.Aquamarine:
          color = new PdfColor(255, 127, 255, 212);
          break;
        case KnownColor.Azure:
          color = new PdfColor(255, 240, 255, 255);
          break;
        case KnownColor.Beige:
          color = new PdfColor(255, 245, 245, 220);
          break;
        case KnownColor.Bisque:
          color = new PdfColor(255, 255, 228, 196);
          break;
        case KnownColor.Black:
          color = new PdfColor(255, 0, 0, 0);
          break;
        case KnownColor.BlanchedAlmond:
          color = new PdfColor(255, 255, 235, 205);
          break;
        case KnownColor.Blue:
          color = new PdfColor(255, 0, 0, 255);
          break;
        case KnownColor.BlueViolet:
          color = new PdfColor(255, 138, 43, 226);
          break;
        case KnownColor.Brown:
          color = new PdfColor(255, 165, 42, 42);
          break;
        case KnownColor.BurlyWood:
          color = new PdfColor(255, 222, 184, 135);
          break;
        case KnownColor.CadetBlue:
          color = new PdfColor(255, 95, 158, 160);
          break;
        case KnownColor.Chartreuse:
          color = new PdfColor(255, 127, 255, 0);
          break;
        case KnownColor.Chocolate:
          color = new PdfColor(255, 210, 105, 30);
          break;
        case KnownColor.Coral:
          color = new PdfColor(255, 255, 127, 80);
          break;
        case KnownColor.CornflowerBlue:
          color = new PdfColor(255, 100, 149, 237);
          break;
        case KnownColor.Cornsilk:
          color = new PdfColor(255, 255, 248, 220);
          break;
        case KnownColor.Crimson:
          color = new PdfColor(255, 220, 20, 60);
          break;
        case KnownColor.Cyan:
          color = new PdfColor(255, 0, 255, 255);
          break;
        case KnownColor.DarkBlue:
          color = new PdfColor(255, 0, 0, 139);
          break;
        case KnownColor.DarkCyan:
          color = new PdfColor(255, 0, 139, 139);
          break;
        case KnownColor.DarkGoldenrod:
          color = new PdfColor(255, 184, 134, 11);
          break;
        case KnownColor.DarkGray:
          color = new PdfColor(255, 169, 169, 169);
          break;
        case KnownColor.DarkGreen:
          color = new PdfColor(255, 0, 100, 0);
          break;
        case KnownColor.DarkKhaki:
          color = new PdfColor(255, 189, 183, 107);
          break;
        case KnownColor.DarkMagenta:
          color = new PdfColor(255, 139, 0, 139);
          break;
        case KnownColor.DarkOliveGreen:
          color = new PdfColor(255, 85, 107, 47);
          break;
        case KnownColor.DarkOrange:
          color = new PdfColor(255, 255, 140, 0);
          break;
        case KnownColor.DarkOrchid:
          color = new PdfColor(255, 153, 50, 204);
          break;
        case KnownColor.DarkRed:
          color = new PdfColor(255, 139, 0, 0);
          break;
        case KnownColor.DarkSalmon:
          color = new PdfColor(255, 233, 150, 122);
          break;
        case KnownColor.DarkSeaGreen:
          color = new PdfColor(255, 143, 188, 139);
          break;
        case KnownColor.DarkSlateBlue:
          color = new PdfColor(255, 72, 61, 139);
          break;
        case KnownColor.DarkSlateGray:
          color = new PdfColor(255, 47, 79, 79);
          break;
        case KnownColor.DarkTurquoise:
          color = new PdfColor(255, 0, 206, 209);
          break;
        case KnownColor.DarkViolet:
          color = new PdfColor(255, 148, 0, 211);
          break;
        case KnownColor.DeepPink:
          color = new PdfColor(255, 255, 20, 147);
          break;
        case KnownColor.DeepSkyBlue:
          color = new PdfColor(255, 0, 191, 255);
          break;
        case KnownColor.DimGray:
          color = new PdfColor(255, 105, 105, 105);
          break;
        case KnownColor.DodgerBlue:
          color = new PdfColor(255, 30, 144, 255);
          break;
        case KnownColor.Firebrick:
          color = new PdfColor(255, 178, 34, 34);
          break;
        case KnownColor.FloralWhite:
          color = new PdfColor(255, 255, 250, 240);
          break;
        case KnownColor.ForestGreen:
          color = new PdfColor(255, 34, 139, 34);
          break;
        case KnownColor.Fuchsia:
          color = new PdfColor(255, 255, 0, 255);
          break;
        case KnownColor.Gainsboro:
          color = new PdfColor(255, 220, 220, 220);
          break;
        case KnownColor.GhostWhite:
          color = new PdfColor(255, 248, 248, 255);
          break;
        case KnownColor.Gold:
          color = new PdfColor(255, 255, 215, 0);
          break;
        case KnownColor.Goldenrod:
          color = new PdfColor(255, 218, 165, 32);
          break;
        case KnownColor.Gray:
          color = new PdfColor(255, 128, 128, 128);
          break;
        case KnownColor.Green:
          color = new PdfColor(255, 0, 128, 0);
          break;
        case KnownColor.GreenYellow:
          color = new PdfColor(255, 173, 255, 47);
          break;
        case KnownColor.Honeydew:
          color = new PdfColor(255, 240, 255, 240);
          break;
        case KnownColor.HotPink:
          color = new PdfColor(255, 255, 105, 180);
          break;
        case KnownColor.IndianRed:
          color = new PdfColor(255, 205, 92, 92);
          break;
        case KnownColor.Indigo:
          color = new PdfColor(255, 75, 0, 130);
          break;
        case KnownColor.Ivory:
          color = new PdfColor(255, 255, 255, 240);
          break;
        case KnownColor.Khaki:
          color = new PdfColor(255, 240, 230, 140);
          break;
        case KnownColor.Lavender:
          color = new PdfColor(255, 230, 230, 250);
          break;
        case KnownColor.LavenderBlush:
          color = new PdfColor(255, 255, 240, 245);
          break;
        case KnownColor.LawnGreen:
          color = new PdfColor(255, 124, 252, 0);
          break;
        case KnownColor.LemonChiffon:
          color = new PdfColor(255, 255, 250, 205);
          break;
        case KnownColor.LightBlue:
          color = new PdfColor(255, 173, 216, 230);
          break;
        case KnownColor.LightCoral:
          color = new PdfColor(255, 240, 128, 128);
          break;
        case KnownColor.LightCyan:
          color = new PdfColor(255, 224, 255, 255);
          break;
        case KnownColor.LightGoldenrodYellow:
          color = new PdfColor(255, 250, 250, 210);
          break;
        case KnownColor.LightGreen:
          color = new PdfColor(255, 144, 238, 144);
          break;
        case KnownColor.LightGray:
          color = new PdfColor(255, 211, 211, 211);
          break;
        case KnownColor.LightPink:
          color = new PdfColor(255, 255, 182, 193);
          break;
        case KnownColor.LightSalmon:
          color = new PdfColor(255, 255, 160, 122);
          break;
        case KnownColor.LightSeaGreen:
          color = new PdfColor(255, 32, 178, 170);
          break;
        case KnownColor.LightSkyBlue:
          color = new PdfColor(255, 135, 206, 250);
          break;
        case KnownColor.LightSlateGray:
          color = new PdfColor(255, 119, 136, 153);
          break;
        case KnownColor.LightSteelBlue:
          color = new PdfColor(255, 176, 196, 222);
          break;
        case KnownColor.LightYellow:
          color = new PdfColor(255, 255, 255, 224);
          break;
        case KnownColor.Lime:
          color = new PdfColor(255, 0, 255, 0);
          break;
        case KnownColor.LimeGreen:
          color = new PdfColor(255, 50, 205, 50);
          break;
        case KnownColor.Linen:
          color = new PdfColor(255, 250, 240, 230);
          break;
        case KnownColor.Magenta:
          color = new PdfColor(255, 255, 0, 255);
          break;
        case KnownColor.Maroon:
          color = new PdfColor(255, 128, 0, 0);
          break;
        case KnownColor.MediumAquamarine:
          color = new PdfColor(255, 102, 205, 170);
          break;
        case KnownColor.MediumBlue:
          color = new PdfColor(255, 0, 0, 205);
          break;
        case KnownColor.MediumOrchid:
          color = new PdfColor(255, 186, 85, 211);
          break;
        case KnownColor.MediumPurple:
          color = new PdfColor(255, 147, 112, 219);
          break;
        case KnownColor.MediumSeaGreen:
          color = new PdfColor(255, 60, 179, 113);
          break;
        case KnownColor.MediumSlateBlue:
          color = new PdfColor(255, 123, 104, 238);
          break;
        case KnownColor.MediumSpringGreen:
          color = new PdfColor(255, 0, 250, 154);
          break;
        case KnownColor.MediumTurquoise:
          color = new PdfColor(255, 72, 209, 204);
          break;
        case KnownColor.MediumVioletRed:
          color = new PdfColor(255, 199, 21, 133);
          break;
        case KnownColor.MidnightBlue:
          color = new PdfColor(255, 25, 25, 112);
          break;
        case KnownColor.MintCream:
          color = new PdfColor(255, 245, 255, 250);
          break;
        case KnownColor.MistyRose:
          color = new PdfColor(255, 255, 228, 225);
          break;
        case KnownColor.Moccasin:
          color = new PdfColor(255, 255, 228, 181);
          break;
        case KnownColor.NavajoWhite:
          color = new PdfColor(255, 255, 222, 173);
          break;
        case KnownColor.Navy:
          color = new PdfColor(255, 0, 0, 128);
          break;
        case KnownColor.OldLace:
          color = new PdfColor(255, 253, 245, 230);
          break;
        case KnownColor.Olive:
          color = new PdfColor(255, 128, 128, 0);
          break;
        case KnownColor.OliveDrab:
          color = new PdfColor(255, 107, 142, 35);
          break;
        case KnownColor.Orange:
          color = new PdfColor(255, 255, 165, 0);
          break;
        case KnownColor.OrangeRed:
          color = new PdfColor(255, 255, 69, 0);
          break;
        case KnownColor.Orchid:
          color = new PdfColor(255, 218, 112, 214);
          break;
        case KnownColor.PaleGoldenrod:
          color = new PdfColor(255, 238, 232, 170);
          break;
        case KnownColor.PaleGreen:
          color = new PdfColor(255, 152, 251, 152);
          break;
        case KnownColor.PaleTurquoise:
          color = new PdfColor(255, 175, 238, 238);
          break;
        case KnownColor.PaleVioletRed:
          color = new PdfColor(255, 219, 112, 147);
          break;
        case KnownColor.PapayaWhip:
          color = new PdfColor(255, 255, 239, 213);
          break;
        case KnownColor.PeachPuff:
          color = new PdfColor(255, 255, 218, 185);
          break;
        case KnownColor.Peru:
          color = new PdfColor(255, 205, 133, 63);
          break;
        case KnownColor.Pink:
          color = new PdfColor(255, 255, 192, 203);
          break;
        case KnownColor.Plum:
          color = new PdfColor(255, 221, 160, 221);
          break;
        case KnownColor.PowderBlue:
          color = new PdfColor(255, 176, 224, 230);
          break;
        case KnownColor.Purple:
          color = new PdfColor(255, 128, 0, 128);
          break;
        case KnownColor.Red:
          color = new PdfColor(255, 255, 0, 0);
          break;
        case KnownColor.RosyBrown:
          color = new PdfColor(255, 188, 143, 143);
          break;
        case KnownColor.RoyalBlue:
          color = new PdfColor(255, 65, 105, 225);
          break;
        case KnownColor.SaddleBrown:
          color = new PdfColor(255, 139, 69, 19);
          break;
        case KnownColor.Salmon:
          color = new PdfColor(255, 250, 128, 114);
          break;
        case KnownColor.SandyBrown:
          color = new PdfColor(255, 244, 164, 96);
          break;
        case KnownColor.SeaGreen:
          color = new PdfColor(255, 46, 139, 87);
          break;
        case KnownColor.SeaShell:
          color = new PdfColor(255, 255, 245, 238);
          break;
        case KnownColor.Sienna:
          color = new PdfColor(255, 160, 82, 45);
          break;
        case KnownColor.Silver:
          color = new PdfColor(255, 192, 192, 192);
          break;
        case KnownColor.SkyBlue:
          color = new PdfColor(255, 135, 206, 235);
          break;
        case KnownColor.SlateBlue:
          color = new PdfColor(255, 106, 90, 205);
          break;
        case KnownColor.SlateGray:
          color = new PdfColor(255, 112, 128, 144);
          break;
        case KnownColor.Snow:
          color = new PdfColor(255, 255, 250, 250);
          break;
        case KnownColor.SpringGreen:
          color = new PdfColor(255, 0, 255, 127);
          break;
        case KnownColor.SteelBlue:
          color = new PdfColor(255, 70, 130, 180);
          break;
        case KnownColor.Tan:
          color = new PdfColor(255, 210, 180, 140);
          break;
        case KnownColor.Teal:
          color = new PdfColor(255, 0, 128, 128);
          break;
        case KnownColor.Thistle:
          color = new PdfColor(255, 216, 191, 216);
          break;
        case KnownColor.Tomato:
          color = new PdfColor(255, 255, 99, 71);
          break;
        case KnownColor.Turquoise:
          color = new PdfColor(255, 64, 224, 208);
          break;
        case KnownColor.Violet:
          color = new PdfColor(255, 238, 130, 238);
          break;
        case KnownColor.Wheat:
          color = new PdfColor(255, 245, 222, 179);
          break;
        case KnownColor.White:
          color = new PdfColor(255, 255, 255, 255);
          break;
        case KnownColor.WhiteSmoke:
          color = new PdfColor(255, 245, 245, 245);
          break;
        case KnownColor.Yellow:
          color = new PdfColor(255, 255, 255, 0);
          break;
        case KnownColor.YellowGreen:
          color = new PdfColor(255, 154, 205, 50);
          break;
      }
      return color;
    };
    PdfBrushes2.sBrushes = new Dictionary();
    return PdfBrushes2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-blend.js
var PdfBlend = (
  /** @class */
  (function() {
    function PdfBlend2(count) {
      this.precision = 1e3;
    }
    Object.defineProperty(PdfBlend2.prototype, "factors", {
      //Properties
      /**
       * Gets or sets the array of factor to the blend.
       * @public
       */
      get: function() {
        return this.mFactors;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : Factors");
        }
        this.mFactors = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBlend2.prototype, "positions", {
      /**
       * 'positions' Gets or sets the array of positions
       * @public
       */
      get: function() {
        return this.mPositions;
      },
      set: function(value) {
        var positionarray = value;
        for (var i = 0; i < positionarray.length; i++) {
          if (positionarray[i] < 0 || positionarray[i] > 1) {
            positionarray[i] = 0;
          }
        }
        this.mPositions = positionarray;
        this.mPositions = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfBlend2.prototype, "count", {
      /**
       * Gets the number of elements that specify the blend.
       * @protected
       */
      get: function() {
        return this.mCount;
      },
      enumerable: true,
      configurable: true
    });
    PdfBlend2.prototype.generateColorBlend = function(colours, colorSpace) {
      if (colours == null) {
        throw new Error("ArgumentNullException : colours");
      }
      if (this.positions == null) {
        this.positions = [0];
      }
      var cBlend = new PdfColorBlend(this.count);
      var positions = this.positions;
      var clrs = null;
      if (positions.length === 1) {
        positions = [3];
        positions[0] = 0;
        positions[1] = this.positions[0];
        positions[2] = 1;
        clrs = new Array(3);
        clrs[0] = colours[0];
        clrs[1] = colours[0];
        clrs[2] = colours[1];
      } else {
        var c1 = colours[0];
        var c2 = colours[1];
        clrs = new Array(this.count);
        var i = 0;
        var count = this.count;
        for (i = 0; i < count; ++i) {
          clrs[i] = this.interpolate(this.mFactors[i], c1, c2, colorSpace);
        }
      }
      cBlend.positions = positions;
      cBlend.colors = clrs;
      return cBlend;
    };
    PdfBlend2.prototype.clonePdfBlend = function() {
      var blend = this;
      if (this.mFactors != null) {
        blend.factors = this.mFactors;
      }
      if (this.positions != null) {
        blend.positions = this.positions;
      }
      return blend;
    };
    PdfBlend2.prototype.gcd = function(u, v) {
      if (typeof u === "number" && typeof v === "number" && typeof v !== "undefined") {
        if (u < 0 || u > 1) {
          throw new Error("ArgumentOutOfRangeException : u");
        }
        if (v < 0 || v > 1) {
          throw new Error("ArgumentOutOfRangeException : v");
        }
        var iU = Math.max(1, u * this.precision);
        var iV = Math.max(1, v * this.precision);
        var iResult = this.gcdInt(iU, iV);
        var result = iResult / this.precision;
        return result;
      } else {
        var values = u;
        if (values == null) {
          throw new Error("ArgumentNullException : values");
        }
        if (values.length < 1) {
          throw new Error("ArgumentException : Not enough values in the array. - values");
        }
        var gcd = values[0];
        if (values.length > 1) {
          var count = values.length;
          for (var i = 1; i < count; ++i) {
            gcd = this.gcd(values[i], gcd);
            if (gcd === 1 / this.precision) {
              break;
            }
          }
        }
        return gcd;
      }
    };
    PdfBlend2.prototype.gcdInt = function(u, v) {
      if (u <= 0) {
        throw new Error("ArgumentOutOfRangeException" + u + "The arguments cannot be less or equal to zero.");
      }
      if (v <= 0) {
        throw new Error("ArgumentOutOfRangeException" + v + "The arguments cannot be less or equal to zero.");
      }
      if (u === 1 || v === 1) {
        return 1;
      }
      var shift = 0;
      while (this.isEven(u, v)) {
        ++shift;
        u >>= 1;
        v >>= 1;
      }
      while ((u & 1) <= 0) {
        u >>= 1;
      }
      do {
        while ((v & 1) <= 0) {
          v >>= 1;
        }
        if (u > v) {
          var t = v;
          v = u;
          u = t;
        }
        v = v - u;
      } while (v !== 0);
      return u << shift;
    };
    PdfBlend2.prototype.isEven = function(arg1, arg2) {
      if (typeof arg2 === "number" && typeof arg2 !== "undefined") {
        var result = true;
        result = result && (arg1 & 1) <= 0;
        result = result && (arg2 & 1) <= 0;
        return result;
      } else {
        return (arg1 & 1) <= 0;
      }
    };
    PdfBlend2.prototype.interpolate = function(t, color1, color2, colorSpace) {
      if (color1 instanceof PdfColor) {
        var color = new PdfColor();
        switch (colorSpace) {
          case PdfColorSpace.Rgb:
            var red = this.interpolate(t, color1.red, color2.red);
            var green = this.interpolate(t, color1.green, color2.green);
            var blue = this.interpolate(t, color1.blue, color2.blue);
            color = new PdfColor(red, green, blue);
            break;
          case PdfColorSpace.GrayScale:
            var gray = this.interpolate(t, color1.gray, color2.gray);
            color = new PdfColor(gray);
            break;
          case PdfColorSpace.Cmyk:
            var cyan = this.interpolate(t, color1.c, color2.c);
            var magenta = this.interpolate(t, color1.m, color2.m);
            var yellow = this.interpolate(t, color1.y, color2.y);
            var black = this.interpolate(t, color1.k, color2.k);
            color = new PdfColor(cyan, magenta, yellow, black);
            break;
        }
        return color;
      } else {
        var t0 = 0;
        var t1 = 1;
        var result = 0;
        if (t === t0) {
          result = color1;
        } else if (t === t1) {
          result = color2;
        } else {
          result = color1 + (t - t0) * ((color2 - color1) / (t1 - t0));
        }
        return result;
      }
    };
    return PdfBlend2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-color-blend.js
var __extends51 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfColorBlend = (
  /** @class */
  (function(_super) {
    __extends51(PdfColorBlend2, _super);
    function PdfColorBlend2(count) {
      var _this = _super.call(this) || this;
      if (typeof count === "number") {
        _this = _super.call(this, count) || this;
      }
      return _this;
    }
    Object.defineProperty(PdfColorBlend2.prototype, "colors", {
      //Properties
      /**
       * Gets or sets the array of colors.
       * @public
       */
      get: function() {
        return this.mcolors;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : Colors");
        }
        this.mcolors = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfColorBlend2.prototype.getFunction = function(colorSpace) {
      var domain = [0, 1];
      var colourComponents = this.getColorComponentsCount(colorSpace);
      var maxComponentValue = this.getMaxComponentValue(colorSpace);
      var range = this.setRange(colourComponents, maxComponentValue);
      var func = null;
      if (this.mbrush == null && typeof this.mbrush === "undefined") {
        var sizes = [1];
        var samplesCount = void 0;
        var step = 1;
        if (this.positions.length === 2) {
          samplesCount = 2;
        } else {
          var positions = this.positions;
          var intervals = this.getIntervals(positions);
          var gcd = this.gcd(intervals);
          step = gcd;
          samplesCount = 1 / gcd + 1;
        }
        sizes[0] = samplesCount;
        var samples = this.getSamplesValues(colorSpace, samplesCount, maxComponentValue, step);
        func = new PdfSampledFunction(domain, range, sizes, samples);
        return func;
      }
      return func;
    };
    PdfColorBlend2.prototype.cloneColorBlend = function() {
      var cBlend = this;
      if (this.mcolors != null && typeof this.mcolors !== "undefined") {
        cBlend.colors = this.mcolors;
      }
      if (this.positions != null && typeof this.positions !== "undefined") {
        cBlend.positions = this.positions;
      }
      return cBlend;
    };
    PdfColorBlend2.prototype.setRange = function(colourComponents, maxValue) {
      var range = [colourComponents * 2];
      for (var i = 0; i < colourComponents; ++i) {
        range[i * 2] = 0;
        range[i * 2 + 1] = 1;
      }
      return range;
    };
    PdfColorBlend2.prototype.getColorComponentsCount = function(colorSpace) {
      var count = 0;
      switch (colorSpace) {
        case PdfColorSpace.Rgb:
          count = 3;
          break;
        case PdfColorSpace.Cmyk:
          count = 4;
          break;
        case PdfColorSpace.GrayScale:
          count = 1;
          break;
        default:
          throw new Error("ArgumentException - Unsupported color space: " + colorSpace + " colorSpace");
      }
      return count;
    };
    PdfColorBlend2.prototype.getSamplesValues = function(colorSpace, sampleCount, maxComponentValue, step) {
      var values;
      switch (colorSpace) {
        case PdfColorSpace.GrayScale:
          values = this.getGrayscaleSamples(sampleCount, maxComponentValue, step);
          break;
        case PdfColorSpace.Cmyk:
          values = this.getCmykSamples(sampleCount, maxComponentValue, step);
          break;
        case PdfColorSpace.Rgb:
          values = this.getRgbSamples(sampleCount, maxComponentValue, step);
          break;
        default:
          throw new Error("ArgumentException - Unsupported color space: " + colorSpace + " colorSpace");
      }
      return values;
    };
    PdfColorBlend2.prototype.getGrayscaleSamples = function(sampleCount, maxComponentValue, step) {
      var values = [sampleCount * 2];
      for (var i = 0; i < sampleCount; ++i) {
        var color = this.getNextColor(i, step, PdfColorSpace.GrayScale);
        var index = i * 2;
      }
      return values;
    };
    PdfColorBlend2.prototype.getRgbSamples = function(sampleCount, maxComponentValue, step) {
      var values = [sampleCount * 3];
      for (var i = 0; i < sampleCount; ++i) {
        var color = this.getNextColor(i, step, PdfColorSpace.Rgb);
        var index = i * 3;
        values[index] = color.r;
        values[index + 1] = color.g;
        values[index + 2] = color.b;
      }
      return values;
    };
    PdfColorBlend2.prototype.getCmykSamples = function(sampleCount, maxComponentValue, step) {
      var values = [sampleCount * 4];
      for (var i = 0; i < sampleCount; i++) {
        var color = this.getNextColor(i, step, PdfColorSpace.Cmyk);
        var index = i * 4;
        values[index] = color.c * maxComponentValue;
        values[index + 1] = color.m * maxComponentValue;
        values[index + 2] = color.y * maxComponentValue;
        values[index + 3] = color.k * maxComponentValue;
      }
      return values;
    };
    PdfColorBlend2.prototype.getNextColor = function(index, step, colorSpace) {
      var position = step * index;
      var indexHi;
      var indexLow;
      var result = this.getIndices(position, indexLow, indexHi);
      indexLow = result.indexLow;
      indexHi = result.indexHi;
      var color;
      if (indexLow === indexHi) {
        color = this.mcolors[indexLow];
      } else {
        var positionLow = this.positions[indexLow];
        var positionHi = this.positions[indexHi];
        var colorLow = this.mcolors[indexLow];
        var colorHi = this.mcolors[indexHi];
        var t = (position - positionLow) / (positionHi - positionLow);
        color = this.interpolate(t, colorLow, colorHi, colorSpace);
      }
      return color;
    };
    PdfColorBlend2.prototype.getIndices = function(position, indexLow, indexHi) {
      var positions = this.positions;
      indexLow = 0;
      indexHi = 0;
      for (var i = 0; i < this.mcolors.length; ++i) {
        var currPos = positions[i];
        if (currPos === position) {
          indexHi = i;
          indexLow = i;
          break;
        } else if (currPos > position) {
          indexHi = i;
          break;
        }
        indexLow = i;
        indexHi = i;
      }
      return { indexLow, indexHi };
    };
    PdfColorBlend2.prototype.getMaxComponentValue = function(colorSpace) {
      var result = 0;
      switch (colorSpace) {
        case PdfColorSpace.Cmyk:
        case PdfColorSpace.Rgb:
          result = 255;
          break;
        case PdfColorSpace.GrayScale:
          result = 65535;
          break;
        default:
          throw new Error("ArgumentException - Unsupported color space: " + colorSpace + "colorSpace");
      }
      return result;
    };
    PdfColorBlend2.prototype.getIntervals = function(positions) {
      var count = positions.length;
      var intervals = [count - 1];
      var prev = positions[0];
      for (var i = 1; i < count; ++i) {
        var v = positions[i];
        intervals[i - 1] = v - prev;
        prev = v;
      }
      return intervals;
    };
    return PdfColorBlend2;
  })(PdfBlend)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-linear-gradient-brush.js
var __extends52 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfLinearGradientBrush = (
  /** @class */
  (function(_super) {
    __extends52(PdfLinearGradientBrush2, _super);
    function PdfLinearGradientBrush2(arg1, arg2, arg3, arg4) {
      var _this = _super.call(this, new PdfDictionary()) || this;
      _this.mDictionaryProperties = new DictionaryProperties();
      if (arg1 instanceof PointF && arg2 instanceof PointF && arg3 instanceof PdfColor && arg4 instanceof PdfColor) {
        _this.initialize(arg3, arg4);
        _this.mPointStart = arg1;
        _this.mPointEnd = arg2;
        _this.setPoints(_this.mPointStart, _this.mPointEnd);
      } else if (arg1 instanceof Rectangle) {
        _this.initialize(arg2, arg3);
        if (arg4 === PdfLinearGradientMode.BackwardDiagonal || arg4 === PdfLinearGradientMode.ForwardDiagonal || arg4 === PdfLinearGradientMode.Horizontal || arg4 === PdfLinearGradientMode.Vertical) {
          _this.mBoundaries = arg1;
          switch (arg4) {
            case PdfLinearGradientMode.BackwardDiagonal:
              _this.mPointStart = new PointF(arg1.right, arg1.top);
              _this.mPointEnd = new PointF(arg1.left, arg1.bottom);
              break;
            case PdfLinearGradientMode.ForwardDiagonal:
              _this.mPointStart = new PointF(arg1.left, arg1.top);
              _this.mPointEnd = new PointF(arg1.right, arg1.bottom);
              break;
            case PdfLinearGradientMode.Horizontal:
              _this.mPointStart = new PointF(arg1.left, arg1.top);
              _this.mPointEnd = new PointF(arg1.right, arg1.top);
              break;
            case PdfLinearGradientMode.Vertical:
              _this.mPointStart = new PointF(arg1.left, arg1.top);
              _this.mPointEnd = new PointF(arg1.left, arg1.bottom);
              break;
            default:
              throw new Error("ArgumentException -- Unsupported linear gradient mode: " + arg4 + " mode");
          }
          _this.setPoints(_this.mPointStart, _this.mPointEnd);
        } else if (typeof arg4 === "number" && typeof arg4 !== "undefined") {
          _this.mBoundaries = arg1;
          arg4 = arg4 % 360;
          if (arg4 === 0) {
            _this.mPointStart = new PointF(arg1.left, arg1.top);
            _this.mPointEnd = new PointF(arg1.right, arg1.top);
          } else if (arg4 === 90) {
            _this.mPointStart = new PointF(arg1.left, arg1.top);
            _this.mPointEnd = new PointF(arg1.left, arg1.bottom);
          } else if (arg4 === 180) {
            _this.mPointEnd = new PointF(arg1.left, arg1.top);
            _this.mPointStart = new PointF(arg1.right, arg1.top);
          } else if (arg4 === 270) {
            _this.mPointEnd = new PointF(arg1.left, arg1.top);
            _this.mPointStart = new PointF(arg1.left, arg1.bottom);
          } else {
            var d2r = Math.PI / 180;
            var radAngle = arg4 * d2r;
            var k = Math.tan(radAngle);
            var x = _this.mBoundaries.left + (_this.mBoundaries.right - _this.mBoundaries.left) / 2;
            var y = _this.mBoundaries.top + (_this.mBoundaries.bottom - _this.mBoundaries.top) / 2;
            var centre = new PointF(x, y);
            x = _this.mBoundaries.width / (2 * Math.cos(radAngle));
            y = k * x;
            x = x + centre.x;
            y = y + centre.y;
            var p1 = new PointF(x, y);
            var cp1 = _this.subPoints(p1, centre);
            var p = _this.choosePoint(arg4);
            var coef = _this.mulPoints(_this.subPoints(p, centre), cp1) / _this.mulPoints(cp1, cp1);
            _this.mPointEnd = _this.addPoints(centre, _this.mulPoint(cp1, coef));
            _this.mPointStart = _this.addPoints(centre, _this.mulPoint(cp1, coef * -1));
          }
          _this.setPoints(_this.mPointEnd, _this.mPointStart);
        }
      }
      return _this;
    }
    PdfLinearGradientBrush2.prototype.initialize = function(color1, color2) {
      this.mColours = [color1, color2];
      this.mColourBlend = new PdfColorBlend(2);
      this.mColourBlend.positions = [0, 1];
      this.mColourBlend.colors = this.mColours;
      this.initShading();
    };
    Object.defineProperty(PdfLinearGradientBrush2.prototype, "blend", {
      //Properties
      /**
       * Gets or sets a PdfBlend that specifies positions
       * and factors that define a custom falloff for the gradient.
       * @public
       */
      get: function() {
        return this.mBlend;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : Blend");
        }
        if (this.mColours == null) {
          throw new Error("NotSupportedException : There is no starting and ending colours specified.");
        }
        this.mBlend = value;
        this.mColourBlend = this.mBlend.generateColorBlend(this.mColours, this.colorSpace);
        this.resetFunction();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLinearGradientBrush2.prototype, "interpolationColors", {
      /**
       * Gets or sets a ColorBlend that defines a multicolor linear gradient.
       * @public
       */
      get: function() {
        return this.mColourBlend;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : InterpolationColors");
        }
        this.mBlend = null;
        this.mColours = null;
        this.mColourBlend = value;
        this.resetFunction();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLinearGradientBrush2.prototype, "linearColors", {
      /**
       * Gets or sets the starting and ending colors of the gradient.
       * @public
       */
      get: function() {
        return this.mColours;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : LinearColors");
        }
        if (value.length < 2) {
          throw new Error("ArgumentException : The array is too small - LinearColors");
        }
        if (this.mColours == null && typeof this.mColours === "undefined") {
          this.mColours = [value[0], value[1]];
        } else {
          this.mColours[0] = value[0];
          this.mColours[1] = value[1];
        }
        if (this.mBlend == null && typeof this.mBlend === "undefined") {
          this.mColourBlend = new PdfColorBlend(2);
          this.mColourBlend.colors = this.mColours;
          this.mColourBlend.positions = [0, 1];
        } else {
          this.mColourBlend = this.mBlend.generateColorBlend(this.mColours, this.colorSpace);
        }
        this.resetFunction();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLinearGradientBrush2.prototype, "rectangle", {
      /**
       * Gets a rectangular region that defines the boundaries of the gradient.
       * @public
       */
      get: function() {
        return this.mBoundaries;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfLinearGradientBrush2.prototype, "extend", {
      /**
       * Gets or sets the value indicating whether the gradient should extend starting and ending points.
       * @public
       */
      get: function() {
        var result = PdfExtend.None;
        var extend2 = this.shading.items.getValue(this.mDictionaryProperties.extend);
        if (extend2 != null) {
          var extStart = extend2.items(0);
          var extEnd = extend2.items(1);
          if (extStart.value) {
            result = result | PdfExtend.Start;
          }
          if (extEnd.value) {
            result = result | PdfExtend.End;
          }
        }
        return result;
      },
      set: function(value) {
        var extend2 = this.shading.items.getValue(this.mDictionaryProperties.extend);
        var extStart;
        var extEnd;
        if (extend2 == null) {
          extStart = new PdfBoolean(false);
          extEnd = new PdfBoolean(false);
          extend2 = new PdfArray();
          extend2.add(extStart);
          extend2.add(extEnd);
          this.shading.items.setValue(this.mDictionaryProperties.extend, extend2);
        } else {
          extStart = extend2.items(0);
          extEnd = extend2.items(1);
        }
      },
      enumerable: true,
      configurable: true
    });
    PdfLinearGradientBrush2.prototype.addPoints = function(point1, point2) {
      var x = point1.x + point2.x;
      var y = point1.y + point2.y;
      var result = new PointF(x, y);
      return result;
    };
    PdfLinearGradientBrush2.prototype.subPoints = function(point1, point2) {
      var x = point1.x - point2.x;
      var y = point1.y - point2.y;
      var result = new PointF(x, y);
      return result;
    };
    PdfLinearGradientBrush2.prototype.mulPoints = function(point1, point2) {
      var result = point1.x * point2.x + point1.y * point2.y;
      return result;
    };
    PdfLinearGradientBrush2.prototype.mulPoint = function(point, value) {
      point.x = point.x * value;
      point.y = point.y * value;
      return point;
    };
    PdfLinearGradientBrush2.prototype.choosePoint = function(angle) {
      var point = new PointF(0, 0);
      if (angle < 90 && angle > 0) {
        point = new PointF(this.mBoundaries.right, this.mBoundaries.bottom);
      } else if (angle < 180 && angle > 90) {
        point = new PointF(this.mBoundaries.left, this.mBoundaries.bottom);
      } else if (angle < 270 && angle > 180) {
        point = new PointF(this.mBoundaries.left, this.mBoundaries.top);
      } else if (angle > 270) {
        point = new PointF(this.mBoundaries.right, this.mBoundaries.top);
      } else {
        throw new Error("PdfException - Internal error.");
      }
      return point;
    };
    PdfLinearGradientBrush2.prototype.setPoints = function(point1, point2) {
      var points = new PdfArray();
      points.add(new PdfNumber(point1.x));
      points.add(new PdfNumber(this.updateY(point1.y)));
      points.add(new PdfNumber(point2.x));
      points.add(new PdfNumber(this.updateY(point2.y)));
      this.shading.items.setValue(this.mDictionaryProperties.coords, points);
    };
    PdfLinearGradientBrush2.prototype.updateY = function(y) {
      if (y !== 0) {
        return -y;
      } else {
        return y;
      }
    };
    PdfLinearGradientBrush2.prototype.initShading = function() {
      this.colorSpace = PdfColorSpace.Rgb;
      this.function = this.mColourBlend.getFunction(this.colorSpace);
      this.shading.items.setValue(this.mDictionaryProperties.shadingType, new PdfNumber(ShadingType.Axial));
    };
    PdfLinearGradientBrush2.prototype.clone = function() {
      var brush = this;
      brush.resetPatternDictionary(new PdfDictionary(this.patternDictionary));
      brush.shading = new PdfDictionary();
      brush.initShading();
      brush.setPoints(brush.mPointStart, brush.mPointEnd);
      if (brush !== null && brush instanceof PdfLinearGradientBrush2) {
        if (this.matrix != null && typeof this.matrix !== "undefined") {
          brush.matrix = this.matrix.clone();
        }
      }
      if (this.mColours != null && typeof this.mColours !== "undefined") {
        brush.mColours = this.mColours;
      }
      if (this.blend != null && typeof this.blend !== "undefined") {
        brush.blend = this.blend.clonePdfBlend();
      } else if (this.interpolationColors != null && typeof this.interpolationColors !== "undefined") {
        brush.interpolationColors = this.interpolationColors.cloneColorBlend();
      }
      brush.extend = this.extend;
      this.cloneBackgroundValue(brush);
      this.cloneAntiAliasingValue(brush);
      return brush;
    };
    PdfLinearGradientBrush2.prototype.resetFunction = function() {
      this.function = this.mColourBlend.getFunction(this.colorSpace);
    };
    return PdfLinearGradientBrush2;
  })(PdfGradientBrush)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/brushes/pdf-radial-gradient-brush.js
var __extends53 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfRadialGradientBrush = (
  /** @class */
  (function(_super) {
    __extends53(PdfRadialGradientBrush2, _super);
    function PdfRadialGradientBrush2(centerStart, radiusStart, centerEnd, radiusEnd, colorStart, colorEnd) {
      var _this = _super.call(this, new PdfDictionary()) || this;
      _this.mDictionaryProperties = new DictionaryProperties();
      _this.initialize(colorStart, colorEnd);
      if (radiusStart < 0) {
        throw new Error("ArgumentOutOfRangeException : radiusStart - The radius cannot be less then zero.");
      }
      if (radiusEnd < 0) {
        throw new Error("ArgumentOutOfRangeException : radiusEnd - The radius cannpt be less then zero.");
      }
      _this.mPointEnd = centerEnd;
      _this.mPointStart = centerStart;
      _this.mRadiusStart = radiusStart;
      _this.mRadiusEnd = radiusEnd;
      _this.setPoints(_this.mPointStart, _this.mPointEnd, _this.mRadiusStart, _this.mRadiusEnd);
      return _this;
    }
    PdfRadialGradientBrush2.prototype.initialize = function(color1, color2) {
      this.mColour = [color1, color2];
      this.mColourBlends = new PdfColorBlend(2);
      this.mColourBlends.positions = [0, 1];
      this.mColourBlends.colors = this.mColour;
      this.initShading();
    };
    Object.defineProperty(PdfRadialGradientBrush2.prototype, "blend", {
      //Properties
      /**
       * Gets or sets a PdfBlend that specifies positions and factors that define a custom falloff for the gradient.
       * @public
       */
      get: function() {
        return this.mBlend;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : Blend");
        }
        if (this.mColour == null && typeof this.mColour === "undefined") {
          throw new Error("NotSupportedException : There is no starting and ending colours specified.");
        }
        this.mBlend = value;
        this.mColourBlends = this.mBlend.generateColorBlend(this.mColour, this.colorSpace);
        this.resetFunction();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush2.prototype, "interpolationColors", {
      /**
       * Gets or sets a ColorBlend that defines a multicolor radial gradient.
       * @public
       */
      get: function() {
        return this.mColourBlends;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : InterpolationColors");
        }
        this.mBlend = null;
        this.mColour = null;
        this.mColourBlends = value;
        this.resetFunction();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush2.prototype, "linearColors", {
      /**
       * Gets or sets the starting and ending colors of the radial gradient.
       * @public
       */
      get: function() {
        return this.mColour;
      },
      set: function(value) {
        if (value == null) {
          throw new Error("ArgumentNullException : radial LinearColors");
        }
        if (value.length < 2) {
          throw new Error("ArgumentException : The array is too small LinearColors");
        }
        if (this.mColour == null && typeof this.mColour === "undefined") {
          this.mColour = [value[0], value[1]];
        } else {
          this.mColour[0] = value[0];
          this.mColour[1] = value[1];
        }
        if (this.mBlend == null && typeof this.mBlend === "undefined") {
          this.mColourBlends = new PdfColorBlend(2);
          this.mColourBlends.colors = this.mColour;
          this.mColourBlends.positions = [0, 1];
        } else {
          this.mColourBlends = this.mBlend.generateColorBlend(this.mColour, this.colorSpace);
        }
        this.resetFunction();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush2.prototype, "rectangle", {
      /**
       * Gets or sets the rectangle.
       * @public
       */
      get: function() {
        return this.mBoundaries;
      },
      set: function(value) {
        this.mBoundaries = value;
        this.bBox = PdfArray.fromRectangle(value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush2.prototype, "extend", {
      /**
       * Gets or sets the value indicating whether the gradient
       *  should extend starting and ending points.
       * @public
       */
      get: function() {
        var result1 = PdfExtend.None;
        var extend1 = this.shading.items.getValue(this.mDictionaryProperties.extend);
        if (extend1 !== null && typeof extend1 !== "undefined") {
          var extStart = extend1.items(0);
          var extEnd = extend1.items(1);
          if (extStart.value) {
            result1 = result1 | PdfExtend.Start;
          }
          if (extEnd.value) {
            result1 = result1 | PdfExtend.End;
          }
        }
        return result1;
      },
      set: function(value) {
        var extend2 = this.shading.items.getValue(this.mDictionaryProperties.extend);
        var extStart;
        var extEnd1;
        if (extend2 == null && typeof extend2 === "undefined") {
          extStart = new PdfBoolean(false);
          extEnd1 = new PdfBoolean(false);
          extend2 = new PdfArray();
          extend2.add(extStart);
          extend2.add(extEnd1);
          this.shading.items.setValue(this.mDictionaryProperties.extend, extend2);
        } else {
          extStart = extend2.items(0);
          extEnd1 = extend2.items(1);
        }
      },
      enumerable: true,
      configurable: true
    });
    PdfRadialGradientBrush2.prototype.setPoints = function(pointStart, pointEnd, radiusStart, radiusEnd) {
      var points = new PdfArray();
      points.add(new PdfNumber(pointStart.x));
      points.add(new PdfNumber(this.updateY(pointStart.y)));
      points.add(new PdfNumber(radiusStart));
      points.add(new PdfNumber(pointEnd.x));
      points.add(new PdfNumber(this.updateY(pointEnd.y)));
      if (radiusStart !== radiusEnd) {
        points.add(new PdfNumber(radiusEnd));
      } else {
        points.add(new PdfNumber(0));
      }
      this.shading.items.setValue(this.mDictionaryProperties.coords, points);
    };
    PdfRadialGradientBrush2.prototype.updateY = function(y) {
      if (y !== 0) {
        return -y;
      } else {
        return y;
      }
    };
    PdfRadialGradientBrush2.prototype.initShading = function() {
      this.colorSpace = PdfColorSpace.Rgb;
      this.function = this.mColourBlends.getFunction(this.colorSpace);
      this.shading.items.setValue(this.mDictionaryProperties.shadingType, new PdfNumber(ShadingType.Radial));
    };
    PdfRadialGradientBrush2.prototype.clone = function() {
      var rBrush = this;
      rBrush.resetPatternDictionary(new PdfDictionary(this.patternDictionary));
      rBrush.shading = new PdfDictionary();
      rBrush.initShading();
      rBrush.setPoints(this.mPointStart, this.mPointEnd, this.mRadiusStart, this.mRadiusEnd);
      if (rBrush instanceof PdfRadialGradientBrush2) {
        if (this.matrix !== null && typeof this.matrix !== "undefined") {
          rBrush.matrix = this.matrix.clone();
        }
      }
      if (this.mColour !== null && typeof this.mColour !== "undefined") {
        rBrush.mColour = this.mColour;
      }
      if (this.blend !== null && typeof this.blend !== "undefined") {
        rBrush.blend = this.blend.clonePdfBlend();
      } else if (this.interpolationColors !== null && typeof this.interpolationColors !== "undefined") {
        rBrush.interpolationColors = this.interpolationColors.cloneColorBlend();
      }
      rBrush.extend = this.extend;
      this.cloneBackgroundValue(rBrush);
      this.cloneAntiAliasingValue(rBrush);
      return rBrush;
    };
    PdfRadialGradientBrush2.prototype.resetFunction = function() {
      this.function = this.mColourBlends.getFunction(this.colorSpace);
    };
    return PdfRadialGradientBrush2;
  })(PdfGradientBrush)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/tables/light-tables/enum.js
var PdfBorderOverlapStyle;
(function(PdfBorderOverlapStyle2) {
  PdfBorderOverlapStyle2[PdfBorderOverlapStyle2["Overlap"] = 0] = "Overlap";
  PdfBorderOverlapStyle2[PdfBorderOverlapStyle2["Inside"] = 1] = "Inside";
})(PdfBorderOverlapStyle || (PdfBorderOverlapStyle = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/styles/style.js
var __extends54 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfGridStyleBase = (
  /** @class */
  (function() {
    function PdfGridStyleBase2() {
    }
    Object.defineProperty(PdfGridStyleBase2.prototype, "backgroundBrush", {
      // Properties
      /**
       * Gets or sets the `background brush`.
       * @private
       */
      get: function() {
        return this.gridBackgroundBrush;
      },
      set: function(value) {
        this.gridBackgroundBrush = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyleBase2.prototype, "textBrush", {
      /**
       * Gets or sets the `text brush`.
       * @private
       */
      get: function() {
        return this.gridTextBrush;
      },
      set: function(value) {
        this.gridTextBrush = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyleBase2.prototype, "textPen", {
      /**
       * Gets or sets the `text pen`.
       * @private
       */
      get: function() {
        return this.gridTextPen;
      },
      set: function(value) {
        this.gridTextPen = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyleBase2.prototype, "font", {
      /**
       * Gets or sets the `font`.
       * @private
       */
      get: function() {
        return this.gridFont;
      },
      set: function(value) {
        this.gridFont = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyleBase2.prototype, "backgroundImage", {
      /**
       * Gets or sets the `background Image`.
       * @private
       */
      get: function() {
        return this.gridBackgroundImage;
      },
      set: function(value) {
        this.gridBackgroundImage = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridStyleBase2;
  })()
);
var PdfGridStyle = (
  /** @class */
  (function(_super) {
    __extends54(PdfGridStyle2, _super);
    function PdfGridStyle2() {
      var _this = _super.call(this) || this;
      _this.gridBorderOverlapStyle = PdfBorderOverlapStyle.Overlap;
      _this.bAllowHorizontalOverflow = false;
      _this.gridHorizontalOverflowType = PdfHorizontalOverflowType.LastPage;
      return _this;
    }
    Object.defineProperty(PdfGridStyle2.prototype, "cellSpacing", {
      //Properties
      /**
       * Gets or sets the `cell spacing` of the 'PdfGrid'.
       * @private
       */
      get: function() {
        if (typeof this.gridCellSpacing === "undefined") {
          this.gridCellSpacing = 0;
        }
        return this.gridCellSpacing;
      },
      set: function(value) {
        this.gridCellSpacing = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyle2.prototype, "horizontalOverflowType", {
      /**
       * Gets or sets the type of the `horizontal overflow` of the 'PdfGrid'.
       * @private
       */
      get: function() {
        return this.gridHorizontalOverflowType;
      },
      set: function(value) {
        this.gridHorizontalOverflowType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyle2.prototype, "allowHorizontalOverflow", {
      /**
       * Gets or sets a value indicating whether to `allow horizontal overflow`.
       * @private
       */
      get: function() {
        return this.bAllowHorizontalOverflow;
      },
      set: function(value) {
        this.bAllowHorizontalOverflow = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyle2.prototype, "cellPadding", {
      /**
       * Gets or sets the `cell padding`.
       * @private
       */
      get: function() {
        if (typeof this.gridCellPadding === "undefined") {
          this.gridCellPadding = new PdfPaddings();
        }
        return this.gridCellPadding;
      },
      set: function(value) {
        if (typeof this.gridCellPadding === "undefined") {
          this.gridCellPadding = new PdfPaddings();
          this.gridCellPadding = value;
        } else {
          this.gridCellPadding = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridStyle2.prototype, "borderOverlapStyle", {
      /**
       * Gets or sets the `border overlap style` of the 'PdfGrid'.
       * @private
       */
      get: function() {
        return this.gridBorderOverlapStyle;
      },
      set: function(value) {
        this.gridBorderOverlapStyle = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridStyle2;
  })(PdfGridStyleBase)
);
var PdfGridCellStyle = (
  /** @class */
  (function(_super) {
    __extends54(PdfGridCellStyle2, _super);
    function PdfGridCellStyle2() {
      var _this = _super.call(this) || this;
      _this.gridCellBorders = PdfBorders.default;
      return _this;
    }
    Object.defineProperty(PdfGridCellStyle2.prototype, "stringFormat", {
      //Properties
      /**
       * Gets the `string format` of the 'PdfGridCell'.
       * @private
       */
      get: function() {
        return this.format;
      },
      set: function(value) {
        this.format = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCellStyle2.prototype, "borders", {
      /**
       * Gets or sets the `border` of the 'PdfGridCell'.
       * @private
       */
      get: function() {
        return this.gridCellBorders;
      },
      set: function(value) {
        this.gridCellBorders = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCellStyle2.prototype, "cellPadding", {
      /**
       * Gets or sets the `cell padding`.
       * @private
       */
      get: function() {
        return this.gridCellPadding;
      },
      set: function(value) {
        if (this.gridCellPadding == null || typeof this.gridCellPadding === "undefined") {
          this.gridCellPadding = new PdfPaddings();
        }
        this.gridCellPadding = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridCellStyle2;
  })(PdfGridStyleBase)
);
var PdfGridRowStyle = (
  /** @class */
  (function() {
    function PdfGridRowStyle2() {
    }
    Object.defineProperty(PdfGridRowStyle2.prototype, "backgroundBrush", {
      // Properties
      /**
       * Gets or sets the `background brush`.
       * @private
       */
      get: function() {
        return this.gridRowBackgroundBrush;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowStyle2.prototype.setBackgroundBrush = function(value) {
      this.gridRowBackgroundBrush = value;
      if (typeof this.parent !== "undefined") {
        for (var i = 0; i < this.parent.cells.count; i++) {
          this.parent.cells.getCell(i).style.backgroundBrush = value;
        }
      }
    };
    Object.defineProperty(PdfGridRowStyle2.prototype, "textBrush", {
      /**
       * Gets or sets the `text brush`.
       * @private
       */
      get: function() {
        return this.gridRowTextBrush;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowStyle2.prototype.setTextBrush = function(value) {
      this.gridRowTextBrush = value;
      if (typeof this.parent !== "undefined") {
        for (var i = 0; i < this.parent.cells.count; i++) {
          this.parent.cells.getCell(i).style.textBrush = value;
        }
      }
    };
    Object.defineProperty(PdfGridRowStyle2.prototype, "textPen", {
      /**
       * Gets or sets the `text pen`.
       * @private
       */
      get: function() {
        return this.gridRowTextPen;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowStyle2.prototype.setTextPen = function(value) {
      this.gridRowTextPen = value;
      if (typeof this.parent !== "undefined") {
        for (var i = 0; i < this.parent.cells.count; i++) {
          this.parent.cells.getCell(i).style.textPen = value;
        }
      }
    };
    Object.defineProperty(PdfGridRowStyle2.prototype, "font", {
      /**
       * Gets or sets the `font`.
       * @private
       */
      get: function() {
        return this.gridRowFont;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowStyle2.prototype.setFont = function(value) {
      this.gridRowFont = value;
      if (typeof this.parent !== "undefined") {
        for (var i = 0; i < this.parent.cells.count; i++) {
          this.parent.cells.getCell(i).style.font = value;
        }
      }
    };
    Object.defineProperty(PdfGridRowStyle2.prototype, "border", {
      /**
       * Gets or sets the `border` of the current row.
       * @private
       */
      get: function() {
        if (typeof this.gridRowBorder === "undefined") {
          this.setBorder(new PdfBorders());
        }
        return this.gridRowBorder;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowStyle2.prototype.setBorder = function(value) {
      this.gridRowBorder = value;
      if (typeof this.parent !== "undefined") {
        for (var i = 0; i < this.parent.cells.count; i++) {
          this.parent.cells.getCell(i).style.borders = value;
        }
      }
    };
    PdfGridRowStyle2.prototype.setParent = function(parent) {
      this.parent = parent;
    };
    Object.defineProperty(PdfGridRowStyle2.prototype, "backgroundImage", {
      /**
       * Gets or sets the `backgroundImage` of the 'PdfGridCell'.
       * @private
       */
      get: function() {
        return this.gridRowBackgroundImage;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowStyle2.prototype.setBackgroundImage = function(value) {
      this.gridRowBackgroundImage = value;
    };
    return PdfGridRowStyle2;
  })()
);
var PdfHorizontalOverflowType;
(function(PdfHorizontalOverflowType2) {
  PdfHorizontalOverflowType2[PdfHorizontalOverflowType2["NextPage"] = 0] = "NextPage";
  PdfHorizontalOverflowType2[PdfHorizontalOverflowType2["LastPage"] = 1] = "LastPage";
})(PdfHorizontalOverflowType || (PdfHorizontalOverflowType = {}));

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/pdf-grid-cell.js
var PdfGridCell = (
  /** @class */
  (function() {
    function PdfGridCell2(row) {
      this.cellWidth = 0;
      this.cellHeight = 0;
      this.tempval = 0;
      this.fontSpilt = false;
      this.finsh = true;
      this.rowSpanRemainingHeight = 0;
      this.hasRowSpan = false;
      this.hasColSpan = false;
      this.isFinish = true;
      this.present = false;
      this.gridRowSpan = 1;
      this.colSpan = 1;
      if (typeof row !== "undefined") {
        this.gridRow = row;
      }
    }
    Object.defineProperty(PdfGridCell2.prototype, "isCellMergeContinue", {
      //Properties
      get: function() {
        return this.internalIsCellMergeContinue;
      },
      set: function(value) {
        this.internalIsCellMergeContinue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "isRowMergeContinue", {
      get: function() {
        return this.internalIsRowMergeContinue;
      },
      set: function(value) {
        this.internalIsRowMergeContinue = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "isCellMergeStart", {
      get: function() {
        return this.internalIsCellMergeStart;
      },
      set: function(value) {
        this.internalIsCellMergeStart = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "isRowMergeStart", {
      get: function() {
        return this.internalIsRowMergeStart;
      },
      set: function(value) {
        this.internalIsRowMergeStart = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "remainingString", {
      /**
       * Gets or sets the `remaining string` after the row split between pages.
       * @private
       */
      get: function() {
        return this.remaining;
      },
      set: function(value) {
        this.remaining = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "FinishedDrawingCell", {
      /**
       * Gets or sets the `FinishedDrawingCell` .
       * @private
       */
      get: function() {
        return this.isFinish;
      },
      set: function(value) {
        this.isFinish = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "stringFormat", {
      /**
       * Gets or sets the `string format`.
       * @private
       */
      get: function() {
        if (this.format == null) {
          this.format = new PdfStringFormat();
        }
        return this.format;
      },
      set: function(value) {
        this.format = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "row", {
      /**
       * Gets or sets the parent `row`.
       * @private
       */
      get: function() {
        return this.gridRow;
      },
      set: function(value) {
        this.gridRow = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "value", {
      /**
       * Gets or sets the `value` of the cell.
       * @private
       */
      get: function() {
        return this.objectValue;
      },
      set: function(value) {
        this.objectValue = value;
        if (this.objectValue instanceof PdfGrid) {
          this.row.grid.isSingleGrid = false;
          var grid = this.objectValue;
          grid.ParentCell = this;
          this.objectValue.isChildGrid = true;
          var rowCount = this.row.grid.rows.count;
          for (var i = 0; i < rowCount; i++) {
            var row = this.row.grid.rows.getRow(i);
            var colCount = row.cells.count;
            for (var j = 0; j < colCount; j++) {
              var cell = row.cells.getCell(j);
              cell.parent = this;
            }
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "rowSpan", {
      /**
       * Gets or sets a value that indicates the total number of rows that cell `spans` within a PdfGrid.
       * @private
       */
      get: function() {
        return this.gridRowSpan;
      },
      set: function(value) {
        if (value < 1) {
          throw new Error("ArgumentException : Invalid span specified, must be greater than or equal to 1");
        } else {
          this.gridRowSpan = value;
          this.row.rowSpanExists = true;
          this.row.grid.hasRowSpanSpan = true;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "style", {
      /**
       * Gets or sets the cell `style`.
       * @private
       */
      get: function() {
        if (this.cellStyle == null) {
          this.cellStyle = new PdfGridCellStyle();
        }
        return this.cellStyle;
      },
      set: function(value) {
        this.cellStyle = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "height", {
      /**
       * Gets the `height` of the PdfGrid cell.[Read-Only].
       * @private
       */
      get: function() {
        if (this.cellHeight === 0) {
          this.cellHeight = this.measureHeight();
        }
        return this.cellHeight;
      },
      set: function(value) {
        this.cellHeight = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "columnSpan", {
      /**
       * Gets or sets a value that indicates the total number of columns that cell `spans` within a PdfGrid.
       * @private
       */
      get: function() {
        return this.colSpan;
      },
      set: function(value) {
        if (value < 1) {
          throw Error("Invalid span specified, must be greater than or equal to 1");
        } else {
          this.colSpan = value;
          this.row.columnSpanExists = true;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridCell2.prototype, "width", {
      /**
       * Gets the `width` of the PdfGrid cell.[Read-Only].
       * @private
       */
      get: function() {
        if (this.cellWidth === 0 || this.row.grid.isComplete) {
          this.cellWidth = this.measureWidth();
        }
        return Math.round(this.cellWidth);
      },
      set: function(value) {
        this.cellWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridCell2.prototype.measureWidth = function() {
      var width = 0;
      var layouter = new PdfStringLayouter();
      if (typeof this.objectValue === "string") {
        var slr = layouter.layout(this.objectValue, this.getTextFont(), this.stringFormat, new SizeF(Number.MAX_VALUE, Number.MAX_VALUE), false, new SizeF(0, 0));
        width += slr.actualSize.width;
        width += (this.style.borders.left.width + this.style.borders.right.width) * 2;
      } else if (this.objectValue instanceof PdfGrid) {
        width = this.objectValue.size.width;
      } else if (this.objectValue instanceof PdfImage || this.objectValue instanceof PdfBitmap) {
        width += this.objectValue.width;
      } else if (this.objectValue instanceof PdfTextWebLink) {
        var webLink = this.objectValue;
        var result = layouter.layout(webLink.text, webLink.font, webLink.stringFormat, new SizeF(0, 0), false, new SizeF(0, 0));
        width += result.actualSize.width;
        width += (this.style.borders.left.width + this.style.borders.right.width) * 2;
      }
      if (!(this.objectValue instanceof PdfGrid)) {
        if (this.style.cellPadding != null) {
          width += this.style.cellPadding.left + this.style.cellPadding.right;
        } else {
          width += this.row.grid.style.cellPadding.left + this.row.grid.style.cellPadding.right;
        }
      } else {
        if (this.style.cellPadding != null || typeof this.style.cellPadding !== "undefined") {
          if (typeof this.style.cellPadding.left !== "undefined" && this.style.cellPadding.hasLeftPad) {
            width += this.style.cellPadding.left;
          }
          if (typeof this.style.cellPadding.right !== "undefined" && this.style.cellPadding.hasRightPad) {
            width += this.style.cellPadding.right;
          }
        } else {
          if (typeof this.row.grid.style.cellPadding.left !== "undefined" && this.row.grid.style.cellPadding.hasLeftPad) {
            width += this.row.grid.style.cellPadding.left;
          }
          if (typeof this.row.grid.style.cellPadding.right !== "undefined" && this.row.grid.style.cellPadding.hasRightPad) {
            width += this.row.grid.style.cellPadding.right;
          }
        }
      }
      width += this.row.grid.style.cellSpacing;
      return width;
    };
    PdfGridCell2.prototype.drawCellBackground = function(graphics, bounds) {
      var backgroundBrush = this.getBackgroundBrush();
      if (backgroundBrush != null) {
        graphics.save();
        graphics.drawRectangle(backgroundBrush, bounds.x, bounds.y, bounds.width, bounds.height);
        graphics.restore();
      }
      if (this.style.backgroundImage != null) {
        var image = this.getBackgroundImage();
        graphics.drawImage(this.style.backgroundImage, bounds.x, bounds.y, bounds.width, bounds.height);
      }
    };
    PdfGridCell2.prototype.adjustContentLayoutArea = function(bounds) {
      var returnBounds = new RectangleF(bounds.x, bounds.y, bounds.width, bounds.height);
      if (!(this.objectValue instanceof PdfGrid)) {
        if (typeof this.style.cellPadding === "undefined" || this.style.cellPadding == null) {
          returnBounds.x += this.gridRow.grid.style.cellPadding.left;
          returnBounds.y += this.gridRow.grid.style.cellPadding.top;
          returnBounds.width -= this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;
          returnBounds.height -= this.gridRow.grid.style.cellPadding.bottom + this.gridRow.grid.style.cellPadding.top;
        } else {
          returnBounds.x += this.style.cellPadding.left;
          returnBounds.y += this.style.cellPadding.top;
          returnBounds.width -= this.style.cellPadding.right + this.style.cellPadding.left;
          returnBounds.height -= this.style.cellPadding.bottom + this.style.cellPadding.top;
          if (this.rowSpan === 1) {
            returnBounds.width -= this.style.borders.left.width;
          }
        }
        if (typeof this.style.borders === "undefined" || this.style.borders == null) {
          returnBounds.x += this.gridRow.style.border.left.width;
          returnBounds.y += this.gridRow.style.border.top.width;
          returnBounds.width -= this.gridRow.style.border.left.width + this.gridRow.style.border.right.width;
          returnBounds.height -= this.gridRow.style.border.top.width + this.gridRow.style.border.bottom.width;
        } else {
          returnBounds.x += this.style.borders.left.width;
          returnBounds.y += this.style.borders.top.width;
          returnBounds.width -= this.style.borders.left.width + this.style.borders.right.width;
          returnBounds.height -= this.style.borders.top.width + this.style.borders.bottom.width;
          if (this.rowSpan === 1) {
            returnBounds.width -= this.style.borders.left.width;
          }
        }
      } else {
        if (this.style.cellPadding == null || typeof this.style.cellPadding === "undefined") {
          if (this.gridRow.grid.style.cellPadding !== null && typeof this.gridRow.grid.style.cellPadding !== "undefined") {
            var hasLeftPad = this.gridRow.grid.style.cellPadding.hasLeftPad;
            var hasTopPad = this.gridRow.grid.style.cellPadding.hasTopPad;
            var hasRightPad = this.gridRow.grid.style.cellPadding.hasRightPad;
            var hasBottomPad = this.gridRow.grid.style.cellPadding.hasBottomPad;
            if (hasLeftPad || hasTopPad || hasRightPad || hasBottomPad) {
              if (typeof this.gridRow.grid.style.cellPadding.left !== "undefined" && hasLeftPad) {
                returnBounds.x += this.gridRow.grid.style.cellPadding.left + this.cellStyle.borders.left.width;
                returnBounds.width -= this.gridRow.grid.style.cellPadding.left;
              }
              if (typeof this.gridRow.grid.style.cellPadding.top !== "undefined" && hasTopPad) {
                returnBounds.y += this.gridRow.grid.style.cellPadding.top + this.cellStyle.borders.top.width;
                returnBounds.height -= this.gridRow.grid.style.cellPadding.top;
              }
              if (typeof this.gridRow.grid.style.cellPadding.right !== "undefined" && hasRightPad) {
                returnBounds.width -= this.gridRow.grid.style.cellPadding.right;
              }
              if (typeof this.gridRow.grid.style.cellPadding.bottom !== "undefined" && hasBottomPad) {
                returnBounds.height -= this.gridRow.grid.style.cellPadding.bottom;
              }
            } else {
              var format = this.getStringFormat();
              if (format.alignment === null || typeof format.alignment === "undefined") {
                returnBounds.x += this.row.grid.style.cellPadding.left;
                returnBounds.y += this.row.grid.style.cellPadding.top;
              }
            }
          } else {
            var format = this.getStringFormat();
            if (format.alignment === null || typeof format.alignment === "undefined") {
              returnBounds.x += this.row.grid.style.cellPadding.left;
              returnBounds.y += this.row.grid.style.cellPadding.top;
            }
          }
        } else {
          if (typeof this.style.cellPadding.left !== "undefined" && this.style.cellPadding.hasLeftPad) {
            returnBounds.x += this.style.cellPadding.left + this.cellStyle.borders.left.width;
            returnBounds.width -= this.style.cellPadding.left;
          }
          if (typeof this.style.cellPadding.top !== "undefined" && this.style.cellPadding.hasTopPad) {
            returnBounds.y += this.style.cellPadding.top + this.cellStyle.borders.top.width;
            returnBounds.height -= this.style.cellPadding.top;
          }
          if (typeof this.style.cellPadding.right !== "undefined" && this.style.cellPadding.hasRightPad) {
            returnBounds.width -= this.style.cellPadding.right;
          }
          if (typeof this.style.cellPadding.bottom !== "undefined" && this.style.cellPadding.hasBottomPad) {
            returnBounds.height -= this.style.cellPadding.bottom;
          }
        }
        returnBounds.width -= this.cellStyle.borders.left.width + this.cellStyle.borders.right.width;
        returnBounds.height -= this.cellStyle.borders.top.width + this.cellStyle.borders.bottom.width;
      }
      return returnBounds;
    };
    PdfGridCell2.prototype.draw = function(graphics, bounds, cancelSubsequentSpans) {
      var isrowbreak = false;
      var result = null;
      if (this.internalIsCellMergeContinue || this.internalIsRowMergeContinue) {
        if (this.internalIsCellMergeContinue && this.row.grid.style.allowHorizontalOverflow) {
          if (this.row.rowOverflowIndex > 0 && this.row.cells.indexOf(this) != this.row.rowOverflowIndex + 1 || this.row.rowOverflowIndex == 0 && this.internalIsCellMergeContinue) {
            return result;
          }
        } else {
          return result;
        }
      }
      bounds = this.adjustOuterLayoutArea(bounds, graphics);
      this.drawCellBackground(graphics, bounds);
      var textPen = this.getTextPen();
      var textBrush = this.getTextBrush();
      if (typeof textPen === "undefined" && typeof textBrush === "undefined") {
        textBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
      }
      var font = this.getTextFont();
      var strFormat = this.getStringFormat();
      var innerLayoutArea = bounds;
      if (innerLayoutArea.height >= graphics.clientSize.height) {
        if (this.row.grid.allowRowBreakAcrossPages) {
          innerLayoutArea.height -= innerLayoutArea.y;
          if (typeof this._rowHeight !== "undefined" && this._rowHeight !== null && innerLayoutArea.height > this._rowHeight) {
            innerLayoutArea.height = this._rowHeight;
          }
        }
      }
      innerLayoutArea = this.adjustContentLayoutArea(innerLayoutArea);
      if (typeof this.objectValue === "string" || typeof this.remaining === "string") {
        var temp = void 0;
        var layoutRectangle = void 0;
        if (innerLayoutArea.height < font.height)
          layoutRectangle = new RectangleF(innerLayoutArea.x, innerLayoutArea.y, innerLayoutArea.width, font.height);
        else
          layoutRectangle = innerLayoutArea;
        if (innerLayoutArea.height < font.height && this.row.grid.isChildGrid && this.row.grid.ParentCell != null) {
          var height = layoutRectangle.height - this.row.grid.ParentCell.row.grid.style.cellPadding.bottom - this.row.grid.style.cellPadding.bottom;
          if (this.row.grid.splitChildRowIndex != -1) {
            this.fontSpilt = true;
            this.row.rowFontSplit = true;
          }
          if (height > 0 && height < font.height)
            layoutRectangle.height = height;
        }
        if (this.gridRow.grid.style.cellSpacing != 0) {
          layoutRectangle.width -= this.gridRow.grid.style.cellSpacing;
          bounds.width -= this.gridRow.grid.style.cellSpacing;
        }
        if (this.isFinish) {
          temp = this.remaining === "" ? this.remaining : this.objectValue;
          graphics.drawString(temp, font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);
          if (this.row.grid.splitChildRowIndex != -1 && !this.row.grid.isChildGrid && typeof this.remaining === "undefined") {
            this.remaining = "";
          }
        } else {
          if (typeof this.remaining == "undefined" || this.remaining === null) {
            this.remaining = "";
          }
          if (this.row.repeatFlag) {
            graphics.drawString(this.remaining, font, textPen, textBrush, layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height, strFormat);
          }
          this.isFinish = true;
        }
        result = graphics.stringLayoutResult;
      } else if (this.objectValue instanceof PdfGrid) {
        var childGrid = this.objectValue;
        childGrid.isChildGrid = true;
        childGrid.ParentCell = this;
        var layoutRect = void 0;
        layoutRect = innerLayoutArea;
        if (this.gridRow.grid.style.cellSpacing != 0) {
          bounds.width -= this.gridRow.grid.style.cellSpacing;
        }
        var layouter = new PdfGridLayouter(childGrid);
        var format = new PdfGridLayoutFormat();
        if (this.row.grid.LayoutFormat != null)
          format = this.row.grid.LayoutFormat;
        else
          format.layout = PdfLayoutType.Paginate;
        var param = new PdfLayoutParams();
        if (graphics.layer != null) {
          param.page = graphics.page;
          param.bounds = layoutRect;
          param.format = format;
          childGrid.setSpan();
          childGrid.checkSpan();
          var childGridResult = layouter.Layouter(param);
          this.value = childGrid;
          if (this.row.grid.splitChildRowIndex !== -1) {
            this.height = this.row.rowBreakHeightValue;
          }
          if (param.page != childGridResult.page) {
            if (this.row.rowBreakHeightValue !== null && typeof this.row.rowBreakHeightValue !== "undefined")
              childGridResult.bounds.height = this.row.rowBreakHeightValue;
            if (this.row.rowBreakHeight == 0)
              this.row.NestedGridLayoutResult = childGridResult;
            else
              this.row.rowBreakHeight = this.row.rowBreakHeightValue;
          }
        }
      } else if (this.objectValue instanceof PdfImage || this.objectValue instanceof PdfBitmap) {
        var imageBounds = new RectangleF(innerLayoutArea.x, innerLayoutArea.y, innerLayoutArea.width, innerLayoutArea.height);
        var image = this.objectValue;
        if (image.width <= innerLayoutArea.width) {
          imageBounds.width = image.width;
        }
        if (image.height <= innerLayoutArea.height) {
          imageBounds.height = image.height;
        }
        graphics.drawImage(this.objectValue, imageBounds.x, imageBounds.y, imageBounds.width, imageBounds.height);
      } else if (this.objectValue instanceof PdfTextWebLink) {
        this.objectValue.draw(graphics.currentPage, innerLayoutArea);
      } else if (typeof this.objectValue === "undefined") {
        this.objectValue = "";
        graphics.drawString(this.objectValue, font, textPen, textBrush, innerLayoutArea.x, innerLayoutArea.y, innerLayoutArea.width, innerLayoutArea.height, strFormat);
        if (this.style.cellPadding != null && this.style.cellPadding.bottom == 0 && this.style.cellPadding.left == 0 && this.style.cellPadding.right == 0 && this.style.cellPadding.top == 0) {
          bounds.width -= this.style.borders.left.width + this.style.borders.right.width;
        }
        if (this.gridRow.grid.style.cellSpacing != 0) {
          bounds.width -= this.gridRow.grid.style.cellSpacing;
        }
      }
      if (this.style.borders != null) {
        if (!this.fontSpilt)
          this.drawCellBorders(graphics, bounds);
        else {
          if (this.row.grid.ParentCell.row.grid.splitChildRowIndex != -1) {
            this.row.rowFontSplit = false;
            this.drawCellBorders(graphics, bounds);
          }
        }
      }
      return result;
    };
    PdfGridCell2.prototype.drawCellBorders = function(graphics, bounds) {
      if (this.row.grid.style.borderOverlapStyle === PdfBorderOverlapStyle.Inside) {
        bounds.x += this.style.borders.left.width;
        bounds.y += this.style.borders.top.width;
        bounds.width -= this.style.borders.right.width;
        bounds.height -= this.style.borders.bottom.width;
      }
      var p1 = new PointF(bounds.x, bounds.y + bounds.height);
      var p2 = new PointF(bounds.x, bounds.y);
      var pen = this.cellStyle.borders.left;
      if (this.cellStyle.borders.left.dashStyle === PdfDashStyle.Solid) {
        pen.lineCap = PdfLineCap.Square;
      }
      if (pen.width !== 0) {
        graphics.drawLine(pen, p1, p2);
      }
      p1 = new PointF(bounds.x + bounds.width, bounds.y);
      p2 = new PointF(bounds.x + bounds.width, bounds.y + bounds.height);
      pen = this.cellStyle.borders.right;
      if (bounds.x + bounds.width > graphics.clientSize.width - pen.width / 2) {
        p1 = new PointF(graphics.clientSize.width - pen.width / 2, bounds.y);
        p2 = new PointF(graphics.clientSize.width - pen.width / 2, bounds.y + bounds.height);
      }
      if (this.cellStyle.borders.right.dashStyle === PdfDashStyle.Solid) {
        pen.lineCap = PdfLineCap.Square;
      }
      if (pen.width !== 0) {
        graphics.drawLine(pen, p1, p2);
      }
      p1 = new PointF(bounds.x, bounds.y);
      p2 = new PointF(bounds.x + bounds.width, bounds.y);
      pen = this.cellStyle.borders.top;
      if (this.cellStyle.borders.top.dashStyle === PdfDashStyle.Solid) {
        pen.lineCap = PdfLineCap.Square;
      }
      if (pen.width !== 0) {
        graphics.drawLine(pen, p1, p2);
      }
      p1 = new PointF(bounds.x + bounds.width, bounds.y + bounds.height);
      p2 = new PointF(bounds.x, bounds.y + bounds.height);
      pen = this.cellStyle.borders.bottom;
      if (bounds.y + bounds.height > graphics.clientSize.height - pen.width / 2) {
        p1 = new PointF(bounds.x + bounds.width, graphics.clientSize.height - pen.width / 2);
        p2 = new PointF(bounds.x, graphics.clientSize.height - pen.width / 2);
      }
      if (this.cellStyle.borders.bottom.dashStyle === PdfDashStyle.Solid) {
        pen.lineCap = PdfLineCap.Square;
      }
      if (pen.width !== 0) {
        graphics.drawLine(pen, p1, p2);
      }
    };
    PdfGridCell2.prototype.adjustOuterLayoutArea = function(bounds, g) {
      var isHeader = false;
      var cellSpacing = this.row.grid.style.cellSpacing;
      if (cellSpacing > 0) {
        bounds = new RectangleF(bounds.x + cellSpacing, bounds.y + cellSpacing, bounds.width - cellSpacing, bounds.height - cellSpacing);
      }
      var currentColIndex = this.row.cells.indexOf(this);
      if (this.columnSpan > 1 || this.row.rowOverflowIndex > 0 && currentColIndex == this.row.rowOverflowIndex + 1 && this.isCellMergeContinue) {
        var span = this.columnSpan;
        if (span == 1 && this.isCellMergeContinue) {
          for (var j = currentColIndex + 1; j < this.row.grid.columns.count; j++) {
            if (this.row.cells.getCell(j).isCellMergeContinue)
              span++;
            else
              break;
          }
        }
        var totalWidth = 0;
        for (var i = currentColIndex; i < currentColIndex + span; i++) {
          if (this.row.grid.style.allowHorizontalOverflow) {
            var width = void 0;
            var compWidth = this.row.grid.size.width < g.clientSize.width ? this.row.grid.size.width : g.clientSize.width;
            if (this.row.grid.size.width > g.clientSize.width) {
              width = bounds.x + totalWidth + this.row.grid.columns.getColumn(i).width;
            } else {
              width = totalWidth + this.row.grid.columns.getColumn(i).width;
            }
            if (width > compWidth) {
              break;
            }
          }
          totalWidth += this.row.grid.columns.getColumn(i).width;
        }
        totalWidth -= this.row.grid.style.cellSpacing;
        bounds.width = totalWidth;
      }
      if (this.rowSpan > 1 || this.row.rowSpanExists) {
        var span = this.rowSpan;
        var currentRowIndex = this.row.grid.rows.rowCollection.indexOf(this.row);
        if (currentRowIndex == -1) {
          currentRowIndex = this.row.grid.headers.indexOf(this.row);
          if (currentRowIndex != -1) {
            isHeader = true;
          }
        }
        var totalHeight = 0;
        var max = 0;
        for (var i = currentRowIndex; i < currentRowIndex + span; i++) {
          totalHeight += isHeader ? this.row.grid.headers.getHeader(i).height : this.row.grid.rows.getRow(i).height;
          var row = this.row.grid.rows.getRow(i);
          var rowIndex = this.row.grid.rows.rowCollection.indexOf(row);
        }
        var cellIndex = this.row.cells.indexOf(this);
        totalHeight -= this.row.grid.style.cellSpacing;
        bounds.height = totalHeight;
        if (!this.row.rowMergeComplete) {
          bounds.height = totalHeight;
        }
      }
      return bounds;
    };
    PdfGridCell2.prototype.getTextFont = function() {
      if (typeof this.style.font !== "undefined" && this.style.font != null) {
        return this.style.font;
      } else if (typeof this.row.style.font !== "undefined" && this.row.style.font != null) {
        return this.row.style.font;
      } else if (typeof this.row.grid.style.font !== "undefined" && this.row.grid.style.font != null) {
        return this.row.grid.style.font;
      } else {
        return PdfDocument.defaultFont;
      }
    };
    PdfGridCell2.prototype.getTextBrush = function() {
      if (typeof this.style.textBrush !== "undefined" && this.style.textBrush != null) {
        return this.style.textBrush;
      } else if (typeof this.row.style.textBrush !== "undefined" && this.row.style.textBrush != null) {
        return this.row.style.textBrush;
      } else {
        return this.row.grid.style.textBrush;
      }
    };
    PdfGridCell2.prototype.getTextPen = function() {
      if (typeof this.style.textPen !== "undefined" && this.style.textPen != null) {
        return this.style.textPen;
      } else if (typeof this.row.style.textPen !== "undefined" && this.row.style.textPen != null) {
        return this.row.style.textPen;
      } else {
        return this.row.grid.style.textPen;
      }
    };
    PdfGridCell2.prototype.getBackgroundBrush = function() {
      if (typeof this.style.backgroundBrush !== "undefined" && this.style.backgroundBrush != null) {
        return this.style.backgroundBrush;
      } else if (typeof this.row.style.backgroundBrush !== "undefined" && this.row.style.backgroundBrush != null) {
        return this.row.style.backgroundBrush;
      } else {
        return this.row.grid.style.backgroundBrush;
      }
    };
    PdfGridCell2.prototype.getBackgroundImage = function() {
      if (typeof this.style.backgroundImage !== "undefined" && this.style.backgroundImage != null) {
        return this.style.backgroundImage;
      } else if (typeof this.row.style.backgroundImage !== "undefined" && this.row.style.backgroundImage != null) {
        return this.row.style.backgroundImage;
      } else {
        return this.row.grid.style.backgroundImage;
      }
    };
    PdfGridCell2.prototype.getStringFormat = function() {
      if (typeof this.style.stringFormat !== "undefined" && this.style.stringFormat != null) {
        return this.style.stringFormat;
      } else {
        return this.stringFormat;
      }
    };
    PdfGridCell2.prototype.measureHeight = function() {
      var width = this.calculateWidth();
      if (this.style.cellPadding == null || typeof this.style.cellPadding === "undefined") {
        width -= this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;
      } else {
        width -= this.style.cellPadding.right + this.style.cellPadding.left;
        width -= this.style.borders.left.width + this.style.borders.right.width;
      }
      var height = 0;
      var layouter = new PdfStringLayouter();
      if (typeof this.objectValue === "string" || typeof this.remaining === "string") {
        var currentValue = this.objectValue;
        if (!this.isFinish)
          currentValue = !(this.remaining === null || this.remaining === "" || typeof this.remaining === "undefined") ? this.remaining : this.objectValue;
        var slr = null;
        var cellIndex = this.row.cells.indexOf(this);
        if (this.gridRow.grid.style.cellSpacing != 0) {
          width -= this.gridRow.grid.style.cellSpacing * 2;
        }
        if (!this.row.cells.getCell(cellIndex).hasColSpan && !this.row.cells.getCell(cellIndex).hasRowSpan) {
          if (this.gridRow.grid.isChildGrid) {
            if (width < 0) {
              this.tempval = width;
              if (this.style.cellPadding == null || typeof this.style.cellPadding === "undefined") {
                this.tempval += this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;
              } else {
                this.tempval += this.style.cellPadding.right + this.style.cellPadding.left;
                this.tempval += this.style.borders.left.width + this.style.borders.right.width;
              }
            } else {
              this.tempval = width;
            }
            slr = layouter.layout(currentValue, this.getTextFont(), this.stringFormat, new SizeF(this.tempval, 0), false, new SizeF(0, 0));
            height += slr.actualSize.height;
          } else {
            slr = layouter.layout(currentValue, this.getTextFont(), this.stringFormat, new SizeF(width, 0), false, new SizeF(0, 0));
            height += slr.actualSize.height;
          }
        }
        height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;
      } else if (this.objectValue instanceof PdfGrid) {
        var cellIndex = this.row.cells.indexOf(this);
        var internalWidth = 0;
        if (this.style.cellPadding != null || typeof this.style.cellPadding !== "undefined") {
          internalWidth = this.calculateWidth();
          if (typeof this.style.cellPadding.left !== "undefined" && this.style.cellPadding.hasLeftPad) {
            internalWidth -= this.style.cellPadding.left;
          }
          if (typeof this.style.cellPadding.right !== "undefined" && this.style.cellPadding.hasRightPad) {
            internalWidth -= this.style.cellPadding.right;
          }
        } else if (this.row.grid.style.cellPadding != null || typeof this.row.grid.style.cellPadding !== "undefined") {
          internalWidth = this.calculateWidth();
          if (typeof this.row.grid.style.cellPadding.left !== "undefined" && this.row.grid.style.cellPadding.hasLeftPad) {
            internalWidth -= this.row.grid.style.cellPadding.left;
          }
          if (typeof this.row.grid.style.cellPadding.right !== "undefined" && this.row.grid.style.cellPadding.hasRightPad) {
            internalWidth -= this.row.grid.style.cellPadding.right;
          }
        } else {
          internalWidth = this.calculateWidth();
        }
        this.objectValue.tempWidth = internalWidth;
        if (!this.row.cells.getCell(cellIndex).hasColSpan && !this.row.cells.getCell(cellIndex).hasRowSpan) {
          height = this.objectValue.size.height;
        } else {
          height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;
        }
        if (this.gridRow.grid.style.cellSpacing !== 0) {
          width -= this.gridRow.grid.style.cellSpacing * 2;
        }
        if (this.style.cellPadding != null || typeof this.style.cellPadding !== "undefined") {
          if (typeof this.row.grid.style.cellPadding.top !== "undefined" && this.row.grid.style.cellPadding.hasTopPad) {
            height += this.row.grid.style.cellPadding.top;
          }
          if (this.row.grid.style.cellPadding.hasBottomPad && typeof this.row.grid.style.cellPadding.bottom !== "undefined") {
            height += this.row.grid.style.cellPadding.bottom;
          }
        }
        height += this.objectValue.style.cellSpacing;
      } else if (this.objectValue instanceof PdfImage || this.objectValue instanceof PdfBitmap) {
        height += this.objectValue.height;
      } else if (this.objectValue instanceof PdfTextWebLink) {
        var webLink = this.objectValue;
        var slr = layouter.layout(webLink.text, webLink.font, webLink.stringFormat, new SizeF(width, 0), false, new SizeF(0, 0));
        height += slr.actualSize.height;
        height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;
      } else if (typeof this.objectValue === "undefined") {
        if (this.style.cellPadding == null || typeof this.style.cellPadding === "undefined") {
          width -= this.gridRow.grid.style.cellPadding.right + this.gridRow.grid.style.cellPadding.left;
        } else {
          width -= this.style.cellPadding.right + this.style.cellPadding.left;
          width -= this.style.borders.left.width + this.style.borders.right.width;
        }
        height += (this.style.borders.top.width + this.style.borders.bottom.width) * 2;
      }
      if (!(this.objectValue instanceof PdfGrid)) {
        if (this.style.cellPadding == null || typeof this.style.cellPadding === "undefined") {
          height += this.row.grid.style.cellPadding.top + this.row.grid.style.cellPadding.bottom;
        } else {
          height += this.style.cellPadding.top + this.style.cellPadding.bottom;
        }
      } else {
        if (this.style.cellPadding == null || typeof this.style.cellPadding === "undefined") {
          if (typeof this.row.grid.style.cellPadding.top !== "undefined" && this.row.grid.style.cellPadding.hasTopPad) {
            height += this.row.grid.style.cellPadding.top;
          }
          if (typeof this.row.grid.style.cellPadding.bottom !== "undefined" && this.row.grid.style.cellPadding.hasBottomPad) {
            height += this.row.grid.style.cellPadding.bottom;
          }
        } else {
          if (typeof this.style.cellPadding.top !== "undefined" && this.style.cellPadding.hasTopPad) {
            height += this.style.cellPadding.top;
          }
          if (typeof this.style.cellPadding.bottom !== "undefined" && this.style.cellPadding.hasBottomPad) {
            height += this.style.cellPadding.bottom;
          }
        }
      }
      height += this.row.grid.style.cellSpacing;
      return height;
    };
    PdfGridCell2.prototype.calculateWidth = function() {
      var cellIndex = this.row.cells.indexOf(this);
      var rowindex = this.row.grid.rows.rowCollection.indexOf(this.row);
      var columnSpan = this.columnSpan;
      var width = 0;
      if (columnSpan === 1) {
        for (var i = 0; i < columnSpan; i++) {
          width += this.row.grid.columns.getColumn(cellIndex + i).width;
        }
      } else if (columnSpan > 1) {
        for (var i = 0; i < columnSpan; i++) {
          width += this.row.grid.columns.getColumn(cellIndex + i).width;
          if (i + 1 < columnSpan) {
            this.row.cells.getCell(cellIndex + i + 1).hasColSpan = true;
          }
        }
      }
      if (this.parent != null && this.parent.row.width > 0) {
        if (this.row.grid.isChildGrid && this.parent != null && this.row.width > this.parent.row.width) {
          width = 0;
          for (var j = 0; j < this.parent.columnSpan; j++) {
            width += this.parent.row.grid.columns.getColumn(j).width;
          }
          width = width / this.row.cells.count;
        }
      }
      return width;
    };
    return PdfGridCell2;
  })()
);
var PdfGridCellCollection = (
  /** @class */
  (function() {
    function PdfGridCellCollection2(row) {
      this.cells = [];
      this.gridRow = row;
    }
    PdfGridCellCollection2.prototype.getCell = function(index) {
      if (index < 0 || index >= this.count) {
        throw new Error("IndexOutOfRangeException");
      }
      return this.cells[index];
    };
    Object.defineProperty(PdfGridCellCollection2.prototype, "count", {
      /**
       * Gets the cells `count`.[Read-Only].
       * @private
       */
      get: function() {
        return this.cells.length;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridCellCollection2.prototype.add = function(cell) {
      if (typeof cell === "undefined") {
        var tempcell = new PdfGridCell();
        this.add(tempcell);
        return cell;
      } else {
        cell.row = this.gridRow;
        this.cells.push(cell);
      }
    };
    PdfGridCellCollection2.prototype.indexOf = function(cell) {
      return this.cells.indexOf(cell);
    };
    return PdfGridCellCollection2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/pdf-grid-column.js
var PdfGridColumn = (
  /** @class */
  (function() {
    function PdfGridColumn2(grid) {
      this.columnWidth = 0;
      this.grid = grid;
    }
    Object.defineProperty(PdfGridColumn2.prototype, "width", {
      /**
       * Gets or sets the `width` of the 'PdfGridColumn'.
       * @private
       */
      get: function() {
        return this.columnWidth;
      },
      set: function(value) {
        this.isCustomWidth = true;
        this.columnWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridColumn2.prototype, "format", {
      /**
       * Gets or sets the information about the text `formatting`.
       * @private
       */
      get: function() {
        if (this.stringFormat == null) {
          this.stringFormat = new PdfStringFormat();
        }
        return this.stringFormat;
      },
      set: function(value) {
        this.stringFormat = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridColumn2;
  })()
);
var PdfGridColumnCollection = (
  /** @class */
  (function() {
    function PdfGridColumnCollection2(grid) {
      this.internalColumns = [];
      this.columnWidth = 0;
      this.grid = grid;
      this.internalColumns = [];
    }
    PdfGridColumnCollection2.prototype.add = function(count) {
      for (var i = 0; i < count; i++) {
        this.internalColumns.push(new PdfGridColumn(this.grid));
        for (var index = 0; index < this.grid.rows.count; index++) {
          var row = this.grid.rows.getRow(index);
          var cell = new PdfGridCell();
          cell.value = "";
          row.cells.add(cell);
        }
      }
    };
    Object.defineProperty(PdfGridColumnCollection2.prototype, "count", {
      /**
       * Gets the `number of columns` in the 'PdfGrid'.[Read-Only].
       * @private
       */
      get: function() {
        return this.internalColumns.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridColumnCollection2.prototype, "width", {
      /**
       * Gets the `widths`.
       * @private
       */
      get: function() {
        if (this.columnWidth === 0) {
          this.columnWidth = this.measureColumnsWidth();
        }
        if (this.grid.initialWidth !== 0 && this.columnWidth !== this.grid.initialWidth && !this.grid.style.allowHorizontalOverflow) {
          this.columnWidth = this.grid.initialWidth;
          this.grid.isPageWidth = true;
        }
        return this.columnWidth;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridColumnCollection2.prototype, "columns", {
      /**
       * Gets the `array of PdfGridColumn`.[Read-Only]
       * @private
       */
      get: function() {
        return this.internalColumns;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridColumnCollection2.prototype.getColumn = function(index) {
      if (index >= 0 && index <= this.columns.length) {
        return this.columns[index];
      } else {
        throw Error("can not get the column from the index: " + index);
      }
    };
    PdfGridColumnCollection2.prototype.measureColumnsWidth = function() {
      var totalWidth = 0;
      this.grid.measureColumnsWidth();
      for (var i = 0, count = this.internalColumns.length; i < count; i++) {
        totalWidth += this.internalColumns[i].width;
      }
      return totalWidth;
    };
    PdfGridColumnCollection2.prototype.getDefaultWidths = function(totalWidth) {
      var widths = [];
      var summ = 0;
      var subFactor = this.count;
      for (var i = 0; i < this.count; i++) {
        if (this.grid.isPageWidth && totalWidth >= 0 && !this.internalColumns[i].isCustomWidth) {
          this.internalColumns[i].width = 0;
        } else {
          widths[i] = this.internalColumns[i].width;
          if (this.internalColumns[i].width > 0 && this.internalColumns[i].isCustomWidth) {
            totalWidth -= this.internalColumns[i].width;
            subFactor--;
          } else {
            widths[i] = 0;
          }
        }
      }
      for (var i = 0; i < this.count; i++) {
        var width = totalWidth / subFactor;
        if (widths[i] <= 0) {
          widths[i] = width;
        }
      }
      return widths;
    };
    return PdfGridColumnCollection2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/pdf-grid-row.js
var PdfGridRow = (
  /** @class */
  (function() {
    function PdfGridRow2(grid) {
      this.gridRowOverflowIndex = 0;
      this.rowHeight = 0;
      this.rowWidth = 0;
      this.isrowFinish = false;
      this.isRowSpanRowHeightSet = false;
      this.noOfPageCount = 0;
      this.isRowHeightSet = false;
      this.isPageBreakRowSpanApplied = false;
      this.isRowMergeComplete = true;
      this.repeatFlag = false;
      this.rowFontSplit = false;
      this.isHeaderRow = false;
      this.pdfGrid = grid;
    }
    Object.defineProperty(PdfGridRow2.prototype, "rowSpanExists", {
      //Properties
      /**
       * Gets or sets a value indicating [`row span exists`].
       * @private
       */
      get: function() {
        return this.bRowSpanExists;
      },
      set: function(value) {
        this.bRowSpanExists = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "cells", {
      /**
       * Gets the `cells` from the selected row.[Read-Only].
       * @private
       */
      get: function() {
        if (this.gridCells == null) {
          this.gridCells = new PdfGridCellCollection(this);
        }
        return this.gridCells;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "grid", {
      /**
       * Gets or sets the parent `grid`.
       * @private
       */
      get: function() {
        return this.pdfGrid;
      },
      set: function(value) {
        this.pdfGrid = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "style", {
      /**
       * Gets or sets the row `style`.
       * @private
       */
      get: function() {
        if (typeof this.rowStyle === "undefined") {
          this.rowStyle = new PdfGridRowStyle();
          this.rowStyle.setParent(this);
        }
        return this.rowStyle;
      },
      set: function(value) {
        this.rowStyle = value;
        for (var i = 0; i < this.cells.count; i++) {
          this.cells.getCell(i).style.borders = value.border;
          if (typeof value.font !== "undefined") {
            this.cells.getCell(i).style.font = value.font;
          }
          if (typeof value.backgroundBrush !== "undefined") {
            this.cells.getCell(i).style.backgroundBrush = value.backgroundBrush;
          }
          if (typeof value.backgroundImage !== "undefined") {
            this.cells.getCell(i).style.backgroundImage = value.backgroundImage;
          }
          if (typeof value.textBrush !== "undefined") {
            this.cells.getCell(i).style.textBrush = value.textBrush;
          }
          if (typeof value.textPen !== "undefined") {
            this.cells.getCell(i).style.textPen = value.textPen;
          }
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "rowBreakHeight", {
      /**
       * `Height` of the row yet to be drawn after split.
       * @private
       */
      get: function() {
        if (typeof this.gridRowBreakHeight === "undefined") {
          this.gridRowBreakHeight = 0;
        }
        return this.gridRowBreakHeight;
      },
      set: function(value) {
        this.gridRowBreakHeight = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "rowOverflowIndex", {
      /**
       * `over flow index` of the row.
       * @private
       */
      get: function() {
        return this.gridRowOverflowIndex;
      },
      set: function(value) {
        this.gridRowOverflowIndex = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "height", {
      /**
       * Gets or sets the `height` of the row.
       * @private
       */
      get: function() {
        if (!this.isRowHeightSet) {
          this.rowHeight = this.measureHeight();
        }
        return this.rowHeight;
      },
      set: function(value) {
        this.rowHeight = value;
        this.isRowHeightSet = true;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "width", {
      /**
       * Gets or sets the `width` of the row.
       * @private
       */
      get: function() {
        if (this.rowWidth === 0 || typeof this.rowWidth === "undefined") {
          this.rowWidth = this.measureWidth();
        }
        return this.rowWidth;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "NestedGridLayoutResult", {
      /**
       * Gets or sets the row `Nested grid Layout Result`.
       * @private
       */
      get: function() {
        return this.gridResult;
      },
      set: function(value) {
        this.gridResult = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "columnSpanExists", {
      /**
       * Gets or sets a value indicating [`column span exists`].
       * @private
       */
      get: function() {
        return this.bColumnSpanExists;
      },
      set: function(value) {
        this.bColumnSpanExists = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "rowMergeComplete", {
      /**
       * Check whether the Row `has row span or row merge continue`.
       * @private
       */
      get: function() {
        return this.isRowMergeComplete;
      },
      set: function(value) {
        this.isRowMergeComplete = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRow2.prototype, "rowIndex", {
      /**
       * Returns `index` of the row.
       * @private
       */
      get: function() {
        return this.grid.rows.rowCollection.indexOf(this);
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRow2.prototype.measureHeight = function() {
      var rowSpanRemainingHeight = 0;
      var rowHeight;
      var maxHeight = 0;
      if (this.cells.getCell(0).rowSpan > 1) {
        rowHeight = 0;
      } else {
        rowHeight = this.cells.getCell(0).height;
      }
      for (var i = 0; i < this.cells.count; i++) {
        var cell = this.cells.getCell(i);
        if (cell.rowSpanRemainingHeight > rowSpanRemainingHeight) {
          rowSpanRemainingHeight = cell.rowSpanRemainingHeight;
        }
        this.rowMergeComplete = false;
        if (cell.rowSpan > 1) {
          var cellIn = i;
          var rowin = this.isHeaderRow ? this.grid.headers.indexOf(this) : this.grid.rows.rowCollection.indexOf(this);
          for (var j = 0; j < cell.rowSpan; j++) {
            if (j + 1 < cell.rowSpan) {
              (this.isHeaderRow ? this.grid.headers.getHeader(rowin + j + 1) : this.grid.rows.getRow(rowin + j + 1)).cells.getCell(cellIn).hasRowSpan = true;
            }
          }
          if (maxHeight < cell.height) {
            maxHeight = cell.height;
          }
          continue;
        }
        rowHeight = Math.max(rowHeight, cell.height);
      }
      if (maxHeight > rowHeight) {
        rowHeight = maxHeight;
      }
      if (rowHeight === 0) {
        rowHeight = maxHeight;
      } else if (rowSpanRemainingHeight > 0) {
        rowHeight += rowSpanRemainingHeight;
      }
      return rowHeight;
    };
    PdfGridRow2.prototype.measureWidth = function() {
      var rowWid = 0;
      for (var i = 0; i < this.grid.columns.count; i++) {
        var column = this.grid.columns.getColumn(i);
        rowWid += column.width;
      }
      return rowWid;
    };
    return PdfGridRow2;
  })()
);
var PdfGridRowCollection = (
  /** @class */
  (function() {
    function PdfGridRowCollection2(grid) {
      this.rows = [];
      this.grid = grid;
    }
    Object.defineProperty(PdfGridRowCollection2.prototype, "count", {
      //Properties
      /**
       * Gets the number of header in the `PdfGrid`.[Read-Only].
       * @private
       */
      get: function() {
        return this.rows.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridRowCollection2.prototype, "rowCollection", {
      //Implementation
      /**
       * Return the row collection of the `grid`.
       * @private
       */
      get: function() {
        return this.rows;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridRowCollection2.prototype.addRow = function(arg) {
      if (typeof arg === "undefined") {
        var temprow = new PdfGridRow(this.grid);
        this.addRow(temprow);
        return temprow;
      } else {
        arg.style.setBackgroundBrush(this.grid.style.backgroundBrush);
        arg.style.setFont(this.grid.style.font);
        arg.style.setTextBrush(this.grid.style.textBrush);
        arg.style.setTextPen(this.grid.style.textPen);
        if (arg.cells.count === 0) {
          for (var i = 0; i < this.grid.columns.count; i++) {
            arg.cells.add(new PdfGridCell());
          }
        }
        this.rows.push(arg);
      }
    };
    PdfGridRowCollection2.prototype.getRow = function(index) {
      return this.rows[index];
    };
    return PdfGridRowCollection2;
  })()
);
var PdfGridHeaderCollection = (
  /** @class */
  (function() {
    function PdfGridHeaderCollection2(grid) {
      this.rows = [];
      this.grid = grid;
      this.rows = [];
    }
    PdfGridHeaderCollection2.prototype.getHeader = function(index) {
      return this.rows[index];
    };
    Object.defineProperty(PdfGridHeaderCollection2.prototype, "count", {
      /**
       * Gets the `number of header` in the 'PdfGrid'.[Read-Only]
       * @private
       */
      get: function() {
        return this.rows.length;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridHeaderCollection2.prototype.add = function(arg) {
      if (typeof arg === "number") {
        var row = void 0;
        for (var i = 0; i < arg; i++) {
          row = new PdfGridRow(this.grid);
          row.isHeaderRow = true;
          for (var j = 0; j < this.grid.columns.count; j++) {
            row.cells.add(new PdfGridCell());
          }
          this.rows.push(row);
        }
        return this.rows;
      } else {
        this.rows.push(arg);
      }
    };
    PdfGridHeaderCollection2.prototype.indexOf = function(row) {
      return this.rows.indexOf(row);
    };
    return PdfGridHeaderCollection2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/pdf-grid.js
var __extends55 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfGrid = (
  /** @class */
  (function(_super) {
    __extends55(PdfGrid2, _super);
    function PdfGrid2() {
      var _this = _super.call(this) || this;
      _this.gridSize = new SizeF(0, 0);
      _this.isGridSplit = false;
      _this.isRearranged = false;
      _this.pageBounds = new RectangleF();
      _this.listOfNavigatePages = [];
      _this.parentCellIndex = 0;
      _this.tempWidth = 0;
      _this.breakRow = true;
      _this.splitChildRowIndex = -1;
      _this.hasRowSpanSpan = false;
      _this.hasColumnSpan = false;
      _this.isSingleGrid = true;
      return _this;
    }
    Object.defineProperty(PdfGrid2.prototype, "raiseBeginCellDraw", {
      //Properties
      /**
       * Gets a value indicating whether the `start cell layout event` should be raised.
       * @private
       */
      get: function() {
        return typeof this.beginCellDraw !== "undefined" && typeof this.beginCellDraw !== null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "raiseEndCellDraw", {
      /**
       * Gets a value indicating whether the `end cell layout event` should be raised.
       * @private
       */
      get: function() {
        return typeof this.endCellDraw !== "undefined" && typeof this.endCellDraw !== null;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "repeatHeader", {
      /**
       * Gets or sets a value indicating whether to `repeat header`.
       * @private
       */
      get: function() {
        if (this.bRepeatHeader == null || typeof this.bRepeatHeader === "undefined") {
          this.bRepeatHeader = false;
        }
        return this.bRepeatHeader;
      },
      set: function(value) {
        this.bRepeatHeader = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "allowRowBreakAcrossPages", {
      /**
       * Gets or sets a value indicating whether to split or cut rows that `overflow a page`.
       * @private
       */
      get: function() {
        return this.breakRow;
      },
      set: function(value) {
        this.breakRow = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "columns", {
      /**
       * Gets the `column` collection of the PdfGrid.[Read-Only]
       * @private
       */
      get: function() {
        if (this.gridColumns == null || typeof this.gridColumns === "undefined") {
          this.gridColumns = new PdfGridColumnCollection(this);
        }
        return this.gridColumns;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "rows", {
      /**
       * Gets the `row` collection from the PdfGrid.[Read-Only]
       * @private
       */
      get: function() {
        if (this.gridRows == null) {
          this.gridRows = new PdfGridRowCollection(this);
        }
        return this.gridRows;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "headers", {
      /**
       * Gets the `headers` collection from the PdfGrid.[Read-Only]
       * @private
       */
      get: function() {
        if (this.gridHeaders == null || typeof this.gridHeaders === "undefined") {
          this.gridHeaders = new PdfGridHeaderCollection(this);
        }
        return this.gridHeaders;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "initialWidth", {
      /**
       * Indicating `initial width` of the page.
       * @private
       */
      get: function() {
        return this.gridInitialWidth;
      },
      set: function(value) {
        this.gridInitialWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "style", {
      /**
       * Gets or sets the `grid style`.
       * @private
       */
      get: function() {
        if (this.gridStyle == null) {
          this.gridStyle = new PdfGridStyle();
        }
        return this.gridStyle;
      },
      set: function(value) {
        if (this.gridStyle == null) {
          this.gridStyle = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "isPageWidth", {
      /**
       * Gets a value indicating whether the grid column width is considered to be `page width`.
       * @private
       */
      get: function() {
        return this.ispageWidth;
      },
      set: function(value) {
        this.ispageWidth = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "isChildGrid", {
      /**
       * Gets or set if grid `is nested grid`.
       * @private
       */
      get: function() {
        return this.ischildGrid;
      },
      set: function(value) {
        this.ischildGrid = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "size", {
      /**
       * Gets or set if grid ' is split or not'
       * @public
       */
      // public get isGridSplit() : boolean {
      //     return this.isgridSplit;
      // }
      // public set isGridSplit(value : boolean) {
      //     this.isgridSplit = value;
      // }public get isGridSplit() : boolean {
      //     return this.isgridSplit;
      // }
      // public set isGridSplit(value : boolean) {
      //     this.isgridSplit = value;
      // }
      /**
       * Gets the `size`.
       * @private
       */
      get: function() {
        if ((this.gridSize.width === 0 || typeof this.gridSize.width === "undefined") && this.gridSize.height === 0) {
          this.gridSize = this.measure();
        }
        return this.gridSize;
      },
      set: function(value) {
        this.gridSize = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "ParentCell", {
      get: function() {
        return this.parentCell;
      },
      set: function(value) {
        this.parentCell = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGrid2.prototype, "LayoutFormat", {
      get: function() {
        return this.layoutFormat;
      },
      enumerable: true,
      configurable: true
    });
    PdfGrid2.prototype.draw = function(arg1, arg2, arg3, arg4) {
      if (arg2 instanceof PointF && typeof arg2.width === "undefined" && typeof arg3 === "undefined") {
        return this.drawHelper(arg1, arg2.x, arg2.y);
      } else if (typeof arg2 === "number" && typeof arg3 === "number" && typeof arg4 === "undefined") {
        return this.drawHelper(arg1, arg2, arg3, null);
      } else if (arg2 instanceof RectangleF && typeof arg2.width !== "undefined" && typeof arg3 === "undefined") {
        return this.drawHelper(arg1, arg2, null);
      } else if (arg2 instanceof PointF && typeof arg2.width === "undefined" && arg3 instanceof PdfLayoutFormat) {
        return this.drawHelper(arg1, arg2.x, arg2.y, arg3);
      } else if (typeof arg2 === "number" && typeof arg3 === "number" && (arg4 instanceof PdfLayoutFormat || arg4 == null)) {
        var width = arg1.graphics.clientSize.width - arg2;
        var layoutRectangle = new RectangleF(arg2, arg3, width, 0);
        return this.drawHelper(arg1, layoutRectangle, arg4);
      } else if (arg2 instanceof RectangleF && typeof arg2.width !== "undefined" && typeof arg3 === "boolean") {
        return this.drawHelper(arg1, arg2, null);
      } else {
        return this.drawHelper(arg1, arg2, arg3);
      }
    };
    PdfGrid2.prototype.measure = function() {
      var height = 0;
      var width = this.columns.width;
      for (var i = 0; i < this.headers.count; i++) {
        var row = this.headers.getHeader(i);
        height += row.height;
      }
      for (var i = 0; i < this.rows.count; i++) {
        var row = this.rows.getRow(i);
        height += row.height;
      }
      return new SizeF(width, height);
    };
    PdfGrid2.prototype.onBeginCellDraw = function(args) {
      if (this.raiseBeginCellDraw) {
        this.beginCellDraw(this, args);
      }
    };
    PdfGrid2.prototype.onEndCellDraw = function(args) {
      if (this.raiseEndCellDraw) {
        this.endCellDraw(this, args);
      }
    };
    PdfGrid2.prototype.layout = function(param) {
      var width = param.bounds.width;
      var height = param.bounds.height;
      var hasChanged = false;
      if (typeof param.bounds.width === "undefined" || param.bounds.width === 0) {
        width = param.page.getClientSize().width - param.bounds.x;
        hasChanged = true;
      }
      if (typeof param.bounds.height === "undefined" || param.bounds.height === 0) {
        height = param.page.getClientSize().height;
        hasChanged = true;
      }
      if (hasChanged) {
        param.bounds = new RectangleF(param.bounds.x, param.bounds.y, width, height);
      }
      if (this.rows.count !== 0) {
        var currentRow = this.rows.getRow(0).cells.getCell(0).style;
        if (currentRow.borders != null && (currentRow.borders.left != null && currentRow.borders.left.width !== 1 || currentRow.borders.top != null && currentRow.borders.top.width !== 1)) {
          var x = currentRow.borders.left.width / 2;
          var y = currentRow.borders.top.width / 2;
          if (param.bounds.x === PdfBorders.default.right.width / 2 && param.bounds.y === PdfBorders.default.right.width / 2) {
            var newBound = new RectangleF(x, y, this.gridSize.width, this.gridSize.height);
            param.bounds = newBound;
          }
        }
      }
      this.setSpan();
      this.checkSpan();
      this.layoutFormat = param.format;
      this._gridLocation = param.bounds;
      var layouter = new PdfGridLayouter(this);
      var result = layouter.Layouter(param);
      return result;
    };
    PdfGrid2.prototype.setSpan = function() {
      var colSpan = 1;
      var rowSpan = 1;
      var currentCellIndex = 0;
      var currentRowIndex = 0;
      var maxSpan = 0;
      var rowCount = this.headers.count;
      for (var i = 0; i < rowCount; i++) {
        var row = this.headers.getHeader(i);
        maxSpan = 0;
        var colCount = row.cells.count;
        for (var j = 0; j < colCount; j++) {
          var cell = row.cells.getCell(j);
          maxSpan = Math.max(maxSpan, cell.rowSpan);
          if (!cell.isCellMergeContinue && !cell.isRowMergeContinue && (cell.columnSpan > 1 || cell.rowSpan > 1)) {
            if (cell.columnSpan + j > row.cells.count) {
              throw new Error("Invalid span specified at row " + j.toString() + " column " + i.toString());
            }
            if (cell.rowSpan + i > this.headers.count) {
              throw new Error("Invalid span specified at Header " + j.toString() + " column " + i.toString());
            }
            if (cell.columnSpan > 1 && cell.rowSpan > 1) {
              colSpan = cell.columnSpan;
              rowSpan = cell.rowSpan;
              currentCellIndex = j;
              currentRowIndex = i;
              cell.isCellMergeStart = true;
              cell.isRowMergeStart = true;
              while (colSpan > 1) {
                currentCellIndex++;
                row.cells.getCell(currentCellIndex).isCellMergeContinue = true;
                row.cells.getCell(currentCellIndex).isRowMergeContinue = true;
                row.cells.getCell(currentCellIndex).rowSpan = rowSpan;
                colSpan--;
              }
              currentCellIndex = j;
              colSpan = cell.columnSpan;
              while (rowSpan > 1) {
                currentRowIndex++;
                this.headers.getHeader(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;
                this.headers.getHeader(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;
                rowSpan--;
                while (colSpan > 1) {
                  currentCellIndex++;
                  this.headers.getHeader(currentRowIndex).cells.getCell(currentCellIndex).isCellMergeContinue = true;
                  this.headers.getHeader(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;
                  colSpan--;
                }
                colSpan = cell.columnSpan;
                currentCellIndex = j;
              }
            } else if (cell.columnSpan > 1 && cell.rowSpan === 1) {
              colSpan = cell.columnSpan;
              currentCellIndex = j;
              cell.isCellMergeStart = true;
              while (colSpan > 1) {
                currentCellIndex++;
                row.cells.getCell(currentCellIndex).isCellMergeContinue = true;
                colSpan--;
              }
            } else if (cell.columnSpan === 1 && cell.rowSpan > 1) {
              rowSpan = cell.rowSpan;
              currentRowIndex = i;
              while (rowSpan > 1) {
                currentRowIndex++;
                this.headers.getHeader(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;
                rowSpan--;
              }
            }
          }
        }
        row.maximumRowSpan = maxSpan;
      }
    };
    PdfGrid2.prototype.checkSpan = function() {
      var cellcolSpan;
      var cellrowSpan = 1;
      var cellmaxSpan = 0;
      var currentCellIndex;
      var currentRowIndex = 0;
      cellcolSpan = cellrowSpan = 1;
      currentCellIndex = currentRowIndex = 0;
      if (this.hasRowSpanSpan || this.hasColumnSpan) {
        var rowCount = this.rows.count;
        for (var i = 0; i < rowCount; i++) {
          var row = this.rows.getRow(i);
          cellmaxSpan = 0;
          var colCount = row.cells.count;
          for (var j = 0; j < colCount; j++) {
            var cell = row.cells.getCell(j);
            cellmaxSpan = Math.max(cellmaxSpan, cell.rowSpan);
            if (!cell.isCellMergeContinue && !cell.isRowMergeContinue && (cell.columnSpan > 1 || cell.rowSpan > 1)) {
              if (cell.columnSpan + j > row.cells.count) {
                throw new Error("Invalid span specified at row  " + j.toString() + " column " + i.toString());
              }
              if (cell.rowSpan + i > this.rows.count) {
                throw new Error("Invalid span specified at row  " + j.toString() + " column " + i.toString());
              }
              if (cell.columnSpan > 1 && cell.rowSpan > 1) {
                cellcolSpan = cell.columnSpan;
                cellrowSpan = cell.rowSpan;
                currentCellIndex = j;
                currentRowIndex = i;
                cell.isCellMergeStart = true;
                cell.isRowMergeStart = true;
                while (cellcolSpan > 1) {
                  currentCellIndex++;
                  row.cells.getCell(currentCellIndex).isCellMergeContinue = true;
                  row.cells.getCell(currentCellIndex).isRowMergeContinue = true;
                  cellcolSpan--;
                }
                currentCellIndex = j;
                cellcolSpan = cell.columnSpan;
                while (cellrowSpan > 1) {
                  currentRowIndex++;
                  this.rows.getRow(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;
                  this.rows.getRow(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;
                  cellrowSpan--;
                  while (cellcolSpan > 1) {
                    currentCellIndex++;
                    this.rows.getRow(currentRowIndex).cells.getCell(currentCellIndex).isCellMergeContinue = true;
                    this.rows.getRow(currentRowIndex).cells.getCell(currentCellIndex).isRowMergeContinue = true;
                    cellcolSpan--;
                  }
                  cellcolSpan = cell.columnSpan;
                  currentCellIndex = j;
                }
              } else if (cell.columnSpan > 1 && cell.rowSpan === 1) {
                cellcolSpan = cell.columnSpan;
                currentCellIndex = j;
                cell.isCellMergeStart = true;
                while (cellcolSpan > 1) {
                  currentCellIndex++;
                  row.cells.getCell(currentCellIndex).isCellMergeContinue = true;
                  cellcolSpan--;
                }
              } else if (cell.columnSpan === 1 && cell.rowSpan > 1) {
                cellrowSpan = cell.rowSpan;
                currentRowIndex = i;
                while (cellrowSpan > 1) {
                  currentRowIndex++;
                  this.rows.getRow(currentRowIndex).cells.getCell(j).isRowMergeContinue = true;
                  cellrowSpan--;
                }
              }
            }
          }
          row.maximumRowSpan = cellmaxSpan;
        }
      }
    };
    PdfGrid2.prototype.measureColumnsWidth = function(bounds) {
      if (typeof bounds !== "undefined") {
        this.isPageWidth = false;
        var widths = this.columns.getDefaultWidths(bounds.width - bounds.x);
        for (var i = 0, count = this.columns.count; i < count; i++) {
          this.columns.getColumn(i).columnWidth = widths[i];
          this.tempWidth = widths[i];
        }
        if (this.ParentCell != null && this.style.allowHorizontalOverflow == false && this.ParentCell.row.grid.style.allowHorizontalOverflow == false) {
          var padding = 0;
          var columnWidth = 0;
          var columnCount = this.columns.count;
          var childGridColumnWidth = 0;
          if (this.ParentCell.style.cellPadding != null || typeof this.ParentCell.style.cellPadding !== "undefined") {
            if (typeof this.ParentCell.style.cellPadding.left != "undefined" && this.ParentCell.style.cellPadding.hasLeftPad) {
              padding += this.ParentCell.style.cellPadding.left;
            }
            if (typeof this.ParentCell.style.cellPadding.right != "undefined" && this.ParentCell.style.cellPadding.hasRightPad) {
              padding += this.ParentCell.style.cellPadding.right;
            }
          }
          for (var i = 0; i < this.ParentCell.columnSpan; i++) {
            columnWidth += this.ParentCell.row.grid.columns.getColumn(this.parentCellIndex + i).width;
          }
          for (var j = 0; j < this.columns.count; j++) {
            if (this.gridColumns.getColumn(j).width > 0 && this.gridColumns.getColumn(j).isCustomWidth) {
              columnWidth -= this.gridColumns.getColumn(j).width;
              columnCount--;
            }
          }
          if (this.ParentCell.row.grid.style.cellPadding != null || typeof this.ParentCell.row.grid.style.cellPadding != "undefined") {
            if (typeof this.ParentCell.row.grid.style.cellPadding.top != "undefined" && this.ParentCell.row.grid.style.cellPadding.hasTopPad) {
              padding += this.ParentCell.row.grid.style.cellPadding.top;
            }
            if (typeof this.ParentCell.row.grid.style.cellPadding.bottom != "undefined" && this.ParentCell.row.grid.style.cellPadding.hasBottomPad) {
              padding += this.ParentCell.row.grid.style.cellPadding.bottom;
            }
          }
          if (this.ParentCell.row.grid.style.cellSpacing != 0) {
            columnWidth -= this.ParentCell.row.grid.style.cellSpacing * 2;
          }
          if (columnWidth > padding) {
            childGridColumnWidth = (columnWidth - padding) / columnCount;
            this.tempWidth = childGridColumnWidth;
            if (this.ParentCell != null) {
              for (var j = 0; j < this.columns.count; j++) {
                if (!this.columns.getColumn(j).isCustomWidth)
                  this.columns.getColumn(j).columnWidth = childGridColumnWidth;
              }
            }
          }
        }
      } else {
        var widths = [this.columns.count];
        for (var n = 0; n < this.columns.count; n++) {
          widths[n] = 0;
        }
        var cellWidth = 0;
        var cellWidths = 0;
        if (typeof this.isChildGrid === "undefined" && typeof this._gridLocation !== "undefined" || this.isChildGrid === null && typeof this._gridLocation !== "undefined") {
          this.initialWidth = this._gridLocation.width;
        }
        if (this.headers.count > 0) {
          var colCount_1 = this.headers.getHeader(0).cells.count;
          var rowCount = this.headers.count;
          for (var i = 0; i < colCount_1; i++) {
            cellWidth = 0;
            for (var j = 0; j < rowCount; j++) {
              var rowWidth = Math.min(this.initialWidth, this.headers.getHeader(j).cells.getCell(i).width);
              cellWidth = Math.max(cellWidth, rowWidth);
            }
            widths[i] = cellWidth;
          }
        }
        cellWidth = 0;
        for (var i = 0, colCount_2 = this.columns.count; i < colCount_2; i++) {
          for (var j = 0, rowCount = this.rows.count; j < rowCount; j++) {
            if (this.rows.getRow(j).cells.getCell(i).columnSpan == 1 && !this.rows.getRow(j).cells.getCell(i).isCellMergeContinue || this.rows.getRow(j).cells.getCell(i).value != null) {
              if (this.rows.getRow(j).cells.getCell(i).value != null && !this.rows.getRow(j).grid.style.allowHorizontalOverflow) {
                var value = this.rows.getRow(j).grid.style.cellPadding.right + this.rows.getRow(j).grid.style.cellPadding.left + this.rows.getRow(j).cells.getCell(i).style.borders.left.width / 2;
              }
              var rowWidth = 0;
              rowWidth = this.initialWidth > 0 ? Math.min(this.initialWidth, this.rows.getRow(j).cells.getCell(i).width) : this.rows.getRow(j).cells.getCell(i).width;
              cellWidth = Math.max(widths[i], Math.max(cellWidth, rowWidth));
              cellWidth = Math.max(this.columns.getColumn(i).width, cellWidth);
            }
          }
          if (this.rows.count != 0)
            widths[i] = cellWidth;
          cellWidth = 0;
        }
        for (var i = 0, RowCount = this.rows.count; i < RowCount; i++) {
          for (var j = 0, ColCount = this.columns.count; j < ColCount; j++) {
            if (this.rows.getRow(i).cells.getCell(j).columnSpan > 1) {
              var total = widths[j];
              for (var k = 1; k < this.rows.getRow(i).cells.getCell(j).columnSpan; k++) {
                total += widths[j + k];
              }
            }
          }
        }
        for (var i = 0, count = this.columns.count; i < count; i++) {
          if (this.columns.getColumn(i).width <= 0)
            this.columns.getColumn(i).columnWidth = widths[i];
          else if (this.columns.getColumn(i).width > 0 && !this.columns.getColumn(i).isCustomWidth)
            this.columns.getColumn(i).columnWidth = widths[i];
        }
        var padding = 0;
        var colWidth = 0;
        var colCount = this.columns.count;
        var childGridColWidth = 0;
        colWidth = this.tempWidth;
        for (var j = 0; j < this.columns.count; j++) {
          if (this.gridColumns.getColumn(j).width > 0 && this.gridColumns.getColumn(j).isCustomWidth) {
            colWidth -= this.gridColumns.getColumn(j).width;
            colCount--;
          }
        }
        if (colWidth > 0) {
          if (this.ParentCell.row.grid.style.cellSpacing != 0) {
            colWidth -= this.ParentCell.row.grid.style.cellSpacing * 2;
          }
        }
        if (colWidth > padding) {
          childGridColWidth = colWidth / colCount;
          if (this.ParentCell != null) {
            for (var j = 0; j < this.columns.count; j++) {
              if (!this.columns.getColumn(j).isCustomWidth)
                this.columns.getColumn(j).columnWidth = childGridColWidth;
            }
          }
        }
      }
    };
    return PdfGrid2;
  })(PdfLayoutElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/structured-elements/grid/layout/grid-layouter.js
var __extends56 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfGridLayouter = (
  /** @class */
  (function(_super) {
    __extends56(PdfGridLayouter2, _super);
    function PdfGridLayouter2(baseFormat) {
      var _this = _super.call(this, baseFormat) || this;
      _this.gridInitialWidth = 0;
      _this.gridSize = new SizeF(0, 0);
      _this.parentCellIndex = 0;
      _this.tempWidth = 0;
      _this.childheight = 0;
      _this.isChildGrid = false;
      _this.hasRowSpanSpan = false;
      _this.isRearranged = false;
      _this.pageBounds = new RectangleF();
      _this.listOfNavigatePages = [];
      _this.flag = true;
      _this.columnRanges = [];
      _this.currentLocation = new PointF(0, 0);
      _this.breakRow = true;
      _this.slr = null;
      _this.remainderText = null;
      _this.isPaginate = false;
      _this.isOverloadWithPosition = false;
      return _this;
    }
    Object.defineProperty(PdfGridLayouter2.prototype, "Grid", {
      //Properties
      get: function() {
        return this.elements;
      },
      enumerable: true,
      configurable: true
    });
    PdfGridLayouter2.prototype.getFormat = function(format) {
      var f = format;
      return f;
    };
    PdfGridLayouter2.prototype.layoutInternal = function(param) {
      var format = this.getFormat(param.format);
      this.gridLayoutFormat = this.getFormat(param.format);
      this.currentPage = param.page;
      if (this.currentPage !== null) {
        var pageHeight = this.currentPage.getClientSize().height;
        var pageWidth = this.currentPage.getClientSize().width;
        this.currentPageBounds = this.currentPage.getClientSize();
      } else {
        throw Error("Can not set page as null");
      }
      this.currentGraphics = this.currentPage.graphics;
      var index = 0;
      index = this.currentGraphics.page.section.indexOf(this.currentGraphics.page);
      this.listOfNavigatePages.push(index);
      if (format != null && format.break === PdfLayoutBreakType.FitColumnsToPage) {
        this.currentBounds = new RectangleF(new PointF(param.bounds.x, param.bounds.y), new SizeF(this.Grid.columns.width, this.currentGraphics.clientSize.height));
      } else {
        this.currentBounds = new RectangleF(new PointF(param.bounds.x, param.bounds.y), this.currentGraphics.clientSize);
      }
      if (this.Grid.rows.count !== 0) {
        this.currentBounds.width = param.bounds.width > 0 ? param.bounds.width : this.currentBounds.width - this.Grid.rows.getRow(0).cells.getCell(0).style.borders.left.width / 2;
      } else if (this.Grid.headers.count !== 0) {
        this.currentBounds.width = param.bounds.width;
      } else {
        throw Error("Please add row or header into grid");
      }
      this.startLocation = new PointF(param.bounds.x, param.bounds.y);
      if (param.bounds.height > 0 && !this.Grid.isChildGrid) {
        this.currentBounds.height = param.bounds.height;
      }
      if (!this.Grid.isChildGrid) {
        this.hType = this.Grid.style.horizontalOverflowType;
      }
      if (!this.Grid.style.allowHorizontalOverflow) {
        this.columnRanges = [];
        if (typeof this.Grid.isChildGrid !== "undefined" && typeof this.Grid.isChildGrid) {
          this.Grid.measureColumnsWidth(this.currentBounds);
        } else {
          this.Grid.measureColumnsWidth(new RectangleF(this.currentBounds.x, this.currentBounds.y, this.currentBounds.x + this.currentBounds.width, this.currentBounds.height));
        }
        this.columnRanges.push([0, this.Grid.columns.count - 1]);
      } else {
        this.Grid.measureColumnsWidth();
        this.determineColumnDrawRanges();
      }
      if (this.Grid.hasRowSpanSpan) {
        for (var i = 0; i < this.Grid.rows.count; i++) {
          if (this.Grid.rows.getRow(i).height !== -1 && !this.Grid.rows.getRow(i).isRowHeightSet) {
            this.Grid.rows.getRow(i).isRowHeightSet = true;
          }
        }
      }
      var result = this.layoutOnPage(param);
      return result;
    };
    PdfGridLayouter2.prototype.determineColumnDrawRanges = function() {
      var startColumn = 0;
      var endColumn = 0;
      var cellWidths = 0;
      var availableWidth = this.currentGraphics.clientSize.width - this.currentBounds.x;
      for (var i = 0; i < this.Grid.columns.count; i++) {
        cellWidths += this.Grid.columns.getColumn(i).width;
        if (cellWidths >= availableWidth) {
          var subWidths = 0;
          for (var j = startColumn; j <= i; j++) {
            subWidths += this.Grid.columns.getColumn(j).width;
            if (subWidths > availableWidth) {
              break;
            }
            endColumn = j;
          }
          this.columnRanges.push([startColumn, endColumn]);
          startColumn = endColumn + 1;
          endColumn = startColumn;
          cellWidths = endColumn <= i ? this.Grid.columns.getColumn(i).width : 0;
        }
      }
      this.columnRanges.push([startColumn, this.Grid.columns.count - 1]);
    };
    PdfGridLayouter2.prototype.layoutOnPage = function(param) {
      this.pageBounds.x = param.bounds.x;
      this.pageBounds.y = param.bounds.y;
      this.pageBounds.height = param.bounds.height;
      var format = this.getFormat(param.format);
      var endArgs = null;
      var result = null;
      var layoutedPages = new TemporaryDictionary();
      var startPage = param.page;
      var isParentCell = false;
      var cellBounds = [];
      for (var index = 0; index < this.columnRanges.length; index++) {
        var range = this.columnRanges[index];
        this.cellStartIndex = range[0];
        this.cellEndIndex = range[1];
        var returnObject = this.raiseBeforePageLayout(this.currentPage, this.currentBounds, this.currentRowIndex);
        this.currentBounds = returnObject.currentBounds;
        this.currentRowIndex = returnObject.currentRowIndex;
        var drawHeader = void 0;
        for (var i_1 = 0; i_1 < this.Grid.headers.count; i_1++) {
          var row = this.Grid.headers.getHeader(i_1);
          var headerHeight = this.currentBounds.y;
          this.isHeader = true;
          if (startPage != this.currentPage) {
            for (var k = this.cellStartIndex; k <= this.cellEndIndex; k++) {
              if (row.cells.getCell(k).isCellMergeContinue) {
                row.cells.getCell(k).isCellMergeContinue = false;
                row.cells.getCell(k).value = "";
              }
            }
          }
          var headerResult = this.drawRow(row);
          if (headerHeight === this.currentBounds.y) {
            drawHeader = true;
            if (PdfGridLayouter2.repeatRowIndex === -1) {
              PdfGridLayouter2.repeatRowIndex = i_1;
            }
          } else {
            drawHeader = false;
          }
          if (!headerResult.isFinish && startPage !== null && format.layout !== PdfLayoutType.OnePage && drawHeader) {
            this.startLocation.x = this.currentBounds.x;
            this.currentPage = this.getNextPageformat(format);
            this.startLocation.y = this.currentBounds.y;
            if (typeof format.paginateBounds !== "undefined" && format.paginateBounds.x === 0 && format.paginateBounds.y === 0 && format.paginateBounds.width === 0 && format.paginateBounds.height === 0)
              this.currentBounds.x += this.startLocation.x;
            this.drawRow(row);
          }
          this.isHeader = false;
        }
        var i = 0;
        var length_1 = this.Grid.rows.count;
        var repeatRow = void 0;
        var startingHeight = 0;
        var flag = true;
        cellBounds = [];
        for (var j = 0; j < this.Grid.rows.count; j++) {
          var row = this.Grid.rows.getRow(j);
          i++;
          this.currentRowIndex = i - 1;
          var originalHeight = this.currentBounds.y;
          startPage = this.currentPage;
          PdfGridLayouter2.repeatRowIndex = -1;
          if (flag && row.grid.isChildGrid) {
            startingHeight = originalHeight;
            flag = false;
          }
          var rowResult = null;
          if (this.Grid.splitChildRowIndex == -1) {
            rowResult = this.drawRow(row);
            row.isrowFinish = true;
          } else {
            if (row.grid.ParentCell.row.grid.isGridSplit && this.Grid.splitChildRowIndex <= row.rowIndex) {
              rowResult = this.drawRow(row);
              row.isrowFinish = true;
            } else if (row.isrowFinish) {
              continue;
            } else {
              break;
            }
          }
          cellBounds.push(rowResult.bounds.width);
          if (originalHeight === this.currentBounds.y) {
            repeatRow = true;
            PdfGridLayouter2.repeatRowIndex = this.Grid.rows.rowCollection.indexOf(row);
          } else {
            repeatRow = false;
            PdfGridLayouter2.repeatRowIndex = -1;
          }
          while (!rowResult.isFinish && startPage != null) {
            var tempResult = this.getLayoutResult();
            endArgs = this.raisePageLayouted(tempResult);
            if (endArgs.cancel || repeatRow)
              break;
            else if (this.Grid.allowRowBreakAcrossPages) {
              this.currentPage = this.getNextPageformat(format);
              originalHeight = this.currentBounds.y;
              var location_1 = new PointF(PdfBorders.default.right.width / 2, PdfBorders.default.top.width / 2);
              if (format.paginateBounds.x === 0 && format.paginateBounds.y === 0 && format.paginateBounds.width === 0 && format.paginateBounds.height === 0 && (this.startLocation.x === location_1.x && this.startLocation.y === location_1.y)) {
                this.currentBounds.x += this.startLocation.x;
                this.currentBounds.y += this.startLocation.y;
              }
              if (this.isPaginate) {
                this.startLocation.y = this.currentBounds.y;
                this.isPaginate = false;
              }
              if (this.Grid.isChildGrid && row.grid.ParentCell != null) {
                if (this.Grid.ParentCell.row.grid.style.cellPadding != null) {
                  if (row.rowBreakHeight + this.Grid.ParentCell.row.grid.style.cellPadding.top < this.currentBounds.height) {
                    this.currentBounds.y = this.Grid.ParentCell.row.grid.style.cellPadding.top;
                  }
                }
              }
              if (row.grid.ParentCell != null) {
                row.grid.ParentCell.row.isRowBreaksNextPage = true;
                row.grid.ParentCell.row.rowBreakHeightValue = row.rowBreakHeight + this.Grid.ParentCell.row.grid.style.cellPadding.top + this.Grid.ParentCell.row.grid.style.cellPadding.bottom;
                for (var i_2 = row.rowIndex + 1; i_2 < row.grid.rows.count; i_2++) {
                  row.grid.ParentCell.row.rowBreakHeightValue += row.grid.rows.getRow(i_2).height;
                }
              }
              if (row.grid.isChildGrid) {
                row.isrowFinish = false;
                row.grid.splitChildRowIndex = row.rowIndex;
                row.grid.ParentCell.row.grid.splitChildRowIndex = row.grid.ParentCell.row.rowIndex;
                if (row.grid.ParentCell.row.grid.isGridSplit) {
                  row.grid.ParentCell.row.noOfPageCount += 1;
                  row.grid.ParentCell.row.grid.isGridSplit = false;
                }
                break;
              }
              if (row.noOfPageCount < 1) {
                if (row.grid.splitChildRowIndex != -1) {
                  row.grid.isGridSplit = true;
                }
                if (row.style.border != null && (row.style.border.left != null && row.style.border.left.width !== 1 || row.style.border.top != null && row.style.border.top.width !== 1)) {
                  var x = row.style.border.left.width / 2;
                  var y = row.style.border.top.width / 2;
                  if (this.currentBounds.x === PdfBorders.default.right.width / 2 && this.currentBounds.y === PdfBorders.default.right.width / 2) {
                    var newBound = new RectangleF(x, y, this.currentBounds.width, this.currentBounds.height);
                    this.currentBounds = newBound;
                  }
                }
                if (this.Grid.repeatHeader) {
                  for (var j_1 = 0; j_1 < this.Grid.headers.count; j_1++) {
                    var headerRepeat = this.Grid.headers.getHeader(j_1);
                    this.drawRow(headerRepeat);
                  }
                }
                rowResult = this.drawRow(row);
                if (row.noOfPageCount >= 1) {
                  var temp = row.rowBreakHeightValue;
                  for (var j_2 = 0; j_2 < row.noOfPageCount; j_2++) {
                    var tempResult1 = this.getLayoutResult();
                    endArgs = this.raisePageLayouted(tempResult1);
                    this.currentPage = this.getNextPageformat(format);
                    originalHeight = this.currentBounds.y;
                    if (row.grid.splitChildRowIndex != -1) {
                      row.grid.isGridSplit = true;
                    }
                    this.currentBounds.y = 0.5;
                    if (this.Grid.repeatHeader) {
                      for (var i_3 = 0; i_3 < this.Grid.headers.count; i_3++) {
                        var header = this.Grid.headers.getHeader(i_3);
                        this.drawRow(header);
                      }
                    }
                    this.drawRow(row);
                  }
                }
                row.grid.splitChildRowIndex = -1;
                row.grid.isGridSplit = false;
                rowResult.isFinish = this.checkIsFisished(row);
                for (var i_4 = 0; i_4 < row.cells.count; i_4++) {
                  if (row.cells.getCell(i_4).value instanceof PdfGrid) {
                    row.cells.getCell(i_4).value.splitChildRowIndex = -1;
                  }
                }
              }
            }
          }
          if (!rowResult.isFinish && startPage !== null && format.layout !== PdfLayoutType.OnePage && repeatRow) {
            this.startLocation.x = this.currentBounds.x;
            var isAddNextPage = false;
            this.currentPage = this.getNextPageformat(format);
            if (this.raiseBeforePageLayout(this.currentPage, this.currentBounds, this.currentRowIndex).returnValue) {
              break;
            }
            if (param.format !== null && !param.format.usePaginateBounds && param.bounds !== null && param.bounds.height > 0 && !this.Grid.isChildGrid) {
              this.currentBounds.height = param.bounds.height;
            }
            if (typeof param.format !== "undefined" && param.format != null && typeof param.format.usePaginateBounds !== "undefined" && !param.format.usePaginateBounds && !(param.format.paginateBounds.x === 0 && param.format.paginateBounds.y === 0 && param.format.paginateBounds.width === 0 && param.format.paginateBounds.height === 0) && param.format.paginateBounds.y === 0) {
              this.currentBounds.y = PdfBorders.default.top.width / 2;
            } else {
              this.currentBounds.y = format == null ? 0 : format.paginateBounds.y;
              if (format != null && (format.paginateBounds.x !== 0 || format.paginateBounds.y !== 0 || format.paginateBounds.height !== 0 || format.paginateBounds.width !== 0)) {
                this.currentBounds.x = format.paginateBounds.x;
                this.currentBounds.width = format.paginateBounds.width;
                this.currentBounds.height = format.paginateBounds.height;
              }
            }
            if (typeof param.format !== "undefined" && param.format !== null && typeof param.format.usePaginateBounds !== "undefined" && !param.format.usePaginateBounds && param.bounds !== null && param.bounds.y > 0 && !this.Grid.isChildGrid) {
              this.currentBounds.y = param.bounds.y;
            }
            this.startLocation.y = this.currentBounds.y;
            if (format.paginateBounds.x === format.paginateBounds.y && format.paginateBounds.y === format.paginateBounds.height && format.paginateBounds.height === format.paginateBounds.width && format.paginateBounds.width === 0) {
              this.currentBounds.x += this.startLocation.x;
            }
            if (this.currentBounds.x === PdfBorders.default.left.width / 2) {
              this.currentBounds.y += this.startLocation.x;
            }
            if (this.Grid.repeatHeader) {
              for (var i_5 = 0; i_5 < this.Grid.headers.count; i_5++) {
                var header = this.Grid.headers.getHeader(i_5);
                this.drawRow(header);
              }
            }
            this.drawRow(row);
            if (this.currentPage !== null && !layoutedPages.containsKey(this.currentPage)) {
              layoutedPages.add(this.currentPage, range);
            }
          }
          if (row.NestedGridLayoutResult != null) {
            this.currentPage = row.NestedGridLayoutResult.page;
            this.currentGraphics = this.currentPage.graphics;
            this.startLocation = new PointF(row.NestedGridLayoutResult.bounds.x, row.NestedGridLayoutResult.bounds.y);
            var recalHeight = this.ReCalculateHeight(row, row.NestedGridLayoutResult.bounds.height);
            this.currentBounds.y = recalHeight;
            if (startPage != this.currentPage) {
              var section = this.currentPage.section;
              var startIndex = section.indexOf(startPage) + 1;
              var endIndex = section.indexOf(this.currentPage);
              for (var page = startIndex; page < endIndex + 1; page++) {
                var pageGraphics = section.getPages()[page].graphics;
                var location_2 = new PointF(format.paginateBounds.x, format.paginateBounds.y);
                var height = page == endIndex ? row.NestedGridLayoutResult.bounds.height - param.bounds.y : this.currentBounds.height - location_2.y;
                if (height <= pageGraphics.clientSize.height)
                  height += param.bounds.y;
                location_2.y = format == null ? 0.5 : format.paginateBounds.y;
                for (var c = 0; c < row.cells.count; c++) {
                  var cell = row.cells.getCell(c);
                  var cellWidth = 0;
                  var totalwidth = 0;
                  var childGridCell = void 0;
                  if (cell.value instanceof PdfGrid) {
                    if (!childGridCell) {
                      childGridCell = cell;
                    }
                    for (var i_6 = 0; i_6 < cell.value.columns.count; i_6++) {
                      totalwidth += cell.value.columns.getColumn(i_6).columnWidth;
                    }
                  } else {
                    totalwidth = cell.width;
                  }
                  if (cell.columnSpan > 1) {
                    for (; c < cell.columnSpan; c++)
                      cellWidth += row.grid.columns.getColumn(c).width;
                  } else
                    cellWidth = Math.max(totalwidth, row.grid.columns.getColumn(c).width);
                  var bottomPadding = void 0;
                  if (childGridCell && childGridCell.style && childGridCell.style.cellPadding) {
                    bottomPadding = childGridCell.style.cellPadding.bottom;
                  } else {
                    bottomPadding = this.Grid.style.cellPadding.bottom;
                  }
                  if (typeof bottomPadding === "number" && height + bottomPadding < pageGraphics.clientSize.height) {
                    height += bottomPadding;
                    this.currentBounds.y += bottomPadding;
                  }
                  cell.drawCellBorders(pageGraphics, new RectangleF(location_2, new SizeF(cellWidth, height)));
                  var rowWidth = this.Grid.rows.getRow(this.Grid.rows.count - 1).width;
                  if (cellWidth !== rowWidth) {
                    cell.drawCellBorders(pageGraphics, new RectangleF(location_2, new SizeF(rowWidth, height)));
                  }
                  location_2.x += cellWidth;
                  c += cell.columnSpan - 1;
                }
              }
              startPage = this.currentPage;
            }
          }
        }
        var isPdfGrid = false;
        var maximumCellBoundsWidth = 0;
        if (cellBounds.length > 0) {
          maximumCellBoundsWidth = cellBounds[0];
        }
        var largeNavigatePage = [[1, 2]];
        for (var c = 0; c < this.Grid.rows.count; c++) {
          if (this.cellEndIndex != -1 && this.Grid.rows.getRow(c).cells.getCell(this.cellEndIndex).value instanceof PdfGrid) {
            var grid = this.Grid.rows.getRow(c).cells.getCell(this.cellEndIndex).value;
            this.rowLayoutBoundsWidth = grid.rowLayoutBoundsWidth;
            isPdfGrid = true;
          }
        }
        if (!isPdfGrid && cellBounds.length > 0) {
          for (var c = 0; c < i - 1; c++) {
            if (maximumCellBoundsWidth < cellBounds[c]) {
              maximumCellBoundsWidth = cellBounds[c];
            }
          }
          this.rowLayoutBoundsWidth = maximumCellBoundsWidth;
        } else {
          this.rowLayoutBoundsWidth = largeNavigatePage[0][1];
        }
        if (this.columnRanges.indexOf(range) < this.columnRanges.length - 1 && startPage != null && format.layout != PdfLayoutType.OnePage) {
          isParentCell = this.Grid.isChildGrid;
          if (largeNavigatePage[0][0] != 0) {
            var section = this.currentPage.section;
            var pageIndex = section.indexOf(this.currentPage);
            this.currentGraphics = this.currentPage.graphics;
            this.currentBounds = new RectangleF(new PointF(0, 0), this.currentPage.getClientSize());
            var pageindex = this.currentGraphics.page.section.indexOf(this.currentGraphics.page);
          } else {
            this.currentPage = this.getNextPageformat(format);
          }
        }
        if (this.columnRanges.length - 1 !== index && this.columnRanges.length > 1 && format.layout !== PdfLayoutType.OnePage) {
          this.currentPage = this.getNextPageformat(format);
          if (format.paginateBounds.x === format.paginateBounds.y && format.paginateBounds.y === format.paginateBounds.height && format.paginateBounds.height === format.paginateBounds.width && format.paginateBounds.width === 0) {
            this.currentBounds.x += this.startLocation.x;
            this.currentBounds.y += this.startLocation.y;
          }
        }
      }
      result = this.getLayoutResult();
      if (this.Grid.style.allowHorizontalOverflow && this.Grid.style.horizontalOverflowType == PdfHorizontalOverflowType.NextPage) {
        this.reArrangePages(layoutedPages);
      }
      this.raisePageLayouted(result);
      return result;
    };
    PdfGridLayouter2.prototype.checkIsFisished = function(row) {
      var result = true;
      for (var i = 0; i < row.cells.count; i++) {
        if (!row.cells.getCell(i).FinishedDrawingCell) {
          result = false;
        }
      }
      return result;
    };
    PdfGridLayouter2.prototype.getNextPageformat = function(format) {
      var section = this.currentPage.section;
      var nextPage = null;
      var index = section.indexOf(this.currentPage);
      this.flag = false;
      if (index === section.count - 1) {
        nextPage = section.add();
      } else {
        nextPage = section.getPages()[index + 1];
      }
      this.currentGraphics = nextPage.graphics;
      var pageindex = this.currentGraphics.page.section.indexOf(this.currentGraphics.page);
      if (!(this.listOfNavigatePages.indexOf(pageindex) !== -1)) {
        this.listOfNavigatePages.push(pageindex);
      }
      this.currentBounds = new RectangleF(new PointF(0, 0), nextPage.getClientSize());
      if (typeof format !== "undefined" && format != null && format.usePaginateBounds && typeof format.paginateBounds !== "undefined" && format.paginateBounds != null && format.paginateBounds.x !== format.paginateBounds.y && format.paginateBounds.y !== format.paginateBounds.height && format.paginateBounds.height !== format.paginateBounds.width && format.paginateBounds.width !== 0) {
        this.currentBounds.x = format.paginateBounds.x;
        this.currentBounds.y = format.paginateBounds.y;
        this.currentBounds.height = format.paginateBounds.height;
      }
      return nextPage;
    };
    PdfGridLayouter2.prototype.CheckIfDefaultFormat = function(format) {
      var defaultFormat = new PdfStringFormat();
      return format.alignment === defaultFormat.alignment && format.characterSpacing === defaultFormat.characterSpacing && format.clipPath === defaultFormat.clipPath && format.firstLineIndent === defaultFormat.firstLineIndent && format.horizontalScalingFactor === defaultFormat.horizontalScalingFactor && format.lineAlignment === defaultFormat.lineAlignment && format.lineLimit === defaultFormat.lineLimit && format.lineSpacing === defaultFormat.lineSpacing && format.measureTrailingSpaces === defaultFormat.measureTrailingSpaces && format.noClip === defaultFormat.noClip && format.paragraphIndent === defaultFormat.paragraphIndent && format.rightToLeft === defaultFormat.rightToLeft && format.subSuperScript === defaultFormat.subSuperScript && format.wordSpacing === defaultFormat.wordSpacing && format.wordWrap === defaultFormat.wordWrap;
    };
    PdfGridLayouter2.prototype.RaiseBeforeCellDraw = function(graphics, rowIndex, cellIndex, bounds, value, style) {
      var args = null;
      if (this.Grid.raiseBeginCellDraw) {
        args = new PdfGridBeginCellDrawEventArgs(graphics, rowIndex, cellIndex, bounds, value, style);
        this.Grid.onBeginCellDraw(args);
        style = args.style;
      }
      return style;
    };
    PdfGridLayouter2.prototype.raiseAfterCellDraw = function(graphics, rowIndex, cellIndex, bounds, value, cellstyle) {
      var args = null;
      if (this.Grid.raiseEndCellDraw) {
        args = new PdfGridEndCellDrawEventArgs(graphics, rowIndex, cellIndex, bounds, value, cellstyle);
        this.Grid.onEndCellDraw(args);
      }
    };
    PdfGridLayouter2.prototype.reArrangePages = function(layoutedPages) {
      var document2 = this.currentPage.document;
      var pages = [];
      var keys2 = layoutedPages.keys();
      var values = layoutedPages.values();
      for (var i = 0; i < keys2.length; i++) {
        var page = keys2[i];
        page.section = null;
        pages.push(page);
        document2.pages.remove(page);
      }
      for (var i = 0; i < layoutedPages.size(); i++) {
        var count = 0;
        for (var j = i, count_1 = layoutedPages.size() / this.columnRanges.length; j < layoutedPages.size(); j += count_1) {
          var page = pages[j];
          if (typeof page !== "undefined" && document2.pages.indexOf(page) === -1) {
            document2.pages.add(page);
          }
        }
      }
    };
    PdfGridLayouter2.prototype.getLayoutResult = function() {
      if (this.Grid.isChildGrid && this.Grid.allowRowBreakAcrossPages) {
        for (var i = 0; i < this.Grid.rows.count; i++) {
          var row = this.Grid.rows.getRow(i);
          if (row.rowBreakHeight > 0 && row.repeatFlag) {
            this.startLocation.y = this.currentPage.origin.y;
          }
        }
      }
      var bounds;
      if (!this.isChanged) {
        bounds = new RectangleF(this.startLocation, new SizeF(this.currentBounds.width, this.currentBounds.y - this.startLocation.y));
      }
      return new PdfGridLayoutResult(this.currentPage, bounds);
    };
    PdfGridLayouter2.prototype.ReCalculateHeight = function(row, height) {
      var newHeight = 0;
      for (var i = this.cellStartIndex; i <= this.cellEndIndex; i++) {
        if (!(row.cells.getCell(i).remainingString === null || row.cells.getCell(i).remainingString === "" || typeof row.cells.getCell(i).remainingString === "undefined")) {
          newHeight = Math.max(newHeight, row.cells.getCell(i).measureHeight());
        }
      }
      return Math.max(height, newHeight);
    };
    PdfGridLayouter2.prototype.raiseBeforePageLayout = function(currentPage, currentBounds, currentRow) {
      var cancel = false;
      if (this.Grid.raiseBeginPageLayout) {
        var args = new PdfGridBeginPageLayoutEventArgs(currentBounds, currentPage, currentRow);
        this.Grid.onBeginPageLayout(args);
        cancel = typeof args.cancel === "undefined" ? false : args.cancel;
        currentBounds = args.bounds;
        currentRow = args.startRowIndex;
      }
      return { returnValue: cancel, currentBounds, currentRowIndex: currentRow };
    };
    PdfGridLayouter2.prototype.raisePageLayouted = function(result) {
      var args = new PdfGridEndPageLayoutEventArgs(result);
      if (this.Grid.raiseEndPageLayout) {
        this.Grid.onEndPageLayout(args);
      }
      return args;
    };
    PdfGridLayouter2.prototype.drawRow = function(row, result, height) {
      if (typeof result === "undefined") {
        var result_1 = new RowLayoutResult();
        var rowHeightWithSpan = 0;
        var location_3 = new PointF(0, 0);
        var size = new SizeF(0, 0);
        var isHeader = false;
        var allowRowBreak = true;
        if (row.rowSpanExists) {
          var maxSpan = 0;
          var currRowIndex = this.Grid.rows.rowCollection.indexOf(row);
          if (currRowIndex === -1) {
            currRowIndex = this.Grid.headers.indexOf(row);
            if (currRowIndex !== -1) {
              isHeader = true;
            }
          }
          for (var i = 0; i < row.cells.count; i++) {
            var cell = row.cells.getCell(i);
            maxSpan = Math.max(maxSpan, cell.rowSpan);
          }
          for (var i = currRowIndex; i < currRowIndex + maxSpan; i++) {
            rowHeightWithSpan += isHeader ? this.Grid.headers.getHeader(i).height : this.Grid.rows.getRow(i).height;
          }
          if (rowHeightWithSpan > this.currentBounds.height || rowHeightWithSpan + this.currentBounds.y > this.currentBounds.height) {
            if (row.rowSpanExists && (this.Grid.LayoutFormat.break === PdfLayoutBreakType.FitElement || !this.Grid.allowRowBreakAcrossPages)) {
              allowRowBreak = false;
            }
          }
          if ((rowHeightWithSpan > this.currentBounds.height || rowHeightWithSpan + this.currentBounds.y > this.currentBounds.height) && allowRowBreak) {
            rowHeightWithSpan = 0;
            row.isPageBreakRowSpanApplied = true;
            for (var i = 0; i < row.cells.count; i++) {
              var cell = row.cells.getCell(i);
              maxSpan = cell.rowSpan;
              for (var i_7 = currRowIndex; i_7 < currRowIndex + maxSpan; i_7++) {
                rowHeightWithSpan += isHeader ? this.Grid.headers.getHeader(i_7).height : this.Grid.rows.getRow(i_7).height;
                var layoutFormat = this.Grid.LayoutFormat;
                var currentBoundsHeight = this.currentPageBounds.height;
                if (layoutFormat.usePaginateBounds && layoutFormat.paginateBounds && layoutFormat.paginateBounds.height > 0) {
                  var bottom = layoutFormat.paginateBounds.y + layoutFormat.paginateBounds.height;
                  if (!this.Grid.isChildGrid && this.Grid.listOfNavigatePages.length === 1) {
                    bottom += this.Grid._gridLocation.y;
                  }
                  if (bottom < currentBoundsHeight) {
                    currentBoundsHeight = bottom;
                    this.currentPageBounds.height = currentBoundsHeight;
                    this.currentBounds.height = currentBoundsHeight;
                  }
                }
                if (this.currentBounds.y + rowHeightWithSpan > currentBoundsHeight) {
                  rowHeightWithSpan -= isHeader ? this.Grid.headers.getHeader(i_7).height : this.Grid.rows.getRow(i_7).height;
                  for (var j = 0; j < this.Grid.rows.getRow(currRowIndex).cells.count; j++) {
                    var newSpan = i_7 - currRowIndex;
                    if (!isHeader && this.Grid.rows.getRow(currRowIndex).cells.getCell(j).rowSpan === maxSpan && newSpan !== 0) {
                      var currCell = this.Grid.rows.getRow(currRowIndex).cells.getCell(j);
                      var nextCell = this.Grid.rows.getRow(i_7).cells.getCell(j);
                      currCell.rowSpan = newSpan === 0 ? 1 : newSpan;
                      this.Grid.rows.getRow(currRowIndex).maximumRowSpan = newSpan === 0 ? 1 : newSpan;
                      nextCell.rowSpan = maxSpan - newSpan;
                      if (this.Grid.rows.getRow(i_7).maximumRowSpan < maxSpan - newSpan) {
                        this.Grid.rows.getRow(i_7).maximumRowSpan = maxSpan - newSpan;
                      }
                      var pdfGrid = currCell.value;
                      nextCell.stringFormat = currCell.stringFormat;
                      nextCell.style = currCell.style;
                      nextCell.style.backgroundImage = null;
                      nextCell.columnSpan = currCell.columnSpan;
                      if (pdfGrid instanceof PdfGrid && this.currentBounds.y + pdfGrid.size.height + this.Grid.rows.getRow(i_7).height + pdfGrid.style.cellPadding.top + pdfGrid.style.cellPadding.bottom >= this.currentBounds.height) {
                        nextCell.value = currCell.value;
                      } else if (!(pdfGrid instanceof PdfGrid)) {
                        nextCell.value = currCell.value;
                      }
                      if (i_7 > 0)
                        this.Grid.rows.getRow(i_7 - 1).rowSpanExists = true;
                      nextCell.isRowMergeContinue = false;
                      nextCell.isRowMergeStart = true;
                    } else if (isHeader && this.Grid.headers.getHeader(currRowIndex).cells.getCell(j).rowSpan === maxSpan) {
                      var headerCell = this.Grid.headers.getHeader(currRowIndex).cells.getCell(j);
                      var nextHeaderCell = this.Grid.headers.getHeader(i_7).cells.getCell(j);
                      headerCell.rowSpan = newSpan === 0 ? 1 : newSpan;
                      nextHeaderCell.rowSpan = maxSpan - newSpan;
                      nextHeaderCell.stringFormat = headerCell.stringFormat;
                      nextHeaderCell.style = headerCell.style;
                      nextHeaderCell.columnSpan = headerCell.columnSpan;
                      nextHeaderCell.value = headerCell.value;
                      this.Grid.headers.getHeader(i_7 - 1).rowSpanExists = false;
                      nextHeaderCell.isRowMergeContinue = false;
                      nextHeaderCell.isRowMergeStart = true;
                    }
                  }
                  break;
                }
              }
              rowHeightWithSpan = 0;
            }
          }
        }
        var calculatedHeight = row.rowBreakHeight > 0 ? row.rowBreakHeight : row.height;
        if (typeof this.Grid.isChildGrid !== "undefined" && this.Grid.isChildGrid && typeof this.Grid.ParentCell !== "undefined" && this.Grid.ParentCell != null) {
          if (this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + calculatedHeight > this.currentPageBounds.height || this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + calculatedHeight > this.currentBounds.height || this.currentBounds.y + this.Grid.ParentCell.row.grid.style.cellPadding.bottom + rowHeightWithSpan > this.currentPageBounds.height) {
            if (typeof this.Grid.ParentCell.row.grid.LayoutFormat !== "undefined" && this.Grid.ParentCell.row.grid.LayoutFormat.break === PdfLayoutBreakType.FitPage) {
              PdfGridLayouter2.repeatRowIndex = this.Grid.rows.rowCollection.indexOf(row);
              this.Grid.splitChildRowIndex = this.Grid.rows.rowCollection.indexOf(row);
            }
            if (PdfGridLayouter2.repeatRowIndex > -1 && PdfGridLayouter2.repeatRowIndex === row.rowIndex) {
              if (this.Grid.allowRowBreakAcrossPages) {
                result_1.isFinish = true;
                result_1.bounds = this.currentBounds;
                this.drawRowWithBreak(result_1, row, calculatedHeight);
                row.repeatFlag = true;
                row.repeatRowNumber = PdfGridLayouter2.repeatRowIndex;
              }
            }
          } else {
            result_1.isFinish = true;
            if (row.grid.ParentCell.row.rowBreakHeightValue > 0) {
              row.repeatFlag = true;
            } else {
              row.repeatFlag = false;
              calculatedHeight = row.height;
            }
            if (this.Grid.isChildGrid && row.rowBreakHeight > 0) {
              if (this.Grid.ParentCell.row.grid.style.cellPadding != null) {
                calculatedHeight += this.Grid.ParentCell.row.grid.style.cellPadding.bottom;
              }
            }
            this.drawRow(row, result_1, calculatedHeight);
          }
        } else {
          if (calculatedHeight > this.currentPageBounds.height) {
            if (this.Grid.allowRowBreakAcrossPages) {
              result_1.isFinish = true;
              this.drawRowWithBreak(result_1, row, calculatedHeight);
              row.isrowFinish = true;
              row.repeatFlag = true;
              if (row.grid.splitChildRowIndex !== -1) {
                result_1.isFinish = false;
              }
            }
          } else if (this.currentBounds.y + calculatedHeight > this.currentPageBounds.height || this.currentBounds.y + calculatedHeight > this.currentBounds.height + this.startLocation.y || this.currentBounds.y + rowHeightWithSpan > this.currentPageBounds.height) {
            var isFit = false;
            if (this.Grid.allowRowBreakAcrossPages && !this.Grid.repeatHeader && !row.isRowHeightSet && !row.rowMergeComplete) {
              if (this.Grid.LayoutFormat !== null && this.Grid.LayoutFormat.paginateBounds.height > 0) {
                isFit = this.isFitToCell(this.currentBounds.height + this.startLocation.y - this.currentBounds.y, this.Grid, row);
              } else
                isFit = this.isFitToCell(this.currentPageBounds.height - this.currentBounds.y, this.Grid, row);
              if (isFit) {
                this.isPaginate = true;
              }
            } else if (this.Grid.allowRowBreakAcrossPages && this.Grid.LayoutFormat != null && this.Grid.LayoutFormat.layout == PdfLayoutType.Paginate && this.Grid.LayoutFormat.break != PdfLayoutBreakType.FitElement && row.isRowHeightSet && this.currentBounds.y + height > this.currentPageBounds.height) {
              isFit = this.isFitToCell(this.currentPageBounds.height - this.currentBounds.y, this.Grid, row);
              if (!isFit)
                isFit = !(this.slr !== null && this.slr.actualSize.height == 0 && this.slr.remainder != null && this.slr.remainder.length > 0 && this.remainderText == this.slr.remainder);
              if (isFit && this.slr != null && this.slr.lineCount > 1) {
                isFit = false;
              }
              this.remainderText = null;
            }
            if (PdfGridLayouter2.repeatRowIndex > -1 && PdfGridLayouter2.repeatRowIndex === row.rowIndex || isFit) {
              if (this.Grid.allowRowBreakAcrossPages) {
                result_1.isFinish = true;
                this.drawRowWithBreak(result_1, row, calculatedHeight);
                row.repeatFlag = true;
                row.repeatRowNumber = PdfGridLayouter2.repeatRowIndex;
                if (row.grid.splitChildRowIndex !== -1) {
                  result_1.isFinish = false;
                }
              } else {
                result_1.isFinish = false;
                this.drawRow(row, result_1, calculatedHeight);
              }
            } else {
              result_1.isFinish = false;
            }
          } else {
            result_1.isFinish = true;
            this.drawRow(row, result_1, calculatedHeight);
            row.repeatFlag = false;
          }
        }
        return result_1;
      } else {
        var skipcell = false;
        var loc = new PointF(this.currentBounds.x, this.currentBounds.y);
        result.bounds = new RectangleF(loc, new SizeF(0, 0));
        height = this.ReCalculateHeight(row, height);
        for (var i = this.cellStartIndex; i <= this.cellEndIndex; i++) {
          var cancelSpans = i > this.cellEndIndex + 1 && row.cells.getCell(i).columnSpan > 1;
          if (!cancelSpans) {
            for (var j = 1; j < row.cells.getCell(i).columnSpan; j++) {
              row.cells.getCell(i + j).isCellMergeContinue = true;
            }
          }
          var size = new SizeF(this.Grid.columns.getColumn(i).width, height);
          if (!this.CheckIfDefaultFormat(this.Grid.columns.getColumn(i).format) && this.CheckIfDefaultFormat(row.cells.getCell(i).stringFormat)) {
            row.cells.getCell(i).stringFormat = this.Grid.columns.getColumn(i).format;
          }
          var cellstyle = row.cells.getCell(i).style;
          var tempValue = typeof row.cells.getCell(i).value === "string" && row.cells.getCell(i).value !== null ? row.cells.getCell(i).value : "";
          row.cells.getCell(i).style = this.RaiseBeforeCellDraw(this.currentGraphics, this.currentRowIndex, i, new RectangleF(loc, size), tempValue, cellstyle);
          if (!skipcell) {
            if (row.cells.getCell(i).value instanceof PdfGrid) {
              var grid = row.cells.getCell(i).value;
              grid.parentCellIndex = i;
            }
            var stringResult = row.cells.getCell(i).draw(this.currentGraphics, new RectangleF(loc, size), cancelSpans);
            if (row.grid.style.allowHorizontalOverflow && (row.cells.getCell(i).columnSpan > this.cellEndIndex || i + row.cells.getCell(i).columnSpan > this.cellEndIndex + 1) && this.cellEndIndex < row.cells.count - 1) {
              row.rowOverflowIndex = this.cellEndIndex;
            }
            if (row.grid.style.allowHorizontalOverflow && (row.rowOverflowIndex > 0 && (row.cells.getCell(i).columnSpan > this.cellEndIndex || i + row.cells.getCell(i).columnSpan > this.cellEndIndex + 1)) && row.cells.getCell(i).columnSpan - this.cellEndIndex + i - 1 > 0) {
              row.cells.getCell(row.rowOverflowIndex + 1).value = stringResult !== null ? stringResult.remainder !== void 0 ? stringResult.remainder : "" : "";
              row.cells.getCell(row.rowOverflowIndex + 1).stringFormat = row.cells.getCell(i).stringFormat;
              row.cells.getCell(row.rowOverflowIndex + 1).style = row.cells.getCell(i).style;
              row.cells.getCell(row.rowOverflowIndex + 1).columnSpan = row.cells.getCell(i).columnSpan - this.cellEndIndex + i - 1;
            }
          }
          tempValue = typeof row.cells.getCell(i).value === "string" && row.cells.getCell(i).value !== null ? row.cells.getCell(i).value : "";
          if (!cancelSpans) {
            this.raiseAfterCellDraw(this.currentGraphics, this.currentRowIndex, i, new RectangleF(loc, size), tempValue, row.cells.getCell(i).style);
          }
          if (row.cells.getCell(i).value instanceof PdfGrid) {
            var grid = row.cells.getCell(i).value;
            if (this.Grid.columns.getColumn(i).width >= this.currentGraphics.clientSize.width) {
              loc.x = grid.rowLayoutBoundsWidth;
              loc.x += grid.style.cellSpacing;
            } else {
              loc.x += this.Grid.columns.getColumn(i).width;
            }
          } else {
            loc.x += this.Grid.columns.getColumn(i).width;
          }
        }
        if (!row.rowMergeComplete || row.isRowHeightSet) {
          this.currentBounds.y += height;
        }
        result.bounds = new RectangleF(new PointF(result.bounds.x, result.bounds.y), new SizeF(loc.x, loc.y));
      }
    };
    PdfGridLayouter2.prototype.isFitToCell = function(currentHeight, grid, gridRow) {
      var isFit = false;
      var layouter = new PdfStringLayouter();
      for (var i = 0; i < gridRow.cells.count; i++) {
        var cell = gridRow.cells.getCell(i);
        if (typeof cell.value !== "undefined" && cell.value !== null && typeof cell.value === "string") {
          var font = null;
          if (typeof cell.style.font !== "undefined" && cell.style.font != null) {
            font = cell.style.font;
          } else if (typeof cell.row.style.font !== "undefined" && cell.row.style.font != null) {
            font = cell.row.style.font;
          } else if (typeof cell.row.grid.style.font !== "undefined" && cell.row.grid.style.font != null) {
            font = cell.row.grid.style.font;
          } else {
            font = PdfDocument.defaultFont;
          }
          this.remainderText = cell.value;
          var width = cell.width;
          var column = grid.columns.getColumn(i);
          if (column.isCustomWidth && cell.width > column.width) {
            width = column.width;
          }
          this.slr = layouter.layout(cell.value, font, cell.stringFormat, new SizeF(width, currentHeight), false, this.currentPageBounds);
          var height = this.slr.actualSize.height;
          if (cell.value !== "" && height === 0) {
            isFit = false;
            break;
          }
          if (cell.style !== null && cell.style.borders !== null && cell.style.borders.top !== null && cell.style.borders.bottom !== null) {
            height += (cell.style.borders.top.width + cell.style.borders.bottom.width) * 2;
          }
          if (this.slr.lineCount > 1 && cell.stringFormat != null && cell.stringFormat.lineSpacing != 0) {
            height += (this.slr.lineCount - 1) * cell.style.stringFormat.lineSpacing;
          }
          if (cell.style.cellPadding === null) {
            height += grid.style.cellPadding.top + grid.style.cellPadding.bottom;
          } else {
            height += grid.style.cellPadding.top + grid.style.cellPadding.bottom;
          }
          height += grid.style.cellSpacing;
          if (currentHeight > height || typeof this.slr.remainder !== "undefined" && this.slr.remainder !== null) {
            isFit = true;
            break;
          }
        }
      }
      return isFit;
    };
    PdfGridLayouter2.prototype.drawRowWithBreak = function(result, row, calculateHeight) {
      var location2 = new PointF(this.currentBounds.x, this.currentBounds.y);
      if (row.grid.isChildGrid && row.grid.allowRowBreakAcrossPages && this.startLocation.x !== this.currentBounds.x) {
        location2.x = this.startLocation.x;
      }
      result.bounds = new RectangleF(location2, new SizeF(0, 0));
      this.gridHeight = row.rowBreakHeight > 0 ? this.currentPageBounds.height : 0;
      if (row.grid.style.cellPadding.top + this.currentBounds.y + row.grid.style.cellPadding.bottom < this.currentPageBounds.height) {
        row.rowBreakHeight = this.currentBounds.y + calculateHeight - this.currentPageBounds.height;
      }
      for (var i = 0; i < row.cells.count; i++) {
        var cell = row.cells.getCell(i);
        var cellHeight = cell.measureHeight();
        if (cellHeight === calculateHeight && cell.value instanceof PdfGrid) {
          row.rowBreakHeight = 0;
        }
      }
      for (var i = this.cellStartIndex; i <= this.cellEndIndex; i++) {
        var gridColumnWidth = this.Grid.columns.getColumn(i).width;
        var cancelSpans = row.cells.getCell(i).columnSpan + i > this.cellEndIndex + 1 && row.cells.getCell(i).columnSpan > 1;
        if (!cancelSpans) {
          for (var k = 1; k < row.cells.getCell(i).columnSpan; k++) {
            row.cells.getCell(i + k).isCellMergeContinue = true;
            gridColumnWidth += this.Grid.columns.getColumn(i + k).width;
          }
        }
        var size = new SizeF(gridColumnWidth, this.gridHeight > 0 ? this.gridHeight : this.currentPageBounds.height);
        var cellstyle1 = row.cells.getCell(i).style;
        row.cells.getCell(i).style = cellstyle1;
        var skipcell = false;
        var stringResult = null;
        if (!skipcell) {
          row.cells.getCell(i)._rowHeight = row.height;
          stringResult = row.cells.getCell(i).draw(this.currentGraphics, new RectangleF(location2, size), cancelSpans);
        }
        if (row.rowBreakHeight > 0) {
          if (stringResult != null && typeof stringResult.remainder !== "undefined") {
            row.cells.getCell(i).FinishedDrawingCell = false;
            row.cells.getCell(i).remainingString = stringResult.remainder == null ? " " : stringResult.remainder;
            row.rowBreakHeight = calculateHeight - stringResult.actualSize.height;
          }
        }
        result.isFinish = !result.isFinish ? result.isFinish : row.cells.getCell(i).FinishedDrawingCell;
        if (row.cells.getCell(i).value instanceof PdfGrid) {
          var grid = row.cells.getCell(i).value;
          this.rowBreakPageHeightCellIndex = i;
          if (this.Grid.columns.getColumn(i).width >= this.currentGraphics.clientSize.width) {
            location2.x = this.rowLayoutBoundsWidth;
            location2.x += grid.style.cellSpacing;
          } else {
            location2.x += this.Grid.columns.getColumn(i).width;
          }
        } else {
          location2.x += this.Grid.columns.getColumn(i).width;
        }
      }
      this.currentBounds.y += this.gridHeight > 0 ? this.gridHeight : calculateHeight;
      result.bounds = new RectangleF(new PointF(result.bounds.x, result.bounds.y), new SizeF(location2.x, location2.y));
    };
    PdfGridLayouter2.repeatRowIndex = -1;
    return PdfGridLayouter2;
  })(ElementLayouter)
);
var PdfGridLayoutResult = (
  /** @class */
  (function(_super) {
    __extends56(PdfGridLayoutResult2, _super);
    function PdfGridLayoutResult2(page, bounds) {
      return _super.call(this, page, bounds) || this;
    }
    return PdfGridLayoutResult2;
  })(PdfLayoutResult)
);
var PdfGridLayoutFormat = (
  /** @class */
  (function(_super) {
    __extends56(PdfGridLayoutFormat2, _super);
    function PdfGridLayoutFormat2(baseFormat) {
      return _super.call(this, baseFormat) || this;
    }
    return PdfGridLayoutFormat2;
  })(PdfLayoutFormat)
);
var GridCellEventArgs = (
  /** @class */
  (function() {
    function GridCellEventArgs2(graphics, rowIndex, cellIndex, bounds, value) {
      this.gridRowIndex = rowIndex;
      this.gridCellIndex = cellIndex;
      this.internalValue = value;
      this.gridBounds = bounds;
      this.pdfGraphics = graphics;
    }
    Object.defineProperty(GridCellEventArgs2.prototype, "rowIndex", {
      // Properties
      /**
       * Gets the value of current `row index`.
       * @private
       */
      get: function() {
        return this.gridRowIndex;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(GridCellEventArgs2.prototype, "cellIndex", {
      /**
       * Gets the value of current `cell index`.
       * @private
       */
      get: function() {
        return this.gridCellIndex;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(GridCellEventArgs2.prototype, "value", {
      /**
       * Gets the actual `value` of current cell.
       * @private
       */
      get: function() {
        return this.internalValue;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(GridCellEventArgs2.prototype, "bounds", {
      /**
       * Gets the `bounds` of current cell.
       * @private
       */
      get: function() {
        return this.gridBounds;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(GridCellEventArgs2.prototype, "graphics", {
      /**
       * Gets the instance of `current graphics`.
       * @private
       */
      get: function() {
        return this.pdfGraphics;
      },
      enumerable: true,
      configurable: true
    });
    return GridCellEventArgs2;
  })()
);
var PdfGridBeginCellDrawEventArgs = (
  /** @class */
  (function(_super) {
    __extends56(PdfGridBeginCellDrawEventArgs2, _super);
    function PdfGridBeginCellDrawEventArgs2(graphics, rowIndex, cellIndex, bounds, value, style) {
      var _this = _super.call(this, graphics, rowIndex, cellIndex, bounds, value) || this;
      _this.style = style;
      return _this;
    }
    Object.defineProperty(PdfGridBeginCellDrawEventArgs2.prototype, "skip", {
      // Properties
      /**
       * Gets or sets a value indicating whether the value of this cell should be `skipped`.
       * @private
       */
      get: function() {
        return this.bSkip;
      },
      set: function(value) {
        this.bSkip = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfGridBeginCellDrawEventArgs2.prototype, "style", {
      /**
       * Gets or sets a `style` value of the cell.
       * @private
       */
      get: function() {
        return this.cellStyle;
      },
      set: function(value) {
        this.cellStyle = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridBeginCellDrawEventArgs2;
  })(GridCellEventArgs)
);
var PdfGridEndCellDrawEventArgs = (
  /** @class */
  (function(_super) {
    __extends56(PdfGridEndCellDrawEventArgs2, _super);
    function PdfGridEndCellDrawEventArgs2(graphics, rowIndex, cellIndex, bounds, value, style) {
      var _this = _super.call(this, graphics, rowIndex, cellIndex, bounds, value) || this;
      _this.cellStyle = style;
      return _this;
    }
    Object.defineProperty(PdfGridEndCellDrawEventArgs2.prototype, "style", {
      // Propertise
      /**
       * Get the `PdfGridCellStyle`.
       * @private
       */
      get: function() {
        return this.cellStyle;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridEndCellDrawEventArgs2;
  })(GridCellEventArgs)
);
var PdfCancelEventArgs = (
  /** @class */
  (function() {
    function PdfCancelEventArgs2() {
    }
    Object.defineProperty(PdfCancelEventArgs2.prototype, "cancel", {
      // Properties
      /**
       * Gets and Sets the value of `cancel`.
       * @private
       */
      get: function() {
        return this.isCancel;
      },
      set: function(value) {
        this.isCancel = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfCancelEventArgs2;
  })()
);
var BeginPageLayoutEventArgs = (
  /** @class */
  (function(_super) {
    __extends56(BeginPageLayoutEventArgs2, _super);
    function BeginPageLayoutEventArgs2(bounds, page) {
      var _this = _super.call(this) || this;
      _this.bounds = bounds;
      _this.pdfPage = page;
      return _this;
    }
    Object.defineProperty(BeginPageLayoutEventArgs2.prototype, "bounds", {
      // Properties
      /**
       * Gets or sets value that indicates the lay outing `bounds` on the page.
       * @private
       */
      get: function() {
        return this.cellBounds;
      },
      set: function(value) {
        this.cellBounds = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(BeginPageLayoutEventArgs2.prototype, "page", {
      /**
       * Gets the `page` where the lay outing should start.
       * @private
       */
      get: function() {
        return this.pdfPage;
      },
      enumerable: true,
      configurable: true
    });
    return BeginPageLayoutEventArgs2;
  })(PdfCancelEventArgs)
);
var EndPageLayoutEventArgs = (
  /** @class */
  (function(_super) {
    __extends56(EndPageLayoutEventArgs2, _super);
    function EndPageLayoutEventArgs2(result) {
      var _this = _super.call(this) || this;
      _this.layoutResult = result;
      return _this;
    }
    Object.defineProperty(EndPageLayoutEventArgs2.prototype, "result", {
      // Properties
      /**
       * Gets the lay outing `result` of the page.
       * @private
       */
      get: function() {
        return this.layoutResult;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(EndPageLayoutEventArgs2.prototype, "nextPage", {
      /**
       * Gets or sets a value indicating the `next page` where the element should be layout.
       * @private
       */
      get: function() {
        return this.nextPdfPage;
      },
      set: function(value) {
        this.nextPdfPage = value;
      },
      enumerable: true,
      configurable: true
    });
    return EndPageLayoutEventArgs2;
  })(PdfCancelEventArgs)
);
var PdfGridBeginPageLayoutEventArgs = (
  /** @class */
  (function(_super) {
    __extends56(PdfGridBeginPageLayoutEventArgs2, _super);
    function PdfGridBeginPageLayoutEventArgs2(bounds, page, startRow) {
      var _this = _super.call(this, bounds, page) || this;
      _this.startRow = startRow;
      return _this;
    }
    Object.defineProperty(PdfGridBeginPageLayoutEventArgs2.prototype, "startRowIndex", {
      // Properties
      /**
       * Gets the `start row index`.
       * @private
       */
      get: function() {
        return this.startRow;
      },
      enumerable: true,
      configurable: true
    });
    return PdfGridBeginPageLayoutEventArgs2;
  })(BeginPageLayoutEventArgs)
);
var PdfGridEndPageLayoutEventArgs = (
  /** @class */
  (function(_super) {
    __extends56(PdfGridEndPageLayoutEventArgs2, _super);
    function PdfGridEndPageLayoutEventArgs2(result) {
      return _super.call(this, result) || this;
    }
    return PdfGridEndPageLayoutEventArgs2;
  })(EndPageLayoutEventArgs)
);
var RowLayoutResult = (
  /** @class */
  (function() {
    function RowLayoutResult2() {
      this.layoutedBounds = new RectangleF(0, 0, 0, 0);
    }
    Object.defineProperty(RowLayoutResult2.prototype, "isFinish", {
      /**
       * Gets or sets a value indicating whether this instance `is finish`.
       * @private
       */
      get: function() {
        return this.bIsFinished;
      },
      set: function(value) {
        this.bIsFinished = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(RowLayoutResult2.prototype, "bounds", {
      /**
       * Gets or sets the `bounds`.
       * @private
       */
      get: function() {
        return this.layoutedBounds;
      },
      set: function(value) {
        this.layoutedBounds = value;
      },
      enumerable: true,
      configurable: true
    });
    return RowLayoutResult2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/shape-layouter.js
var __extends57 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var ShapeLayouter = (
  /** @class */
  (function(_super) {
    __extends57(ShapeLayouter2, _super);
    function ShapeLayouter2(element) {
      var _this = _super.call(this, element) || this;
      _this.olderPdfForm = 0;
      _this.shapeBounds = new RectangleF();
      _this.totalPageSize = 0;
      return _this;
    }
    Object.defineProperty(ShapeLayouter2.prototype, "element", {
      // Properties
      /**
       * Gets shape element.
       * @private
       */
      get: function() {
        return this.elements;
      },
      enumerable: true,
      configurable: true
    });
    ShapeLayouter2.prototype.layoutInternal = function(param) {
      var currentPage = param.page;
      var currentBounds = param.bounds;
      var shapeLayoutBounds = this.element.getBounds();
      shapeLayoutBounds.x = 0;
      shapeLayoutBounds.y = 0;
      var isEmpty = this.shapeBounds.x === this.shapeBounds.y && this.shapeBounds.y === this.shapeBounds.width && this.shapeBounds.width === this.shapeBounds.height && this.shapeBounds.height === 0 ? true : false;
      if (this.isPdfGrid && !isEmpty) {
        shapeLayoutBounds = this.shapeBounds;
      }
      var result = null;
      var pageResult = new ShapeLayoutResult();
      pageResult.page = currentPage;
      while (true) {
        var result1 = this.raiseBeforePageLayout(currentPage, currentBounds);
        currentBounds = result1.currentBounds;
        var endArgs = null;
        if (!result1.cancel) {
          pageResult = this.layoutOnPage(currentPage, currentBounds, shapeLayoutBounds, param);
          endArgs = this.raiseEndPageLayout(pageResult);
          result1.cancel = endArgs === null ? false : endArgs.cancel;
        }
        if (!pageResult.end && !result1.cancel) {
          currentBounds = this.getPaginateBounds(param);
          shapeLayoutBounds = this.getNextShapeBounds(shapeLayoutBounds, pageResult);
          currentPage = endArgs === null || endArgs.nextPage === null ? this.getNextPage(currentPage) : endArgs.nextPage;
          if (this.isPdfGrid) {
            result = this.getLayoutResult(pageResult);
            break;
          }
        } else {
          result = this.getLayoutResult(pageResult);
          break;
        }
      }
      return result;
    };
    ShapeLayouter2.prototype.raiseBeforePageLayout = function(currentPage, currentBounds) {
      var cancel = false;
      if (this.element.raiseBeginPageLayout) {
        var args = new BeginPageLayoutEventArgs(currentBounds, currentPage);
        this.element.onBeginPageLayout(args);
        cancel = args.cancel;
        currentBounds = args.bounds;
      }
      return { currentBounds, cancel };
    };
    ShapeLayouter2.prototype.raiseEndPageLayout = function(pageResult) {
      var args = null;
      if (this.element.raiseEndPageLayout) {
        var res = this.getLayoutResult(pageResult);
        args = new EndPageLayoutEventArgs(res);
        this.element.onEndPageLayout(args);
      }
      return args;
    };
    ShapeLayouter2.prototype.getLayoutResult = function(pageResult) {
      var result = new PdfLayoutResult(pageResult.page, pageResult.bounds);
      return result;
    };
    ShapeLayouter2.prototype.getNextShapeBounds = function(shapeLayoutBounds, pageResult) {
      var layoutedBounds = pageResult.bounds;
      shapeLayoutBounds.y = shapeLayoutBounds.y + layoutedBounds.height;
      shapeLayoutBounds.height = shapeLayoutBounds.height - layoutedBounds.height;
      return shapeLayoutBounds;
    };
    ShapeLayouter2.prototype.layoutOnPage = function(currentPage, curBounds, sBounds, param) {
      var result = new ShapeLayoutResult();
      curBounds = this.checkCorrectCurrentBounds(currentPage, curBounds, param);
      var fitToPage = this.fitsToBounds(curBounds, sBounds);
      var canDraw = !(param.format.break === PdfLayoutBreakType.FitElement && (!fitToPage && currentPage === param.page));
      var shapeFinished = false;
      if (canDraw) {
        var drawRectangle2 = this.getDrawBounds(curBounds, sBounds);
        this.drawShape(currentPage.graphics, curBounds, drawRectangle2);
        result.bounds = this.getPageResultBounds(curBounds, sBounds);
        shapeFinished = curBounds.height >= sBounds.height;
      }
      result.end = shapeFinished || param.format.layout === PdfLayoutType.OnePage;
      result.page = currentPage;
      return result;
    };
    ShapeLayouter2.prototype.getDrawBounds = function(currentBounds, shapeLayoutBounds) {
      var result = currentBounds;
      result.y = result.y - shapeLayoutBounds.y;
      result.height = result.height + shapeLayoutBounds.y;
      return result;
    };
    ShapeLayouter2.prototype.drawShape = function(g, currentBounds, drawRectangle2) {
      var gState = g.save();
      try {
        g.setClip(currentBounds);
        this.element.drawGraphicsHelper(g, new PointF(drawRectangle2.x, drawRectangle2.y));
      } finally {
        g.restore(gState);
      }
    };
    ShapeLayouter2.prototype.checkCorrectCurrentBounds = function(currentPage, curBounds, param) {
      var pageSize = currentPage.graphics.clientSize;
      curBounds.width = curBounds.width > 0 ? curBounds.width : pageSize.width - curBounds.x;
      curBounds.height = curBounds.height > 0 ? curBounds.height : pageSize.height - curBounds.y;
      if (this.isPdfGrid) {
        curBounds.height = curBounds.height - this.bottomCellPadding;
      }
      return curBounds;
    };
    ShapeLayouter2.prototype.getPageResultBounds = function(currentBounds, shapeLayoutBounds) {
      var result = currentBounds;
      result.height = Math.min(result.height, shapeLayoutBounds.height);
      return result;
    };
    ShapeLayouter2.prototype.fitsToBounds = function(currentBounds, shapeLayoutBounds) {
      var fits = shapeLayoutBounds.height <= currentBounds.height;
      return fits;
    };
    ShapeLayouter2.index = 0;
    ShapeLayouter2.splitDiff = 0;
    ShapeLayouter2.last = false;
    ShapeLayouter2.borderWidth = 0;
    return ShapeLayouter2;
  })(ElementLayouter)
);
var ShapeLayoutResult = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ShapeLayoutResult2() {
    }
    return ShapeLayoutResult2;
  })()
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/pdf-shape-element.js
var __extends58 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfShapeElement = (
  /** @class */
  (function(_super) {
    __extends58(PdfShapeElement2, _super);
    function PdfShapeElement2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PdfShapeElement2.prototype.getBounds = function() {
      var rect = this.getBoundsInternal();
      return rect;
    };
    PdfShapeElement2.prototype.drawGraphicsHelper = function(graphics, location2) {
      if (graphics == null) {
        throw new Error("ArgumentNullException :graphics");
      }
      this.drawShapeHelper(graphics, location2.x, location2.y);
    };
    PdfShapeElement2.prototype.drawShapeHelper = function(graphics, x, y) {
      var bNeedSave = x !== 0.5 || y !== 0.5;
      var gState = null;
      if (bNeedSave) {
        gState = graphics.save();
        graphics.translateTransform(x, y);
      }
      this.drawInternal(graphics);
      if (bNeedSave) {
        graphics.restore(gState);
      }
    };
    PdfShapeElement2.prototype.layout = function(param) {
      var layouter = new ShapeLayouter(this);
      var result = layouter.layout(param);
      return result;
    };
    return PdfShapeElement2;
  })(PdfLayoutElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/draw-element.js
var __extends59 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfDrawElement = (
  /** @class */
  (function(_super) {
    __extends59(PdfDrawElement2, _super);
    function PdfDrawElement2(pen) {
      var _this = _super.call(this) || this;
      if (typeof pen !== "undefined") {
        _this.mpen = pen;
      }
      return _this;
    }
    Object.defineProperty(PdfDrawElement2.prototype, "pen", {
      // Properties
      /**
       * Gets or sets a pen that will be used to draw the element.
       * @public
       */
      get: function() {
        return this.mpen;
      },
      set: function(value) {
        this.mpen = value;
      },
      enumerable: true,
      configurable: true
    });
    return PdfDrawElement2;
  })(PdfShapeElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/base/fill-element.js
var __extends60 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfFillElement = (
  /** @class */
  (function(_super) {
    __extends60(PdfFillElement2, _super);
    function PdfFillElement2(arg1, arg2) {
      var _this = _super.call(this) || this;
      _this.mbrush = null;
      if (typeof arg1 === "undefined") {
      } else if (arg1 instanceof PdfPen) {
        _this = _super.call(this, arg1) || this;
      } else {
        _this.mbrush = arg2;
      }
      return _this;
    }
    Object.defineProperty(PdfFillElement2.prototype, "brush", {
      // Properties
      /**
       * Gets or sets a brush of the element.
       * @public
       */
      get: function() {
        return this.mbrush;
      },
      set: function(value) {
        this.mbrush = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfFillElement2.prototype.obtainPen = function() {
      return this.mbrush == null && this.pen == null ? new PdfPen(new PdfColor(0, 0, 0)) : this.pen;
    };
    return PdfFillElement2;
  })(PdfDrawElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/path.js
var __extends61 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfPath = (
  /** @class */
  (function(_super) {
    __extends61(PdfPath2, _super);
    function PdfPath2(arg1, arg2, arg3, arg4) {
      var _this = _super.call(this) || this;
      _this.mpoints = null;
      _this.mpathTypes = null;
      _this.mStartFigure = true;
      _this.mfillMode = PdfFillMode.Alternate;
      _this.isBeziers3 = false;
      _this.isXps = false;
      if (typeof arg1 === "undefined") {
      } else if (arg1 instanceof PdfPen) {
        _this = _super.call(this, arg1) || this;
        if (arg2 instanceof PdfBrush) {
          _this = _super.call(this, arg1, arg2) || this;
          _this.fillMode = arg3;
        } else if (arg2 !== null && typeof arg2 !== "undefined" && arg3 !== null && typeof arg3 !== "undefined") {
          _this.addPath(arg2, arg3);
        }
      } else if (arg1 instanceof PdfBrush) {
        _this = _super.call(this, arg1) || this;
        if (arg2 !== null && typeof arg2 !== "undefined") {
          _this.fillMode = arg2;
        }
        if (arg3 !== null && typeof arg3 !== "undefined" && arg4 !== null && typeof arg4 !== "undefined") {
          _this.addPath(arg3, arg4);
        }
      } else {
        _this.addPath(arg1, arg2);
      }
      return _this;
    }
    Object.defineProperty(PdfPath2.prototype, "fillMode", {
      // Properties
      /**
       * Gets or sets the fill mode.
       * @public
       */
      get: function() {
        return this.mfillMode;
      },
      set: function(value) {
        this.mfillMode = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPath2.prototype, "pathPoints", {
      /**
       * Gets the path points.
       * @public
       */
      get: function() {
        return this.points;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPath2.prototype, "pathTypes", {
      /**
       * Gets the path point types.
       * @public
       */
      get: function() {
        return this.types;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPath2.prototype, "pointCount", {
      /**
       * Gets the point count.
       * @public
       */
      get: function() {
        var count = 0;
        if (this.mpoints != null) {
          count = this.mpoints.length;
        }
        return count;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPath2.prototype, "lastPoint", {
      /**
       * Gets the last points.
       * @public
       */
      get: function() {
        return this.getLastPoint();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPath2.prototype, "points", {
      /**
       * Gets the points list.
       * @private
       */
      get: function() {
        if (this.mpoints == null) {
          this.mpoints = [];
        }
        return this.mpoints;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPath2.prototype, "types", {
      /**
       * Gets the types.
       * @private
       */
      get: function() {
        if (this.mpathTypes == null) {
          this.mpathTypes = [];
        }
        return this.mpathTypes;
      },
      enumerable: true,
      configurable: true
    });
    PdfPath2.prototype.draw = function(arg1, arg2, arg3, arg4) {
      if (arg2 instanceof PointF && typeof arg2.width === "undefined" && typeof arg3 === "undefined") {
        return this.drawHelper(arg1, arg2.x, arg2.y);
      } else if (arg2 instanceof RectangleF && typeof arg2.width !== "undefined" && typeof arg3 === "undefined") {
        return this.drawHelper(arg1, arg2, null);
      } else if (typeof arg2 === "number" && typeof arg3 === "number" && typeof arg4 === "undefined") {
        return this.drawHelper(arg1, arg2, arg3, null);
      } else if (arg2 instanceof PointF && arg3 instanceof PdfLayoutFormat) {
        return this.drawHelper(arg1, arg2.x, arg2.y, arg3);
      } else if (typeof arg2 === "number" && (arg4 instanceof PdfLayoutFormat || arg4 == null) && typeof arg3 === "number") {
        var widthValue = arg1.graphics.clientSize.width - arg2;
        var layoutRect = new RectangleF(arg2, arg3, widthValue, 0);
        return this.drawHelper(arg1, layoutRect, arg4);
      } else if (arg2 instanceof RectangleF && arg3 instanceof PdfLayoutFormat) {
        return this.drawHelper(arg1, arg2, arg3);
      } else {
        return this.drawHelper(arg1, arg2, arg3);
      }
    };
    PdfPath2.prototype.addArc = function(arg1, arg2, arg3, arg4, arg5, arg6) {
      if (arg1 instanceof RectangleF) {
        this.addArc(arg1.x, arg1.y, arg1.width, arg1.height, arg2, arg3);
      } else {
        var points = this.getBezierArcPoints(arg1, arg2, arg2 + arg3, arg2 + arg4, arg5, arg6);
        for (var i = 0; i < points.length; i = i + 8) {
          var point = [points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5], points[i + 6], points[i + 7]];
          this.addPoints(point, PathPointType.Bezier3);
        }
      }
    };
    PdfPath2.prototype.addBezier = function(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      if (arg1 instanceof PointF && arg2 instanceof PointF && arg3 instanceof PointF && arg4 instanceof PointF) {
        this.addBezier(arg1.x, arg1.y, arg2.x, arg2.y, arg3.x, arg3.y, arg4.x, arg4.y);
      } else {
        var points = [];
        points.push(arg1);
        points.push(arg2);
        points.push(arg3);
        points.push(arg4);
        points.push(arg5);
        points.push(arg6);
        points.push(arg7);
        points.push(arg8);
        this.addPoints(points, PathPointType.Bezier3);
      }
    };
    PdfPath2.prototype.addEllipse = function(arg1, arg2, arg3, arg4) {
      if (arg1 instanceof RectangleF) {
        this.addEllipse(arg1.x, arg1.y, arg1.width, arg1.height);
      } else {
        this.startFigure();
        this.addArc(arg1, arg2, arg3, arg4, 0, 360);
        this.closeFigure();
      }
    };
    PdfPath2.prototype.addLine = function(arg1, arg2, arg3, arg4) {
      if (arg1 instanceof PointF && arg2 instanceof PointF) {
        this.addLine(arg1.x, arg1.y, arg2.x, arg2.y);
      } else {
        var points = [];
        points.push(arg1);
        points.push(arg2);
        points.push(arg3);
        points.push(arg4);
        this.addPoints(points, PathPointType.Line);
      }
    };
    PdfPath2.prototype.addPath = function(arg1, arg2) {
      if (arg1 instanceof PdfPath2) {
        this.addPath(arg1.pathPoints, arg1.pathTypes);
      } else {
        if (arg1 == null) {
          throw new Error("ArgumentNullException:pathPoints");
        }
        if (arg2 == null) {
          throw new Error("ArgumentNullException:pathTypes");
        }
        var count = arg1.length;
        if (count !== arg2.length) {
          throw new Error("The argument arrays should be of equal length.");
        }
      }
    };
    PdfPath2.prototype.addPie = function(arg1, arg2, arg3, arg4, arg5, arg6) {
      if (arg1 instanceof RectangleF) {
        this.addPie(arg1.x, arg1.y, arg1.width, arg1.height, arg2, arg3);
      } else {
        this.startFigure();
        this.addArc(arg1, arg2, arg3, arg4, arg5, arg6);
        this.addPoint(new PointF(arg1 + arg3 / 2, arg2 + arg4 / 2), PathPointType.Line);
        this.closeFigure();
      }
    };
    PdfPath2.prototype.addPolygon = function(points) {
      var count = points.length * 2;
      var p = [];
      this.startFigure();
      for (var i = 0; i < points.length; i++) {
        p.push(points[i].x);
        p.push(points[i].y);
      }
      this.addPoints(p, PathPointType.Line);
      this.closeFigure();
    };
    PdfPath2.prototype.addRectangle = function(arg1, y, width, height) {
      if (arg1 instanceof RectangleF) {
        this.addRectangle(arg1.x, arg1.y, arg1.width, arg1.height);
      } else {
        var points = [];
        this.startFigure();
        points.push(arg1);
        points.push(y);
        points.push(arg1 + width);
        points.push(y);
        points.push(arg1 + width);
        points.push(y + height);
        points.push(arg1);
        points.push(y + height);
        this.addPoints(points, PathPointType.Line);
        this.closeFigure();
      }
    };
    PdfPath2.prototype.startFigure = function() {
      this.mStartFigure = true;
    };
    PdfPath2.prototype.closeAllFigures = function() {
      var startPath = this.pathPoints[0];
      for (var i = 0; i < this.mpathTypes.length; i++) {
        var pt = this.types[i];
        var flag = false;
        if (i !== 0 && pt === PathPointType.Start) {
          this.closeFigure(i - 1);
          flag = true;
        } else if (i === this.mpathTypes.length - 1 && (!flag && this.isXps)) {
          if (startPath.x === this.pathPoints[i].y) {
            this.closeFigure(i);
          }
        }
      }
    };
    PdfPath2.prototype.getLastPoint = function() {
      var lastPoint = new PointF(0, 0);
      var count = this.pointCount;
      if (count > 0 && this.mpoints != null) {
        lastPoint.x = this.mpoints[count - 1].x;
        lastPoint.y = this.mpoints[count - 1].y;
      }
      return lastPoint;
    };
    PdfPath2.prototype.getBezierArcPoints = function(x1, y1, x2, y2, s1, e1) {
      if (x1 > x2) {
        var tmp = void 0;
        tmp = x1;
        x1 = x2;
        x2 = tmp;
      }
      if (y2 > y1) {
        var tmp = void 0;
        tmp = y1;
        y1 = y2;
        y2 = tmp;
      }
      var fragAngle;
      var numFragments;
      if (Math.abs(e1) <= 90) {
        fragAngle = e1;
        numFragments = 1;
      } else {
        numFragments = Math.ceil(Math.abs(e1) / 90);
        fragAngle = e1 / numFragments;
      }
      var xcen = (x1 + x2) / 2;
      var ycen = (y1 + y2) / 2;
      var rx = (x2 - x1) / 2;
      var ry = (y2 - y1) / 2;
      var halfAng = fragAngle * (Math.PI / 360);
      var kappa = Math.abs(4 / 3 * (1 - Math.cos(halfAng)) / Math.sin(halfAng));
      var pointList = [];
      for (var i = 0; i < numFragments; i++) {
        var theta0 = (s1 + i * fragAngle) * (Math.PI / 180);
        var theta1 = (s1 + (i + 1) * fragAngle) * (Math.PI / 180);
        var cos0 = Math.cos(theta0);
        var cos1 = Math.cos(theta1);
        var sin0 = Math.sin(theta0);
        var sin1 = Math.sin(theta1);
        if (fragAngle > 0) {
          pointList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 - kappa * sin0), ycen - ry * (sin0 + kappa * cos0), xcen + rx * (cos1 + kappa * sin1), ycen - ry * (sin1 - kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);
        } else {
          pointList.push(xcen + rx * cos0, ycen - ry * sin0, xcen + rx * (cos0 + kappa * sin0), ycen - ry * (sin0 - kappa * cos0), xcen + rx * (cos1 - kappa * sin1), ycen - ry * (sin1 + kappa * cos1), xcen + rx * cos1, ycen - ry * sin1);
        }
      }
      return pointList;
    };
    PdfPath2.prototype.getBoundsInternal = function() {
      var points = this.pathPoints;
      var bounds = new RectangleF(0, 0, 0, 0);
      if (points.length > 0) {
        var xmin = points[0].x;
        var xmax = points[0].x;
        var ymin = points[0].y;
        var ymax = points[0].y;
        for (var i = 1; i < points.length; i++) {
          var point = points[i];
          xmin = Math.min(point.x, xmin);
          xmax = Math.max(point.x, xmax);
          ymin = Math.min(point.y, ymin);
          ymax = Math.max(point.y, ymax);
        }
        bounds = new RectangleF(xmin, ymin, xmax - xmin, ymax - ymin);
      }
      return bounds;
    };
    PdfPath2.prototype.drawInternal = function(graphics) {
      if (graphics == null) {
        throw new Error("ArgumentNullException :graphics");
      }
      graphics.drawPath(this.obtainPen(), this.brush, this);
    };
    PdfPath2.prototype.addPoints = function(points, pointType, startIndex, endIndex) {
      if (typeof startIndex === "undefined" && typeof endIndex === "undefined") {
        this.addPoints(points, pointType, 0, points.length);
      } else {
        for (var i = startIndex; i < endIndex; i++) {
          var point = new PointF(points[i], points[i + 1]);
          if (i === startIndex) {
            if (this.pointCount <= 0 || this.mStartFigure) {
              this.addPoint(point, PathPointType.Start);
              this.mStartFigure = false;
            } else if (point.x !== this.lastPoint.x && point.y !== this.lastPoint.y && !this.isBeziers3) {
              this.addPoint(point, PathPointType.Line);
            } else if (point.x !== this.lastPoint.x && point.y !== this.lastPoint.y) {
              this.addPoint(point, PathPointType.Bezier3);
            }
          } else {
            this.addPoint(point, pointType);
          }
          i++;
        }
      }
    };
    PdfPath2.prototype.addPoint = function(point, pointType) {
      this.points.push(point);
      this.types.push(pointType);
    };
    PdfPath2.prototype.closeFigure = function(index) {
      if (typeof index === "undefined") {
        if (this.pointCount > 0) {
          this.closeFigure(this.pointCount - 1);
        }
        this.startFigure();
      } else {
        if (index < 0) {
          throw new Error("IndexOutOfRangeException()");
        }
        var pt = this.types[index];
        pt = pt | PathPointType.CloseSubpath;
        this.types[index] = pt;
      }
    };
    return PdfPath2;
  })(PdfFillElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/rectangle-area.js
var __extends62 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfRectangleArea = (
  /** @class */
  (function(_super) {
    __extends62(PdfRectangleArea2, _super);
    function PdfRectangleArea2(arg1, arg2, arg3, arg4, arg5, arg6) {
      var _this = _super.call(this) || this;
      _this.bounds = new RectangleF(0, 0, 0, 0);
      if (typeof arg1 === "undefined") {
      } else if (arg1 instanceof PdfPen) {
        _this = _super.call(this, arg1, arg2) || this;
        if (arg3 instanceof RectangleF) {
          _this.bounds = arg3;
        } else {
          _this.bounds = new RectangleF(arg3, arg4, arg5, arg6);
        }
      } else if (arg1 instanceof RectangleF) {
        _this.bounds = arg1;
      } else {
        _this.bounds = new RectangleF(arg1, arg2, arg3, arg4);
      }
      return _this;
    }
    Object.defineProperty(PdfRectangleArea2.prototype, "x", {
      //Properties
      /**
       * Gets or sets the X co-ordinate of the upper-left corner of this the element.
       * @public
       */
      get: function() {
        return this.bounds.x;
      },
      set: function(value) {
        this.bounds.x = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRectangleArea2.prototype, "y", {
      /**
       * Gets or sets the Y co-ordinate of the upper-left corner of this the element.
       * @public
       */
      get: function() {
        return this.bounds.y;
      },
      set: function(value) {
        this.bounds.y = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRectangleArea2.prototype, "width", {
      /**
       * Gets or sets the width of this element.
       * @public
       */
      get: function() {
        return this.bounds.width;
      },
      set: function(value) {
        this.bounds.width = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfRectangleArea2.prototype, "height", {
      /**
       * Gets or sets the height of this element.
       * @public
       */
      get: function() {
        return this.bounds.height;
      },
      set: function(value) {
        this.bounds.height = value;
      },
      enumerable: true,
      configurable: true
    });
    PdfRectangleArea2.prototype.getBoundsInternal = function() {
      return this.bounds;
    };
    return PdfRectangleArea2;
  })(PdfFillElement)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/ellipse-part.js
var __extends63 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfEllipsePart = (
  /** @class */
  (function(_super) {
    __extends63(PdfEllipsePart2, _super);
    function PdfEllipsePart2(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      var _this = _super.call(this) || this;
      _this.startAngle = 0;
      _this.sweepAngle = 0;
      if (typeof arg1 === "undefined") {
      } else if (arg1 instanceof RectangleF && typeof arg2 !== "undefined" && typeof arg3 !== "undefined") {
        _this = _super.call(this, arg1) || this;
        _this.startAngle = arg2;
        _this.sweepAngle = arg3;
      } else if (arg1 instanceof PdfPen) {
        if (arg3 instanceof RectangleF) {
          _this = _super.call(this, arg1, arg2, arg3) || this;
          _this.startAngle = arg4;
          _this.sweepAngle = arg5;
        } else {
          _this = _super.call(this, arg1, arg2, arg3, arg4, arg5, arg6) || this;
          _this.startAngle = arg7;
          _this.sweepAngle = arg8;
        }
      } else {
        _this = _super.call(this, arg1, arg2, arg3, arg4) || this;
        _this.startAngle = arg5;
        _this.sweepAngle = arg6;
      }
      return _this;
    }
    return PdfEllipsePart2;
  })(PdfRectangleArea)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/figures/arc.js
var __extends64 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfArc = (
  /** @class */
  (function(_super) {
    __extends64(PdfArc2, _super);
    function PdfArc2(arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
      var _this = this;
      if (typeof arg1 === "undefined") {
        _this = _super.call(this) || this;
      } else if (arg1 instanceof RectangleF) {
        _this = _super.call(this, arg1, arg2, arg3) || this;
      } else if (arg1 instanceof PdfPen) {
        if (arg2 instanceof RectangleF) {
          _this = _super.call(this, arg1, null, arg2, arg3, arg4) || this;
        } else if (typeof arg6 === "undefined" && typeof arg7 === "undefined") {
          _this = _super.call(this, arg1, null, 0, 0, arg2, arg3, arg4, arg5) || this;
        } else if (typeof arg6 !== "undefined" && typeof arg7 !== "undefined") {
          _this = _super.call(this, arg1, null, arg2, arg3, arg4, arg5, arg6, arg7) || this;
        }
      } else if (typeof arg1 !== "undefined" && typeof arg5 === "undefined" && typeof arg6 === "undefined") {
        _this = _super.call(this, 0, 0, arg1, arg2, arg3, arg4) || this;
      } else if (typeof arg1 !== "undefined" && typeof arg5 !== "undefined" && typeof arg6 !== "undefined") {
        _this = _super.call(this, arg1, arg2, arg3, arg4, arg5, arg6) || this;
      }
      return _this;
    }
    PdfArc2.prototype.draw = function(argu1, arg2, arg3, arg4) {
      if (arg2 instanceof PointF && typeof arg2.width === "undefined" && typeof arg3 === "undefined") {
        return this.drawHelper(argu1, arg2.x, arg2.y);
      } else if (arg2 instanceof RectangleF && typeof arg2.width !== "undefined" && typeof arg3 === "undefined") {
        return this.drawHelper(argu1, arg2, null);
      } else if (typeof arg2 === "number" && typeof arg3 === "number" && typeof arg4 === "undefined") {
        return this.drawHelper(argu1, arg2, arg3, null);
      } else if (arg2 instanceof PointF && arg3 instanceof PdfLayoutFormat) {
        return this.drawHelper(argu1, arg2.x, arg2.y, arg3);
      } else if (typeof arg2 === "number" && (arg4 instanceof PdfLayoutFormat || arg4 == null) && typeof arg3 === "number") {
        var widthValue = argu1.graphics.clientSize.width - arg2;
        var layoutRect = new RectangleF(arg2, arg3, widthValue, 0);
        return this.drawHelper(argu1, layoutRect, arg4);
      } else {
        return this.drawHelper(argu1, arg2, arg3);
      }
    };
    PdfArc2.prototype.drawInternal = function(graphics) {
      if (graphics == null) {
        throw new Error("ArgumentNullException : graphics");
      }
      graphics.drawArc(this.obtainPen(), this.bounds, this.startAngle, this.sweepAngle);
    };
    return PdfArc2;
  })(PdfEllipsePart)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/graphics/fonts/pdf-true-type-font.js
var __extends65 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var PdfTrueTypeFont = (
  /** @class */
  (function(_super) {
    __extends65(PdfTrueTypeFont2, _super);
    function PdfTrueTypeFont2(base64String, size, style) {
      var _this = _super.call(this, size) || this;
      _this.isEmbedFont = false;
      _this.isUnicode = true;
      if (style !== void 0) {
        _this.createFontInternal(base64String, style);
      } else {
        _this.createFontInternal(base64String, PdfFontStyle.Regular);
      }
      return _this;
    }
    PdfTrueTypeFont2.prototype.equalsToFont = function(font) {
      var result = false;
      return result;
    };
    PdfTrueTypeFont2.prototype.getLineWidth = function(line, format) {
      var width = 0;
      if (format !== null && typeof format !== "undefined" && format.textDirection !== PdfTextDirection.None) {
        var returnValue = this.getUnicodeLineWidth(
          line,
          /*out*/
          width,
          format
        );
        width = returnValue.width;
      } else {
        width = this.fontInternal.getLineWidth(line);
      }
      var size = this.metrics.getSize(format);
      width *= PdfFont.charSizeMultiplier * size;
      width = this.applyFormatSettings(line, format, width);
      return width;
    };
    PdfTrueTypeFont2.prototype.getCharWidth = function(charCode, format) {
      var codeWidth = this.fontInternal.getCharWidth(charCode);
      var size = this.metrics.getSize(format);
      codeWidth *= 1e-3 * size;
      return codeWidth;
    };
    PdfTrueTypeFont2.prototype.createFontInternal = function(base64String, style) {
      this.fontInternal = new UnicodeTrueTypeFont(base64String, this.size);
      this.calculateStyle(style);
      this.initializeInternals();
    };
    PdfTrueTypeFont2.prototype.calculateStyle = function(style) {
      var iStyle = this.fontInternal.ttfMetrics.macStyle;
      if ((style & PdfFontStyle.Underline) !== 0) {
        iStyle |= PdfFontStyle.Underline;
      }
      if ((style & PdfFontStyle.Strikeout) !== 0) {
        iStyle |= PdfFontStyle.Strikeout;
      }
      this.setStyle(iStyle);
    };
    PdfTrueTypeFont2.prototype.initializeInternals = function() {
      var equalFont = null;
      if (PdfDocument.enableCache) {
        equalFont = PdfDocument.cache.search(this);
      }
      var internals = null;
      if (equalFont !== null && equalFont !== void 0) {
        internals = equalFont.getInternals();
        var metrics = equalFont.metrics;
        metrics = metrics.clone();
        metrics.size = this.size;
        this.metrics = metrics;
        this.fontInternal = equalFont.fontInternal;
      } else {
        if (equalFont == null) {
          if (this.fontInternal instanceof UnicodeTrueTypeFont) {
            this.fontInternal.isEmbed = this.isEmbedFont;
          }
          this.fontInternal.createInternals();
          internals = this.fontInternal.getInternals();
          this.metrics = this.fontInternal.metrics;
        }
      }
      this.metrics.isUnicodeFont = true;
      this.setInternals(internals);
    };
    PdfTrueTypeFont2.prototype.setSymbols = function(text) {
      var internalFont = this.fontInternal;
      if (internalFont != null) {
        internalFont.setSymbols(text);
      }
    };
    Object.defineProperty(PdfTrueTypeFont2.prototype, "Unicode", {
      /**
       * Property
       *
       */
      get: function() {
        return this.isUnicode;
      },
      enumerable: true,
      configurable: true
    });
    PdfTrueTypeFont2.prototype.getUnicodeLineWidth = function(line, width, format) {
      width = 0;
      var glyphIndices = null;
      var rtlRender = new RtlRenderer();
      var result = rtlRender.getGlyphIndex(
        line,
        this,
        format.textDirection === PdfTextDirection.RightToLeft ? true : false,
        /*out*/
        glyphIndices,
        true
      );
      var resultGlyph = result.success;
      glyphIndices = result.glyphs;
      if (resultGlyph && glyphIndices !== null) {
        var ttfReader = this.fontInternal.ttfReader;
        for (var i = 0, len = glyphIndices.length; i < len; i++) {
          var glyphIndex = glyphIndices[i];
          var glyph = ttfReader.getGlyph(glyphIndex);
          if (glyph !== null && typeof glyph !== "undefined") {
            width += glyph.width;
          }
        }
      }
      return { success: resultGlyph, width };
    };
    return PdfTrueTypeFont2;
  })(PdfFont)
);

// node_modules/@syncfusion/ej2-pdf-export/src/implementation/pages/pdf-page-template-element.js
var PdfPageTemplateElement = (
  /** @class */
  (function() {
    function PdfPageTemplateElement2(arg1, arg2, arg3, arg4, arg5) {
      if (arg1 instanceof RectangleF && typeof arg2 === "undefined") {
        this.InitiateBounds(arg1.x, arg1.y, arg1.width, arg1.height, null);
      } else if (arg1 instanceof RectangleF && arg2 instanceof PdfPage && typeof arg3 === "undefined") {
        this.InitiateBounds(arg1.x, arg1.y, arg1.width, arg1.height, arg2);
      } else if (arg1 instanceof PointF && arg2 instanceof SizeF && typeof arg3 === "undefined") {
        this.InitiateBounds(arg1.x, arg1.y, arg2.width, arg2.height, null);
      } else if (arg1 instanceof PointF && arg2 instanceof SizeF && arg3 instanceof PdfPage && typeof arg4 === "undefined") {
        this.InitiateBounds(arg1.x, arg1.y, arg2.width, arg2.height, arg3);
      } else if (arg1 instanceof SizeF && typeof arg2 === "undefined") {
        this.InitiateBounds(0, 0, arg1.width, arg1.height, null);
      } else if (typeof arg1 === "number" && typeof arg2 === "number" && typeof arg3 === "undefined") {
        this.InitiateBounds(0, 0, arg1, arg2, null);
      } else if (typeof arg1 === "number" && typeof arg2 === "number" && arg3 instanceof PdfPage && typeof arg4 === "undefined") {
        this.InitiateBounds(0, 0, arg1, arg2, arg3);
      } else if (typeof arg1 === "number" && typeof arg2 === "number" && typeof arg3 === "number" && typeof arg4 === "number" && typeof arg5 === "undefined") {
        this.InitiateBounds(arg1, arg2, arg3, arg4, null);
      } else {
        this.InitiateBounds(arg1, arg2, arg3, arg4, null);
      }
    }
    Object.defineProperty(PdfPageTemplateElement2.prototype, "dock", {
      // Properties
      /**
       * Gets or sets the `dock style` of the page template element.
       * @private
       */
      get: function() {
        return this.dockStyle;
      },
      set: function(value) {
        this.dockStyle = value;
        this.resetAlignment();
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "alignment", {
      /**
       * Gets or sets `alignment` of the page template element.
       * @private
       */
      get: function() {
        return this.alignmentStyle;
      },
      set: function(value) {
        this.setAlignment(value);
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "foreground", {
      /**
       * Indicates whether the page template is located `in front of the page layers or behind of it`.
       * @private
       */
      get: function() {
        return this.isForeground;
      },
      set: function(value) {
        this.isForeground = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "background", {
      /**
       * Indicates whether the page template is located `behind of the page layers or in front of it`.
       * @private
       */
      get: function() {
        return !this.isForeground;
      },
      set: function(value) {
        this.isForeground = !value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "location", {
      /**
       * Gets or sets `location` of the page template element.
       * @private
       */
      get: function() {
        return this.currentLocation;
      },
      set: function(value) {
        if (this.type === TemplateType.None) {
          this.currentLocation = value;
        } else {
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "x", {
      /**
       * Gets or sets `X` co-ordinate of the template element on the page.
       * @private
       */
      get: function() {
        var value = typeof this.currentLocation !== "undefined" ? this.currentLocation.x : 0;
        return value;
      },
      set: function(value) {
        if (this.type === TemplateType.None) {
          this.currentLocation.x = value;
        } else {
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "y", {
      /**
       * Gets or sets `Y` co-ordinate of the template element on the page.
       * @private
       */
      get: function() {
        var value = typeof this.currentLocation !== "undefined" ? this.currentLocation.y : 0;
        return value;
      },
      set: function(value) {
        if (this.type === TemplateType.None) {
          this.currentLocation.y = value;
        } else {
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "size", {
      /**
       * Gets or sets `size` of the page template element.
       * @private
       */
      get: function() {
        return this.template.size;
      },
      set: function(value) {
        if (this.type === TemplateType.None) {
          this.template.reset(value);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "width", {
      /**
       * Gets or sets `width` of the page template element.
       * @private
       */
      get: function() {
        return this.template.width;
      },
      set: function(value) {
        if (this.template.width !== value && this.type === TemplateType.None) {
          var size = this.template.size;
          size.width = value;
          this.template.reset(size);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "height", {
      /**
       * Gets or sets `height` of the page template element.
       * @private
       */
      get: function() {
        return this.template.height;
      },
      set: function(value) {
        if (this.template.height !== value && this.type === TemplateType.None) {
          var size = this.template.size;
          size.height = value;
          this.template.reset(size);
        }
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "graphics", {
      /**
       * Gets `graphics` context of the page template element.
       * @private
       */
      get: function() {
        return this.template.graphics;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "template", {
      /**
       * Gets Pdf `template` object.
       * @private
       */
      get: function() {
        return this.pdfTemplate;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "type", {
      /**
       * Gets or sets `type` of the usage of this page template.
       * @private
       */
      get: function() {
        return this.templateType;
      },
      set: function(value) {
        this.updateDocking(value);
        this.templateType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(PdfPageTemplateElement2.prototype, "bounds", {
      /**
       * Gets or sets `bounds` of the page template.
       * @public
       */
      get: function() {
        return new RectangleF(new PointF(this.x, this.y), this.size);
      },
      set: function(value) {
        if (this.type === TemplateType.None) {
          this.location = new PointF(value.x, value.y);
          this.size = new SizeF(value.width, value.height);
        }
      },
      enumerable: true,
      configurable: true
    });
    PdfPageTemplateElement2.prototype.InitiateBounds = function(arg1, arg2, arg3, arg4, arg5) {
      this.x = arg1;
      this.y = arg2;
      this.pdfTemplate = new PdfTemplate(arg3, arg4);
    };
    PdfPageTemplateElement2.prototype.updateDocking = function(type) {
      if (type !== TemplateType.None) {
        switch (type) {
          case TemplateType.Top:
            this.dock = PdfDockStyle.Top;
            break;
          case TemplateType.Bottom:
            this.dock = PdfDockStyle.Bottom;
            break;
          case TemplateType.Left:
            this.dock = PdfDockStyle.Left;
            break;
          case TemplateType.Right:
            this.dock = PdfDockStyle.Right;
            break;
        }
        this.resetAlignment();
      }
    };
    PdfPageTemplateElement2.prototype.resetAlignment = function() {
      this.alignment = PdfAlignmentStyle.None;
    };
    PdfPageTemplateElement2.prototype.setAlignment = function(alignment) {
      if (this.dock === PdfDockStyle.None) {
        this.alignmentStyle = alignment;
      } else {
        var canBeSet = false;
        switch (this.dock) {
          case PdfDockStyle.Left:
            canBeSet = alignment === PdfAlignmentStyle.TopLeft || alignment === PdfAlignmentStyle.MiddleLeft || alignment === PdfAlignmentStyle.BottomLeft || alignment === PdfAlignmentStyle.None;
            break;
          case PdfDockStyle.Top:
            canBeSet = alignment === PdfAlignmentStyle.TopLeft || alignment === PdfAlignmentStyle.TopCenter || alignment === PdfAlignmentStyle.TopRight || alignment === PdfAlignmentStyle.None;
            break;
          case PdfDockStyle.Right:
            canBeSet = alignment === PdfAlignmentStyle.TopRight || alignment === PdfAlignmentStyle.MiddleRight || alignment === PdfAlignmentStyle.BottomRight || alignment === PdfAlignmentStyle.None;
            break;
          case PdfDockStyle.Bottom:
            canBeSet = alignment === PdfAlignmentStyle.BottomLeft || alignment === PdfAlignmentStyle.BottomCenter || alignment === PdfAlignmentStyle.BottomRight || alignment === PdfAlignmentStyle.None;
            break;
          case PdfDockStyle.Fill:
            canBeSet = alignment === PdfAlignmentStyle.MiddleCenter || alignment === PdfAlignmentStyle.None;
            break;
        }
        if (canBeSet) {
          this.alignmentStyle = alignment;
        }
      }
    };
    PdfPageTemplateElement2.prototype.draw = function(layer, document2) {
      var page = layer.page;
      var bounds = this.calculateBounds(page, document2);
      layer.graphics.drawPdfTemplate(this.template, new PointF(bounds.x, bounds.y), new SizeF(bounds.width, bounds.height));
    };
    PdfPageTemplateElement2.prototype.calculateBounds = function(page, document2) {
      var result = this.bounds;
      if (this.alignmentStyle !== PdfAlignmentStyle.None) {
        result = this.getAlignmentBounds(page, document2);
      } else if (this.dockStyle !== PdfDockStyle.None) {
        result = this.getDockBounds(page, document2);
      }
      return result;
    };
    PdfPageTemplateElement2.prototype.getAlignmentBounds = function(page, document2) {
      var result = this.bounds;
      if (this.type === TemplateType.None) {
        result = this.getSimpleAlignmentBounds(page, document2);
      } else {
        result = this.getTemplateAlignmentBounds(page, document2);
      }
      return result;
    };
    PdfPageTemplateElement2.prototype.getSimpleAlignmentBounds = function(page, document2) {
      var bounds = this.bounds;
      var pdfSection = page.section;
      var actualBounds = pdfSection.getActualBounds(document2, page, false);
      var x = this.x;
      var y = this.y;
      switch (this.alignmentStyle) {
        case PdfAlignmentStyle.TopLeft:
          x = 0;
          y = 0;
          break;
        case PdfAlignmentStyle.TopCenter:
          x = (actualBounds.width - this.width) / 2;
          y = 0;
          break;
        case PdfAlignmentStyle.TopRight:
          x = actualBounds.width - this.width;
          y = 0;
          break;
        case PdfAlignmentStyle.MiddleLeft:
          x = 0;
          y = (actualBounds.height - this.height) / 2;
          break;
        case PdfAlignmentStyle.MiddleCenter:
          x = (actualBounds.width - this.width) / 2;
          y = (actualBounds.height - this.height) / 2;
          break;
        case PdfAlignmentStyle.MiddleRight:
          x = actualBounds.width - this.width;
          y = (actualBounds.height - this.height) / 2;
          break;
        case PdfAlignmentStyle.BottomLeft:
          x = 0;
          y = actualBounds.height - this.height;
          break;
        case PdfAlignmentStyle.BottomCenter:
          x = (actualBounds.width - this.width) / 2;
          y = actualBounds.height - this.height;
          break;
        case PdfAlignmentStyle.BottomRight:
          x = actualBounds.width - this.width;
          y = actualBounds.height - this.height;
          break;
      }
      bounds.x = x;
      bounds.y = y;
      return bounds;
    };
    PdfPageTemplateElement2.prototype.getTemplateAlignmentBounds = function(page, document2) {
      var result = this.bounds;
      var section = page.section;
      var actualBounds = section.getActualBounds(document2, page, false);
      var x = this.x;
      var y = this.y;
      switch (this.alignmentStyle) {
        case PdfAlignmentStyle.TopLeft:
          if (this.type === TemplateType.Left) {
            x = this.convertSign(actualBounds.x);
            y = 0;
          } else if (this.type === TemplateType.Top) {
            x = this.convertSign(actualBounds.x);
            y = this.convertSign(actualBounds.y);
          }
          break;
        case PdfAlignmentStyle.TopCenter:
          x = (actualBounds.width - this.width) / 2;
          y = this.convertSign(actualBounds.y);
          break;
        case PdfAlignmentStyle.TopRight:
          if (this.type === TemplateType.Right) {
            x = actualBounds.width + section.getRightIndentWidth(document2, page, false) - this.width;
            y = 0;
          } else if (this.type === TemplateType.Top) {
            x = actualBounds.width + section.getRightIndentWidth(document2, page, false) - this.width;
            y = this.convertSign(actualBounds.y);
          }
          break;
        case PdfAlignmentStyle.MiddleLeft:
          x = this.convertSign(actualBounds.x);
          y = (actualBounds.height - this.height) / 2;
          break;
        case PdfAlignmentStyle.MiddleCenter:
          x = (actualBounds.width - this.width) / 2;
          y = (actualBounds.height - this.height) / 2;
          break;
        case PdfAlignmentStyle.MiddleRight:
          x = actualBounds.width + section.getRightIndentWidth(document2, page, false) - this.width;
          y = (actualBounds.height - this.height) / 2;
          break;
        case PdfAlignmentStyle.BottomLeft:
          if (this.type === TemplateType.Left) {
            x = this.convertSign(actualBounds.x);
            y = actualBounds.height - this.height;
          } else if (this.type === TemplateType.Bottom) {
            x = this.convertSign(actualBounds.x);
            y = actualBounds.height + section.getBottomIndentHeight(document2, page, false) - this.height;
          }
          break;
        case PdfAlignmentStyle.BottomCenter:
          x = (actualBounds.width - this.width) / 2;
          y = actualBounds.height + section.getBottomIndentHeight(document2, page, false) - this.height;
          break;
        case PdfAlignmentStyle.BottomRight:
          if (this.type === TemplateType.Right) {
            x = actualBounds.width + section.getRightIndentWidth(document2, page, false) - this.width;
            y = actualBounds.height - this.height;
          } else if (this.type === TemplateType.Bottom) {
            x = actualBounds.width + section.getRightIndentWidth(document2, page, false) - this.width;
            y = actualBounds.height + section.getBottomIndentHeight(document2, page, false) - this.height;
          }
          break;
      }
      result.x = x;
      result.y = y;
      return result;
    };
    PdfPageTemplateElement2.prototype.getDockBounds = function(page, document2) {
      var result = this.bounds;
      if (this.type === TemplateType.None) {
        result = this.getSimpleDockBounds(page, document2);
      } else {
        result = this.getTemplateDockBounds(page, document2);
      }
      return result;
    };
    PdfPageTemplateElement2.prototype.getSimpleDockBounds = function(page, document2) {
      var result = this.bounds;
      var section = page.section;
      var actualBounds = section.getActualBounds(document2, page, false);
      var x = this.x;
      var y = this.y;
      var width = this.width;
      var height = this.height;
      switch (this.dockStyle) {
        case PdfDockStyle.Left:
          x = 0;
          y = 0;
          width = this.width;
          height = actualBounds.height;
          break;
        case PdfDockStyle.Top:
          x = 0;
          y = 0;
          width = actualBounds.width;
          height = this.height;
          break;
        case PdfDockStyle.Right:
          x = actualBounds.width - this.width;
          y = 0;
          width = this.width;
          height = actualBounds.height;
          break;
        case PdfDockStyle.Bottom:
          x = 0;
          y = actualBounds.height - this.height;
          width = actualBounds.width;
          height = this.height;
          break;
        case PdfDockStyle.Fill:
          x = 0;
          x = 0;
          width = actualBounds.width;
          height = actualBounds.height;
          break;
      }
      result = new RectangleF(x, y, width, height);
      return result;
    };
    PdfPageTemplateElement2.prototype.getTemplateDockBounds = function(page, document2) {
      var result = this.bounds;
      var section = page.section;
      var actualBounds = section.getActualBounds(document2, page, false);
      var actualSize = section.pageSettings.getActualSize();
      var x = this.x;
      var y = this.y;
      var width = this.width;
      var height = this.height;
      switch (this.dockStyle) {
        case PdfDockStyle.Left:
          x = this.convertSign(actualBounds.x);
          y = 0;
          width = this.width;
          height = actualBounds.height;
          break;
        case PdfDockStyle.Top:
          x = this.convertSign(actualBounds.x);
          y = this.convertSign(actualBounds.y);
          width = actualSize.width;
          height = this.height;
          if (actualBounds.height < 0) {
            y = actualSize.height - actualBounds.y;
          }
          break;
        case PdfDockStyle.Right:
          x = actualBounds.width + section.getRightIndentWidth(document2, page, false) - this.width;
          y = 0;
          width = this.width;
          height = actualBounds.height;
          break;
        case PdfDockStyle.Bottom:
          x = this.convertSign(actualBounds.x);
          y = actualBounds.height + section.getBottomIndentHeight(document2, page, false) - this.height;
          width = actualSize.width;
          height = this.height;
          if (actualBounds.height < 0) {
            y -= actualSize.height;
          }
          break;
        case PdfDockStyle.Fill:
          x = 0;
          x = 0;
          width = actualBounds.width;
          height = actualBounds.height;
          break;
      }
      result = new RectangleF(x, y, width, height);
      return result;
    };
    PdfPageTemplateElement2.prototype.convertSign = function(value) {
      return value !== 0 || value === 0 && 1 / value === -Infinity ? -value : value;
    };
    return PdfPageTemplateElement2;
  })()
);

// node_modules/@syncfusion/ej2-maps/src/maps/model/export-pdf.js
var PdfExport = (
  /** @class */
  (function() {
    function PdfExport2() {
    }
    PdfExport2.prototype.export = function(maps, type, fileName, allowDownload, orientation) {
      var promise = new Promise(function(resolve) {
        if (maps.isTileMap) {
          maps.isExportInitialTileMap = true;
        }
        var canvasElement = createElement("canvas", {
          id: "ej2-canvas",
          attrs: {
            "width": maps.availableSize.width.toString(),
            "height": maps.availableSize.height.toString()
          }
        });
        orientation = isNullOrUndefined(orientation) ? PdfPageOrientation.Landscape : orientation;
        var svgParent = document.getElementById(maps.element.id + "_Tile_SVG_Parent");
        var svgData;
        var exportElement = maps.svgObject.cloneNode(true);
        var backgroundElement = exportElement.childNodes[0];
        var backgroundColor = backgroundElement.getAttribute("fill");
        if ((maps.theme === "Tailwind" || maps.theme === "Tailwind3" || maps.theme === "Bootstrap5" || maps.theme === "Fluent" || maps.theme === "Material3" || maps.theme === "Fluent2") && (backgroundColor === "rgba(255,255,255, 0.0)" || backgroundColor === "transparent")) {
          exportElement.childNodes[0].setAttribute("fill", "rgba(255,255,255, 1)");
        } else if ((maps.theme === "TailwindDark" || maps.theme === "Tailwind3Dark" || maps.theme === "Bootstrap5Dark" || maps.theme === "FluentDark" || maps.theme === "Material3Dark" || maps.theme === "Fluent2Dark" || maps.theme === "Fluent2HighContrast") && (backgroundColor === "rgba(255,255,255, 0.0)" || backgroundColor === "transparent")) {
          exportElement.childNodes[0].setAttribute("fill", "rgba(0, 0, 0, 1)");
        }
        var url = window.URL.createObjectURL(new Blob(type === "SVG" ? [svgData] : [new XMLSerializer().serializeToString(exportElement)], { type: "image/svg+xml" }));
        var pdfDocument = new PdfDocument();
        var image = new Image();
        var ctx = canvasElement.getContext("2d");
        if (!maps.isTileMap) {
          image.onload = (function() {
            ctx.drawImage(image, 0, 0);
            window.URL.revokeObjectURL(url);
            if (type === "PDF") {
              var imageString = canvasElement.toDataURL("image/jpeg").replace("image/jpeg", "image/octet-stream");
              pdfDocument.pageSettings.orientation = orientation;
              imageString = imageString.slice(imageString.indexOf(",") + 1);
              pdfDocument.pages.add().graphics.drawImage(new PdfBitmap(imageString), 0, 0, maps.availableSize.width - 60, maps.availableSize.height);
              if (allowDownload) {
                pdfDocument.save(fileName + ".pdf");
                pdfDocument.destroy();
              } else {
                resolve(null);
              }
            }
          });
          image.src = url;
        } else {
          var svgParentElement = document.getElementById(maps.element.id + "_MapAreaBorder");
          var top_1 = parseFloat(svgParentElement.getAttribute("y"));
          var left_1 = parseFloat(svgParentElement.getAttribute("x"));
          var xHttp = new XMLHttpRequest();
          var tileLength_1 = maps.mapLayerPanel.tiles.length;
          var _loop_1 = function(i2) {
            var tile = document.getElementById(maps.element.id + "_tile_" + (i2 - 1));
            var tileImg = new Image();
            tileImg.crossOrigin = "Anonymous";
            var background = maps.background ? maps.background : (maps.theme === "Tailwind" || maps.theme === "Tailwind3" || maps.theme === "Bootstrap5" || maps.theme === "Fluent" || maps.theme === "Material3") && (backgroundColor === "rgba(255,255,255, 0.0)" || backgroundColor === "transparent") ? "#ffffff" : (maps.theme === "TailwindDark" || maps.theme === "Tailwind3Dark" || maps.theme === "Bootstrap5Dark" || maps.theme === "FluentDark" || maps.theme === "Material3Dark") && (backgroundColor === "rgba(255,255,255, 0.0)" || backgroundColor === "transparent") ? "#000000" : "#ffffff";
            ctx.fillStyle = background;
            ctx.fillRect(0, 0, maps.availableSize.width, maps.availableSize.height);
            ctx.font = maps.titleSettings.textStyle.size + " Arial";
            var titleElement = document.getElementById(maps.element.id + "_Map_title");
            if (!isNullOrUndefined(titleElement)) {
              ctx.fillStyle = titleElement.getAttribute("fill");
              ctx.fillText(maps.titleSettings.text, parseFloat(titleElement.getAttribute("x")), parseFloat(titleElement.getAttribute("y")));
            }
            tileImg.onload = (function() {
              if (i2 === 0 || i2 === tileLength_1 + 1) {
                if (i2 === 0) {
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.rect(0, top_1, parseFloat(svgParent.style.width), parseFloat(svgParent.style.height));
                  ctx.clip();
                } else {
                  ctx.setTransform(1, 0, 0, 1, left_1, top_1);
                }
              } else {
                ctx.setTransform(1, 0, 0, 1, parseFloat(tile.style.left) + left_1, parseFloat(tile.style.top) + top_1);
              }
              ctx.drawImage(tileImg, 0, 0);
              if (i2 === tileLength_1 + 1) {
                if (type === "PDF") {
                  localStorage.setItem("saved-image-example", canvasElement.toDataURL("image/jpeg"));
                  var x = localStorage.getItem("saved-image-example");
                  pdfDocument.pageSettings.orientation = orientation;
                  x = x.slice(x.indexOf(",") + 1);
                  pdfDocument.pages.add().graphics.drawImage(new PdfBitmap(x), 0, 0, maps.availableSize.width - 60, maps.availableSize.height);
                  maps.isExportInitialTileMap = false;
                  if (allowDownload) {
                    pdfDocument.save(fileName + ".pdf");
                    pdfDocument.destroy();
                  } else {
                    resolve(null);
                  }
                }
              }
            });
            if (i2 === 0 || i2 === tileLength_1 + 1) {
              if (i2 === 0) {
                tileImg.src = url;
              } else {
                setTimeout(function() {
                  var tileSvg = document.getElementById(maps.element.id + "_Tile_SVG");
                  tileImg.src = window.URL.createObjectURL(new Blob([new XMLSerializer().serializeToString(tileSvg)], { type: "image/svg+xml" }));
                }, 300);
              }
            } else {
              xHttp.open("GET", tile.children[0].getAttribute("src"), true);
              xHttp.send();
              tileImg.src = tile.children[0].getAttribute("src");
            }
          };
          for (var i = 0; i <= tileLength_1 + 1; i++) {
            _loop_1(i);
          }
        }
      });
      return promise;
    };
    PdfExport2.prototype.getModuleName = function() {
      return "PdfExport";
    };
    PdfExport2.prototype.destroy = function() {
    };
    return PdfExport2;
  })()
);

// node_modules/@syncfusion/ej2-react-maps/src/maps/maps.component.js
var __extends66 = /* @__PURE__ */ (function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var MapsComponent = (
  /** @class */
  (function(_super) {
    __extends66(MapsComponent2, _super);
    function MapsComponent2(props) {
      var _this = _super.call(this, props) || this;
      _this.initRenderCalled = false;
      _this.checkInjectedModules = true;
      _this.directivekeys = { "layers": { "layer": { "initialShapeSelections": "initialShapeSelection", "markers": "marker", "bubbles": { "bubble": { "colorMappings": "colorMapping" } }, "navigationLines": "navigationLine" } }, "annotations": "annotation" };
      _this.statelessTemplateProps = null;
      _this.templateProps = null;
      _this.immediateRender = false;
      _this.isReactMock = true;
      _this.portals = [];
      return _this;
    }
    MapsComponent2.prototype.render = function() {
      this.isReactMock = false;
      if ((this.element && !this.initRenderCalled || this.refreshing) && !this.isReactForeceUpdate) {
        _super.prototype.render.call(this);
        this.initRenderCalled = true;
      } else {
        return React5.createElement("div", this.getDefaultAttributes(), [].concat(this.props.children, this.portals));
      }
    };
    return MapsComponent2;
  })(Maps)
);
applyMixins(MapsComponent, [ComponentBase, React5.Component]);
export {
  Annotation,
  AnnotationDirective,
  Annotations,
  AnnotationsDirective,
  Arrow,
  BingMap,
  Border,
  Bubble,
  BubbleDirective,
  BubbleSettings,
  BubblesDirective,
  CenterPosition,
  CircleOption,
  ColorMapping,
  ColorMappingDirective,
  ColorMappingSettings,
  ColorMappingsDirective,
  ColorValue,
  CommonTitleSettings,
  ConnectorLineSettings,
  Coordinate,
  DataLabel,
  DataLabelSettings,
  Font,
  GeoLocation,
  Highlight,
  HighlightSettings,
  ImageExport,
  InitialMarkerSelectionSettings,
  InitialShapeSelectionDirective,
  InitialShapeSelectionSettings,
  InitialShapeSelectionsDirective,
  Inject,
  Internalize,
  LayerDirective,
  LayerPanel,
  LayerSettings,
  LayersDirective,
  Legend,
  LegendSettings,
  Line,
  LineOption,
  MapAjax,
  MapLocation,
  Maps,
  MapsAreaSettings,
  MapsComponent,
  MapsTooltip,
  Margin,
  Marker,
  MarkerBase,
  MarkerClusterData,
  MarkerClusterSettings,
  MarkerDirective,
  MarkerSettings,
  MarkersDirective,
  MinMax,
  NavigationLine,
  NavigationLineDirective,
  NavigationLineSettings,
  NavigationLinesDirective,
  PathOption2 as PathOption,
  PatternOptions,
  PdfExport,
  Point,
  Polygon,
  PolygonOption,
  PolygonSetting,
  PolygonSettings,
  PolygonTooltipSettings,
  PolylineOption,
  Print,
  Rect2 as Rect,
  RectOption,
  RelativePoint,
  Selection,
  SelectionSettings,
  ShapeSettings,
  Size2 as Size,
  SubTitleSettings,
  TextOption2 as TextOption,
  Tile,
  TitleSettings,
  ToggleLegendSettings,
  TooltipSettings,
  Zoom,
  ZoomSettings,
  ZoomToolbarButtonSettings,
  ZoomToolbarSettings,
  ZoomToolbarTooltipSettings,
  acos,
  aitoff,
  animate,
  animationComplete,
  annotationRendering,
  appendShape,
  beforePrint,
  bubbleClick,
  bubbleMouseMove,
  bubbleRendering,
  calculateBound,
  calculateCenterFromPixel,
  calculatePolygonPath,
  calculateScale,
  calculateShapes2 as calculateShapes,
  calculateSize,
  calculateZoomLevel,
  changeBorderWidth,
  changeNavaigationLineWidth,
  checkPropertyPath,
  checkShapeDataFields,
  click,
  clusterSeparate,
  clusterTemplate,
  compareZoomFactor,
  convertElement,
  convertElementFromLabel,
  convertGeoToPoint,
  convertStringToValue,
  convertTileLatLongToPoint,
  createStyle,
  createSvg,
  createTooltip,
  customizeStyle,
  dataLabelRendering,
  degreesToRadians,
  doubleClick,
  drawBalloon,
  drawCircle,
  drawCross,
  drawDiamond,
  drawHorizontalLine,
  drawLine,
  drawPath,
  drawPattern,
  drawPolygon,
  drawPolyline,
  drawRectangle,
  drawStar,
  drawSymbol2 as drawSymbol,
  drawSymbols,
  drawTriangle,
  drawVerticalLine,
  elementAnimate,
  filter,
  findMidPointOfPolygon,
  findPosition,
  fixInitialScaleForTile,
  formatValue,
  getDistance,
  getElement2 as getElement,
  getElementByID,
  getElementOffset,
  getElementsByClassName,
  getFieldData,
  getHexColor,
  getMousePosition,
  getProcessedMarginValue,
  getRatioOfBubble,
  getShapeData,
  getTargetElement,
  getTemplateFunction,
  getTouchCenter,
  getTouches,
  getTranslate,
  getValueFromObject,
  getZoomTranslate,
  isCustomPath,
  itemHighlight,
  itemSelection,
  layerRendering,
  legendRendering,
  load,
  loaded,
  maintainSelection,
  maintainStyleClass,
  maintainToggleSelection,
  marker,
  markerBoundsComparer,
  markerClick,
  markerClusterClick,
  markerClusterListHandler,
  markerClusterMouseMove,
  markerClusterRendering,
  markerColorChoose,
  markerDragEnd,
  markerDragStart,
  markerMouseMove,
  markerRendering,
  markerShapeChoose,
  markerTemplate,
  measureText2 as measureText,
  measureTextElement,
  mergeSeparateCluster,
  mouseMove,
  mousedown,
  mousemove,
  mouseup,
  onclick,
  pan,
  panComplete,
  processResult,
  querySelector,
  radiansToDegrees,
  removeClass2 as removeClass,
  removeElement2 as removeElement,
  renderLegendShape,
  renderTextElement,
  resize,
  rightClick,
  roundTo,
  shapeHighlight,
  shapeRendering,
  shapeSelected,
  showTooltip,
  sinci,
  smoothTranslate,
  stringToNumber,
  sum,
  targetTouches,
  textTrim,
  timeout,
  tooltipRender,
  triggerDownload,
  triggerItemSelectionEvent,
  triggerShapeEvent,
  wordWrap,
  xToCoordinate,
  yToCoordinate,
  zoomAnimate,
  zoomComplete,
  zoomIn,
  zoomOut
};
//# sourceMappingURL=@syncfusion_ej2-react-maps.js.map
